#!/usr/bin/env python3
"""
Certificate management functionality for TeddyCloudStarter.
"""
import os
import shutil
import time
import platform
import subprocess
import re
from pathlib import Path
from typing import Optional
from rich.console import Console
from rich.panel import Panel
from rich import box

# Global console instance for rich output
console = Console()


class CertificateManager:
    """Handles certificate operations for TeddyCloudStarter."""
    
    def __init__(self, base_dir: str = None, translator=None):
        # Use provided base_dir or try to get project path from config
        if base_dir is None:
            # Import here to avoid circular imports
            from .config_manager import ConfigManager
            config_manager = ConfigManager()
            project_path = None
            try:
                if config_manager and config_manager.config:
                    project_path = config_manager.config.get("environment", {}).get("path")
            except Exception:
                pass
            self.base_dir = Path(project_path) if project_path else Path(".")
        else:
            self.base_dir = Path(base_dir)
            
        self.client_certs_dir = self.base_dir / "data" / "client_certs"
        self.ca_dir = self.client_certs_dir / "ca"
        self.clients_dir = self.client_certs_dir / "clients"
        self.server_dir = self.client_certs_dir / "server"
        self.crl_dir = self.client_certs_dir / "crl"
        self.translator = translator

    
    def _translate(self, text):
        """Helper method to translate text if translator is available."""
        if self.translator:
            return self.translator.get(text)
        return text
    
    def _check_openssl(self) -> bool:
        """Check if OpenSSL is available."""
        try:
            subprocess.run(["openssl", "version"], check=True, capture_output=True)
            return True
        except (subprocess.SubprocessError, FileNotFoundError):
            console.print(Panel(
                f"[bold red]{self._translate('OpenSSL is not available on your system.')}[/]\n\n"
                f"[bold yellow]{self._translate('Installation instructions:')}[/]\n"
                f"- [bold]{self._translate('Windows:')}[/] {self._translate('Download and install from https://slproweb.com/products/Win32OpenSSL.html')}\n"
                f"- [bold]{self._translate('macOS:')}[/] {self._translate('Use Homebrew: \'brew install openssl\'')}\n"
                f"- [bold]{self._translate('Linux (Debian/Ubuntu):')}[/] {self._translate('Run \'sudo apt install openssl\'')}\n"
                f"- [bold]{self._translate('Linux (Fedora/RHEL):')}[/] {self._translate('Run \'sudo dnf install openssl\'')}\n\n"
                f"{self._translate('After installing OpenSSL, restart the wizard or choose a different option.')}",
                box=box.ROUNDED,
                border_style="red"
            ))
            return False
    
    def _create_ca_info_file(self) -> bool:
        """Create an info file in the CA directory with version information.
        
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Get OpenSSL version
            openssl_version = "Unknown"
            try:
                result = subprocess.run(
                    ["openssl", "version"],
                    capture_output=True, text=True, check=True
                )
                openssl_version = result.stdout.strip()
            except subprocess.SubprocessError:
                pass
            
            # Get current date and time
            current_datetime = time.strftime("%Y-%m-%d %H:%M:%S")
            
            # Get operating system info
            os_info = f"{platform.system()} {platform.release()}"
            
            # TeddyCloudStarter version - hardcoded for now, could be dynamic in the future
            teddycloudstarter_version = "1.0.0"  # This should ideally come from a central version
            
            # Create the info file
            info_file = self.ca_dir / "ca_info.txt"
            with open(info_file, "w") as f:
                f.write(f"""# TeddyCloudStarter CA Certificate Information
# ======================================

Generated on: {current_datetime}
Operating System: {os_info}
OpenSSL Version: {openssl_version}
TeddyCloudStarter Version: {teddycloudstarter_version}

This Certificate Authority was generated by TeddyCloudStarter.
The CA is used to sign client certificates for secure access to TeddyCloud.

Files in this directory:
- ca.key: The Certificate Authority private key (KEEP SECURE!)
- ca.crt: The Certificate Authority public certificate
- ca_info.txt: This information file

For more information, visit: https://github.com/quentendo64/teddycloudstarter
""")
            
            return True
        except Exception as e:
            error_msg = f"Warning: Could not create CA info file: {e}"
            console.print(f"[bold yellow]{self._translate(error_msg)}[/]")
            return False
    
    def generate_client_certificate(self, client_name: Optional[str] = None, project_path: Optional[str] = None) -> bool:
        """Generate client certificates using OpenSSL.
        
        Args:
            client_name: Optional name for the client certificate. If not provided, will use default
            project_path: Optional path to the project directory. If provided, will override the base_dir
            
        Returns:
            bool: True if successful, False otherwise
        """
        console.print(f"[bold cyan]{self._translate('Generating client certificates...')}[/]")
        
        try:
            # If project_path is provided, update the base_dir and related paths
            if project_path:
                self.base_dir = Path(project_path)
                self.client_certs_dir = self.base_dir / "data" / "client_certs"
                self.ca_dir = self.client_certs_dir / "ca"
                self.clients_dir = self.client_certs_dir / "clients"
                self.server_dir = self.client_certs_dir / "server"
                self.crl_dir = self.client_certs_dir / "crl"
            
            # Ensure directories exist
            self.client_certs_dir.mkdir(parents=True, exist_ok=True)
            self.server_dir.mkdir(exist_ok=True)
            self.clients_dir.mkdir(exist_ok=True)
            self.ca_dir.mkdir(exist_ok=True)
            
            # Check if OpenSSL is available
            if not self._check_openssl():
                return False
            
            # Use default name if none provided
            if not client_name:
                client_name = "TeddyCloudClient"
            
            # Ensure client_name is valid as file name by removing special chars
            safe_name = re.sub(r'[^\w\-\.]', '_', client_name)
            
            # Check if CA exists, if not create it
            ca_key_path = self.ca_dir / "ca.key"
            ca_crt_path = self.ca_dir / "ca.crt"
            server_created = False
            
            # Create CA if it doesn't exist
            if not ca_key_path.exists() or not ca_crt_path.exists():
                # Generate CA key and certificate
                subprocess.run([
                    "openssl", "req", "-x509", "-newkey", "rsa:4096", "-nodes",
                    "-keyout", str(ca_key_path),
                    "-out", str(ca_crt_path),
                    "-subj", "/CN=TeddyCloudStarterCA",
                    "-days", "3650"
                ], check=True)
                
                # Generate server key and CSR
                server_key = self.server_dir / "server.key"
                server_csr = self.server_dir / "server.csr"
                server_crt = self.server_dir / "server.crt"
                
                subprocess.run([
                    "openssl", "req", "-newkey", "rsa:4096", "-nodes",
                    "-keyout", str(server_key),
                    "-out", str(server_csr),
                    "-subj", "/CN=TeddyCloudServer"
                ], check=True)
                
                # Sign server certificate with CA
                subprocess.run([
                    "openssl", "x509", "-req",
                    "-in", str(server_csr),
                    "-CA", str(ca_crt_path),
                    "-CAkey", str(ca_key_path),
                    "-CAcreateserial",
                    "-out", str(server_crt),
                    "-days", "3650"
                ], check=True)
                
                
                # Create CA info file
                self._create_ca_info_file()
                
                server_created = True
            
            # Generate client key and CSR with the provided name
            client_key = self.clients_dir / f"{safe_name}.key"
            client_csr = self.clients_dir / f"{safe_name}.csr"
            client_crt = self.clients_dir / f"{safe_name}.crt"
            client_p12 = self.clients_dir / f"{safe_name}.p12"
            
            subprocess.run([
                "openssl", "req", "-newkey", "rsa:4096", "-nodes",
                "-keyout", str(client_key),
                "-out", str(client_csr),
                "-subj", f"/CN={client_name}"
            ], check=True)
            
            # Sign client certificate with CA
            subprocess.run([
                "openssl", "x509", "-req",
                "-in", str(client_csr),
                "-CA", str(ca_crt_path),
                "-CAkey", str(ca_key_path),
                "-CAcreateserial",
                "-out", str(client_crt),
                "-days", "3650"
            ], check=True)
            
            # Create PKCS#12 file for client
            subprocess.run([
                "openssl", "pkcs12", "-export",
                "-inkey", str(client_key),
                "-in", str(client_crt),
                "-certfile", str(ca_crt_path),
                "-out", str(client_p12),
                "-passout", "pass:teddycloud"
            ], check=True)
            
            message = f"[bold green]{self._translate('Client certificate generated successfully!')}[/]\n\n"
            if server_created:
                message += f"{self._translate('CA certificate has been created in the ca subfolder.')}\n"
                message += f"{self._translate('Server certificate has been created in the server subfolder.')}\n\n"
            
            message += f"{self._translate('Client certificate')} '{client_name}' {self._translate('has been created in the clients subfolder:')}\n"
            message += f"- {client_key}: {self._translate('The client private key')}\n"
            message += f"- {client_crt}: {self._translate('The client certificate')}\n"
            message += f"- {client_p12}: {self._translate('Client certificate bundle (password: teddycloud)')}\n\n"
            message += f"{self._translate('Install the .p12 file on devices that need to access TeddyCloud.')}"
            
            console.print(Panel(
                message,
                box=box.ROUNDED,
                border_style="green"
            ))
            
            return True
        except subprocess.SubprocessError as e:
            error_msg = f"Error generating certificates: {e}"
            console.print(f"[bold red]{self._translate(error_msg)}[/]")
            return False
        except Exception as e:
            error_msg = f"Error: {e}"
            console.print(f"[bold red]{self._translate(error_msg)}[/]")
            return False
    
    def revoke_client_certificate(self, cert_name: Optional[str] = None) -> bool:
        """Revoke a client certificate.
        
        Args:
            cert_name: Optional name of the certificate to revoke. If not provided, will prompt user
            
        Returns:
            bool: True if successful, False otherwise
        """
        console.print(f"[bold cyan]{self._translate('Revoking client certificate...')}[/]")
        
        try:
            if not self.client_certs_dir.exists():
                console.print(f"[bold red]{self._translate('No client certificates directory found.')}[/]")
                return False
            
            # Check if clients subfolder exists
            if not self.clients_dir.exists() or not any(self.clients_dir.glob('*.crt')):
                console.print(f"[bold red]{self._translate('No client certificates found to revoke.')}[/]")
                return False
            
            # Create crl subfolder if it doesn't exist
            self.crl_dir.mkdir(exist_ok=True)
            
            # Check if CA exists
            ca_key_path = self.ca_dir / "ca.key"
            ca_crt_path = self.ca_dir / "ca.crt"
            
            # If CA files not found in ca subfolder, look for them in the root directory
            if not ca_key_path.exists() or not ca_crt_path.exists():
                root_ca_crt = self.client_certs_dir / "ca.crt"
                root_ca_key = self.client_certs_dir / "ca.key"
                
                # Check if CA exists in root directory (backwards compatibility)
                if root_ca_crt.exists() and root_ca_key.exists():
                    # Use root directory CA files
                    ca_crt_path = root_ca_crt
                    ca_key_path = root_ca_key
                else:
                    console.print(f"[bold red]{self._translate('CA certificate or key not found. Cannot revoke certificate.')}[/]")
                    return False
                
            # Validate the certificate name or get from the list
            if cert_name:
                cert_file = self.clients_dir / f"{cert_name}.crt"
                if not cert_file.exists():
                    error_msg = f"Certificate {cert_name}.crt not found."
                    console.print(f"[bold red]{self._translate(error_msg)}[/]")
                    return False
            else:
                # Get a list of available certificates
                cert_files = list(self.clients_dir.glob('*.crt'))
                if not cert_files:
                    console.print(f"[bold red]{self._translate('No client certificates found to revoke.')}[/]")
                    return False
                
                # Get first available certificate as an example
                cert_file = cert_files[0]
                cert_name = cert_file.stem
                
            # Initialize or update the certificate index file
            index_file = self.ca_dir / "index.txt"
            if not index_file.exists():
                # Create an empty index file
                with open(index_file, "w") as f:
                    pass
            
            # Create serial file if it doesn't exist
            serial_file = self.ca_dir / "serial"
            if not serial_file.exists():
                with open(serial_file, "w") as f:
                    f.write("01")
            
            # Create crlnumber file if it doesn't exist
            crlnumber_file = self.ca_dir / "crlnumber"
            if not crlnumber_file.exists():
                with open(crlnumber_file, "w") as f:
                    f.write("01")
            
            # Get the certificate serial number
            result = subprocess.run(
                ["openssl", "x509", "-noout", "-serial", "-in", str(cert_file)],
                capture_output=True, text=True, check=True
            )
            serial = result.stdout.strip().split('=')[1]
            
            # Create OpenSSL config file for revocation
            openssl_conf_file = self.ca_dir / "openssl.cnf"
            if not openssl_conf_file.exists():
                # Create minimal OpenSSL configuration
                with open(openssl_conf_file, "w") as f:
                    f.write("""
[ ca ]
default_ca = CA_default

[ CA_default ]
dir               = ./
database         = $dir/index.txt
serial           = $dir/serial
new_certs_dir    = $dir/newcerts
certificate      = $dir/ca.crt
private_key      = $dir/ca.key
default_days     = 3650
default_crl_days = 30
default_md       = sha256
policy           = policy_any
crlnumber        = $dir/crlnumber

[ policy_any ]
countryName            = optional
stateOrProvinceName    = optional
organizationName       = optional
organizationalUnitName = optional
commonName             = supplied
emailAddress           = optional

[ v3_ca ]
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer
basicConstraints = critical,CA:true

[ crl_ext ]
authorityKeyIdentifier=keyid:always
""")
            
            # Create newcerts directory if it doesn't exist
            newcerts_dir = self.ca_dir / "newcerts"
            newcerts_dir.mkdir(exist_ok=True)
            
            # Revoke the certificate
            try:
                # Ensure we're in the CA directory for relative paths in the config
                original_dir = os.getcwd()
                os.chdir(str(self.ca_dir.absolute()))
                
                subprocess.run([
                    "openssl", "ca", "-config", "openssl.cnf",
                    "-revoke", str(self.clients_dir / f"{cert_name}.crt"),
                    "-keyfile", str(ca_key_path),
                    "-cert", str(ca_crt_path)
                ], check=True)
                
                # Generate CRL
                subprocess.run([
                    "openssl", "ca", "-config", "openssl.cnf",
                    "-gencrl",
                    "-keyfile", str(ca_key_path),
                    "-cert", str(ca_crt_path),
                    "-out", str(self.crl_dir / "ca.crl")
                ], check=True)
                
                # Return to original directory
                os.chdir(original_dir)
                
                success_msg = f"Certificate {cert_name} has been revoked successfully."
                console.print(f"[bold green]{self._translate(success_msg)}[/]")
                update_msg = "The Certificate Revocation List (CRL) has been updated."
                console.print(f"[cyan]{self._translate(update_msg)}[/]")
                restart_msg = "You may need to restart services for the changes to take effect."
                console.print(f"[cyan]{self._translate(restart_msg)}[/]")
                
                return True
                
            except subprocess.SubprocessError as e:
                error_msg = f"Error revoking certificate: {e}"
                console.print(f"[bold red]{self._translate(error_msg)}[/]")
                # Return to original directory on error
                os.chdir(original_dir)
                return False
            
        except Exception as e:
            error_msg = f"Error during certificate revocation: {e}"
            console.print(f"[bold red]{self._translate(error_msg)}[/]")
            return False

    def test_domain_for_letsencrypt(self, domain: str) -> bool:
        """Test if a domain is properly set up for Let's Encrypt.
        
        Tests DNS resolution and tries to obtain a test certificate in staging mode.
        If staging mode fails, offers to try production mode.
        
        Args:
            domain: Domain name to test
            
        Returns:
            bool: True if domain passed at least one test, False otherwise
        """
        console.print(f"[bold cyan]{self._translate('Testing domain for Let\'s Encrypt compatibility...')}[/]")
        
        # 1. Check domain DNS resolution
        console.print(f"[cyan]{self._translate('Step 1: Testing DNS resolution for')} {domain}...[/]")
        try:
            import socket
            socket.gethostbyname(domain)
            console.print(f"[bold green]{self._translate('DNS resolution successful!')}[/]")
            dns_check_passed = True
        except socket.gaierror:
            console.print(f"[bold red]{self._translate('DNS resolution failed. Your domain may not be properly configured.')}[/]")
            console.print(f"[yellow]{self._translate('Make sure your domain points to this server\'s public IP address.')}[/]")
            dns_check_passed = False
        
        # 2. Test HTTP connectivity (port 80 reachability)
        console.print(f"[cyan]{self._translate('Step 2: Testing port 80 accessibility for ACME challenge...')}[/]")
        
        # Create simple Docker container to test port 80
        try:
            check_cmd = [
                "docker", "run", "--rm",
                "busybox", "wget", "-q", "-T", "5", "-O-",
                f"http://{domain}/.well-known/acme-challenge/test"
            ]
            process = subprocess.run(check_cmd, capture_output=True, text=True)
            
            # We actually expect a 404 error (page not found), if we get a connection
            http_check_passed = process.returncode == 1 and "404" in process.stderr
            
            if http_check_passed:
                console.print(f"[bold green]{self._translate('Port 80 appears to be accessible!')}[/]")
            else:
                console.print(f"[bold yellow]{self._translate('Port 80 might not be reachable from the internet.')}[/]")
                console.print(f"[yellow]{self._translate('Make sure port 80 is forwarded to this server if you\'re behind a router/firewall.')}[/]")
        except Exception as e:
            console.print(f"[bold yellow]{self._translate('Could not test HTTP connectivity:')} {str(e)}[/]")
            http_check_passed = False
        
        # 3. Request a certificate in staging mode
        console.print(f"[cyan]{self._translate('Step 3: Testing certificate issuance in staging mode...')}[/]")
        
        staging_success = self.request_letsencrypt_certificate(domain, staging=True)
        
        if staging_success:
            console.print(f"[bold green]{self._translate('Staging certificate request successful!')}[/]")
            console.print(f"[green]{self._translate('Your domain seems to be properly configured for Let\'s Encrypt.')}[/]")
            return True
        else:
            console.print(f"[bold yellow]{self._translate('Staging certificate request failed.')}[/]")
            
            # If DNS check passed, we'll offer to try production mode
            if dns_check_passed:
                from rich.prompt import Confirm
                try_production = Confirm.ask(
                    f"[bold yellow]{self._translate('Would you like to try a real certificate request?')}[/]"
                )
                
                if try_production:
                    console.print(f"[cyan]{self._translate('Attempting production Let\'s Encrypt certificate request...')}[/]")
                    production_success = self.request_letsencrypt_certificate(domain, staging=False)
                    
                    if production_success:
                        console.print(f"[bold green]{self._translate('Production certificate request successful!')}[/]")
                        console.print(f"[green]{self._translate('Your domain is properly configured for Let\'s Encrypt.')}[/]")
                        return True
                    else:
                        console.print(f"[bold red]{self._translate('Production certificate request also failed.')}[/]")
                        console.print(f"[yellow]{self._translate('Please check that:')}[/]")
                        console.print(f"[yellow]- {self._translate('Your domain points to this server')}")
                        console.print(f"[yellow]- {self._translate('Ports 80 and 443 are properly forwarded')}")
                        console.print(f"[yellow]- {self._translate('No firewall is blocking incoming connections')}")
                        return False
            else:
                console.print(f"[bold red]{self._translate('Domain validation failed. Cannot proceed with Let\'s Encrypt.')}[/]")
                return False
        
    def request_letsencrypt_certificate(self, domain: str, staging: bool = True) -> bool:
        """Request Let's Encrypt certificate.
        
        Args:
            domain: Domain name for the certificate
            staging: Whether to use staging environment (default is True)
            
        Returns:
            bool: True if successful, False otherwise
        """
        mode_msg = f"Requesting Let's Encrypt certificate{' in staging mode' if staging else ''}..."
        console.print(f"[bold cyan]{self._translate(mode_msg)}[/]")
        
        try:
    
            cmd = [
                "docker", "run", "--rm",
                "-v", "certbot_data:/etc/letsencrypt",
                "-v", "certbot_www:/.well-known/acme-challenge",
                "certbot/certbot", "certonly", "--webroot",
                "--webroot-path=/.well-known/acme-challenge",
                "--register-unsafely-without-email", "--agree-tos",
            ]
            
            # Add staging flag if requested
            if staging:
                cmd.append("--staging")
                
            # Add domain
            cmd.extend(["-d", domain])
            
            process = subprocess.run(cmd, capture_output=True, text=True)
            
            if process.returncode == 0:
                console.print(f"[bold green]{self._translate('Certificate request was successful!')}[/]")
                return True
            else:
                error_msg = f"Certificate request failed: {process.stderr}"
                console.print(f"[bold red]{self._translate(error_msg)}[/]")
                return False
                
        except Exception as e:
            error_msg = f"Error requesting certificate: {e}"
            console.print(f"[bold red]{self._translate(error_msg)}[/]")
            return False
    
    def force_refresh_letsencrypt_certificates(self, domain: str, email: Optional[str] = None) -> bool:
        """Force refresh Let's Encrypt certificates.
        
        Args:
            domain: Domain name for the certificate
            email: Optional email address for notifications
            
        Returns:
            bool: True if successful, False otherwise
        """
        console.print(f"[bold cyan]{self._translate('Force refreshing Let\'s Encrypt certificates...')}[/]")
        
        try:

            # Run certbot certonly with force-renewal option
            cmd = [
                "docker", "run", "--rm",
                "-v", "certbot_data:/etc/letsencrypt",
                "-v", "certbot_www:/var/www/certbot",
                "certbot/certbot", "certonly", "--webroot",
                "--webroot-path=/var/www/certbot",
                "--force-renewal",
                "-d", domain
            ]
            
            # Add email or register-unsafely-without-email
            if email:
                cmd.extend(["--email", email])
            else:
                cmd.append("--register-unsafely-without-email")
            
            cmd.append("--agree-tos")
            
            # Run the command
            process = subprocess.run(cmd, capture_output=True, text=True)
            
            if process.returncode == 0:
                console.print(f"[bold green]{self._translate('Certificate refresh was successful!')}[/]")
                return True
            else:
                error_msg = f"Certificate refresh failed with return code {process.returncode}"
                console.print(f"[bold red]{self._translate(error_msg)}[/]")
                
                # Display error details
                if process.stderr:
                    error_lines = process.stderr.split('\n')
                    filtered_errors = [line for line in error_lines if line.strip() and not line.startswith('Saving debug log')]
                    
                    if filtered_errors:
                        console.print(f"[bold red]{self._translate('Error details:')}[/]")
                        for line in filtered_errors[:10]:  # Show first 10 lines to avoid flooding
                            if "error:" in line.lower() or "critical:" in line.lower() or "problem" in line.lower():
                                console.print(f"[red]{line}[/]")
                            else:
                                console.print(line)
                        
                        if len(filtered_errors) > 10:
                            console.print(f"[dim]{self._translate('... additional error lines omitted ...')}[/]")
                
                return False
                
        except Exception as e:
            error_msg = f"Error during certificate refresh: {e}"
            console.print(f"[bold red]{self._translate(error_msg)}[/]")
            return False