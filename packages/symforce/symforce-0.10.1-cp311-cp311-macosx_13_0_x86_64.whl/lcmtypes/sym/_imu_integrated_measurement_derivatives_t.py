# This file automatically generated by skymarshal
# DO NOT MODIFY BY HAND
# fmt: off
# isort: off
# mypy: disallow-untyped-defs
#
# From Source File: /Users/runner/work/symforce/symforce/lcmtypes/symforce.lcm

import copy
import typing as T  # pylint: disable=unused-import

from io import BytesIO
import struct
from lcmtypes.eigen_lcm._Matrix3d import Matrix3d

class imu_integrated_measurement_derivatives_t(object):
    __slots__: T.List[str] = ["DR_D_gyro_bias", "Dv_D_accel_bias", "Dv_D_gyro_bias", "Dp_D_accel_bias", "Dp_D_gyro_bias"]

    def __init__(
        self,
        DR_D_gyro_bias: T.Optional[Matrix3d]=None,
        Dv_D_accel_bias: T.Optional[Matrix3d]=None,
        Dv_D_gyro_bias: T.Optional[Matrix3d]=None,
        Dp_D_accel_bias: T.Optional[Matrix3d]=None,
        Dp_D_gyro_bias: T.Optional[Matrix3d]=None,
        _skip_initialize: bool=False,
    ) -> None:
        """ If _skip_initialize is True, all other constructor arguments are ignored """
        if _skip_initialize:
            return
        self.DR_D_gyro_bias: Matrix3d = Matrix3d._default() if DR_D_gyro_bias is None else DR_D_gyro_bias
        self.Dv_D_accel_bias: Matrix3d = Matrix3d._default() if Dv_D_accel_bias is None else Dv_D_accel_bias
        self.Dv_D_gyro_bias: Matrix3d = Matrix3d._default() if Dv_D_gyro_bias is None else Dv_D_gyro_bias
        self.Dp_D_accel_bias: Matrix3d = Matrix3d._default() if Dp_D_accel_bias is None else Dp_D_accel_bias
        self.Dp_D_gyro_bias: Matrix3d = Matrix3d._default() if Dp_D_gyro_bias is None else Dp_D_gyro_bias

    @staticmethod
    def from_all_fields(
        DR_D_gyro_bias: Matrix3d,
        Dv_D_accel_bias: Matrix3d,
        Dv_D_gyro_bias: Matrix3d,
        Dp_D_accel_bias: Matrix3d,
        Dp_D_gyro_bias: Matrix3d,
    ) -> "imu_integrated_measurement_derivatives_t":
        return imu_integrated_measurement_derivatives_t(
            DR_D_gyro_bias=DR_D_gyro_bias,
            Dv_D_accel_bias=Dv_D_accel_bias,
            Dv_D_gyro_bias=Dv_D_gyro_bias,
            Dp_D_accel_bias=Dp_D_accel_bias,
            Dp_D_gyro_bias=Dp_D_gyro_bias,
        )

    @staticmethod
    def _skytype_meta() -> T.Dict[str, str]:
        return dict(
            type="struct",
            package="sym",
            name="imu_integrated_measurement_derivatives_t",
        )

    @classmethod
    def _default(cls) -> "imu_integrated_measurement_derivatives_t":
        return cls()

    def __repr__(self) -> str:
        return "imu_integrated_measurement_derivatives_t({})".format(
            ", ".join("{}={}".format(name, repr(getattr(self, name))) for name in self.__slots__))

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, imu_integrated_measurement_derivatives_t):
            return NotImplemented
        return (
            (self.DR_D_gyro_bias==other.DR_D_gyro_bias) and
            (self.Dv_D_accel_bias==other.Dv_D_accel_bias) and
            (self.Dv_D_gyro_bias==other.Dv_D_gyro_bias) and
            (self.Dp_D_accel_bias==other.Dp_D_accel_bias) and
            (self.Dp_D_gyro_bias==other.Dp_D_gyro_bias)
        )
    # Disallow hashing for python struct lcmtypes.
    __hash__ = None  # type: ignore[assignment]

    def encode(self) -> bytes:
        buf = BytesIO()
        buf.write(imu_integrated_measurement_derivatives_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf: T.BinaryIO) -> None:
        if hasattr(self.DR_D_gyro_bias, '_get_packed_fingerprint'):
            assert self.DR_D_gyro_bias._get_packed_fingerprint() == Matrix3d._get_packed_fingerprint()
        else:
            assert self.DR_D_gyro_bias._get_hash_recursive([]) == Matrix3d._get_hash_recursive([])
        self.DR_D_gyro_bias._encode_one(buf)
        if hasattr(self.Dv_D_accel_bias, '_get_packed_fingerprint'):
            assert self.Dv_D_accel_bias._get_packed_fingerprint() == Matrix3d._get_packed_fingerprint()
        else:
            assert self.Dv_D_accel_bias._get_hash_recursive([]) == Matrix3d._get_hash_recursive([])
        self.Dv_D_accel_bias._encode_one(buf)
        if hasattr(self.Dv_D_gyro_bias, '_get_packed_fingerprint'):
            assert self.Dv_D_gyro_bias._get_packed_fingerprint() == Matrix3d._get_packed_fingerprint()
        else:
            assert self.Dv_D_gyro_bias._get_hash_recursive([]) == Matrix3d._get_hash_recursive([])
        self.Dv_D_gyro_bias._encode_one(buf)
        if hasattr(self.Dp_D_accel_bias, '_get_packed_fingerprint'):
            assert self.Dp_D_accel_bias._get_packed_fingerprint() == Matrix3d._get_packed_fingerprint()
        else:
            assert self.Dp_D_accel_bias._get_hash_recursive([]) == Matrix3d._get_hash_recursive([])
        self.Dp_D_accel_bias._encode_one(buf)
        if hasattr(self.Dp_D_gyro_bias, '_get_packed_fingerprint'):
            assert self.Dp_D_gyro_bias._get_packed_fingerprint() == Matrix3d._get_packed_fingerprint()
        else:
            assert self.Dp_D_gyro_bias._get_hash_recursive([]) == Matrix3d._get_hash_recursive([])
        self.Dp_D_gyro_bias._encode_one(buf)

    @staticmethod
    def decode(data: T.Union[bytes, T.BinaryIO]) -> "imu_integrated_measurement_derivatives_t":
        # NOTE(eric): This function can technically accept either a BinaryIO or
        # anything that supports the C++ Buffer Protocol,
        # which is unspecifiable in type hints.

        if hasattr(data, "read"):
            # NOTE(eric): mypy isn't able to figure out the hasattr check
            buf = T.cast(T.BinaryIO, data)
        else:
            buf = BytesIO(T.cast(bytes, data))

        if buf.read(8) != imu_integrated_measurement_derivatives_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return imu_integrated_measurement_derivatives_t._decode_one(buf)

    @staticmethod
    def _decode_one(buf: T.BinaryIO) -> "imu_integrated_measurement_derivatives_t":
        self = imu_integrated_measurement_derivatives_t(_skip_initialize=True)
        self.DR_D_gyro_bias = Matrix3d._decode_one(buf)
        self.Dv_D_accel_bias = Matrix3d._decode_one(buf)
        self.Dv_D_gyro_bias = Matrix3d._decode_one(buf)
        self.Dp_D_accel_bias = Matrix3d._decode_one(buf)
        self.Dp_D_gyro_bias = Matrix3d._decode_one(buf)
        return self

    @staticmethod
    def _get_hash_recursive(parents: T.List[T.Type]) -> int:
        if imu_integrated_measurement_derivatives_t in parents: return 0
        newparents = parents + [imu_integrated_measurement_derivatives_t]
        tmphash = (0xafcc2d0dcef62f5b+ Matrix3d._get_hash_recursive(newparents)+ Matrix3d._get_hash_recursive(newparents)+ Matrix3d._get_hash_recursive(newparents)+ Matrix3d._get_hash_recursive(newparents)+ Matrix3d._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash

    _packed_fingerprint: T.Optional[bytes] = None

    @staticmethod
    def _get_packed_fingerprint() -> bytes:
        if imu_integrated_measurement_derivatives_t._packed_fingerprint is None:
            imu_integrated_measurement_derivatives_t._packed_fingerprint = struct.pack(">Q", imu_integrated_measurement_derivatives_t._get_hash_recursive([]))
        return imu_integrated_measurement_derivatives_t._packed_fingerprint

    def deepcopy(self, **kwargs: T.Any) -> "imu_integrated_measurement_derivatives_t":
        """
        Deep copy of this LCM type

        Returns a copy w/ members specified by kwargs replaced with new values specified by kwargs.
        """
        result = copy.deepcopy(self)
        for key in kwargs:
            if not hasattr(result, key):
                raise KeyError("Type imu_integrated_measurement_derivatives_t does not have attribute: " + str(key))
            setattr(result, key, kwargs[key])
        return result
