# This file automatically generated by skymarshal
# DO NOT MODIFY BY HAND
# fmt: off
# isort: off
# mypy: disallow-untyped-defs
#
# From Source File: /project/lcmtypes/symforce.lcm

import copy
import typing as T  # pylint: disable=unused-import

from io import BytesIO
import struct
from lcmtypes.eigen_lcm._MatrixXd import MatrixXd
from lcmtypes.eigen_lcm._VectorXd import VectorXd
from lcmtypes.sym._values_t import values_t

class optimization_iteration_t(object):
    __slots__: T.List[str] = ["iteration", "current_lambda", "new_error_linear", "new_error", "relative_reduction", "update_accepted", "update_angle_change", "update", "values", "residual", "jacobian_values"]

    def __init__(
        self,
        iteration: int=0,
        current_lambda: float=0.0,
        new_error_linear: float=0.0,
        new_error: float=0.0,
        relative_reduction: float=0.0,
        update_accepted: bool=False,
        update_angle_change: float=0.0,
        update: T.Optional[VectorXd]=None,
        values: T.Optional[values_t]=None,
        residual: T.Optional[VectorXd]=None,
        jacobian_values: T.Optional[MatrixXd]=None,
        _skip_initialize: bool=False,
    ) -> None:
        """ If _skip_initialize is True, all other constructor arguments are ignored """
        if _skip_initialize:
            return
        # Zero-indexed iteration number (Information before the first iteration is
        # included at index -1)
        self.iteration: int = iteration
        # Value of lambda at this iteration
        self.current_lambda: float = current_lambda
        # Error after the iteration, using the linearized cost
        self.new_error_linear: float = new_error_linear
        # Error after the iteration, using the full nonlinear cost function
        self.new_error: float = new_error
        # Relative reduction in error between the initial and updated states for
        # this iteration
        self.relative_reduction: float = relative_reduction
        # Was the update accepted?
        self.update_accepted: bool = update_accepted
        # Angle between previous update and current update
        self.update_angle_change: float = update_angle_change
        # The update, values, residual, and jacobian are only populated when debug_stats is true,
        # otherwise they are size 0
        # The update at this step
        self.update: VectorXd = VectorXd._default() if update is None else update
        # The Values at this step
        self.values: values_t = values_t._default() if values is None else values
        # The problem residual
        self.residual: VectorXd = VectorXd._default() if residual is None else residual
        # The problem jacobian exactly if dense, or as CSC format sparse data column vector if sparse
        self.jacobian_values: MatrixXd = MatrixXd._default() if jacobian_values is None else jacobian_values

    @staticmethod
    def from_all_fields(
        iteration: int,
        current_lambda: float,
        new_error_linear: float,
        new_error: float,
        relative_reduction: float,
        update_accepted: bool,
        update_angle_change: float,
        update: VectorXd,
        values: values_t,
        residual: VectorXd,
        jacobian_values: MatrixXd,
    ) -> "optimization_iteration_t":
        return optimization_iteration_t(
            iteration=iteration,
            current_lambda=current_lambda,
            new_error_linear=new_error_linear,
            new_error=new_error,
            relative_reduction=relative_reduction,
            update_accepted=update_accepted,
            update_angle_change=update_angle_change,
            update=update,
            values=values,
            residual=residual,
            jacobian_values=jacobian_values,
        )

    @staticmethod
    def _skytype_meta() -> T.Dict[str, str]:
        return dict(
            type="struct",
            package="sym",
            name="optimization_iteration_t",
        )

    @classmethod
    def _default(cls) -> "optimization_iteration_t":
        return cls()

    def __repr__(self) -> str:
        return "optimization_iteration_t({})".format(
            ", ".join("{}={}".format(name, repr(getattr(self, name))) for name in self.__slots__))

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, optimization_iteration_t):
            return NotImplemented
        return (
            (self.iteration==other.iteration) and
            (self.current_lambda==other.current_lambda) and
            (self.new_error_linear==other.new_error_linear) and
            (self.new_error==other.new_error) and
            (self.relative_reduction==other.relative_reduction) and
            (self.update_accepted==other.update_accepted) and
            (self.update_angle_change==other.update_angle_change) and
            (self.update==other.update) and
            (self.values==other.values) and
            (self.residual==other.residual) and
            (self.jacobian_values==other.jacobian_values)
        )
    # Disallow hashing for python struct lcmtypes.
    __hash__ = None  # type: ignore[assignment]

    def encode(self) -> bytes:
        buf = BytesIO()
        buf.write(optimization_iteration_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf: T.BinaryIO) -> None:
        buf.write(optimization_iteration_t._CACHED_STRUCT_0.pack(self.iteration, self.current_lambda, self.new_error_linear, self.new_error, self.relative_reduction, self.update_accepted, self.update_angle_change))
        if hasattr(self.update, '_get_packed_fingerprint'):
            assert self.update._get_packed_fingerprint() == VectorXd._get_packed_fingerprint()
        else:
            assert self.update._get_hash_recursive([]) == VectorXd._get_hash_recursive([])
        self.update._encode_one(buf)
        if hasattr(self.values, '_get_packed_fingerprint'):
            assert self.values._get_packed_fingerprint() == values_t._get_packed_fingerprint()
        else:
            assert self.values._get_hash_recursive([]) == values_t._get_hash_recursive([])
        self.values._encode_one(buf)
        if hasattr(self.residual, '_get_packed_fingerprint'):
            assert self.residual._get_packed_fingerprint() == VectorXd._get_packed_fingerprint()
        else:
            assert self.residual._get_hash_recursive([]) == VectorXd._get_hash_recursive([])
        self.residual._encode_one(buf)
        if hasattr(self.jacobian_values, '_get_packed_fingerprint'):
            assert self.jacobian_values._get_packed_fingerprint() == MatrixXd._get_packed_fingerprint()
        else:
            assert self.jacobian_values._get_hash_recursive([]) == MatrixXd._get_hash_recursive([])
        self.jacobian_values._encode_one(buf)

    @staticmethod
    def decode(data: T.Union[bytes, T.BinaryIO]) -> "optimization_iteration_t":
        # NOTE(eric): This function can technically accept either a BinaryIO or
        # anything that supports the C++ Buffer Protocol,
        # which is unspecifiable in type hints.

        if hasattr(data, "read"):
            # NOTE(eric): mypy isn't able to figure out the hasattr check
            buf = T.cast(T.BinaryIO, data)
        else:
            buf = BytesIO(T.cast(bytes, data))

        if buf.read(8) != optimization_iteration_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return optimization_iteration_t._decode_one(buf)

    @staticmethod
    def _decode_one(buf: T.BinaryIO) -> "optimization_iteration_t":
        self = optimization_iteration_t(_skip_initialize=True)
        self.iteration, self.current_lambda, self.new_error_linear, self.new_error, self.relative_reduction = optimization_iteration_t._CACHED_STRUCT_1.unpack(buf.read(34))
        self.update_accepted = bool(optimization_iteration_t._CACHED_STRUCT_2.unpack(buf.read(1))[0])
        self.update_angle_change = optimization_iteration_t._CACHED_STRUCT_3.unpack(buf.read(8))[0]
        self.update = VectorXd._decode_one(buf)
        self.values = values_t._decode_one(buf)
        self.residual = VectorXd._decode_one(buf)
        self.jacobian_values = MatrixXd._decode_one(buf)
        return self

    @staticmethod
    def _get_hash_recursive(parents: T.List[T.Type]) -> int:
        if optimization_iteration_t in parents: return 0
        newparents = parents + [optimization_iteration_t]
        tmphash = (0xd872c6c0039b22bb+ VectorXd._get_hash_recursive(newparents)+ values_t._get_hash_recursive(newparents)+ VectorXd._get_hash_recursive(newparents)+ MatrixXd._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash

    _packed_fingerprint: T.Optional[bytes] = None

    @staticmethod
    def _get_packed_fingerprint() -> bytes:
        if optimization_iteration_t._packed_fingerprint is None:
            optimization_iteration_t._packed_fingerprint = struct.pack(">Q", optimization_iteration_t._get_hash_recursive([]))
        return optimization_iteration_t._packed_fingerprint

    def deepcopy(self, **kwargs: T.Any) -> "optimization_iteration_t":
        """
        Deep copy of this LCM type

        Returns a copy w/ members specified by kwargs replaced with new values specified by kwargs.
        """
        result = copy.deepcopy(self)
        for key in kwargs:
            if not hasattr(result, key):
                raise KeyError("Type optimization_iteration_t does not have attribute: " + str(key))
            setattr(result, key, kwargs[key])
        return result

    _CACHED_STRUCT_0 = struct.Struct(">hddddbd")
    _CACHED_STRUCT_1 = struct.Struct(">hdddd")
    _CACHED_STRUCT_2 = struct.Struct("b")
    _CACHED_STRUCT_3 = struct.Struct(">d")
