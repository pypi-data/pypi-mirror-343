# This file automatically generated by skymarshal
# DO NOT MODIFY BY HAND
# fmt: off
# isort: off
# mypy: disallow-untyped-defs
#
# From Source File: /project/lcmtypes/symforce.lcm

import copy
import typing as T  # pylint: disable=unused-import

from io import BytesIO
import struct
from lcmtypes.eigen_lcm._VectorXi import VectorXi
from lcmtypes.sym._optimization_iteration_t import optimization_iteration_t
from lcmtypes.sym._optimization_status_t import optimization_status_t
from lcmtypes.sym._sparse_matrix_structure_t import sparse_matrix_structure_t

class optimization_stats_t(object):
    __slots__: T.List[str] = ["iterations", "best_index", "status", "failure_reason", "jacobian_sparsity", "linear_solver_ordering", "cholesky_factor_sparsity"]

    def __init__(
        self,
        iterations: T.Optional[T.List[optimization_iteration_t]]=None,
        best_index: int=0,
        status: T.Optional[optimization_status_t]=None,
        failure_reason: int=0,
        jacobian_sparsity: T.Optional[sparse_matrix_structure_t]=None,
        linear_solver_ordering: T.Optional[VectorXi]=None,
        cholesky_factor_sparsity: T.Optional[sparse_matrix_structure_t]=None,
        _skip_initialize: bool=False,
    ) -> None:
        """ If _skip_initialize is True, all other constructor arguments are ignored """
        if _skip_initialize:
            return
        self.iterations: T.List[optimization_iteration_t] = [] if iterations is None else iterations
        # Index into iterations of the best iteration (containing the optimal Values)
        self.best_index: int = best_index
        # What was the result of the optimization? (did it converge, fail, etc.)
        self.status: optimization_status_t = optimization_status_t._default() if status is None else status
        # If status == FAILED, why?  This should be cast to the Optimizer::FailureReason enum
        # for the nonlinear solver you used.
        self.failure_reason: int = failure_reason
        # The sparsity pattern of the problem jacobian
        # Only filled if Optimizer created with debug_stats = true and include_jacobians = true,
        # otherwise default constructed.
        # If using a dense linearization, only the shape field will be filled.
        self.jacobian_sparsity: sparse_matrix_structure_t = sparse_matrix_structure_t._default() if jacobian_sparsity is None else jacobian_sparsity
        # The permutation used by the linear solver
        # Only filled if using an Optimizer created with debug_stats = true and a linear solver that
        # exposes Permutation() (such as the default SparseCholeskySolver).  Otherwise, will be default
        # constructed.
        self.linear_solver_ordering: VectorXi = VectorXi._default() if linear_solver_ordering is None else linear_solver_ordering
        # The sparsity pattern of the cholesky factor L
        # Only filled if using an Optimizer created with debug_stats = true and a linear solver that
        # exposes L() (such as the default SparseCholeskySolver).  Otherwise, will be default
        # constructed.
        self.cholesky_factor_sparsity: sparse_matrix_structure_t = sparse_matrix_structure_t._default() if cholesky_factor_sparsity is None else cholesky_factor_sparsity

    @staticmethod
    def from_all_fields(
        iterations: T.List[optimization_iteration_t],
        best_index: int,
        status: optimization_status_t,
        failure_reason: int,
        jacobian_sparsity: sparse_matrix_structure_t,
        linear_solver_ordering: VectorXi,
        cholesky_factor_sparsity: sparse_matrix_structure_t,
    ) -> "optimization_stats_t":
        return optimization_stats_t(
            iterations=iterations,
            best_index=best_index,
            status=status,
            failure_reason=failure_reason,
            jacobian_sparsity=jacobian_sparsity,
            linear_solver_ordering=linear_solver_ordering,
            cholesky_factor_sparsity=cholesky_factor_sparsity,
        )

    @staticmethod
    def _skytype_meta() -> T.Dict[str, str]:
        return dict(
            type="struct",
            package="sym",
            name="optimization_stats_t",
        )

    @classmethod
    def _default(cls) -> "optimization_stats_t":
        return cls()

    def __repr__(self) -> str:
        return "optimization_stats_t({})".format(
            ", ".join("{}={}".format(name, repr(getattr(self, name))) for name in self.__slots__))

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, optimization_stats_t):
            return NotImplemented
        return (
            (self.iterations==other.iterations) and
            (self.best_index==other.best_index) and
            (self.status==other.status) and
            (self.failure_reason==other.failure_reason) and
            (self.jacobian_sparsity==other.jacobian_sparsity) and
            (self.linear_solver_ordering==other.linear_solver_ordering) and
            (self.cholesky_factor_sparsity==other.cholesky_factor_sparsity)
        )
    # Disallow hashing for python struct lcmtypes.
    __hash__ = None  # type: ignore[assignment]

    def encode(self) -> bytes:
        buf = BytesIO()
        buf.write(optimization_stats_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf: T.BinaryIO) -> None:
        v_num_iterations = len(self.iterations)
        buf.write(optimization_stats_t._CACHED_STRUCT_0.pack(v_num_iterations))
        for i0 in range(v_num_iterations):
            if hasattr(self.iterations[i0], '_get_packed_fingerprint'):
                assert self.iterations[i0]._get_packed_fingerprint() == optimization_iteration_t._get_packed_fingerprint()
            else:
                assert self.iterations[i0]._get_hash_recursive([]) == optimization_iteration_t._get_hash_recursive([])
            self.iterations[i0]._encode_one(buf)
        buf.write(optimization_stats_t._CACHED_STRUCT_0.pack(self.best_index))
        if hasattr(self.status, '_get_packed_fingerprint'):
            assert self.status._get_packed_fingerprint() == optimization_status_t._get_packed_fingerprint()
        else:
            assert self.status._get_hash_recursive([]) == optimization_status_t._get_hash_recursive([])
        self.status._encode_one(buf)
        buf.write(optimization_stats_t._CACHED_STRUCT_0.pack(self.failure_reason))
        if hasattr(self.jacobian_sparsity, '_get_packed_fingerprint'):
            assert self.jacobian_sparsity._get_packed_fingerprint() == sparse_matrix_structure_t._get_packed_fingerprint()
        else:
            assert self.jacobian_sparsity._get_hash_recursive([]) == sparse_matrix_structure_t._get_hash_recursive([])
        self.jacobian_sparsity._encode_one(buf)
        if hasattr(self.linear_solver_ordering, '_get_packed_fingerprint'):
            assert self.linear_solver_ordering._get_packed_fingerprint() == VectorXi._get_packed_fingerprint()
        else:
            assert self.linear_solver_ordering._get_hash_recursive([]) == VectorXi._get_hash_recursive([])
        self.linear_solver_ordering._encode_one(buf)
        if hasattr(self.cholesky_factor_sparsity, '_get_packed_fingerprint'):
            assert self.cholesky_factor_sparsity._get_packed_fingerprint() == sparse_matrix_structure_t._get_packed_fingerprint()
        else:
            assert self.cholesky_factor_sparsity._get_hash_recursive([]) == sparse_matrix_structure_t._get_hash_recursive([])
        self.cholesky_factor_sparsity._encode_one(buf)

    @staticmethod
    def decode(data: T.Union[bytes, T.BinaryIO]) -> "optimization_stats_t":
        # NOTE(eric): This function can technically accept either a BinaryIO or
        # anything that supports the C++ Buffer Protocol,
        # which is unspecifiable in type hints.

        if hasattr(data, "read"):
            # NOTE(eric): mypy isn't able to figure out the hasattr check
            buf = T.cast(T.BinaryIO, data)
        else:
            buf = BytesIO(T.cast(bytes, data))

        if buf.read(8) != optimization_stats_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return optimization_stats_t._decode_one(buf)

    @staticmethod
    def _decode_one(buf: T.BinaryIO) -> "optimization_stats_t":
        self = optimization_stats_t(_skip_initialize=True)
        v_num_iterations = optimization_stats_t._CACHED_STRUCT_0.unpack(buf.read(4))[0]
        self.iterations = []
        for i0 in range(v_num_iterations):
            self.iterations.append(optimization_iteration_t._decode_one(buf))
        self.best_index = optimization_stats_t._CACHED_STRUCT_0.unpack(buf.read(4))[0]
        self.status = optimization_status_t._decode_one(buf)
        self.failure_reason = optimization_stats_t._CACHED_STRUCT_0.unpack(buf.read(4))[0]
        self.jacobian_sparsity = sparse_matrix_structure_t._decode_one(buf)
        self.linear_solver_ordering = VectorXi._decode_one(buf)
        self.cholesky_factor_sparsity = sparse_matrix_structure_t._decode_one(buf)
        return self

    @staticmethod
    def _get_hash_recursive(parents: T.List[T.Type]) -> int:
        if optimization_stats_t in parents: return 0
        newparents = parents + [optimization_stats_t]
        tmphash = (0xf934e9f17e183800+ optimization_iteration_t._get_hash_recursive(newparents)+ optimization_status_t._get_hash_recursive(newparents)+ sparse_matrix_structure_t._get_hash_recursive(newparents)+ VectorXi._get_hash_recursive(newparents)+ sparse_matrix_structure_t._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash

    _packed_fingerprint: T.Optional[bytes] = None

    @staticmethod
    def _get_packed_fingerprint() -> bytes:
        if optimization_stats_t._packed_fingerprint is None:
            optimization_stats_t._packed_fingerprint = struct.pack(">Q", optimization_stats_t._get_hash_recursive([]))
        return optimization_stats_t._packed_fingerprint

    def deepcopy(self, **kwargs: T.Any) -> "optimization_stats_t":
        """
        Deep copy of this LCM type

        Returns a copy w/ members specified by kwargs replaced with new values specified by kwargs.
        """
        result = copy.deepcopy(self)
        for key in kwargs:
            if not hasattr(result, key):
                raise KeyError("Type optimization_stats_t does not have attribute: " + str(key))
            setattr(result, key, kwargs[key])
        return result

    _CACHED_STRUCT_0 = struct.Struct(">i")
