<html data-bs-theme="dark">

<head>
    <title>"placeholder_dashboard_title"</title>
    <!-- ChartJs import -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>

    <!-- ChartJs Datalabel plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>

    <!-- ChartJs timeline plugin (helps create time axis) -->
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <!-- ChartJs boxplot plugin (for time deviation graph) -->
    <script type="text/javascript"
        src="https://unpkg.com/@sgratzl/chartjs-chart-boxplot@3.6.0/build/index.umd.min.js"></script>

    <!-- DataTables and Bootstrap imports -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.0/css/bootstrap.min.css"
        rel="stylesheet" />
    <link href="https://cdn.datatables.net/v/bs5/jq-3.7.0/dt-2.1.8/datatables.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.datatables.net/v/bs5/jq-3.7.0/dt-2.1.8/datatables.min.js"></script>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon"
        href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKcAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAqAAAAAAAAAAAAAAAAAAAALIAAAD/AAAA4AAAANwAAADcAAAA3AAAANwAAADcAAAA3AAAANwAAADcAAAA4AAAAP8AAACxAAAAAAAAAKYAAAD/AAAAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/AAAA/wAAAKkAAAD6AAAAzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN8AAAD/AAAA+gAAAMMAAAAAAAAAAgAAAGsAAABrAAAAawAAAGsAAABrAAAAawAAAGsAAABrAAAADAAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAAIsAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAANEAAAAAAAAA2gAAAP8AAAD6AAAAwwAAAAAAAAAAAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAFAAAAAAAAANoAAAD/AAAA+gAAAMMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAADwAAAB8AAAAAAAAAGAAAABcAAAAAAAAAH8AAABKAAAAAAAAAAAAAAAAAAAA2gAAAP8AAAD6AAAAwwAAAAAAAADCAAAA/wAAACkAAADqAAAA4QAAAAAAAAD7AAAA/wAAALAAAAAGAAAAAAAAANoAAAD/AAAA+gAAAMMAAAAAAAAAIwAAAP4AAAD/AAAA/wAAAGAAAAAAAAAAAAAAAMkAAAD/AAAAigAAAAAAAADaAAAA/wAAAPoAAADDAAAAAAAAAAAAAAAIAAAAcAAAABkAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAA2gAAAP8AAAD7AAAAywAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN4AAAD/AAAAqwAAAP8AAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALIAAAD/AAAAsgAAAAAAAAC5AAAA/wAAAMoAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMkAAAD/AAAAvAAAAAAAAAAAAAAAAAAAAKwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAArQAAAAAAAAAAwAMAAIABAAAf+AAAP/wAAD/8AAAgBAAAP/wAAD/8AAA//AAAJIwAADHEAAA//AAAP/wAAB/4AACAAQAAwAMAAA==" />

    <style>
        :root {
            font-family: Helvetica, sans-serif;
        }

        @media (prefers-color-scheme: light) {
            body {
                background-color: #eee;
            }
        }

        @media (prefers-color-scheme: dark) {
            :root {
                color-scheme: dark;
            }
        }

        .canvas {
            width: 800px;
            height: 540px;
            text-align: center;
        }

        .canvas-vertical {
            overflow-y: auto;
        }

        .card {
            margin-bottom: 10px;
        }

        .dt-container {
            margin-top: 20px;
        }

        .stats {
            float: right;
            text-align: right;
            font-size: 0.9em;
            white-space: nowrap;
        }

        .fullscreen {
            position: fixed;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
            background: #212529;
            z-index: 10;
            padding: 11px 20px 70px 20px;
        }

        .selectBox {
            position: relative;
        }

        .selectBox select {
            width: 100%;
        }

        .overSelect {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
        }

        #checkboxes {
            display: none;
            position: absolute;
            z-index: 2;
        }

        #checkboxes label {
            display: block;
        }

        .border,
        .controls {
            min-height: 165px;
        }
    </style>
</head>

<body>
    <div class="container-fluid mt-4">
        <div class="card" id="filterSection">
            <div class="card-body">
                <div class="row">
                    <div class="col-10">
                        <div class="row">
                            <div class="col-auto">
                                <h1>"placeholder_dashboard_title"</h1>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-auto">
                                <label class="form-label form-label-sm" for="runs">Runs</label>
                                <select class="form-select form-select-sm" id="runs"></select>
                            </div>
                            <div class="col-auto">
                                <div class="selectBox" id="selectRunTags">
                                    <label class="form-label form-label-sm" for="runTag">Run Tags</label>
                                    <select class="form-select form-select-sm">
                                        <option>Select Tags</option>
                                    </select>
                                    <div class="overSelect"></div>
                                </div>
                                <div id="checkboxes">
                                    <ul class="list-group" id="runTag"></ul>
                                </div>
                            </div>
                            <div class="col-auto">
                                <label class="form-label form-label-sm" for="fromDate">From Date</label>
                                <input class="form-control form-control-sm" id="fromDate" type="date" />
                            </div>
                            <div class="col-auto">
                                <label class="form-label form-label-sm" for="fromTime">From Time</label>
                                <input class="form-control form-control-sm" id="fromTime" type="time" />
                            </div>
                            <div class="col-auto">
                                <label class="form-label form-label-sm" for="toDate">To Date</label>
                                <input class="form-control form-control-sm" id="toDate" type="date" />
                            </div>
                            <div class="col-auto">
                                <label class="form-label form-label-sm" for="toTime">To Time</label>
                                <input class="form-control form-control-sm" id="toTime" type="time" />
                            </div>
                            <div class="col-auto d-flex">
                                <button class="btn btn-outline-primary btn-sm mt-auto" id="resetFilters">Reset
                                    Filters</button>
                            </div>
                            <div class="col-auto d-flex">
                                <button type="button" class="btn btn-outline-primary btn-sm mt-auto"
                                    data-bs-toggle="modal" data-bs-target="#hideModal">
                                    Customize View
                                </button>
                            </div>
                            <div class="col-auto mt-auto">
                                <a href="/">
                                    <button class="btn btn-outline-primary btn-sm" id="openDashboard"
                                        hidden="placeholder_server_admin_page">Open
                                        Admin Page</button>
                                </a>
                            </div>
                        </div>
                    </div>
                    <div class="col-2 stats">
                        <span id="stats"></span>
                    </div>
                </div>
            </div>
        </div>

        <div class="card" id="runStatisticsSection">
            <div class="card-header">
                <div class="row">
                    <div class="col-auto mt-2">
                        <div class="btn btn-sm btn-secondary" id="runDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#runDetails" aria-expanded="true" aria-controls="runDetails"></div>
                    </div>
                    <div class="col-4">
                        <h2 id="runTitle">Statistics</h2>
                    </div>
                </div>
            </div>
            <div class="card-body collapse show" id="runDetails">
                <div class="row" id="runStatisticsChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary" id="runStatisticsDurationButton" data-bs-toggle="collapse"
                            data-bs-target="#runStatisticsDurationCollapse" aria-expanded="true"
                            aria-controls="runStatisticsDurationCollapse"></div>
                    </div>
                    <div class="col">
                        <h4>Statistics & Duration</h4>
                    </div>
                </div>
                <div class="row collapse show" id="runStatisticsDurationCollapse">
                    <div class="col canvas mb-5" id="runStatisticsCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="runStatisticsGraphPercentages">Percentages</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="runStatisticsGraphAmount">Amount</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="runStatisticsGraphLine">Timeline</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="runStatisticsFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="runStatisticsClose"
                            hidden>Close</button>
                        <canvas id="runStatisticsGraph"></canvas>
                    </div>
                    <div class="col canvas mb-5" id="runDurationCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled" id="runDurationGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="runDurationGraphLine">Line
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="runDurationFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="runDurationClose"
                            hidden>Close</button>
                        <canvas id="runDurationGraph"></canvas>
                    </div>
                </div>
                <div class="row" id="runTableChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary collapsed" id="runTableButton" data-bs-toggle="collapse"
                            data-bs-target="#runTableCollapse" aria-expanded="true" aria-controls="runTableCollapse">
                        </div>
                    </div>
                    <div class="col">
                        <h4>Table</h4>
                    </div>
                </div>
                <div class="row collapse" id="runTableCollapse">
                    <div class="col">
                        <table class="table table-striped" id="runTable"></table>
                    </div>
                </div>
            </div>
        </div>

        <div class="card" id="suiteStatisticsSection">
            <div class="card-header">
                <div class="row">
                    <div class="col-auto mt-2">
                        <div class="btn btn-sm btn-secondary" id="suiteDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#suiteDetails" aria-expanded="true" aria-controls="suiteDetails"></div>
                    </div>
                    <div class="col-4">
                        <h2 id="suiteTitle">Suite Statistics</h2>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="suiteSelectSuites">Suite</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="suiteSelectSuites"></select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="card-body collapse show" id="suiteDetails">
                <div class="row" id="suiteStatisticsChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary" id="suiteStatisticsDurationButton"
                            data-bs-toggle="collapse" data-bs-target="#suiteStatisticsDurationCollapse"
                            aria-expanded="true" aria-controls="suiteStatisticsDurationCollapse"></div>
                    </div>
                    <div class="col">
                        <h4>Statistics & Duration</h4>
                    </div>
                </div>
                <div class="row collapse show" id="suiteStatisticsDurationCollapse">
                    <div class="col canvas mb-5" id="suiteStatisticsCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="suiteStatisticsGraphPercentages">Percentages</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="suiteStatisticsGraphAmount">Amount</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="suiteStatisticsGraphLine">Timeline</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="suiteStatisticsFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="suiteStatisticsClose"
                            hidden>Close</button>
                        <canvas id="suiteStatisticsGraph"></canvas>
                    </div>
                    <div class="col canvas mb-5" id="suiteDurationCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled" id="suiteDurationGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="suiteDurationGraphLine">Line
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="suiteDurationFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="suiteDurationClose"
                            hidden>Close</button>
                        <canvas id="suiteDurationGraph"></canvas>
                    </div>
                </div>
                <div class="row" id="suiteMostFailedChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary" id="suiteMostFailedButton" data-bs-toggle="collapse"
                            data-bs-target="#suiteMostFailedCollapse" aria-expanded="true"
                            aria-controls="suiteMostFailedCollapse"></div>
                    </div>
                    <div class="col">
                        <h4>Most Failed</h4>
                    </div>
                </div>
                <div class="row collapse show" id="suiteMostFailedCollapse">
                    <div class="col canvas mb-5" id="suiteMostFailedCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="suiteMostFailedGraphBar">Bar View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="suiteMostFailedGraphTimeline">Timeline View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="suiteMostFailedFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="suiteMostFailedClose"
                            hidden>Close</button>
                        <canvas id="suiteMostFailedGraph"></canvas>
                    </div>
                </div>
                <div class="row" id="suiteTableChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary collapsed" id="suiteTableButton" data-bs-toggle="collapse"
                            data-bs-target="#suiteTableCollapse" aria-expanded="true"
                            aria-controls="suiteTableCollapse"></div>
                    </div>
                    <div class="col">
                        <h4>Table</h4>
                    </div>
                </div>
                <div class="row collapse" id="suiteTableCollapse">
                    <div class="col">
                        <table class="table table-striped" id="suiteTable"></table>
                    </div>
                </div>
            </div>
        </div>

        <div class="card" id="testStatisticsSection">
            <div class="card-header">
                <div class="row">
                    <div class="col-auto mt-2">
                        <div class="btn btn-sm btn-secondary" id="testDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#testDetails" aria-expanded="true" aria-controls="testDetails"></div>
                    </div>
                    <div class="col-4">
                        <h2 id="testTitle">Test Statistics</h2>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="suiteSelectTests">Suite</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="suiteSelectTests"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="testTagsSelect">Test Tags</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="testTagsSelect"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="testSelect">Test</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="testSelect"></select>
                        </div>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group ms-1">
                            <label class="form-check-label mt-2" for="showOnlySelectedtestStatistics">Show Only
                                Test</label>
                        </div>
                        <div class="btn-group form-switch ms-1">
                            <input class="form-check-input mt-2" type="checkbox" role="switch"
                                id="showOnlySelectedtestStatistics" />
                        </div>
                    </div>
                </div>
            </div>
            <div class="card-body collapse show" id="testDetails">
                <div class="row" id="testStatisticsChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary" id="testStatisticsDurationButton"
                            data-bs-toggle="collapse" data-bs-target="#testStatisticsDurationCollapse"
                            aria-expanded="true" aria-controls="testStatisticsDurationCollapse"></div>
                    </div>
                    <div class="col">
                        <h4>Statistics & Duration</h4>
                    </div>
                </div>
                <div class="row collapse show" id="testStatisticsDurationCollapse">
                    <div class="col canvas canvas-vertical" id="testStatisticsCanvas">
                        <div id="testStatisticsVertical">
                            <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                                id="testStatisticsFullscreen">Fullscreen</button>
                            <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testStatisticsClose"
                                hidden>Close</button>
                            <canvas id="testStatisticsGraph"></canvas>
                        </div>
                    </div>
                    <div class="col canvas mb-5" id="testDurationCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled" id="testDurationGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testDurationGraphLine">Line
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="testDurationFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testDurationClose"
                            hidden>Close</button>
                        <canvas id="testDurationGraph"></canvas>
                    </div>
                </div>
                <div class="row" id="testDurationDeviationChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary" id="testDurationDeviationButton" data-bs-toggle="collapse"
                            data-bs-target="#testDurationDeviationCollapse" aria-expanded="true"
                            aria-controls="testDurationDeviationCollapse"></div>
                    </div>
                    <div class="col">
                        <h4>Duration Deviation</h4>
                    </div>
                </div>
                <div class="row collapse show" id="testDurationDeviationCollapse">
                    <div class="col canvas mb-5" id="testDurationDeviationCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="testDurationDeviationGraphBar">Boxplot
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="testDurationDeviationFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testDurationDeviationClose"
                            hidden>Close</button>
                        <canvas id="testDurationDeviationGraph"></canvas>
                    </div>
                </div>
                <div class="row" id="testMostFlakyChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary" id="testMostFlakyButton" data-bs-toggle="collapse"
                            data-bs-target="#testMostFlakyCollapse" aria-expanded="true"
                            aria-controls="testMostFlakyCollapse"></div>
                    </div>
                    <div class="col">
                        <h4>Most Flaky</h4>
                    </div>
                </div>
                <div class="row collapse show" id="testMostFlakyCollapse">
                    <div class="col canvas mb-5" id="testMostFlakyCanvas">
                        <div class="btn-group me-1">
                            <label class="form-check-label mb-2" for="ignoreSkips">Ignore Skips</label>
                        </div>
                        <div class="btn-group form-switch me-1">
                            <input class="form-check-input mb-2" type="checkbox" role="switch" id="ignoreSkips">
                        </div>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMostFlakyGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="testMostFlakyGraphTimeline">Timeline View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMostFlakyFullscreen"
                            style="margin-right:56px;">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMostFlakyClose" hidden
                            style="margin-right:56px;">Close</button>
                        <canvas id="testMostFlakyGraph"></canvas>
                    </div>
                </div>
                <div class="row" id="testMostFailedChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary" id="testMostFailedMessagesButton"
                            data-bs-toggle="collapse" data-bs-target="#testMostFailedMessagesCollapse"
                            aria-expanded="true" aria-controls="testMostFailedMessagesCollapse"></div>
                    </div>
                    <div class="col">
                        <h4>Most Failed & Messages</h4>
                    </div>
                </div>
                <div class="row collapse show" id="testMostFailedMessagesCollapse">
                    <div class="col canvas mb-5" id="testMostFailedCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMostFailedGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="testMostFailedGraphTimeline">Timeline View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="testMostFailedFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMostFailedClose"
                            hidden>Close</button>
                        <canvas id="testMostFailedGraph"></canvas>
                    </div>
                    <div class="col canvas mb-5" id="testMessagesCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMessagesGraphBar">Bar
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="testMessagesGraphTimeline">Timeline
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="testMessagesFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="testMessagesClose"
                            hidden>Close</button>
                        <canvas id="testMessagesGraph"></canvas>
                    </div>
                </div>
                <div class="row" id="testTableChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary collapsed" id="testTableButton" data-bs-toggle="collapse"
                            data-bs-target="#testTableCollapse" aria-expanded="true" aria-controls="testTableCollapse">
                        </div>
                    </div>
                    <div class="col">
                        <h4>Table</h4>
                    </div>
                </div>
                <div class="row collapse" id="testTableCollapse">
                    <div class="col">
                        <table class="table table-striped" id="testTable"></table>
                    </div>
                </div>
            </div>
        </div>

        <div class="card" id="keywordStatisticsSection">
            <div class="card-header">
                <div class="row">
                    <div class="col-auto mt-2">
                        <div class="btn btn-sm btn-secondary" id="keywordDetailsButton" data-bs-toggle="collapse"
                            data-bs-target="#keywordDetails" aria-expanded="true" aria-controls="keywordDetails"></div>
                    </div>
                    <div class="col-4">
                        <h2 id="keywordTitle">Keyword Statistics</h2>
                    </div>
                    <div class="col-auto">
                        <div class="btn-group">
                            <label class="form-label mt-2" for="keywordSelect">Keyword</label>
                        </div>
                        <div class="btn-group">
                            <select class="form-select form-select-sm" id="keywordSelect"></select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="card-body collapse show" id="keywordDetails">
                <div class="row" id="keywordStatisticsChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary" id="keywordStatisticsTimesRunButton"
                            data-bs-toggle="collapse" data-bs-target="#keywordStatisticsTimesRunCollapse"
                            aria-expanded="true" aria-controls="keywordStatisticsTimesRunCollapse"></div>
                    </div>
                    <div class="col">
                        <h4>Statistics & Times Run</h4>
                    </div>
                </div>
                <div class="row collapse show" id="keywordStatisticsTimesRunCollapse">
                    <div class="col canvas mb-5" id="keywordStatisticsCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="keywordStatisticsGraphPercentages">Percentages</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="keywordStatisticsGraphAmount">Amount</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="keywordStatisticsGraphLine">Timeline</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="keywordStatisticsFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordStatisticsClose"
                            hidden>Close</button>
                        <canvas id="keywordStatisticsGraph"></canvas>
                    </div>
                    <div class="col canvas mb-5" id="keywordTimesRunCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="keywordTimesRunGraphBar">Bar View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordTimesRunGraphLine">Line
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="keywordTimesRunFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordTimesRunClose"
                            hidden>Close</button>
                        <canvas id="keywordTimesRunGraph"></canvas>
                    </div>
                </div>
                <div class="row" id="keywordTotalDurationChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary" id="keywordTotalAverageButton" data-bs-toggle="collapse"
                            data-bs-target="#keywordTotalAverageCollapse" aria-expanded="true"
                            aria-controls="keywordTotalAverageCollapse"></div>
                    </div>
                    <div class="col">
                        <h4>Total Duration & Average Duration</h4>
                    </div>
                </div>
                <div class="row collapse show" id="keywordTotalAverageCollapse">
                    <div class="col canvas mb-5" id="keywordTotalDurationCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="keywordTotalDurationGraphBar">Bar View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordTotalDurationGraphLine">Line
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="keywordTotalDurationFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordTotalDurationClose"
                            hidden>Close</button>
                        <canvas id="keywordTotalDurationGraph"></canvas>
                    </div>
                    <div class="col canvas mb-5" id="keywordAverageDurationCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="keywordAverageDurationGraphBar">Bar View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="keywordAverageDurationGraphLine">Line
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="keywordAverageDurationFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordAverageDurationClose"
                            hidden>Close</button>
                        <canvas id="keywordAverageDurationGraph"></canvas>
                    </div>
                </div>
                <div class="row" id="keywordMinDurationChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary" id="keywordMinMaxButton" data-bs-toggle="collapse"
                            data-bs-target="#keywordMinMaxCollapse" aria-expanded="true"
                            aria-controls="keywordMinMaxCollapse"></div>
                    </div>
                    <div class="col">
                        <h4>Min Duration & Max Duration</h4>
                    </div>
                </div>
                <div class="row collapse show" id="keywordMinMaxCollapse">
                    <div class="col canvas mb-5" id="keywordMinDurationCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="keywordMinDurationGraphBar">Bar View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordMinDurationGraphLine">Line
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="keywordMinDurationFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordMinDurationClose"
                            hidden>Close</button>
                        <canvas id="keywordMinDurationGraph"></canvas>
                    </div>
                    <div class="col canvas mb-5" id="keywordMaxDurationCanvas">
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1 disabled"
                            id="keywordMaxDurationGraphBar">Bar View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordMaxDurationGraphLine">Line
                            View</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1"
                            id="keywordMaxDurationFullscreen">Fullscreen</button>
                        <button class="btn btn-outline-primary btn-sm mb-3 mt-1" id="keywordMaxDurationClose"
                            hidden>Close</button>
                        <canvas id="keywordMaxDurationGraph"></canvas>
                    </div>
                </div>
                <div class="row" id="keywordTableChevronRow">
                    <div class="col-auto mt-1">
                        <div class="btn btn-sm btn-secondary collapsed" id="keywordTableButton"
                            data-bs-toggle="collapse" data-bs-target="#keywordTableCollapse" aria-expanded="true"
                            aria-controls="keywordTableCollapse"></div>
                    </div>
                    <div class="col">
                        <h4>Table</h4>
                    </div>
                </div>
                <div class="row collapse" id="keywordTableCollapse">
                    <div class="col">
                        <table class="table table-striped" id="keywordTable"></table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal for hiding graphs/sections -->
        <div class="modal fade" id="hideModal" tabindex="-1" aria-labelledby="hideModalLabel">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header">
                        <h1 class="modal-title" id="hideModalLabel">Customize View</h1>
                        <button type="button" class="btn btn-outline-primary btn-sm mt-auto" data-bs-dismiss="modal"
                            id="saveHide">Save</button>
                    </div>
                    <div class="modal-body">
                        <div class="row justify-content-evenly">
                            <div class="col">
                                <h2>Sections</h2>
                            </div>
                            <div class="col">
                                <h2>Graphs</h2>
                            </div>
                        </div>
                        <div class="row mt-2">
                            <div class="col">
                                <h4>Show</h4>
                                <div class="border border-3 rounded-3">
                                    <ul id="sectionShow" class="list-group"></ul>
                                </div>
                            </div>
                            <div class="col-auto mt-5">
                                <div class="controls mt-5">
                                    <button class="btn btn-sm btn-secondary" id="sectionRight"></button>
                                    <button class="btn btn-sm btn-secondary" id="sectionLeft"></button>
                                </div>
                            </div>
                            <div class="col">
                                <h4>Hide</h4>
                                <div class="border border-3 rounded-3">
                                    <ul id="sectionHide" class="list-group"></ul>
                                </div>
                            </div>
                            <div class="col">
                                <h4>Show</h4>
                                <div class="border border-3 rounded-3">
                                    <ul id="graphShow" class="list-group"></ul>
                                </div>
                            </div>
                            <div class="col-auto mt-5">
                                <div class="controls mt-5">
                                    <button class="btn btn-sm btn-secondary" id="graphRight"></button>
                                    <button class="btn btn-sm btn-secondary" id="graphLeft"></button>
                                </div>
                            </div>
                            <div class="col">
                                <h4>Hide</h4>
                                <div class="border border-3 rounded-3">
                                    <ul id="graphHide" class="list-group"></ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // collapse/expand buttons icons/svgs
        const collapsed =
            '<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 52 52"><g><path d="M17.9,4.4l20.7,20.5c0.6,0.6,0.6,1.6,0,2.2L17.9,47.6c-0.6,0.6-1.6,0.6-2.2,0l-2.2-2.2c-0.6-0.6-0.6-1.6,0-2.2l16.3-16.1c0.6-0.6,0.6-1.6,0-2.2L13.6,8.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2C16.4,3.9,17.3,3.9,17.9,4.4z"></path></g></svg>';
        const collapsedSmall =
            '<svg xmlns="http://www.w3.org/2000/svg" width="12px" height="12px" viewBox="0 0 52 52"><g><path d="M17.9,4.4l20.7,20.5c0.6,0.6,0.6,1.6,0,2.2L17.9,47.6c-0.6,0.6-1.6,0.6-2.2,0l-2.2-2.2c-0.6-0.6-0.6-1.6,0-2.2l16.3-16.1c0.6-0.6,0.6-1.6,0-2.2L13.6,8.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2C16.4,3.9,17.3,3.9,17.9,4.4z"></path></g></svg>';
        const expanded =
            '<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 52 52"><path d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"/></svg>';
        const expandedSmall =
            '<svg xmlns="http://www.w3.org/2000/svg" width="12px" height="12px" viewBox="0 0 52 52"><path d="M47.6,17.8L27.1,38.5c-0.6,0.6-1.6,0.6-2.2,0L4.4,17.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2c0.6-0.6,1.6-0.6,2.2,0l16.1,16.3c0.6,0.6,1.6,0.6,2.2,0l16.1-16.2c0.6-0.6,1.6-0.6,2.2,0l2.2,2.2C48.1,16.3,48.1,17.2,47.6,17.8z"/></svg>';
        const inversedCollapsed =
            '<svg xmlns="http://www.w3.org/2000/svg" width="16px" height="16px" viewBox="0 0 52 52"><g transform="scale(-1,1) translate(-52,0)"><path d="M17.9,4.4l20.7,20.5c0.6,0.6,0.6,1.6,0,2.2L17.9,47.6c-0.6,0.6-1.6,0.6-2.2,0l-2.2-2.2c-0.6-0.6-0.6-1.6,0-2.2l16.3-16.1c0.6-0.6,0.6-1.6,0-2.2L13.6,8.8c-0.6-0.6-0.6-1.6,0-2.2l2.2-2.2C16.4,3.9,17.3,3.9,17.9,4.4z"/></g></svg>'

        // theme function based on browser/machine color scheme
        if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
            Chart.defaults.color = "#e2e1d7";
            Chart.defaults.borderColor = "rgba(255,255,255,0.1)";
            Chart.defaults.backgroundColor = "rgba(255,255,0,0.1)";
            Chart.defaults.elements.line.borderColor = "rgba(255,255,0,0.4)";
        } else {
            document.getElementsByTagName("html")[0].setAttribute("data-bs-theme", "light");
        }

        // colors
        const passedBackgroundBorderColor = "#97bd61";
        const passedBackgroundColor = "rgba(151, 189, 97, 0.7)";
        const skippedBackgroundBorderColor = "#fed84f";
        const skippedBackgroundColor = "rgba(254, 216, 79, 0.7)";
        const failedBackgroundBorderColor = "#ce3e01";
        const failedBackgroundColor = "rgba(206, 62, 1, 0.7)";
        const greyBackgroundBorderColor = "#212529";
        const greyBackgroundColor = "rgba(33, 37, 41, 0.7)";

        // prepare input data
        var runs = "placeholder_runs".sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        var suites = "placeholder_suites".sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        var tests = "placeholder_tests".sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        var keywords = "placeholder_keywords".sort((a, b) => new Date(a.run_start).getTime() - new Date(b.run_start).getTime());
        var message_config = '"placeholder_message_config"'
        if (!message_config.includes('placeholder_message_config')) { message_config = JSON.parse(message_config) }
        const use_run_aliases = false

        // set default values
        document.getElementById("stats").innerHTML = `<i><a href="https://github.com/timdegroot1996/robotframework-dashboard" target="_blank">"placeholder_version"</a></i><br>
        <b>Database Summary</b><br>
        Runs: ${runs.length}<br>
        Suites: ${suites.length}<br>
        Tests: ${tests.length}<br>
        Keywords: ${keywords.length}`;

        // Map the arrow actions and associated operations
        const arrowMappings = {
            'sectionRight': { from: 'sectionShow', to: 'sectionHide', content: collapsed },
            'sectionLeft': { from: 'sectionHide', to: 'sectionShow', content: inversedCollapsed },
            'graphRight': { from: 'graphShow', to: 'graphHide', content: collapsed },
            'graphLeft': { from: 'graphHide', to: 'graphShow', content: inversedCollapsed }
        };

        // Initialize arrows with their respective functionality and content
        for (let arrow in arrowMappings) {
            const { from, to, content } = arrowMappings[arrow];
            // Update button content based on direction
            update_arrow_button(arrow, content);
            // Add event listener to each arrow button
            document.getElementById(arrow).addEventListener("click", () => {
                moveItems(from, to);
            });
        }

        // Function to update arrow button content
        function update_arrow_button(id, content) {
            document.getElementById(id).innerHTML = content;
        }

        // add items in hide modal
        var hideSections = [
            'Run Statistics',
            'Suite Statistics',
            'Test Statistics',
            'Keyword Statistics',
        ]
        var hideGraphs = [
            'Run Statistics',
            'Run Duration',
            'Run Table',
            'Suite Statistics',
            'Suite Duration',
            'Suite Most Failed',
            'Suite Table',
            'Test Statistics',
            'Test Duration',
            'Test Duration Deviation',
            'Test Most Flaky',
            'Test Most Failed',
            'Test Messages',
            'Test Table',
            'Keyword Statistics',
            'Keyword Times Run',
            'Keyword Total Duration',
            'Keyword Average Duration',
            'Keyword Min Duration',
            'Keyword Max Duration',
            'Keyword Table'
        ]
        var hideItem = '<li class="hideItem list-group-item list-group-item-action">{value}</li>'
        var sectionShowItems = ''
        var sectionHideItems = ''
        var graphShowItems = ''
        var graphHideItems = ''
        for (let section of hideSections) {
            const element = hideItem.replaceAll('{value}', section)
            var hidden = localStorage.getItem('sectionHide')
            var adminHidden = "placeholder_admin_section_hide"
            if (hidden == null) { // first load to create a string
                localStorage.setItem('sectionHide', '')
            }
            if (hidden == '' && adminHidden.includes(',')) { // override empty config with admin config if exists
                localStorage.setItem('sectionHide', adminHidden)
            }
            hidden = localStorage.getItem('sectionHide')
            if (hidden.includes(`'${section}'`)) {
                sectionHideItems += element
            } else {
                sectionShowItems += element
            }
        }
        for (let graph of hideGraphs) {
            const element = hideItem.replaceAll('{value}', graph)
            var hidden = localStorage.getItem('graphHide')
            var adminHidden = "placeholder_admin_graph_hide"
            if (hidden == null) { // first load to create a string
                localStorage.setItem('graphHide', '')
            }
            if (hidden == '' && adminHidden.includes(',')) { // override empty config with admin config if exists
                localStorage.setItem('graphHide', adminHidden)
            }
            hidden = localStorage.getItem('graphHide')
            if (hidden.includes(`'${graph}'`)) {
                graphHideItems += element
            } else {
                graphShowItems += element
            }
        }
        document.getElementById('sectionShow').innerHTML = sectionShowItems
        document.getElementById('sectionHide').innerHTML = sectionHideItems
        document.getElementById('graphShow').innerHTML = graphShowItems
        document.getElementById('graphHide').innerHTML = graphHideItems

        // function to add/remove disabled to the graphs in the customize view popup
        function disable_graphs_in_customize_view(disable, identifier) {
            const relatedGraphs1 = document.getElementById("graphShow").querySelectorAll(".hideItem")
            const relatedGraphs2 = document.getElementById("graphHide").querySelectorAll(".hideItem")
            const relatedGraphs = [ ...relatedGraphs1, ...relatedGraphs2 ]
            for (const graph of relatedGraphs) {
                if (graph.innerText.startsWith(identifier)) {
                    if (disable) {
                        graph.classList.add('disabled');
                    } else {
                        graph.classList.remove('disabled');
                    }
                }
            }
        }

        // function to move the items from showing to hidden
        function moveItems(fromId, toId) {
            const fromBox = document.getElementById(fromId);
            const toBox = document.getElementById(toId);
            const selectedItems = fromBox.querySelectorAll('.active');

            if (toId.includes('Hide')) {
                for (let item of selectedItems) {
                    var hidden = localStorage.getItem(toId)
                    hidden += `'${item.innerText}',`
                    localStorage.setItem(toId, hidden)
                }
                if (toId.includes('section')) {
                    for (let item of selectedItems) {
                        const identifier = item.innerText.split(" ")[0]
                        disable_graphs_in_customize_view(true, identifier)
                    }
                }
            } else {
                for (let item of selectedItems) {
                    var hidden = localStorage.getItem(fromId)
                    hidden = hidden.replaceAll(`'${item.innerText}',`, '')
                    localStorage.setItem(fromId, hidden)
                }
                if (toId.includes('section')) {
                    for (let item of selectedItems) {
                        const identifier = item.innerText.split(" ")[0]
                        disable_graphs_in_customize_view(false, identifier)
                    }
                }
            }

            selectedItems.forEach(item => {
                item.classList.remove('active');
                toBox.appendChild(item);
            });
        }

        // set which sections and graphs are shown and fill the modal
        document.querySelectorAll('.hideItem').forEach(item => {
            item.addEventListener('click', function () {
                this.classList.toggle('active');
            });
        });

        // update all graphs based on new hidden graphs/sections
        document.getElementById('saveHide').addEventListener('click', update_all_graphs)

        // create graphs
        var runStatisticsGraph;
        var runStatisticsGraphType = "percentages";
        var runDurationGraph;
        var runDurationGraphType = "bar";
        var runTable;
        var suiteStatisticsGraph;
        var suiteStatisticsGraphType = "percentages";
        var suiteDurationGraph;
        var suiteDurationGraphType = "bar";
        var suiteMostFailedGraph;
        var suiteMostFailedGraphType = "bar";
        var suiteTable;
        var testStatisticsGraph;
        var testDurationGraph;
        var testDurationGraphType = "bar";
        var testMostFlakyGraph;
        var testMostFlakyGraphType = "timeline"
        var testDurationDeviationGraph;
        var testDurationDeviationGraphType = "boxplot"
        var testMostFailedGraph;
        var testMostFailedGraphType = "timeline";
        var testMessagesGraph
        var testMessagesGraphType = "timeline";
        var testTable;
        var keywordStatisticsGraph;
        var keywordStatisticsGraphType = "percentages";
        var keywordTimesRunGraph;
        var keywordTimesRunGraphType = "bar";
        var keywordTotalDurationGraph;
        var keywordTotalDurationGraphType = "bar";
        var keywordAverageDurationGraph;
        var keywordAverageDurationGraphType = "bar";
        var keywordMinDurationGraph;
        var keywordMinDurationGraphType = "bar";
        var keywordMaxDurationGraph;
        var keywordMaxDurationGraphType = "bar";
        var keywordTable;

        // filtered data vars
        var filteredRuns;
        var filteredSuites;
        var filteredTests;
        var filteredKeywords;

        // var to keep track of the checkbox statuses
        var showOnlySelectedtestStatistics = false;
        var ignoreSkips = false;

        // initialize all collapsables by adding the eventlisteners to the buttonIds
        const collapsables = [
            "runDetailsButton",
            "runStatisticsDurationButton",
            "runTableButton",
            "suiteDetailsButton",
            "suiteStatisticsDurationButton",
            "suiteMostFailedButton",
            "suiteTableButton",
            "testDetailsButton",
            "testStatisticsDurationButton",
            "testDurationDeviationButton",
            "testMostFlakyButton",
            "testMostFailedMessagesButton",
            "testTableButton",
            "keywordDetailsButton",
            "keywordStatisticsTimesRunButton",
            "keywordTotalAverageButton",
            "keywordMinMaxButton",
            "keywordTableButton"
        ]
        for (let collapsable of collapsables) {
            update_collapse_button(collapsable);
            document.getElementById(collapsable).addEventListener("click", (e) => {
                update_collapse_button(collapsable);
            });
        }
        // function that handles the setting of the correct icon when expanding/collapsing sections
        function update_collapse_button(id) {
            if (document.getElementById(id).className.includes("collapsed")) {
                if (id.includes('Details')) {
                    document.getElementById(id).innerHTML = collapsed;
                } else {
                    document.getElementById(id).innerHTML = collapsedSmall;
                }
            } else {
                if (id.includes('Details')) {
                    document.getElementById(id).innerHTML = expanded;
                } else {
                    document.getElementById(id).innerHTML = expandedSmall;
                }
            }
        }

        // eventlisteners for filters (runTags is done separately because of different usage)
        const filters = ["runs", "fromDate", "fromTime", "toDate", "toTime"]
        for (let f of filters) {
            document.getElementById(f).addEventListener("change", update_data_and_all_graphs);
        }

        // eventlisteners for fullscreen buttons
        const fullscreenButtons = ["runStatistics", "runDuration", "suiteStatistics",
            "suiteDuration", "suiteMostFailed", "testStatistics", "testDuration",
            "testMostFlaky", "testDurationDeviation", "testMostFailed", "testMessages",
            "keywordStatistics", "keywordTimesRun", "keywordTotalDuration",
            "keywordAverageDuration", "keywordMinDuration", "keywordMaxDuration"]
        for (let fullscreenButton of fullscreenButtons) {
            document.getElementById(`${fullscreenButton}Fullscreen`).addEventListener("click", (e) => {
                document.getElementById(`${fullscreenButton}Canvas`).classList.add("fullscreen");
                document.getElementById(`${fullscreenButton}Close`).hidden = false
                document.getElementById(`${fullscreenButton}Fullscreen`).hidden = true
                document.body.style.overflow = 'hidden';
            });
            document.getElementById(`${fullscreenButton}Close`).addEventListener("click", (e) => {
                document.getElementById(`${fullscreenButton}Canvas`).classList.remove("fullscreen");
                document.getElementById(`${fullscreenButton}Close`).hidden = true
                document.getElementById(`${fullscreenButton}Fullscreen`).hidden = false
                document.body.style.overflow = 'auto';
            });
        }

        // eventlisteners for buttons to change graph views
        const graphChangeButtons = {
            'run_statistics': 'Percentages,Line,Amount',
            'run_duration': 'Bar,Line',
            'suite_statistics': 'Percentages,Line,Amount',
            'suite_duration': 'Bar,Line',
            'suite_most_failed': 'Bar,Timeline',
            'test_duration': 'Bar,Line',
            'test_most_flaky': 'Bar,Timeline',
            'test_duration_deviation': 'Boxplot',
            'test_most_failed': 'Bar,Timeline',
            'test_messages': 'Bar,Timeline',
            'keyword_statistics': 'Percentages,Line,Amount',
            'keyword_times_run': 'Bar,Line',
            'keyword_total_duration': 'Bar,Line',
            'keyword_average_duration': 'Bar,Line',
            'keyword_min_duration': 'Bar,Line',
            'keyword_max_duration': 'Bar,Line',
        };

        function underscoreToCamelcase(str) {
            return str.replace(/_(.)/g, (match, group) => group.toUpperCase());
        }

        function handleGraphButtonClick(graphChangeButton, graphType, camelButtonName) {
            // Dynamically trigger the graph creation function
            window[`create_${graphChangeButton}_graph`](graphType);
            // Update the UI to enable/disable buttons accordingly
            const buttons = ['Bar', 'Line', 'Timeline', 'Percentages', 'Amount']; // All possible button types
            buttons.forEach(button => {
                const buttonId = `${camelButtonName}Graph${button}`;
                if (document.getElementById(buttonId)) {
                    if (button.toLowerCase() === graphType.toLowerCase()) {
                        document.getElementById(buttonId).classList.add("disabled");
                    } else {
                        document.getElementById(buttonId).classList.remove("disabled");
                    }
                }
            });
        }

        function addGraphEventListeners(graphChangeButton, buttonTypes) {
            const camelButtonName = underscoreToCamelcase(graphChangeButton);
            const graphTypes = buttonTypes.split(',');
            graphTypes.forEach((graphType, index) => {
                const buttonId = `${camelButtonName}Graph${graphType}`;
                if (document.getElementById(buttonId)) {
                    document.getElementById(buttonId).addEventListener("click", (e) => {
                        handleGraphButtonClick(graphChangeButton, graphType.toLowerCase(), camelButtonName);
                    });
                }
            });
        }

        // Iterate over the graphChangeButtons object to attach event listeners
        Object.entries(graphChangeButtons).forEach(([graphChangeButton, buttonTypes]) => {
            addGraphEventListeners(graphChangeButton, buttonTypes);
        });

        // eventlistener for run tags selection
        document.getElementById("selectRunTags").addEventListener("click", show_checkboxes);
        // eventlistener for reset filter button
        document.getElementById("resetFilters").addEventListener("click", reset_filters);
        // eventlistener for all selection boxes and their respective graphs that should be updated
        document.getElementById("suiteSelectSuites").addEventListener("change", (e) => {
            create_suite_duration_graph();
            create_suite_statistics_graph();
        });
        document.getElementById("showOnlySelectedtestStatistics").addEventListener("change", (e) => {
            showOnlySelectedtestStatistics = !showOnlySelectedtestStatistics;
            create_test_statistics_graph();
        });
        document.getElementById("ignoreSkips").addEventListener("change", (e) => {
            ignoreSkips = !ignoreSkips;
            create_test_most_flaky_graph();
        });
        document.getElementById("suiteSelectTests").addEventListener("change", (e) => {
            add_testtags_in_select();
            add_tests_in_select();
            create_test_statistics_graph();
            create_test_duration_graph();
            create_test_duration_deviation_graph();
        });
        document.getElementById("testTagsSelect").addEventListener("change", (e) => {
            add_tests_in_select();
            create_test_statistics_graph();
            create_test_duration_graph();
            create_test_duration_deviation_graph();
        });
        document.getElementById("testSelect").addEventListener("change", (e) => {
            if (showOnlySelectedtestStatistics) {
                create_test_statistics_graph();
            }
            create_test_duration_graph();
            create_test_duration_deviation_graph();
        });
        document.getElementById("keywordSelect").addEventListener("change", (e) => {
            create_keyword_statistics_graph();
            create_keyword_times_run_graph();
            create_keyword_total_duration_graph();
            create_keyword_average_duration_graph();
            create_keyword_min_duration_graph();
            create_keyword_max_duration_graph();
        });

        // set initial filters and fill selects based on provided data
        set_lowest_highest_dates();
        add_runs_in_select();
        add_runtags_in_select();

        //initialize all data and graphs on load of the dashboard.html
        update_data_and_all_graphs();

        // function that initializes the from date/time and to date/time selection boxes in the filters
        function set_lowest_highest_dates() {
            var dates = [];
            for (run of runs) {
                dates.push(new Date(run.run_start));
            }
            if (dates.length == 0) {
                document.getElementById("fromDate").value = "1900-01-01";
                document.getElementById("fromTime").value = "00:00";
                document.getElementById("toDate").value = "9999-12-31";
                document.getElementById("toTime").value = "23:59";
                return
            }
            var lowest = new Date(Math.min.apply(null, dates));
            var highest = new Date(Math.max.apply(null, dates));
            var tzoffset = new Date().getTimezoneOffset() * 60000;
            lowest = new Date(new Date(lowest - tzoffset).getTime() + -1 * 60000); // this is to account for seconds in the initial filter value
            highest = new Date(new Date(highest - tzoffset).getTime() + 1 * 60000); // this is to account for seconds in the initial filter value
            lowest.setTime(lowest.getTime() - 1 * 60 * 60 * 1000) // minus 1 hour to account for possible daylight saving time switches of 1 hour!
            highest.setTime(highest.getTime() + 1 * 60 * 60 * 1000) // plus 1 hour to account for possible daylight saving time switches of 1 hour!
            document.getElementById("fromDate").value = lowest.toISOString().split("T")[0];
            document.getElementById("fromTime").value = lowest.toISOString().split("T")[1].substring(0, 5);
            document.getElementById("toDate").value = highest.toISOString().split("T")[0];
            document.getElementById("toTime").value = highest.toISOString().split("T")[1].substring(0, 5);
        }

        // generic function to update all graph data, function is called when updating filters and when the page loads
        function update_data_and_all_graphs() {
            update_filtered_data();
            update_all_graphs();
        }

        // function updates the data in the graphs whenever filters are updated
        function update_filtered_data() {
            // filter run data
            filteredRuns = filter_runs(runs);
            filteredRuns = filter_runtags(filteredRuns);
            filteredRuns = filter_dates(filteredRuns);
            // filter suites and tests based on filtered runs
            filteredSuites = filter_data("suites");
            filteredTests = filter_data("tests");
            filteredKeywords = filter_data("keywords");
            // set titles with amount of filtered items
            document.getElementById("runTitle").innerText = `Run Statistics (${Object.keys(filteredRuns).length})`;
            document.getElementById("suiteTitle").innerText = `Suite Statistics (${Object.keys(filteredSuites).length})`;
            document.getElementById("testTitle").innerText = `Test Statistics (${Object.keys(filteredTests).length})`;
            document.getElementById("keywordTitle").innerText = `Keyword Statistics (${Object.keys(filteredKeywords).length})`;
            // update tests select based on filtered runs
            add_suites_in_selects();
            add_testtags_in_select();
            add_tests_in_select();
            add_keywords_in_select();
        }

        // function that updates all graphs based on the new filtered data and hidden choices
        function update_all_graphs() {
            create_run_statistics_graph();
            create_run_duration_graph();
            create_run_table();
            create_suite_statistics_graph();
            create_suite_duration_graph();
            create_suite_most_failed_graph();
            create_suite_table();
            create_test_statistics_graph();
            create_test_duration_graph();
            create_test_duration_deviation_graph();
            create_test_most_flaky_graph();
            create_test_most_failed_graph();
            create_test_messages_graph();
            create_test_table();
            create_keyword_statistics_graph();
            create_keyword_times_run_graph();
            create_keyword_total_duration_graph();
            create_keyword_average_duration_graph();
            create_keyword_min_duration_graph();
            create_keyword_max_duration_graph();
            create_keyword_table();
            set_hidden_sections_and_graphs();
        }

        function set_hidden_sections_and_graphs() {
            const hiddenSections = localStorage.getItem("sectionHide");
            const hiddenGraphs = localStorage.getItem("graphHide");
            // function to convert to camelcase
            function spaceToCamelCase(string) {
                return string.replace(/(?:^\w|[A-Z]|\b\w)/g, function (word, index) {
                    return index === 0 ? word.toLowerCase() : word.toUpperCase();
                }).replace(/\s+/g, '');
            }
            // function to show or hide elements
            function toggleElement(id, condition) {
                const element = document.getElementById(id);
                if (element) element.hidden = condition;
            }
            // function to handle a section
            function handleSection(sectionId, graphs) {
                const isSectionHidden = hiddenSections.includes(sectionId);
                toggleElement(spaceToCamelCase(sectionId.toLowerCase() + 'Section'), isSectionHidden);
                if (!isSectionHidden) {
                    graphs.forEach(({ id, dependencies }) => {
                        const isGraphHidden = hiddenGraphs.includes(id);
                        toggleElement(spaceToCamelCase(id + ' Canvas'), isGraphHidden);

                        if (dependencies) {
                            const areDependenciesHidden = dependencies.every(dep => hiddenGraphs.includes(dep));
                            toggleElement(spaceToCamelCase(id + ' ChevronRow'), areDependenciesHidden);
                        }
                    });
                } else {
                    disable_graphs_in_customize_view(true, sectionId.split(" ")[0])
                }
            }
            handleSection('Run Statistics', [
                { id: 'Run Statistics', dependencies: ['Run Statistics', 'Run Duration'] },
                { id: 'Run Duration' },
                { id: 'Run Table', dependencies: ['Run Table'] }
            ]);
            handleSection('Suite Statistics', [
                { id: 'Suite Statistics', dependencies: ['Suite Statistics', 'Suite Duration'] },
                { id: 'Suite Duration' },
                { id: 'Suite Most Failed', dependencies: ['Suite Most Failed'] },
                { id: 'Suite Table', dependencies: ['Suite Table'] }
            ]);
            handleSection('Test Statistics', [
                { id: 'Test Statistics', dependencies: ['Test Statistics', 'Test Duration'] },
                { id: 'Test Duration' },
                { id: 'Test Duration Deviation', dependencies: ['Test Duration Deviation'] },
                { id: 'Test Most Flaky', dependencies: ['Test Most Flaky'] },
                { id: 'Test Most Failed', dependencies: ['Test Most Failed', 'Test Messages'] },
                { id: 'Test Messages' },
                { id: 'Test Table', dependencies: ['Test Table'] }
            ]);
            handleSection('Keyword Statistics', [
                { id: 'Keyword Statistics', dependencies: ['Keyword Statistics', 'Keyword Times Run'] },
                { id: 'Keyword Times Run' },
                { id: 'Keyword Total Duration', dependencies: ['Keyword Total Duration', 'Keyword Average Duration'] },
                { id: 'Keyword Average Duration' },
                { id: 'Keyword Min Duration', dependencies: ['Keyword Min Duration', 'Keyword Max Duration'] },
                { id: 'Keyword Max Duration' },
                { id: 'Keyword Table', dependencies: ['Keyword Table'] }
            ]);
        }

        // function to filter run data based on the runs (aka run name) filter
        function filter_runs(runs) {
            const selectedRun = document.getElementById("runs").value;
            // If "All" is selected, return the original array of runs
            if (selectedRun === "All") {
                return runs;
            }
            return Object.values(runs).filter(run => run.name === selectedRun);
        }

        // function to filter run data based on the run tags filter
        function filter_runtags(runs) {
            const tagElements = document.getElementById("runTag").getElementsByTagName("input");
            const useOrTags = document.getElementById("useOrTags").checked;
            const selectedTags = Array.from(tagElements)
                .filter(tagElement => tagElement.checked)
                .map(tagElement => tagElement.id);
            // If "All" is selected, return all runs
            if (selectedTags.includes("All")) {
                return runs;
            }
            // If no tags are selected, return an empty list
            if (selectedTags.length === 0) {
                return [];
            }
            return runs.filter(run => {
                const runTags = run.tags.split(",");
                // Use AND logic: the run must contain all selected tags
                if (!useOrTags) {
                    return selectedTags.every(selectedTag => runTags.includes(selectedTag));
                }
                // Use OR logic: the run must contain at least one selected tag
                return selectedTags.some(selectedTag => runTags.includes(selectedTag));
            });
        }

        // function to filter the run data based on the selected date range
        function filter_dates(runs) {
            const fromDate = document.getElementById("fromDate").value;
            const fromTime = document.getElementById("fromTime").value;
            const toDate = document.getElementById("toDate").value;
            const toTime = document.getElementById("toTime").value;
            // Return all runs if any date/time values are missing
            if (!fromDate || !fromTime || !toDate || !toTime) {
                return runs;
            }
            const fromDateTime = new Date(`${fromDate} ${fromTime}:00`);
            const toDateTime = new Date(`${toDate} ${toTime}:00`);
            // Check for valid date range
            if (fromDateTime > toDateTime) {
                alert("Filter error: The selected from date + time is later than your selected to date + time. Date filter has not been applied!");
                return runs;  // Return all runs if invalid range
            }
            // Use the array filter method for a cleaner approach
            return runs.filter(run => {
                const runStart = new Date(run.run_start);
                return runStart >= fromDateTime && runStart <= toDateTime;
            });
        }

        // function to filter suites/tests/keywords based on the already filtered runs
        function filter_data(dataType) {
            var validRunStarts = [];
            for (value of filteredRuns) {
                validRunStarts.push(value.run_start);
            }
            var filteredData = [];
            for (value of window[dataType]) {
                if (validRunStarts.includes(value.run_start)) {
                    filteredData.push(value);
                }
            }
            return filteredData;
        }

        // function to reset the filters at the top and update the graphs
        function reset_filters() {
            document.getElementById("runs").value = "All";
            document.getElementById("runTag").value = "All";
            set_lowest_highest_dates(runs);
            update_data_and_all_graphs();
        }

        // function to update the available runs to select in the filters
        function add_runs_in_select() {
            // Use a Set to collect unique run names
            const runOptions = new Set();
            // Collect all unique run names
            runs.forEach(run => runOptions.add(run.name));
            // Build the options HTML (including "All" as the first option)
            const optionsHtml = Array.from(runOptions)
                .map(runName => `<option value="${runName}">${runName}</option>`)
                .join('');
            // Add the "All" option and append all other options
            const runsSelect = document.getElementById("runs");
            runsSelect.innerHTML = `<option value="All">All</option>` + optionsHtml;
        }


        // function to update the available runtags to select in the filters
        function add_runtags_in_select() {
            // Use a Set to collect unique tags
            const tags = new Set();
            // Collect all unique tags from the runs
            runs.forEach(run => {
                run.tags.split(",").forEach(tag => {
                    if (tag) { // Avoid adding empty tags
                        tags.add(tag);
                    }
                });
            });
            // Create the "Use OR" toggle item
            const andOrTags = `
                <li class="list-group-item d-flex small">
                    <div class="btn-group form-switch">
                        <input class="form-check-input" type="checkbox" role="switch" id="useOrTags" />
                    </div>
                    <div class="btn-group">
                        <label class="form-check-label" for="orTags">Use OR (default AND)</label>
                    </div>
                </li>
            `;
            // Template for list items
            const listItemTemplate = (value) => `
                <li class="list-group-item list-group-item-action d-flex small" onclick="update_data_and_all_graphs()">
                    <input class="form-check-input me-1" type="checkbox" value="" id="${value}">
                    <label class="form-check-label ms-2" for="${value}">${value}</label>
                </li>
            `;
            // Build the list items for all tags and the "All" tag
            const listItems = [listItemTemplate('All')].concat(
                Array.from(tags).map(tag => listItemTemplate(tag))
            ).join('');
            // Insert the generated HTML into the DOM
            const tagsSelect = document.getElementById("runTag");
            tagsSelect.innerHTML = andOrTags + listItems;
            // Set the "All" tag to be checked by default
            document.getElementById("All").checked = true;
        }

        const checkboxesElement = document.getElementById('checkboxes');
        const runTagsSelectElement = document.getElementById('selectRunTags')
        // listen for click events on body to hide the run checkboxes when clicking outside of the select/checkboxes elements
        document.body.addEventListener('click', function (event) {
            if (showingRunTags == true && !checkboxesElement.contains(event.target) && !runTagsSelectElement.contains(event.target)) {
                show_checkboxes()
            }
        });

        // var and function to keep track of the checkboxes for the runtags
        let showingRunTags = false;
        function show_checkboxes() {
            const checkboxes = document.getElementById("checkboxes");
            showingRunTags = !showingRunTags;
            checkboxes.style.display = showingRunTags ? "block" : "none";
        }

        // function to update the available suites to select in the filters
        // applies to the suite filter on the suite statistics level and the test statistics level
        function add_suites_in_selects() {
            const suiteSelectTests = document.getElementById("suiteSelectTests");
            const suiteSelectSuites = document.getElementById("suiteSelectSuites");
            // Clear existing options
            suiteSelectTests.innerHTML = "";
            suiteSelectSuites.innerHTML = "";
            // Extract and sort suite names
            const suiteNames = [...new Set(filteredSuites.map(suite => suite.name))].sort();
            // Add "All" as default
            suiteSelectTests.options.add(new Option("All", "All"));
            suiteSelectSuites.options.add(new Option("All", "All"));
            // Add suite names to selects
            suiteNames.forEach(suiteName => {
                suiteSelectTests.options.add(new Option(suiteName, suiteName));
                suiteSelectSuites.options.add(new Option(suiteName, suiteName));
            });
            // Set the default selection to the second option (All is default)
            suiteSelectTests.selectedIndex = 1;
            suiteSelectSuites.selectedIndex = 1;
        }

        // function to update the available tests to select in the filters
        // applies to the test filter on the test statistics level
        function add_tests_in_select() {
            const suiteSelect = document.getElementById("suiteSelectTests").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            const testSelect = document.getElementById("testSelect");
            // Clear existing options
            testSelect.innerHTML = "";
            // Filter test names based on suite and tags
            const testNames = filteredTests.reduce((names, test) => {
                const isInSuite = test.full_name.includes(`.${suiteSelect}.${test.name}`) || suiteSelect === "All";
                const hasTag = testTagsSelect === "All" || test.tags.includes(testTagsSelect);

                if (isInSuite && hasTag && !names.includes(test.name)) {
                    names.push(test.name);
                }

                return names;
            }, []);
            // Add "All" as default
            testSelect.options.add(new Option("All", "All"));
            // Add filtered test names to select
            testNames.forEach(testName => testSelect.options.add(new Option(testName, testName)));
        }

        // function to update the available testtags to select in the filters
        // applies to the testtag filter on the test statistics level
        function add_testtags_in_select() {
            const suiteSelect = document.getElementById("suiteSelectTests").value;
            const testTagsSelect = document.getElementById("testTagsSelect");
            // Clear existing options
            testTagsSelect.innerHTML = "";
            // Extract unique tags for the selected suite
            const testTags = [...new Set(filteredTests.reduce((tags, test) => {
                if (test.full_name.includes(`.${suiteSelect}.${test.name}`) || suiteSelect === "All") {
                    test.tags.replace(/\[|\]/g, '').split(',').forEach(tag => tags.push(tag.trim()));
                }
                return tags;
            }, []))];
            // Add "All" as default
            testTagsSelect.options.add(new Option("All", "All"));
            // Add tags to select
            testTags.forEach(tag => testTagsSelect.options.add(new Option(tag, tag)));
        }

        // function to update the available keywords to select in the filters
        // applies to the keyword filter on the keyword statistics level
        function add_keywords_in_select() {
            const keywordSelect = document.getElementById("keywordSelect");
            // Clear existing options
            keywordSelect.innerHTML = "";
            // Extract unique keyword names
            const keywordNames = [...new Set(filteredKeywords.map(keyword => keyword.name))].sort();
            // Add keywords to select
            keywordNames.forEach(keywordName => keywordSelect.options.add(new Option(keywordName, keywordName)));
            // Select the last keyword by default
            keywordSelect.selectedIndex = keywordNames.length - 1;
        }

        // function to create run statistics graph in the run section
        function create_run_statistics_graph(type) {
            if (typeof type === "string") {
                runStatisticsGraphType = type;
            }
            if (runStatisticsGraph) {
                runStatisticsGraph.destroy();
            }
            var graphData = get_statistics_graph_data("run", runStatisticsGraphType, filteredRuns);
            if (runStatisticsGraphType == "line") {
                var config = get_graph_config("line", graphData, "Amount Of Tests (Line)", "Date", "amount", false);
                runStatisticsGraph = new Chart("runStatisticsGraph", config);
            } else if (runStatisticsGraphType == "amount") {
                Chart.register(ChartDataLabels);
                var config = get_graph_config("bar", graphData, "Run Statistics (Bar)", "Run", "Amount Of Tests");
                runStatisticsGraph = new Chart("runStatisticsGraph", config);
            } else if (runStatisticsGraphType == "percentages") {
                Chart.register(ChartDataLabels);
                var config = get_graph_config("bar", graphData, "Run Statistics (Bar)", "Run", "Percentage");
                runStatisticsGraph = new Chart("runStatisticsGraph", config);
            }
        }

        // function to create run duration graph in the run section
        function create_run_duration_graph(type) {
            if (typeof type === "string") {
                runDurationGraphType = type;
            }
            if (runDurationGraph) {
                runDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("run", runDurationGraphType, "elapsed_s", filteredRuns);
            if (runDurationGraphType == "bar") {
                var config = get_graph_config("bar", graphData, "Run Duration (Bar) First 30 Bars Only", "Run", "Duration");
                runDurationGraph = new Chart("runDurationGraph", config);
            } else if (runDurationGraphType == "line") {
                var config = get_graph_config("line", graphData, "Run Duration (Line)", "Date", "Duration");
                runDurationGraph = new Chart("runDurationGraph", config);
            }
        }

        // function to create run table in the run section
        function create_run_table() {
            if (runTable) {
                runTable.destroy();
            }
            data = [];
            for (run of filteredRuns) {
                data.push([
                    run.run_start,
                    run.full_name,
                    run.name,
                    run.total,
                    run.passed,
                    run.failed,
                    run.skipped,
                    run.elapsed_s,
                    run.start_time,
                    run.tags,
                    run.run_alias,
                ]);
            }
            runTable = new DataTable("#runTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "full_name" },
                    { title: "name" },
                    { title: "total" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "elapsed_s" },
                    { title: "start_time" },
                    { title: "tags" },
                    { title: "alias" }
                ],
                data: data,
            });
        }

        // function to create suite statistics graph in the suite section
        function create_suite_statistics_graph(type) {
            if (typeof type === "string") {
                suiteStatisticsGraphType = type;
            }
            if (suiteStatisticsGraph) {
                suiteStatisticsGraph.destroy();
            }
            var graphData = get_statistics_graph_data("suite", suiteStatisticsGraphType, filteredSuites);
            if (suiteStatisticsGraphType == "line") {
                var config = get_graph_config("line", graphData, "Amount Of Tests (Line)", "Date", "amount", false);
                suiteStatisticsGraph = new Chart("suiteStatisticsGraph", config);
            } else if (suiteStatisticsGraphType == "amount") {
                Chart.register(ChartDataLabels);
                var config = get_graph_config("bar", graphData, "Suite Statistics (Bar)", "Run", "Amount Of Tests");
                suiteStatisticsGraph = new Chart("suiteStatisticsGraph", config);
            } else if (suiteStatisticsGraphType == "percentages") {
                Chart.register(ChartDataLabels);
                var config = get_graph_config("bar", graphData, "Suite Statistics (Bar)", "Run", "Percentage");
                suiteStatisticsGraph = new Chart("suiteStatisticsGraph", config);
            }
        }

        // function to create suite duration graph in the suite section
        function create_suite_duration_graph(type) {
            if (typeof type === "string") {
                suiteDurationGraphType = type;
            }
            if (suiteDurationGraph) {
                suiteDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("suite", suiteDurationGraphType, "elapsed_s", filteredSuites);
            if (suiteDurationGraphType == "bar") {
                var config = get_graph_config("bar", graphData, "Suite Duration (Bar) First 30 Bars Only", "Run", "Duration");
                suiteDurationGraph = new Chart("suiteDurationGraph", config);
            } else if (suiteDurationGraphType == "line") {
                var config = get_graph_config("line", graphData, "Suite Duration (Line)", "Date", "Duration");
                suiteDurationGraph = new Chart("suiteDurationGraph", config);
            }
        }

        // function to create suite most failed graph in the suite section
        function create_suite_most_failed_graph(type) {
            if (typeof type === "string") {
                suiteMostFailedGraphType = type;
            }
            if (suiteMostFailedGraph) {
                suiteMostFailedGraph.destroy();
            }
            var graphData = get_most_failed_data("suite", suiteMostFailedGraphType, filteredSuites);
            var callbackData = graphData[0];
            graphData = graphData[1];
            if (suiteMostFailedGraphType == "bar") {
                var config = get_graph_config("bar", graphData, "Top 10 Most Failed Suites", "Suite Name", "Times Failed");
                // overwrite legend and tooltip
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                suiteMostFailedGraph = new Chart("suiteMostFailedGraph", config);
            } else if (suiteMostFailedGraphType == "timeline") {
                var config = get_graph_config("timeline", graphData, "Top 10 Most Failed Suites");
                // overwrite tooltip and x scale with callbacks
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                };
                suiteMostFailedGraph = new Chart("suiteMostFailedGraph", config);
            }
        }

        // function to create suite table in the suite section
        function create_suite_table() {
            if (suiteTable) {
                suiteTable.destroy();
            }
            data = [];
            for (suite of filteredSuites) {
                data.push([
                    suite.run_start,
                    suite.full_name,
                    suite.name,
                    suite.total,
                    suite.passed,
                    suite.failed,
                    suite.skipped,
                    suite.elapsed_s,
                    suite.start_time,
                    suite.run_alias,
                ]);
            }
            suiteTable = new DataTable("#suiteTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "full_name" },
                    { title: "name" },
                    { title: "total" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "elapsed_s" },
                    { title: "start_time" },
                    { title: "alias" },
                ],
                data: data,
            });
        }

        // function to create test statistics graph in the test section
        function create_test_statistics_graph() {
            if (testStatisticsGraph) {
                testStatisticsGraph.destroy();
            }
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testSelect = document.getElementById("testSelect").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            var [labels, runStarts, datasets] = [[], [], []];
            for (test of filteredTests) {
                if (suiteSelectTests != "All" && !test.full_name.includes(`.${suiteSelectTests}.${test.name}`) && test.full_name != `${suiteSelectTests}.${test.name}`) {
                    continue;
                }
                if (showOnlySelectedtestStatistics && testSelect != "All" && test.name != testSelect) {
                    continue;
                }
                if (testTagsSelect != "All" && !test.tags.replace(/\[|\]/g, '').split(',').includes(testTagsSelect)) {
                    continue
                }
                if (!labels.includes(test.name)) {
                    labels.push(test.name);
                }
                if (use_run_aliases) {
                    if (!runStarts.includes(test.run_alias)) {
                        runStarts.push(test.run_alias);
                    }
                    var runAxis = runStarts.indexOf(test.run_alias)
                } else {
                    if (!runStarts.includes(test.run_start)) {
                        runStarts.push(test.run_start);
                    }
                    var runAxis = runStarts.indexOf(test.run_start)
                }
                if (test.passed == 1) {
                    datasets.push({
                        label: test.name,
                        data: [{ x: [runAxis, runAxis + 1], y: test.name }],
                        backgroundColor: passedBackgroundColor,
                        borderColor: passedBackgroundBorderColor,
                        borderWidth: 1,
                    });
                } else if (test.failed == 1) {
                    datasets.push({
                        label: test.name,
                        data: [{ x: [runAxis, runAxis + 1], y: test.name }],
                        backgroundColor: failedBackgroundColor,
                        borderColor: failedBackgroundBorderColor,
                        borderWidth: 1,
                    });
                } else if (test.skipped == 1) {
                    datasets.push({
                        label: test.name,
                        data: [{ x: [runAxis, runAxis + 1], y: test.name }],
                        backgroundColor: skippedBackgroundColor,
                        borderColor: skippedBackgroundBorderColor,
                        borderWidth: 1,
                    });
                }
            }
            var graphData = {
                labels: labels,
                datasets: datasets,
            };
            var config = get_graph_config("timeline", graphData, "Test Statistics (Bar)");
            // overwrite tooltip and x scale with callbacks
            config.options.plugins.tooltip = {
                callbacks: {
                    label: function (context) {
                        return runStarts[context.raw.x[0]];
                    },
                },
            };
            config.options.scales.x = {
                ticks: {
                    minRotation: 45,
                    maxRotation: 45,
                    callback: function (value, index, ticks) {
                        return runStarts[this.getLabelForValue(value)];
                    },
                },
            };
            testStatisticsGraph = new Chart("testStatisticsGraph", config);
            update_height('testStatisticsVertical', testStatisticsGraph)
        }

        // function to create test duration graph in the test section
        function create_test_duration_graph(type) {
            if (typeof type === "string") {
                testDurationGraphType = type;
            }
            if (testDurationGraph) {
                testDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("test", testDurationGraphType, "elapsed_s", filteredTests);
            if (testDurationGraphType == "bar") {
                var config = get_graph_config("bar", graphData, "Test Duration (Bar) First 30 Bars Only", "Run", "Duration");
                testDurationGraph = new Chart("testDurationGraph", config);
            } else if (testDurationGraphType == "line") {
                var config = get_graph_config("line", graphData, "Test Duration (Line)", "Date", "Duration");
                testDurationGraph = new Chart("testDurationGraph", config);
            }
        }

        // function to create test most flaky graph in test section
        function create_test_most_flaky_graph(type) {
            if (typeof type === "string") {
                testMostFlakyGraphType = type;
            }
            if (testMostFlakyGraph) {
                testMostFlakyGraph.destroy();
            }
            var graphData = get_most_flaky_data("test", testMostFlakyGraphType, filteredTests);
            var callbackData = graphData[0];
            graphData = graphData[1];
            if (testMostFlakyGraphType == "bar") {
                var config = get_graph_config("bar", graphData, "Top 10 Most Flaky Tests (most status flips)", "Test Name", "Times Status Flipped");
                // disable lenged in bar graph
                config.options.plugins.legend = false
                testMostFlakyGraph = new Chart("testMostFlakyGraph", config);
            } else if (testMostFlakyGraphType == "timeline") {
                var config = get_graph_config("timeline", graphData, "Top 10 Most Flaky Tests (most status flips)");
                // overwrite tooltip and x scale with callbacks
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                };
                testMostFlakyGraph = new Chart("testMostFlakyGraph", config);
            }
        }

        function create_test_duration_deviation_graph(type) {
            if (typeof type === "string") {
                testDurationDeviationGraphType = type;
            }
            if (testDurationDeviationGraph) {
                testDurationDeviationGraph.destroy();
            }

            var graphData = get_duration_deviation_data("test", testDurationDeviationGraphType, filteredTests)
            var config = get_graph_config("boxplot", graphData, "Duration Deviation", "Test Name", "Duration");
            testDurationDeviationGraph = new Chart("testDurationDeviationGraph", config);
        }

        // function to create test most failed graph in the test section
        function create_test_most_failed_graph(type) {
            if (typeof type === "string") {
                testMostFailedGraphType = type;
            }
            if (testMostFailedGraph) {
                testMostFailedGraph.destroy();
            }
            var graphData = get_most_failed_data("test", testMostFailedGraphType, filteredTests);
            var callbackData = graphData[0];
            graphData = graphData[1];
            if (testMostFailedGraphType == "bar") {
                var config = get_graph_config("bar", graphData, "Top 10 Most Failed Tests", "Test Name", "Times Failed");
                // overwrite legend and tooltip
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                testMostFailedGraph = new Chart("testMostFailedGraph", config);
            } else if (testMostFailedGraphType == "timeline") {
                var config = get_graph_config("timeline", graphData, "Top 10 Most Failed Tests");
                // overwrite tooltip and x scale with callbacks
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                };
                testMostFailedGraph = new Chart("testMostFailedGraph", config);
            }
        }

        // function to create test messages graph in the test section
        function create_test_messages_graph(type) {
            if (typeof type === "string") {
                testMessagesGraphType = type;
            }
            if (testMessagesGraph) {
                testMessagesGraph.destroy();
            }
            var graphData = get_messages_data("test", testMessagesGraphType, filteredTests);
            var callbackData = graphData[0];
            graphData = graphData[1];
            if (testMessagesGraphType == "bar") {
                var config = get_graph_config("bar", graphData, "Top 10 Fail Messages", "Message", "Times");
                // overwrite legend and tooltip
                config.options.plugins.legend = { display: false };
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (tooltipItem) {
                            return callbackData[tooltipItem.label];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index) {
                            return this.getLabelForValue(value).slice(0, 40);
                        },
                    },
                };
                testMessagesGraph = new Chart("testMessagesGraph", config);
            } else if (testMessagesGraphType == "timeline") {
                var config = get_graph_config("timeline", graphData, "Top 10 Fail Messages");
                // overwrite tooltip and x and y scale with callbacks
                config.options.plugins.tooltip = {
                    callbacks: {
                        label: function (context) {
                            return callbackData[context.raw.x[0]];
                        },
                    },
                };
                config.options.scales.x = {
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                        callback: function (value, index, ticks) {
                            return callbackData[this.getLabelForValue(value)];
                        },
                    },
                };
                config.options.scales.y.ticks = {
                    callback: function (value, index, ticks) {
                        return this.getLabelForValue(value).slice(0, 40);
                    },
                };
                testMessagesGraph = new Chart("testMessagesGraph", config);
            }
        }

        // function to create test table in the test section
        function create_test_table() {
            if (testTable) {
                testTable.destroy();
            }
            data = [];
            for (test of filteredTests) {
                data.push([test.run_start, test.full_name, test.name, test.passed, test.failed, test.skipped, test.elapsed_s, test.start_time, test.message, test.tags, test.run_alias]);
            }
            testTable = new DataTable("#testTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "full_name" },
                    { title: "name" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "elapsed_s" },
                    { title: "start_time" },
                    { title: "message" },
                    { title: "tags" },
                    { title: "alias" },
                ],
                data: data,
            });
        }

        // function to keyword statistics graph in the keyword section
        function create_keyword_statistics_graph(type) {
            if (typeof type === "string") {
                keywordStatisticsGraphType = type;
            }
            if (keywordStatisticsGraph) {
                keywordStatisticsGraph.destroy();
            }
            var graphData = get_statistics_graph_data("keyword", keywordStatisticsGraphType, filteredKeywords);
            if (keywordStatisticsGraphType == "line") {
                var config = get_graph_config("line", graphData, "Keyword Statistics (Line)", "Date", "Amount", false);
                keywordStatisticsGraph = new Chart("keywordStatisticsGraph", config);
            } else if (keywordStatisticsGraphType == "amount") {
                Chart.register(ChartDataLabels);
                var config = get_graph_config("bar", graphData, "Keyword Statistics (Bar)", "Run", "Amount");
                keywordStatisticsGraph = new Chart("keywordStatisticsGraph", config);
            } else if (keywordStatisticsGraphType == "percentages") {
                Chart.register(ChartDataLabels);
                var config = get_graph_config("bar", graphData, "Keyword Statistics (Bar)", "Run", "Percentage");
                keywordStatisticsGraph = new Chart("keywordStatisticsGraph", config);
            }
        }

        // function to keyword times run graph in the keyword section
        function create_keyword_times_run_graph(type) {
            if (typeof type === "string") {
                keywordTimesRunGraphType = type;
            }
            if (keywordTimesRunGraph) {
                keywordTimesRunGraph.destroy();
            }
            var graphData = get_duration_graph_data("keyword", keywordTimesRunGraphType, "times_run", filteredKeywords);
            if (keywordTimesRunGraphType == "bar") {
                var config = get_graph_config("bar", graphData, "Times Run (Bar) First 30 Bars Only", "Run", "Duration");
                keywordTimesRunGraph = new Chart("keywordTimesRunGraph", config);
            } else if (keywordTimesRunGraphType == "line") {
                var config = get_graph_config("line", graphData, "Times Run (Line)", "Date", "Duration");
                keywordTimesRunGraph = new Chart("keywordTimesRunGraph", config);
            }
        }

        // function to keyword total time graph in the keyword section
        function create_keyword_total_duration_graph(type) {
            if (typeof type === "string") {
                keywordTotalDurationGraphType = type;
            }
            if (keywordTotalDurationGraph) {
                keywordTotalDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("keyword", keywordTotalDurationGraphType, "total_time_s", filteredKeywords);
            if (keywordTotalDurationGraphType == "bar") {
                var config = get_graph_config("bar", graphData, "Total Duration (Bar) First 30 Bars Only", "Run", "Duration");
                keywordTotalDurationGraph = new Chart("keywordTotalDurationGraph", config);
            } else if (keywordTotalDurationGraphType == "line") {
                var config = get_graph_config("line", graphData, "Total Duration (Line)", "Date", "Duration");
                keywordTotalDurationGraph = new Chart("keywordTotalDurationGraph", config);
            }
        }

        // function to keyword average time graph in the keyword section
        function create_keyword_average_duration_graph(type) {
            if (typeof type === "string") {
                keywordAverageDurationGraphType = type;
            }
            if (keywordAverageDurationGraph) {
                keywordAverageDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("keyword", keywordAverageDurationGraphType, "average_time_s", filteredKeywords);
            if (keywordAverageDurationGraphType == "bar") {
                var config = get_graph_config("bar", graphData, "Average Duration (Bar) First 30 Bars Only", "Run", "Duration");
                keywordAverageDurationGraph = new Chart("keywordAverageDurationGraph", config);
            } else if (keywordAverageDurationGraphType == "line") {
                var config = get_graph_config("line", graphData, "Average Duration (Line)", "Date", "Duration");
                keywordAverageDurationGraph = new Chart("keywordAverageDurationGraph", config);
            }
        }

        // function to keyword min time graph in the keyword section
        function create_keyword_min_duration_graph(type) {
            if (typeof type === "string") {
                keywordMinDurationGraphType = type;
            }
            if (keywordMinDurationGraph) {
                keywordMinDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("keyword", keywordMinDurationGraphType, "min_time_s", filteredKeywords);
            if (keywordMinDurationGraphType == "bar") {
                var config = get_graph_config("bar", graphData, "Min Duration (Bar) First 30 Bars Only", "Run", "Duration");
                keywordMinDurationGraph = new Chart("keywordMinDurationGraph", config);
            } else if (keywordMinDurationGraphType == "line") {
                var config = get_graph_config("line", graphData, "Min Duration (Line)", "Date", "Duration");
                keywordMinDurationGraph = new Chart("keywordMinDurationGraph", config);
            }
        }

        // function to keyword max time graph in the keyword section
        function create_keyword_max_duration_graph(type) {
            if (typeof type === "string") {
                keywordMaxDurationGraphType = type;
            }
            if (keywordMaxDurationGraph) {
                keywordMaxDurationGraph.destroy();
            }
            var graphData = get_duration_graph_data("keyword", keywordMaxDurationGraphType, "max_time_s", filteredKeywords);
            if (keywordMaxDurationGraphType == "bar") {
                var config = get_graph_config("bar", graphData, "Max Duration (Bar) First 30 Bars Only", "Run", "Duration");
                keywordMaxDurationGraph = new Chart("keywordMaxDurationGraph", config);
            } else if (keywordMaxDurationGraphType == "line") {
                var config = get_graph_config("line", graphData, "Max Duration (Line)", "Date", "Duration");
                keywordMaxDurationGraph = new Chart("keywordMaxDurationGraph", config);
            }
        }

        // function to keyword table in the keyword section
        function create_keyword_table() {
            if (keywordTable) {
                keywordTable.destroy();
            }
            data = [];
            for (keyword of filteredKeywords) {
                data.push([
                    keyword.run_start,
                    keyword.name,
                    keyword.passed,
                    keyword.failed,
                    keyword.skipped,
                    keyword.times_run,
                    keyword.total_time_s,
                    keyword.average_time_s,
                    keyword.min_time_s,
                    keyword.max_time_s,
                    keyword.run_alias,
                ]);
            }
            keywordTable = new DataTable("#keywordTable", {
                layout: {
                    topStart: "info",
                    bottomStart: null,
                },
                columns: [
                    { title: "run" },
                    { title: "name" },
                    { title: "passed" },
                    { title: "failed" },
                    { title: "skipped" },
                    { title: "times_run" },
                    { title: "total_execution_time" },
                    { title: "average_execution_time" },
                    { title: "min_execution_time" },
                    { title: "max_execution_time" },
                    { title: "alias" },
                ],
                data: data,
            });
        }

        // function to retrieve the required graph config for chartjs, based on the different type of graphs
        function get_graph_config(graphType, graphData, graphTitle, xTitle, yTitle, dataSets = true) {
            // Common base config to reduce repetition
            const baseConfig = {
                normalized: true,
                animation: false,
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: graphTitle,
                    },
                    datalabels: {
                        display: false,
                    },
                },
            };
            // Common scales configuration
            const commonScales = {
                x: {
                    title: {
                        display: true,
                        text: xTitle,
                    },
                    ticks: {
                        minRotation: 45,
                        maxRotation: 45,
                    },
                },
                y: {
                    title: {
                        display: true,
                        text: yTitle,
                    },
                    grace: "5%",
                },
            };
            if (dataSets && graphType == "line") {
                graphData = { datasets: graphData };
            }
            // Configuration for 'line' graph
            if (graphType === "line") {
                return {
                    type: "line",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            ...commonScales,
                            x: {
                                ...commonScales.x,
                                type: "time",
                                time: {
                                    tooltipFormat: "dd.MM.yyyy - HH:mm:ss.SSS",
                                },
                            },
                        },
                    },
                };
            }
            // Configuration for 'bar' graph
            if (graphType === "bar") {
                return {
                    type: "bar",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            ...commonScales,
                            y: {
                                ...commonScales.y,
                                stacked: true,
                            },
                        },
                        interaction: {
                            mode: "x",
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            tooltip: {
                                filter: (tooltipItem) => tooltipItem.dataset.data[tooltipItem.dataIndex] > 0,
                            },
                            datalabels: {
                                color: "#000000",
                                align: "center",
                                anchor: "center",
                                formatter: (value) => value > 0 ? value : "",
                            },
                        },
                    },
                };
            }
            // Configuration for 'timeline' graph
            if (graphType === "timeline") {
                return {
                    type: "bar",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        indexAxis: "y",
                        scales: {
                            y: {
                                stacked: true,
                            },
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            legend: {
                                display: false,
                            },
                        },
                    },
                };
            }

            // Configuration for 'boxplot' graph
            if (graphType === "boxplot") {
                return {
                    type: "boxplot",
                    data: graphData,
                    options: {
                        ...baseConfig,
                        scales: {
                            ...commonScales,
                            x: {
                                ...commonScales.x,
                                ticks: {
                                    minRotation: 45,
                                    maxRotation: 45,
                                },
                            },
                        },
                        plugins: {
                            ...baseConfig.plugins,
                            tooltip: {
                                enabled: false,
                            },
                            legend: {
                                display: false,
                            },
                        },
                    },
                };
            }
        }

        // function to prepare the data in the correct format for statistics graphs
        function get_statistics_graph_data(dataType, graphType, filteredData) {
            // Cache DOM values once for performance
            const keywordSelect = document.getElementById("keywordSelect").value;
            const suiteSelectSuites = document.getElementById("suiteSelectSuites").value;
            // Initialize arrays to store the data
            const passed = [], failed = [], skipped = [], labels = [], aliases = [];
            // Helper function to calculate percentages
            const calculatePercentage = (value, total) => Math.round((value / total) * 100 * 100) / 100;
            // Helper function to process each value for graph data
            const processValue = (value) => {
                const total = value.passed + value.failed + value.skipped;
                const passedPercentage = calculatePercentage(value.passed, total);
                const failedPercentage = calculatePercentage(value.failed, total);
                const skippedPercentage = calculatePercentage(value.skipped, total);
                passed.push(passedPercentage);
                failed.push(failedPercentage);
                skipped.push(skippedPercentage);
                labels.push(value.run_start);
                aliases.push(value.run_alias);
            };
            // Loop through filtered data and process it based on the graph type
            for (const value of filteredData) {
                if (dataType === "suite" && suiteSelectSuites !== "All" && value.name !== suiteSelectSuites) continue;
                if (dataType === "keyword" && value.name !== keywordSelect) continue;
                // Process percentage-based data
                if (graphType === "percentages") {
                    if (dataType === "keyword") {
                        if (value.name === keywordSelect) {
                            processValue(value);
                        }
                    } else {
                        processValue(value);
                    }
                } else {
                    // Process raw count data
                    passed.push(value.passed);
                    failed.push(value.failed);
                    skipped.push(value.skipped);
                    labels.push(value.run_start);
                    aliases.push(value.run_alias);
                }
            }
            // Determine if we need to use aliases for labels
            const finalLabels = use_run_aliases ? aliases : labels;
            // Common dataset construction logic
            const createDataset = (label, data, backgroundColor, borderColor) => ({
                label,
                data,
                backgroundColor,
                borderColor,
                borderWidth: 1,
                stack: graphType === "percentages" || "amount" ? "Stack 0" : undefined,
            });
            // Construct the statistics data based on the graph type
            const statisticsData = {
                labels: finalLabels,
                datasets: [
                    createDataset("Failed", failed, failedBackgroundColor, failedBackgroundBorderColor),
                    createDataset("Skipped", skipped, skippedBackgroundColor, skippedBackgroundBorderColor),
                    createDataset("Passed", passed, passedBackgroundColor, passedBackgroundBorderColor),
                ],
            };
            return statisticsData;
        }

        // function to prepare the data in the correct format for duration graphs
        function get_duration_graph_data(dataType, graphType, objectDataAttribute, filteredData) {
            // Cache DOM elements once for performance
            const suiteSelectSuites = document.getElementById("suiteSelectSuites").value;
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testSelect = document.getElementById("testSelect").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            const keywordSelect = document.getElementById("keywordSelect").value;
            // Helper function for filtering based on selection criteria
            const shouldInclude = (value) => {
                if (dataType === "keyword" && value.name !== keywordSelect) return false;
                if (dataType === "suite" && suiteSelectSuites !== "All" && value.name !== suiteSelectSuites) return false;
                if (dataType === "test" && suiteSelectTests !== "All" && !value.full_name.includes(`.${suiteSelectTests}.${value.name}`) && value.full_name !== `${suiteSelectTests}.${value.name}`) return false;
                if (dataType === "test" && testSelect !== "All" && value.name !== testSelect) return false;
                if (dataType === "test" && testTagsSelect !== "All" && !value.tags.replace(/\[|\]/g, '').split(',').includes(testTagsSelect)) return false;
                return true;
            };
            // Bar graph construction
            if (graphType === "bar") {
                const labels = [];
                const data = new Map();
                const aliases = [];
                for (const value of filteredData) {
                    if (!shouldInclude(value)) continue;
                    labels.push(value.run_start);
                    aliases.push(value.run_alias);
                    const roundedValue = Math.round(value[objectDataAttribute] * 100) / 100;
                    for (const [key, arr] of data.entries()) {
                        arr.push(key === value.name ? roundedValue : 0); // Append to each dataset
                    }
                    if (!data.has(value.name)) {
                        const arr = Array(labels.length - 1).fill(0); // Fill up to current length
                        arr.push(roundedValue);
                        data.set(value.name, arr);
                    }
                    if (labels.length > 30) break;
                }
                if (use_run_aliases) {
                    labels.length = 0;
                    labels.push(...aliases);
                }
                // Prepare graph data for bar chart
                const graphData = {
                    labels,
                    datasets: Array.from(data.entries()).map(([label, dataset]) => ({
                        label,
                        data: dataset,
                        stack: "Stack 0",
                    })),
                };
                return graphData;
            }
            // Line graph construction
            else if (graphType === "line") {
                const labels = [];
                const sets = new Map();
                for (const value of filteredData) {
                    if (!shouldInclude(value)) continue;
                    const name = value.name;
                    const run_start = new Date(value.run_start);
                    const roundedValue = Math.round(value[objectDataAttribute] * 100) / 100;
                    if (!sets.has(name)) {
                        labels.push(name);
                        sets.set(name, [{ x: run_start, y: roundedValue }]);
                    } else {
                        sets.get(name).push({ x: run_start, y: roundedValue });
                    }
                }
                // Prepare graph data for line chart
                const datasets = Array.from(sets.entries()).map(([key, values]) => ({
                    label: key,
                    fill: false,
                    data: values,
                }));
                return datasets;
            }
        }

        // function to prepare the data in the correct format for the duration deviation graph
        function get_duration_deviation_data(dataType, graphType, filteredData) {
            // Cache the DOM selections once to avoid repeated access
            const suiteSelectTests = document.getElementById("suiteSelectTests").value;
            const testSelect = document.getElementById("testSelect").value;
            const testTagsSelect = document.getElementById("testTagsSelect").value;
            // Use a Map to store data for better performance and management
            const data = new Map();
            // Only process if graphType is 'boxplot'
            if (graphType === 'boxplot') {
                // Iterate over filteredData to collect elapsed times
                for (const value of filteredData) {
                    // Apply filtering based on user selections
                    if (dataType === "test") {
                        if (suiteSelectTests !== "All" && !value.full_name.includes(`.${suiteSelectTests}.${value.name}`) && value.full_name !== `${suiteSelectTests}.${value.name}`) {
                            continue;
                        }
                        if (testSelect !== "All" && value.name !== testSelect) {
                            continue;
                        }
                        if (testTagsSelect !== "All" && !value.tags.replace(/\[|\]/g, '').split(',').includes(testTagsSelect)) {
                            continue;
                        }
                    }
                    // Add elapsed time data to the Map, grouping by test name
                    if (data.has(value.name)) {
                        data.get(value.name).push(value.elapsed_s);
                    } else {
                        data.set(value.name, [value.elapsed_s]);
                    }
                }
                // Prepare the data for the graph (labels and datasets)
                const labels = [];
                const datasets = [];
                // Iterate over the Map and construct graph data
                for (const [testName, elapsedTimes] of data.entries()) {
                    labels.push(testName);
                    datasets.push(elapsedTimes);
                }
                // Return the graph data object
                return {
                    labels,
                    datasets: [{
                        itemRadius: 3,
                        data: datasets
                    }],
                };
            }
        }

        // function to prepare the data in the correct format for most flaky test graph
        function get_most_flaky_data(dataType, graphType, filteredData) {
            var data = {};
            for (value of filteredData) {
                if (data[value.name]) {
                    data[value.name]['run_starts'].push(value.run_start)
                    var current_status
                    if (value.passed == 1) { current_status = 'passed' }
                    if (value.failed == 1) { current_status = 'failed' }
                    if (!ignoreSkips) {
                        if (value.skipped == 1) { current_status = 'skipped' }
                    }
                    if (current_status != data[value.name]['previous_status']) {
                        data[value.name]['flips'] += 1
                        data[value.name]['previous_status'] = current_status
                    }
                } else {
                    var previous_status
                    if (value.passed == 1) { previous_status = 'passed' }
                    if (value.failed == 1) { previous_status = 'failed' }
                    if (!ignoreSkips) {
                        if (value.skipped == 1) { previous_status = 'skipped' }
                    }
                    data[value.name] = {
                        'run_starts': [value.run_start],
                        'flips': 0,
                        'previous_status': previous_status,
                    }
                }
            }
            var sortedData = [];
            for (var test in data) {
                if (data[test].flips > 0) {
                    sortedData.push([test, data[test]]);
                }
            }
            sortedData.sort(function (a, b) {
                return b[1].flips - a[1].flips;
            });
            if (graphType == "bar") {
                var [datasets, labels, count] = [[], [], 0];
                for (key in sortedData) {
                    if (count > 9) {
                        break;
                    }
                    labels.push(sortedData[key][0]);
                    datasets.push(sortedData[key][1].flips);
                    count += 1;
                }
                const graphData = {
                    labels,
                    datasets: [{
                        data: datasets,
                        backgroundColor: failedBackgroundColor,
                        borderColor: failedBackgroundBorderColor,
                        borderWidth: 1,
                    }],
                };
                return [data, graphData];
            } else if (graphType == "timeline") {
                var [labels, runStarts, count, run_aliases] = [[], [], 0, []];
                for (key in sortedData) {
                    if (count > 9) {
                        break;
                    }
                    labels.push(sortedData[key][0]);
                    for (runStart of sortedData[key][1].run_starts) {
                        if (!runStarts.includes(runStart)) {
                            runStarts.push(runStart);
                        }
                    }
                    count += 1;
                }
                var datasets = [];
                var runAxis = 0;
                runStarts = runStarts.sort((a, b) => new Date(a).getTime() - new Date(b).getTime())
                for (runStart of runStarts) {
                    for (label of labels) {
                        var foundValues = [];
                        for (value of filteredData) {
                            if (value.name == label && value.run_start == runStart) {
                                foundValues.push(value);
                                if (!run_aliases.includes(value.run_alias)) { run_aliases.push(value.run_alias) }
                            }
                        }
                        if (foundValues.length > 0) {
                            var value = foundValues[0];
                            if (value.passed == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    backgroundColor: passedBackgroundColor,
                                    borderColor: passedBackgroundBorderColor,
                                    borderWidth: 1,
                                });
                            }
                            else if (value.failed == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    backgroundColor: failedBackgroundColor,
                                    borderColor: failedBackgroundBorderColor,
                                    borderWidth: 1,
                                });
                            }
                            else if (value.skipped == 1) {
                                datasets.push({
                                    label: label,
                                    data: [{ x: [runAxis, runAxis + 1], y: label }],
                                    backgroundColor: skippedBackgroundColor,
                                    borderColor: skippedBackgroundBorderColor,
                                    borderWidth: 1,
                                });
                            }
                        }
                    }
                    runAxis += 1;
                }
                if (use_run_aliases) { runStarts = run_aliases }
                var graphData = {
                    labels: labels,
                    datasets: datasets,
                };
                return [runStarts, graphData];
            }
        }

        // function to prepare the data in the correct format for most failed graphs
        function get_most_failed_data(dataType, graphType, filteredData) {
            // Maps to store data and aliases
            const data = new Map();
            const aliases = new Map();
            // Collect data and aliases
            for (const value of filteredData) {
                if (value.failed > 0) {
                    if (!data.has(value.name)) {
                        data.set(value.name, []);
                        aliases.set(value.name, []);
                    }
                    data.get(value.name).push(value.run_start);
                    aliases.get(value.name).push(value.run_alias);
                }
            }
            // Sort the data based on the number of failures (descending order)
            const sortedData = [...data.entries()].sort((a, b) => b[1].length - a[1].length);
            if (graphType === 'bar') {
                const datasets = [];
                const labels = [];
                let count = 0;
                for (const [name, runStarts] of sortedData) {
                    if (count > 9) break;
                    labels.push(name);
                    if (use_run_aliases) {
                        data.set(name, aliases.get(name));
                    }
                    datasets.push(runStarts.length);
                    count++;
                }
                const graphData = {
                    labels,
                    datasets: [{
                        data: datasets,
                        backgroundColor: failedBackgroundColor,
                        borderColor: failedBackgroundBorderColor,
                        borderWidth: 1,
                    }],
                };
                return [Object.fromEntries(sortedData.map(([name, runs]) => [name, aliases.get(name)])), graphData];
            } else if (graphType === 'timeline') {
                const labels = [];
                const runStartsSet = new Set();
                const runAliasesSet = new Set();
                let count = 0;
                // Collect unique run starts and labels
                for (const [name, runStarts] of sortedData) {
                    if (count > 9) break;
                    labels.push(name);
                    runStarts.forEach(runStart => runStartsSet.add(runStart));
                    count++;
                }
                // Convert set to sorted array
                const runStarts = Array.from(runStartsSet).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
                // Build datasets
                const datasets = [];
                let runAxis = 0;
                for (const runStart of runStarts) {
                    for (const label of labels) {
                        const foundValues = filteredData.filter(value => value.name === label && value.run_start === runStart && value.failed > 0);
                        if (foundValues.length > 0) {
                            const value = foundValues[0];
                            datasets.push({
                                label: label,
                                data: [{ x: [runAxis, runAxis + 1], y: label }],
                                backgroundColor: failedBackgroundColor,
                                borderColor: failedBackgroundBorderColor,
                                borderWidth: 1,
                            });
                            foundValues.forEach(value => runAliasesSet.add(value.run_alias));
                        }
                    }
                    runAxis++;
                }
                const runStartsArray = use_run_aliases ? Array.from(runAliasesSet) : runStarts;
                const graphData = {
                    labels,
                    datasets,
                };
                return [runStartsArray, graphData];
            }
        }

        // function to prepare the data in the correct format for messages graphs
        function get_messages_data(dataType, graphType, filteredData) {
            // Maps to store data and aliases
            const data = new Map();
            const aliases = new Map();

            // Build data and aliases
            for (const value of filteredData) {
                if (value.message && (value.failed === 1 || value.skipped === 1)) {
                    if (!data.has(value.message)) {
                        data.set(value.message, []);
                        aliases.set(value.message, []);
                    }
                    data.get(value.message).push(value.run_start);
                    aliases.get(value.message).push(value.run_alias);
                }
            }

            // If there is a message config use that to merge the data
            if (!message_config.includes('placeholder_message_config')) {
                function matches_message_config(str, rule) {
                    rule = rule.replace(/\$\{.*?\}/g, "*") // match any ${something} string
                    var escapeRegex = (str) => str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"); // escape the test messages to prevent regex mismatches
                    return new RegExp("^" + rule.split("*").map(escapeRegex).join(".*") + "$").test(str);
                }

                for (const config of message_config) {
                    for (const [message, runStarts] of data) {
                        if (message == config) { continue }
                        if (matches_message_config(message, config)) {
                            if (!data.has(config)) {
                                data.set(config, []);
                            }
                            data.get(config).push(...runStarts);
                            data.delete(message)
                        }
                    }
                }

                for (const [message, runStarts] of data) {
                    arrayWithDuplicates = data.get(message)
                    data.set(message, [...new Set(arrayWithDuplicates)])
                }
            }

            // Sort messages by failure count
            const sortedData = [...data.entries()].sort((a, b) => b[1].length - a[1].length);
            if (graphType === 'bar') {
                const [datasets, labels] = [[], []];
                let count = 0;

                for (const [message, runStarts] of sortedData) {
                    if (count > 9) break;
                    labels.push(message);
                    datasets.push(runStarts.length);
                    if (use_run_aliases) {
                        data.set(message, aliases.get(message));
                    }
                    count++;
                }
                const graphData = {
                    labels,
                    datasets: [{
                        data: datasets,
                        backgroundColor: failedBackgroundColor,
                        borderColor: failedBackgroundBorderColor,
                        borderWidth: 1,
                    }],
                };
                return [Object.fromEntries(sortedData.map(([message, runs]) => [message, aliases.get(message)])), graphData];
            } else if (graphType === 'timeline') {
                const labels = [];
                const runStartsSet = new Set();
                const runAliasesSet = new Set();
                let count = 0;
                // Collect unique run starts and labels
                for (const [message, runStarts] of sortedData) {
                    if (count > 9) break;
                    labels.push(message);
                    runStarts.forEach(runStart => runStartsSet.add(runStart));
                    count++;
                }
                // Convert set to sorted array
                const runStarts = Array.from(runStartsSet).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());
                // Build datasets
                const datasets = [];
                let runAxis = 0;
                function check_label(message, label) {
                    return !message_config.includes('placeholder_message_config')
                        ? matches_message_config(message, label)
                        : message === label;
                }
                for (const runStart of runStarts) {
                    for (const label of labels) {
                        const foundValues = filteredData.filter(value => check_label(value.message, label) && value.run_start === runStart);
                        if (foundValues.length > 0) {
                            const value = foundValues[0];
                            datasets.push({
                                label: label,
                                data: [{ x: [runAxis, runAxis + 1], y: label }],
                                backgroundColor: failedBackgroundColor,
                                borderColor: failedBackgroundBorderColor,
                                borderWidth: 1,
                            });
                            foundValues.forEach(value => runAliasesSet.add(value.run_alias));
                        }
                    }
                    runAxis++;
                }
                const runStartsArray = use_run_aliases ? Array.from(runAliasesSet) : runStarts;
                const graphData = {
                    labels,
                    datasets,
                };
                return [runStartsArray, graphData];
            }
        }

        // function to update the height of the test statistics graph and enable scrolling
        function update_height(verticalId, graph) {
            document.getElementById(verticalId).style.height = `489px`
            if (graph.data.labels.length > 10) {
                var newHeight = 489 + (graph.data.labels.length - 10) * 25
                document.getElementById(verticalId).style.height = `${newHeight}px`
            }
        }
    </script>
</body>

</html>