import typing, clr, abc
from System import Array_1, IDisposable, ReadOnlySpan_1, Span_1, SystemException, Exception, IAsyncResult, AsyncCallback, Memory_1, ReadOnlyMemory_1, IEquatable_1, Range
from System.Collections import ICollection, IEnumerator, IDictionary
from System.Reflection import MethodBase
from System.IO import Stream, SeekOrigin
from System.Threading.Tasks import ValueTask, Task, ValueTask_1, Task_1
from System.Threading import CancellationToken
from System.Security import SecureString, SecurityElement

class Aes(SymmetricAlgorithm):
    @property
    def BlockSize(self) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> int: ...
    @property
    def IV(self) -> Array_1[int]: ...
    @IV.setter
    def IV(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalBlockSizes(self) -> Array_1[KeySizes]: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def Mode(self) -> CipherMode: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> PaddingMode: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> Aes:...
        @typing.overload
        def __call__(self, algorithmName: str) -> Aes:...



class AesCcm(IDisposable):
    @typing.overload
    def __init__(self, key: ReadOnlySpan_1[int]) -> None: ...
    @typing.overload
    def __init__(self, key: Array_1[int]) -> None: ...
    @classmethod
    @property
    def IsSupported(cls) -> bool: ...
    @classmethod
    @property
    def NonceByteSizes(cls) -> KeySizes: ...
    @classmethod
    @property
    def TagByteSizes(cls) -> KeySizes: ...
    def Dispose(self) -> None: ...
    # Skipped Decrypt due to it being static, abstract and generic.

    Decrypt : Decrypt_MethodGroup
    class Decrypt_MethodGroup:
        @typing.overload
        def __call__(self, nonce: Array_1[int], ciphertext: Array_1[int], tag: Array_1[int], plaintext: Array_1[int], associatedData: Array_1[int] = ...) -> None:...
        @typing.overload
        def __call__(self, nonce: ReadOnlySpan_1[int], ciphertext: ReadOnlySpan_1[int], tag: ReadOnlySpan_1[int], plaintext: Span_1[int], associatedData: ReadOnlySpan_1[int] = ...) -> None:...

    # Skipped Encrypt due to it being static, abstract and generic.

    Encrypt : Encrypt_MethodGroup
    class Encrypt_MethodGroup:
        @typing.overload
        def __call__(self, nonce: Array_1[int], plaintext: Array_1[int], ciphertext: Array_1[int], tag: Array_1[int], associatedData: Array_1[int] = ...) -> None:...
        @typing.overload
        def __call__(self, nonce: ReadOnlySpan_1[int], plaintext: ReadOnlySpan_1[int], ciphertext: Span_1[int], tag: Span_1[int], associatedData: ReadOnlySpan_1[int] = ...) -> None:...



class AesCryptoServiceProvider(Aes):
    def __init__(self) -> None: ...
    @property
    def BlockSize(self) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> int: ...
    @property
    def IV(self) -> Array_1[int]: ...
    @IV.setter
    def IV(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalBlockSizes(self) -> Array_1[KeySizes]: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def Mode(self) -> CipherMode: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> PaddingMode: ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...
    # Skipped CreateDecryptor due to it being static, abstract and generic.

    CreateDecryptor : CreateDecryptor_MethodGroup
    class CreateDecryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...

    # Skipped CreateEncryptor due to it being static, abstract and generic.

    CreateEncryptor : CreateEncryptor_MethodGroup
    class CreateEncryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...



class AesGcm(IDisposable):
    @typing.overload
    def __init__(self, key: ReadOnlySpan_1[int]) -> None: ...
    @typing.overload
    def __init__(self, key: Array_1[int]) -> None: ...
    @classmethod
    @property
    def IsSupported(cls) -> bool: ...
    @classmethod
    @property
    def NonceByteSizes(cls) -> KeySizes: ...
    @classmethod
    @property
    def TagByteSizes(cls) -> KeySizes: ...
    def Dispose(self) -> None: ...
    # Skipped Decrypt due to it being static, abstract and generic.

    Decrypt : Decrypt_MethodGroup
    class Decrypt_MethodGroup:
        @typing.overload
        def __call__(self, nonce: Array_1[int], ciphertext: Array_1[int], tag: Array_1[int], plaintext: Array_1[int], associatedData: Array_1[int] = ...) -> None:...
        @typing.overload
        def __call__(self, nonce: ReadOnlySpan_1[int], ciphertext: ReadOnlySpan_1[int], tag: ReadOnlySpan_1[int], plaintext: Span_1[int], associatedData: ReadOnlySpan_1[int] = ...) -> None:...

    # Skipped Encrypt due to it being static, abstract and generic.

    Encrypt : Encrypt_MethodGroup
    class Encrypt_MethodGroup:
        @typing.overload
        def __call__(self, nonce: Array_1[int], plaintext: Array_1[int], ciphertext: Array_1[int], tag: Array_1[int], associatedData: Array_1[int] = ...) -> None:...
        @typing.overload
        def __call__(self, nonce: ReadOnlySpan_1[int], plaintext: ReadOnlySpan_1[int], ciphertext: Span_1[int], tag: Span_1[int], associatedData: ReadOnlySpan_1[int] = ...) -> None:...



class AesManaged(Aes):
    def __init__(self) -> None: ...
    @property
    def BlockSize(self) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> int: ...
    @property
    def IV(self) -> Array_1[int]: ...
    @IV.setter
    def IV(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalBlockSizes(self) -> Array_1[KeySizes]: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def Mode(self) -> CipherMode: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> PaddingMode: ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...
    # Skipped CreateDecryptor due to it being static, abstract and generic.

    CreateDecryptor : CreateDecryptor_MethodGroup
    class CreateDecryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...

    # Skipped CreateEncryptor due to it being static, abstract and generic.

    CreateEncryptor : CreateEncryptor_MethodGroup
    class CreateEncryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...



class AsnEncodedData:
    @typing.overload
    def __init__(self, asnEncodedData: AsnEncodedData) -> None: ...
    @typing.overload
    def __init__(self, oid: Oid, rawData: Array_1[int]) -> None: ...
    @typing.overload
    def __init__(self, oid: str, rawData: Array_1[int]) -> None: ...
    @typing.overload
    def __init__(self, oid: Oid, rawData: ReadOnlySpan_1[int]) -> None: ...
    @typing.overload
    def __init__(self, oid: str, rawData: ReadOnlySpan_1[int]) -> None: ...
    @typing.overload
    def __init__(self, rawData: Array_1[int]) -> None: ...
    @typing.overload
    def __init__(self, rawData: ReadOnlySpan_1[int]) -> None: ...
    @property
    def Oid(self) -> Oid: ...
    @Oid.setter
    def Oid(self, value: Oid) -> Oid: ...
    @property
    def RawData(self) -> Array_1[int]: ...
    @RawData.setter
    def RawData(self, value: Array_1[int]) -> Array_1[int]: ...
    def CopyFrom(self, asnEncodedData: AsnEncodedData) -> None: ...
    def Format(self, multiLine: bool) -> str: ...


class AsnEncodedDataCollection(ICollection):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, asnEncodedData: AsnEncodedData) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> AsnEncodedData: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def Add(self, asnEncodedData: AsnEncodedData) -> int: ...
    def CopyTo(self, array: Array_1[AsnEncodedData], index: int) -> None: ...
    def GetEnumerator(self) -> AsnEncodedDataEnumerator: ...
    def Remove(self, asnEncodedData: AsnEncodedData) -> None: ...


class AsnEncodedDataEnumerator(IEnumerator):
    @property
    def Current(self) -> AsnEncodedData: ...
    def MoveNext(self) -> bool: ...
    def Reset(self) -> None: ...


class AsymmetricAlgorithm(IDisposable, abc.ABC):
    @property
    def KeyExchangeAlgorithm(self) -> str: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def SignatureAlgorithm(self) -> str: ...
    def Clear(self) -> None: ...
    def Dispose(self) -> None: ...
    def ExportPkcs8PrivateKey(self) -> Array_1[int]: ...
    def ExportSubjectPublicKeyInfo(self) -> Array_1[int]: ...
    def FromXmlString(self, xmlString: str) -> None: ...
    def ImportFromPem(self, input: ReadOnlySpan_1[str]) -> None: ...
    def ImportPkcs8PrivateKey(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ImportSubjectPublicKeyInfo(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ToXmlString(self, includePrivateParameters: bool) -> str: ...
    def TryExportPkcs8PrivateKey(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryExportSubjectPublicKeyInfo(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> AsymmetricAlgorithm:...
        @typing.overload
        def __call__(self, algName: str) -> AsymmetricAlgorithm:...

    # Skipped ExportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    ExportEncryptedPkcs8PrivateKey : ExportEncryptedPkcs8PrivateKey_MethodGroup
    class ExportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], pbeParameters: PbeParameters) -> Array_1[int]:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], pbeParameters: PbeParameters) -> Array_1[int]:...

    # Skipped ImportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    ImportEncryptedPkcs8PrivateKey : ImportEncryptedPkcs8PrivateKey_MethodGroup
    class ImportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...

    # Skipped ImportFromEncryptedPem due to it being static, abstract and generic.

    ImportFromEncryptedPem : ImportFromEncryptedPem_MethodGroup
    class ImportFromEncryptedPem_MethodGroup:
        @typing.overload
        def __call__(self, input: ReadOnlySpan_1[str], password: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, input: ReadOnlySpan_1[str], passwordBytes: ReadOnlySpan_1[int]) -> None:...

    # Skipped TryExportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    TryExportEncryptedPkcs8PrivateKey : TryExportEncryptedPkcs8PrivateKey_MethodGroup
    class TryExportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], pbeParameters: PbeParameters, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], pbeParameters: PbeParameters, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool:...



class AsymmetricKeyExchangeDeformatter(abc.ABC):
    @property
    def Parameters(self) -> str: ...
    @Parameters.setter
    def Parameters(self, value: str) -> str: ...
    @abc.abstractmethod
    def DecryptKeyExchange(self, rgb: Array_1[int]) -> Array_1[int]: ...
    @abc.abstractmethod
    def SetKey(self, key: AsymmetricAlgorithm) -> None: ...


class AsymmetricKeyExchangeFormatter(abc.ABC):
    @property
    def Parameters(self) -> str: ...
    @abc.abstractmethod
    def SetKey(self, key: AsymmetricAlgorithm) -> None: ...
    # Skipped CreateKeyExchange due to it being static, abstract and generic.

    CreateKeyExchange : CreateKeyExchange_MethodGroup
    class CreateKeyExchange_MethodGroup:
        @typing.overload
        def __call__(self, data: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], symAlgType: typing.Type[typing.Any]) -> Array_1[int]:...



class AsymmetricSignatureDeformatter(abc.ABC):
    @abc.abstractmethod
    def SetHashAlgorithm(self, strName: str) -> None: ...
    @abc.abstractmethod
    def SetKey(self, key: AsymmetricAlgorithm) -> None: ...
    # Skipped VerifySignature due to it being static, abstract and generic.

    VerifySignature : VerifySignature_MethodGroup
    class VerifySignature_MethodGroup:
        @typing.overload
        def __call__(self, rgbHash: Array_1[int], rgbSignature: Array_1[int]) -> bool:...
        @typing.overload
        def __call__(self, hash: HashAlgorithm, rgbSignature: Array_1[int]) -> bool:...



class AsymmetricSignatureFormatter(abc.ABC):
    @abc.abstractmethod
    def SetHashAlgorithm(self, strName: str) -> None: ...
    @abc.abstractmethod
    def SetKey(self, key: AsymmetricAlgorithm) -> None: ...
    # Skipped CreateSignature due to it being static, abstract and generic.

    CreateSignature : CreateSignature_MethodGroup
    class CreateSignature_MethodGroup:
        @typing.overload
        def __call__(self, rgbHash: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, hash: HashAlgorithm) -> Array_1[int]:...



class ChaCha20Poly1305(IDisposable):
    @typing.overload
    def __init__(self, key: ReadOnlySpan_1[int]) -> None: ...
    @typing.overload
    def __init__(self, key: Array_1[int]) -> None: ...
    @classmethod
    @property
    def IsSupported(cls) -> bool: ...
    def Dispose(self) -> None: ...
    # Skipped Decrypt due to it being static, abstract and generic.

    Decrypt : Decrypt_MethodGroup
    class Decrypt_MethodGroup:
        @typing.overload
        def __call__(self, nonce: Array_1[int], ciphertext: Array_1[int], tag: Array_1[int], plaintext: Array_1[int], associatedData: Array_1[int] = ...) -> None:...
        @typing.overload
        def __call__(self, nonce: ReadOnlySpan_1[int], ciphertext: ReadOnlySpan_1[int], tag: ReadOnlySpan_1[int], plaintext: Span_1[int], associatedData: ReadOnlySpan_1[int] = ...) -> None:...

    # Skipped Encrypt due to it being static, abstract and generic.

    Encrypt : Encrypt_MethodGroup
    class Encrypt_MethodGroup:
        @typing.overload
        def __call__(self, nonce: Array_1[int], plaintext: Array_1[int], ciphertext: Array_1[int], tag: Array_1[int], associatedData: Array_1[int] = ...) -> None:...
        @typing.overload
        def __call__(self, nonce: ReadOnlySpan_1[int], plaintext: ReadOnlySpan_1[int], ciphertext: Span_1[int], tag: Span_1[int], associatedData: ReadOnlySpan_1[int] = ...) -> None:...



class CipherMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    CBC : CipherMode # 1
    ECB : CipherMode # 2
    OFB : CipherMode # 3
    CFB : CipherMode # 4
    CTS : CipherMode # 5


class CryptoConfig:
    def __init__(self) -> None: ...
    @classmethod
    @property
    def AllowOnlyFipsAlgorithms(cls) -> bool: ...
    @staticmethod
    def AddAlgorithm(algorithm: typing.Type[typing.Any], names: Array_1[str]) -> None: ...
    @staticmethod
    def AddOID(oid: str, names: Array_1[str]) -> None: ...
    @staticmethod
    def EncodeOID(str: str) -> Array_1[int]: ...
    @staticmethod
    def MapNameToOID(name: str) -> str: ...
    # Skipped CreateFromName due to it being static, abstract and generic.

    CreateFromName : CreateFromName_MethodGroup
    class CreateFromName_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> typing.Any:...
        @typing.overload
        def __call__(self, name: str, args: Array_1[typing.Any]) -> typing.Any:...



class CryptographicException(SystemException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, format: str, insert: str) -> None: ...
    @typing.overload
    def __init__(self, hr: int) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, inner: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class CryptographicOperations(abc.ABC):
    @staticmethod
    def FixedTimeEquals(left: ReadOnlySpan_1[int], right: ReadOnlySpan_1[int]) -> bool: ...
    @staticmethod
    def ZeroMemory(buffer: Span_1[int]) -> None: ...


class CryptographicUnexpectedOperationException(CryptographicException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, format: str, insert: str) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, inner: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class CryptoStream(Stream):
    @typing.overload
    def __init__(self, stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode, leaveOpen: bool) -> None: ...
    @property
    def CanRead(self) -> bool: ...
    @property
    def CanSeek(self) -> bool: ...
    @property
    def CanTimeout(self) -> bool: ...
    @property
    def CanWrite(self) -> bool: ...
    @property
    def HasFlushedFinalBlock(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    @property
    def Position(self) -> int: ...
    @Position.setter
    def Position(self, value: int) -> int: ...
    @property
    def ReadTimeout(self) -> int: ...
    @ReadTimeout.setter
    def ReadTimeout(self, value: int) -> int: ...
    @property
    def WriteTimeout(self) -> int: ...
    @WriteTimeout.setter
    def WriteTimeout(self, value: int) -> int: ...
    def BeginRead(self, buffer: Array_1[int], offset: int, count: int, callback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    def BeginWrite(self, buffer: Array_1[int], offset: int, count: int, callback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    def Clear(self) -> None: ...
    def DisposeAsync(self) -> ValueTask: ...
    def EndRead(self, asyncResult: IAsyncResult) -> int: ...
    def EndWrite(self, asyncResult: IAsyncResult) -> None: ...
    def Flush(self) -> None: ...
    def FlushFinalBlock(self) -> None: ...
    def FlushFinalBlockAsync(self, cancellationToken: CancellationToken = ...) -> ValueTask: ...
    def ReadByte(self) -> int: ...
    def Seek(self, offset: int, origin: SeekOrigin) -> int: ...
    def SetLength(self, value: int) -> None: ...
    def WriteByte(self, value: int) -> None: ...
    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, destination: Stream) -> None:...
        @typing.overload
        def __call__(self, destination: Stream, bufferSize: int) -> None:...

    # Skipped CopyToAsync due to it being static, abstract and generic.

    CopyToAsync : CopyToAsync_MethodGroup
    class CopyToAsync_MethodGroup:
        @typing.overload
        def __call__(self, destination: Stream) -> Task:...
        @typing.overload
        def __call__(self, destination: Stream, bufferSize: int) -> Task:...
        @typing.overload
        def __call__(self, destination: Stream, cancellationToken: CancellationToken) -> Task:...
        @typing.overload
        def __call__(self, destination: Stream, bufferSize: int, cancellationToken: CancellationToken) -> Task:...

    # Skipped FlushAsync due to it being static, abstract and generic.

    FlushAsync : FlushAsync_MethodGroup
    class FlushAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Task:...

    # Skipped Read due to it being static, abstract and generic.

    Read : Read_MethodGroup
    class Read_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Span_1[int]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> int:...

    # Skipped ReadAsync due to it being static, abstract and generic.

    ReadAsync : ReadAsync_MethodGroup
    class ReadAsync_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Memory_1[int], cancellationToken: CancellationToken = ...) -> ValueTask_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> Task_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, cancellationToken: CancellationToken) -> Task_1[int]:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> None:...

    # Skipped WriteAsync due to it being static, abstract and generic.

    WriteAsync : WriteAsync_MethodGroup
    class WriteAsync_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ReadOnlyMemory_1[int], cancellationToken: CancellationToken = ...) -> ValueTask:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> Task:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, cancellationToken: CancellationToken) -> Task:...



class CryptoStreamMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Read : CryptoStreamMode # 0
    Write : CryptoStreamMode # 1


class CspKeyContainerInfo:
    def __init__(self, parameters: CspParameters) -> None: ...
    @property
    def Accessible(self) -> bool: ...
    @property
    def Exportable(self) -> bool: ...
    @property
    def HardwareDevice(self) -> bool: ...
    @property
    def KeyContainerName(self) -> str: ...
    @property
    def KeyNumber(self) -> KeyNumber: ...
    @property
    def MachineKeyStore(self) -> bool: ...
    @property
    def Protected(self) -> bool: ...
    @property
    def ProviderName(self) -> str: ...
    @property
    def ProviderType(self) -> int: ...
    @property
    def RandomlyGenerated(self) -> bool: ...
    @property
    def Removable(self) -> bool: ...
    @property
    def UniqueKeyContainerName(self) -> str: ...


class CspParameters:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, dwTypeIn: int) -> None: ...
    @typing.overload
    def __init__(self, dwTypeIn: int, strProviderNameIn: str) -> None: ...
    @typing.overload
    def __init__(self, dwTypeIn: int, strProviderNameIn: str, strContainerNameIn: str) -> None: ...
    KeyContainerName : str
    KeyNumber : int
    ProviderName : str
    ProviderType : int
    @property
    def Flags(self) -> CspProviderFlags: ...
    @Flags.setter
    def Flags(self, value: CspProviderFlags) -> CspProviderFlags: ...
    @property
    def KeyPassword(self) -> SecureString: ...
    @KeyPassword.setter
    def KeyPassword(self, value: SecureString) -> SecureString: ...
    @property
    def ParentWindowHandle(self) -> int: ...
    @ParentWindowHandle.setter
    def ParentWindowHandle(self, value: int) -> int: ...


class CspProviderFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    NoFlags : CspProviderFlags # 0
    UseMachineKeyStore : CspProviderFlags # 1
    UseDefaultKeyContainer : CspProviderFlags # 2
    UseNonExportableKey : CspProviderFlags # 4
    UseExistingKey : CspProviderFlags # 8
    UseArchivableKey : CspProviderFlags # 16
    UseUserProtectedKey : CspProviderFlags # 32
    NoPrompt : CspProviderFlags # 64
    CreateEphemeralKey : CspProviderFlags # 128


class DeriveBytes(IDisposable, abc.ABC):
    def Dispose(self) -> None: ...
    @abc.abstractmethod
    def GetBytes(self, cb: int) -> Array_1[int]: ...
    @abc.abstractmethod
    def Reset(self) -> None: ...


class DES(SymmetricAlgorithm):
    @property
    def BlockSize(self) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> int: ...
    @property
    def IV(self) -> Array_1[int]: ...
    @IV.setter
    def IV(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalBlockSizes(self) -> Array_1[KeySizes]: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def Mode(self) -> CipherMode: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> PaddingMode: ...
    @staticmethod
    def IsSemiWeakKey(rgbKey: Array_1[int]) -> bool: ...
    @staticmethod
    def IsWeakKey(rgbKey: Array_1[int]) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> DES:...
        @typing.overload
        def __call__(self, algName: str) -> DES:...



class DESCryptoServiceProvider(DES):
    def __init__(self) -> None: ...
    @property
    def BlockSize(self) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> int: ...
    @property
    def IV(self) -> Array_1[int]: ...
    @IV.setter
    def IV(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalBlockSizes(self) -> Array_1[KeySizes]: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def Mode(self) -> CipherMode: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> PaddingMode: ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...
    # Skipped CreateDecryptor due to it being static, abstract and generic.

    CreateDecryptor : CreateDecryptor_MethodGroup
    class CreateDecryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...

    # Skipped CreateEncryptor due to it being static, abstract and generic.

    CreateEncryptor : CreateEncryptor_MethodGroup
    class CreateEncryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...



class DSA(AsymmetricAlgorithm):
    @property
    def KeyExchangeAlgorithm(self) -> str: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def SignatureAlgorithm(self) -> str: ...
    @abc.abstractmethod
    def ExportParameters(self, includePrivateParameters: bool) -> DSAParameters: ...
    def FromXmlString(self, xmlString: str) -> None: ...
    def GetMaxSignatureSize(self, signatureFormat: DSASignatureFormat) -> int: ...
    def ImportFromPem(self, input: ReadOnlySpan_1[str]) -> None: ...
    @abc.abstractmethod
    def ImportParameters(self, parameters: DSAParameters) -> None: ...
    def ImportPkcs8PrivateKey(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ImportSubjectPublicKeyInfo(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ToXmlString(self, includePrivateParameters: bool) -> str: ...
    def TryExportPkcs8PrivateKey(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryExportSubjectPublicKeyInfo(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> DSA:...
        @typing.overload
        def __call__(self, keySizeInBits: int) -> DSA:...
        @typing.overload
        def __call__(self, algName: str) -> DSA:...
        @typing.overload
        def __call__(self, parameters: DSAParameters) -> DSA:...

    # Skipped CreateSignature due to it being static, abstract and generic.

    CreateSignature : CreateSignature_MethodGroup
    class CreateSignature_MethodGroup:
        @typing.overload
        def __call__(self, rgbHash: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, rgbHash: Array_1[int], signatureFormat: DSASignatureFormat) -> Array_1[int]:...

    # Skipped ImportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    ImportEncryptedPkcs8PrivateKey : ImportEncryptedPkcs8PrivateKey_MethodGroup
    class ImportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...

    # Skipped ImportFromEncryptedPem due to it being static, abstract and generic.

    ImportFromEncryptedPem : ImportFromEncryptedPem_MethodGroup
    class ImportFromEncryptedPem_MethodGroup:
        @typing.overload
        def __call__(self, input: ReadOnlySpan_1[str], password: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, input: ReadOnlySpan_1[str], passwordBytes: ReadOnlySpan_1[int]) -> None:...

    # Skipped SignData due to it being static, abstract and generic.

    SignData : SignData_MethodGroup
    class SignData_MethodGroup:
        @typing.overload
        def __call__(self, data: Array_1[int], hashAlgorithm: HashAlgorithmName) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Stream, hashAlgorithm: HashAlgorithmName) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, hashAlgorithm: HashAlgorithmName) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> Array_1[int]:...

    # Skipped TryCreateSignature due to it being static, abstract and generic.

    TryCreateSignature : TryCreateSignature_MethodGroup
    class TryCreateSignature_MethodGroup:
        @typing.overload
        def __call__(self, hash: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool:...
        @typing.overload
        def __call__(self, hash: ReadOnlySpan_1[int], destination: Span_1[int], signatureFormat: DSASignatureFormat, bytesWritten: clr.Reference[int]) -> bool:...

    # Skipped TryExportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    TryExportEncryptedPkcs8PrivateKey : TryExportEncryptedPkcs8PrivateKey_MethodGroup
    class TryExportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], pbeParameters: PbeParameters, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], pbeParameters: PbeParameters, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool:...

    # Skipped TrySignData due to it being static, abstract and generic.

    TrySignData : TrySignData_MethodGroup
    class TrySignData_MethodGroup:
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int], destination: Span_1[int], hashAlgorithm: HashAlgorithmName, bytesWritten: clr.Reference[int]) -> bool:...
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int], destination: Span_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: clr.Reference[int]) -> bool:...

    # Skipped VerifyData due to it being static, abstract and generic.

    VerifyData : VerifyData_MethodGroup
    class VerifyData_MethodGroup:
        @typing.overload
        def __call__(self, data: Array_1[int], signature: Array_1[int], hashAlgorithm: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], hashAlgorithm: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, data: Stream, signature: Array_1[int], hashAlgorithm: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], signature: Array_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> bool:...
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> bool:...
        @typing.overload
        def __call__(self, data: Stream, signature: Array_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, signature: Array_1[int], hashAlgorithm: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, signature: Array_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> bool:...

    # Skipped VerifySignature due to it being static, abstract and generic.

    VerifySignature : VerifySignature_MethodGroup
    class VerifySignature_MethodGroup:
        @typing.overload
        def __call__(self, rgbHash: Array_1[int], rgbSignature: Array_1[int]) -> bool:...
        @typing.overload
        def __call__(self, hash: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int]) -> bool:...
        @typing.overload
        def __call__(self, rgbHash: Array_1[int], rgbSignature: Array_1[int], signatureFormat: DSASignatureFormat) -> bool:...
        @typing.overload
        def __call__(self, hash: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], signatureFormat: DSASignatureFormat) -> bool:...



class DSACryptoServiceProvider(DSA, ICspAsymmetricAlgorithm):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, dwKeySize: int) -> None: ...
    @typing.overload
    def __init__(self, dwKeySize: int, parameters: CspParameters) -> None: ...
    @typing.overload
    def __init__(self, parameters: CspParameters) -> None: ...
    @property
    def CspKeyContainerInfo(self) -> CspKeyContainerInfo: ...
    @property
    def KeyExchangeAlgorithm(self) -> str: ...
    @property
    def KeySize(self) -> int: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def PersistKeyInCsp(self) -> bool: ...
    @PersistKeyInCsp.setter
    def PersistKeyInCsp(self, value: bool) -> bool: ...
    @property
    def PublicOnly(self) -> bool: ...
    @property
    def SignatureAlgorithm(self) -> str: ...
    @classmethod
    @property
    def UseMachineKeyStore(cls) -> bool: ...
    @classmethod
    @UseMachineKeyStore.setter
    def UseMachineKeyStore(cls, value: bool) -> bool: ...
    def ExportCspBlob(self, includePrivateParameters: bool) -> Array_1[int]: ...
    def ExportParameters(self, includePrivateParameters: bool) -> DSAParameters: ...
    def ImportCspBlob(self, keyBlob: Array_1[int]) -> None: ...
    def ImportParameters(self, parameters: DSAParameters) -> None: ...
    def SignHash(self, rgbHash: Array_1[int], str: str) -> Array_1[int]: ...
    def VerifyHash(self, rgbHash: Array_1[int], str: str, rgbSignature: Array_1[int]) -> bool: ...
    # Skipped CreateSignature due to it being static, abstract and generic.

    CreateSignature : CreateSignature_MethodGroup
    class CreateSignature_MethodGroup:
        @typing.overload
        def __call__(self, rgbHash: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, rgbHash: Array_1[int], signatureFormat: DSASignatureFormat) -> Array_1[int]:...

    # Skipped ImportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    ImportEncryptedPkcs8PrivateKey : ImportEncryptedPkcs8PrivateKey_MethodGroup
    class ImportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...

    # Skipped SignData due to it being static, abstract and generic.

    SignData : SignData_MethodGroup
    class SignData_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, inputStream: Stream) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], hashAlgorithm: HashAlgorithmName) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Stream, hashAlgorithm: HashAlgorithmName) -> Array_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, hashAlgorithm: HashAlgorithmName) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> Array_1[int]:...

    # Skipped VerifyData due to it being static, abstract and generic.

    VerifyData : VerifyData_MethodGroup
    class VerifyData_MethodGroup:
        @typing.overload
        def __call__(self, rgbData: Array_1[int], rgbSignature: Array_1[int]) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], signature: Array_1[int], hashAlgorithm: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], hashAlgorithm: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, data: Stream, signature: Array_1[int], hashAlgorithm: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], signature: Array_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> bool:...
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> bool:...
        @typing.overload
        def __call__(self, data: Stream, signature: Array_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, signature: Array_1[int], hashAlgorithm: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, signature: Array_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> bool:...

    # Skipped VerifySignature due to it being static, abstract and generic.

    VerifySignature : VerifySignature_MethodGroup
    class VerifySignature_MethodGroup:
        @typing.overload
        def __call__(self, rgbHash: Array_1[int], rgbSignature: Array_1[int]) -> bool:...
        @typing.overload
        def __call__(self, hash: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int]) -> bool:...
        @typing.overload
        def __call__(self, rgbHash: Array_1[int], rgbSignature: Array_1[int], signatureFormat: DSASignatureFormat) -> bool:...
        @typing.overload
        def __call__(self, hash: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], signatureFormat: DSASignatureFormat) -> bool:...



class DSAParameters:
    Counter : int
    G : Array_1[int]
    J : Array_1[int]
    P : Array_1[int]
    Q : Array_1[int]
    Seed : Array_1[int]
    X : Array_1[int]
    Y : Array_1[int]


class DSASignatureDeformatter(AsymmetricSignatureDeformatter):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: AsymmetricAlgorithm) -> None: ...
    def SetHashAlgorithm(self, strName: str) -> None: ...
    def SetKey(self, key: AsymmetricAlgorithm) -> None: ...
    # Skipped VerifySignature due to it being static, abstract and generic.

    VerifySignature : VerifySignature_MethodGroup
    class VerifySignature_MethodGroup:
        @typing.overload
        def __call__(self, rgbHash: Array_1[int], rgbSignature: Array_1[int]) -> bool:...
        @typing.overload
        def __call__(self, hash: HashAlgorithm, rgbSignature: Array_1[int]) -> bool:...



class DSASignatureFormat(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    IeeeP1363FixedFieldConcatenation : DSASignatureFormat # 0
    Rfc3279DerSequence : DSASignatureFormat # 1


class DSASignatureFormatter(AsymmetricSignatureFormatter):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: AsymmetricAlgorithm) -> None: ...
    def SetHashAlgorithm(self, strName: str) -> None: ...
    def SetKey(self, key: AsymmetricAlgorithm) -> None: ...
    # Skipped CreateSignature due to it being static, abstract and generic.

    CreateSignature : CreateSignature_MethodGroup
    class CreateSignature_MethodGroup:
        @typing.overload
        def __call__(self, rgbHash: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, hash: HashAlgorithm) -> Array_1[int]:...



class ECCurve:
    A : Array_1[int]
    B : Array_1[int]
    Cofactor : Array_1[int]
    CurveType : ECCurve.ECCurveType
    G : ECPoint
    Hash : typing.Optional[HashAlgorithmName]
    Order : Array_1[int]
    Polynomial : Array_1[int]
    Prime : Array_1[int]
    Seed : Array_1[int]
    @property
    def IsCharacteristic2(self) -> bool: ...
    @property
    def IsExplicit(self) -> bool: ...
    @property
    def IsNamed(self) -> bool: ...
    @property
    def IsPrime(self) -> bool: ...
    @property
    def Oid(self) -> Oid: ...
    @Oid.setter
    def Oid(self, value: Oid) -> Oid: ...
    @staticmethod
    def CreateFromFriendlyName(oidFriendlyName: str) -> ECCurve: ...
    @staticmethod
    def CreateFromOid(curveOid: Oid) -> ECCurve: ...
    @staticmethod
    def CreateFromValue(oidValue: str) -> ECCurve: ...
    def Validate(self) -> None: ...

    class ECCurveType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Implicit : ECCurve.ECCurveType # 0
        PrimeShortWeierstrass : ECCurve.ECCurveType # 1
        PrimeTwistedEdwards : ECCurve.ECCurveType # 2
        PrimeMontgomery : ECCurve.ECCurveType # 3
        Characteristic2 : ECCurve.ECCurveType # 4
        Named : ECCurve.ECCurveType # 5


    class NamedCurves(abc.ABC):
        @classmethod
        @property
        def brainpoolP160r1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP160t1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP192r1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP192t1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP224r1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP224t1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP256r1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP256t1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP320r1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP320t1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP384r1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP384t1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP512r1(cls) -> ECCurve: ...
        @classmethod
        @property
        def brainpoolP512t1(cls) -> ECCurve: ...
        @classmethod
        @property
        def nistP256(cls) -> ECCurve: ...
        @classmethod
        @property
        def nistP384(cls) -> ECCurve: ...
        @classmethod
        @property
        def nistP521(cls) -> ECCurve: ...



class ECDiffieHellman(AsymmetricAlgorithm):
    @property
    def KeyExchangeAlgorithm(self) -> str: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def PublicKey(self) -> ECDiffieHellmanPublicKey: ...
    @property
    def SignatureAlgorithm(self) -> str: ...
    def DeriveKeyMaterial(self, otherPartyPublicKey: ECDiffieHellmanPublicKey) -> Array_1[int]: ...
    def DeriveKeyTls(self, otherPartyPublicKey: ECDiffieHellmanPublicKey, prfLabel: Array_1[int], prfSeed: Array_1[int]) -> Array_1[int]: ...
    def ExportECPrivateKey(self) -> Array_1[int]: ...
    def ExportExplicitParameters(self, includePrivateParameters: bool) -> ECParameters: ...
    def ExportParameters(self, includePrivateParameters: bool) -> ECParameters: ...
    def FromXmlString(self, xmlString: str) -> None: ...
    def GenerateKey(self, curve: ECCurve) -> None: ...
    def ImportECPrivateKey(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ImportFromPem(self, input: ReadOnlySpan_1[str]) -> None: ...
    def ImportParameters(self, parameters: ECParameters) -> None: ...
    def ImportPkcs8PrivateKey(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ImportSubjectPublicKeyInfo(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ToXmlString(self, includePrivateParameters: bool) -> str: ...
    def TryExportECPrivateKey(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryExportPkcs8PrivateKey(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryExportSubjectPublicKeyInfo(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> ECDiffieHellman:...
        @typing.overload
        def __call__(self, algorithm: str) -> ECDiffieHellman:...
        @typing.overload
        def __call__(self, curve: ECCurve) -> ECDiffieHellman:...
        @typing.overload
        def __call__(self, parameters: ECParameters) -> ECDiffieHellman:...

    # Skipped DeriveKeyFromHash due to it being static, abstract and generic.

    DeriveKeyFromHash : DeriveKeyFromHash_MethodGroup
    class DeriveKeyFromHash_MethodGroup:
        @typing.overload
        def __call__(self, otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName) -> Array_1[int]:...
        @typing.overload
        def __call__(self, otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, secretPrepend: Array_1[int], secretAppend: Array_1[int]) -> Array_1[int]:...

    # Skipped DeriveKeyFromHmac due to it being static, abstract and generic.

    DeriveKeyFromHmac : DeriveKeyFromHmac_MethodGroup
    class DeriveKeyFromHmac_MethodGroup:
        @typing.overload
        def __call__(self, otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, otherPartyPublicKey: ECDiffieHellmanPublicKey, hashAlgorithm: HashAlgorithmName, hmacKey: Array_1[int], secretPrepend: Array_1[int], secretAppend: Array_1[int]) -> Array_1[int]:...

    # Skipped ImportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    ImportEncryptedPkcs8PrivateKey : ImportEncryptedPkcs8PrivateKey_MethodGroup
    class ImportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...

    # Skipped ImportFromEncryptedPem due to it being static, abstract and generic.

    ImportFromEncryptedPem : ImportFromEncryptedPem_MethodGroup
    class ImportFromEncryptedPem_MethodGroup:
        @typing.overload
        def __call__(self, input: ReadOnlySpan_1[str], password: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, input: ReadOnlySpan_1[str], passwordBytes: ReadOnlySpan_1[int]) -> None:...

    # Skipped TryExportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    TryExportEncryptedPkcs8PrivateKey : TryExportEncryptedPkcs8PrivateKey_MethodGroup
    class TryExportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], pbeParameters: PbeParameters, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], pbeParameters: PbeParameters, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool:...



class ECDiffieHellmanPublicKey(IDisposable, abc.ABC):
    def Dispose(self) -> None: ...
    def ExportExplicitParameters(self) -> ECParameters: ...
    def ExportParameters(self) -> ECParameters: ...
    def ExportSubjectPublicKeyInfo(self) -> Array_1[int]: ...
    def ToByteArray(self) -> Array_1[int]: ...
    def ToXmlString(self) -> str: ...
    def TryExportSubjectPublicKeyInfo(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...


class ECDsa(AsymmetricAlgorithm):
    @property
    def KeyExchangeAlgorithm(self) -> str: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def SignatureAlgorithm(self) -> str: ...
    def ExportECPrivateKey(self) -> Array_1[int]: ...
    def ExportExplicitParameters(self, includePrivateParameters: bool) -> ECParameters: ...
    def ExportParameters(self, includePrivateParameters: bool) -> ECParameters: ...
    def FromXmlString(self, xmlString: str) -> None: ...
    def GenerateKey(self, curve: ECCurve) -> None: ...
    def GetMaxSignatureSize(self, signatureFormat: DSASignatureFormat) -> int: ...
    def ImportECPrivateKey(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ImportFromPem(self, input: ReadOnlySpan_1[str]) -> None: ...
    def ImportParameters(self, parameters: ECParameters) -> None: ...
    def ImportPkcs8PrivateKey(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ImportSubjectPublicKeyInfo(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ToXmlString(self, includePrivateParameters: bool) -> str: ...
    def TryExportECPrivateKey(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryExportPkcs8PrivateKey(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryExportSubjectPublicKeyInfo(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> ECDsa:...
        @typing.overload
        def __call__(self, algorithm: str) -> ECDsa:...
        @typing.overload
        def __call__(self, curve: ECCurve) -> ECDsa:...
        @typing.overload
        def __call__(self, parameters: ECParameters) -> ECDsa:...

    # Skipped ImportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    ImportEncryptedPkcs8PrivateKey : ImportEncryptedPkcs8PrivateKey_MethodGroup
    class ImportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...

    # Skipped ImportFromEncryptedPem due to it being static, abstract and generic.

    ImportFromEncryptedPem : ImportFromEncryptedPem_MethodGroup
    class ImportFromEncryptedPem_MethodGroup:
        @typing.overload
        def __call__(self, input: ReadOnlySpan_1[str], password: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, input: ReadOnlySpan_1[str], passwordBytes: ReadOnlySpan_1[int]) -> None:...

    # Skipped SignData due to it being static, abstract and generic.

    SignData : SignData_MethodGroup
    class SignData_MethodGroup:
        @typing.overload
        def __call__(self, data: Array_1[int], hashAlgorithm: HashAlgorithmName) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Stream, hashAlgorithm: HashAlgorithmName) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Stream, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, hashAlgorithm: HashAlgorithmName) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> Array_1[int]:...

    # Skipped SignHash due to it being static, abstract and generic.

    SignHash : SignHash_MethodGroup
    class SignHash_MethodGroup:
        @typing.overload
        def __call__(self, hash: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, hash: Array_1[int], signatureFormat: DSASignatureFormat) -> Array_1[int]:...

    # Skipped TryExportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    TryExportEncryptedPkcs8PrivateKey : TryExportEncryptedPkcs8PrivateKey_MethodGroup
    class TryExportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], pbeParameters: PbeParameters, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], pbeParameters: PbeParameters, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool:...

    # Skipped TrySignData due to it being static, abstract and generic.

    TrySignData : TrySignData_MethodGroup
    class TrySignData_MethodGroup:
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int], destination: Span_1[int], hashAlgorithm: HashAlgorithmName, bytesWritten: clr.Reference[int]) -> bool:...
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int], destination: Span_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat, bytesWritten: clr.Reference[int]) -> bool:...

    # Skipped TrySignHash due to it being static, abstract and generic.

    TrySignHash : TrySignHash_MethodGroup
    class TrySignHash_MethodGroup:
        @typing.overload
        def __call__(self, hash: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool:...
        @typing.overload
        def __call__(self, hash: ReadOnlySpan_1[int], destination: Span_1[int], signatureFormat: DSASignatureFormat, bytesWritten: clr.Reference[int]) -> bool:...

    # Skipped VerifyData due to it being static, abstract and generic.

    VerifyData : VerifyData_MethodGroup
    class VerifyData_MethodGroup:
        @typing.overload
        def __call__(self, data: Array_1[int], signature: Array_1[int], hashAlgorithm: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], hashAlgorithm: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, data: Stream, signature: Array_1[int], hashAlgorithm: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], signature: Array_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> bool:...
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> bool:...
        @typing.overload
        def __call__(self, data: Stream, signature: Array_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, signature: Array_1[int], hashAlgorithm: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, signature: Array_1[int], hashAlgorithm: HashAlgorithmName, signatureFormat: DSASignatureFormat) -> bool:...

    # Skipped VerifyHash due to it being static, abstract and generic.

    VerifyHash : VerifyHash_MethodGroup
    class VerifyHash_MethodGroup:
        @typing.overload
        def __call__(self, hash: Array_1[int], signature: Array_1[int]) -> bool:...
        @typing.overload
        def __call__(self, hash: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int]) -> bool:...
        @typing.overload
        def __call__(self, hash: Array_1[int], signature: Array_1[int], signatureFormat: DSASignatureFormat) -> bool:...
        @typing.overload
        def __call__(self, hash: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], signatureFormat: DSASignatureFormat) -> bool:...



class ECParameters:
    Curve : ECCurve
    D : Array_1[int]
    Q : ECPoint
    def Validate(self) -> None: ...


class ECPoint:
    X : Array_1[int]
    Y : Array_1[int]


class FromBase64Transform(ICryptoTransform):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, whitespaces: FromBase64TransformMode) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Clear(self) -> None: ...
    def Dispose(self) -> None: ...
    def TransformBlock(self, inputBuffer: Array_1[int], inputOffset: int, inputCount: int, outputBuffer: Array_1[int], outputOffset: int) -> int: ...
    def TransformFinalBlock(self, inputBuffer: Array_1[int], inputOffset: int, inputCount: int) -> Array_1[int]: ...


class FromBase64TransformMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    IgnoreWhiteSpaces : FromBase64TransformMode # 0
    DoNotIgnoreWhiteSpaces : FromBase64TransformMode # 1


class HashAlgorithm(ICryptoTransform, abc.ABC):
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Clear(self) -> None: ...
    def ComputeHashAsync(self, inputStream: Stream, cancellationToken: CancellationToken = ...) -> Task_1[Array_1[int]]: ...
    def Dispose(self) -> None: ...
    @abc.abstractmethod
    def Initialize(self) -> None: ...
    def TransformBlock(self, inputBuffer: Array_1[int], inputOffset: int, inputCount: int, outputBuffer: Array_1[int], outputOffset: int) -> int: ...
    def TransformFinalBlock(self, inputBuffer: Array_1[int], inputOffset: int, inputCount: int) -> Array_1[int]: ...
    def TryComputeHash(self, source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped ComputeHash due to it being static, abstract and generic.

    ComputeHash : ComputeHash_MethodGroup
    class ComputeHash_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, inputStream: Stream) -> Array_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> Array_1[int]:...

    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> HashAlgorithm:...
        @typing.overload
        def __call__(self, hashName: str) -> HashAlgorithm:...



class HashAlgorithmName(IEquatable_1[HashAlgorithmName]):
    def __init__(self, name: str) -> None: ...
    @classmethod
    @property
    def MD5(cls) -> HashAlgorithmName: ...
    @property
    def Name(self) -> str: ...
    @classmethod
    @property
    def SHA1(cls) -> HashAlgorithmName: ...
    @classmethod
    @property
    def SHA256(cls) -> HashAlgorithmName: ...
    @classmethod
    @property
    def SHA384(cls) -> HashAlgorithmName: ...
    @classmethod
    @property
    def SHA512(cls) -> HashAlgorithmName: ...
    @staticmethod
    def FromOid(oidValue: str) -> HashAlgorithmName: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: HashAlgorithmName, right: HashAlgorithmName) -> bool: ...
    def __ne__(self, left: HashAlgorithmName, right: HashAlgorithmName) -> bool: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryFromOid(oidValue: str, value: clr.Reference[HashAlgorithmName]) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: HashAlgorithmName) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class HKDF(abc.ABC):
    # Skipped DeriveKey due to it being static, abstract and generic.

    DeriveKey : DeriveKey_MethodGroup
    class DeriveKey_MethodGroup:
        @typing.overload
        def __call__(self, hashAlgorithmName: HashAlgorithmName, ikm: Array_1[int], outputLength: int, salt: Array_1[int] = ..., info: Array_1[int] = ...) -> Array_1[int]:...
        @typing.overload
        def __call__(self, hashAlgorithmName: HashAlgorithmName, ikm: ReadOnlySpan_1[int], output: Span_1[int], salt: ReadOnlySpan_1[int], info: ReadOnlySpan_1[int]) -> None:...

    # Skipped Expand due to it being static, abstract and generic.

    Expand : Expand_MethodGroup
    class Expand_MethodGroup:
        @typing.overload
        def __call__(self, hashAlgorithmName: HashAlgorithmName, prk: Array_1[int], outputLength: int, info: Array_1[int] = ...) -> Array_1[int]:...
        @typing.overload
        def __call__(self, hashAlgorithmName: HashAlgorithmName, prk: ReadOnlySpan_1[int], output: Span_1[int], info: ReadOnlySpan_1[int]) -> None:...

    # Skipped Extract due to it being static, abstract and generic.

    Extract : Extract_MethodGroup
    class Extract_MethodGroup:
        @typing.overload
        def __call__(self, hashAlgorithmName: HashAlgorithmName, ikm: Array_1[int], salt: Array_1[int] = ...) -> Array_1[int]:...
        @typing.overload
        def __call__(self, hashAlgorithmName: HashAlgorithmName, ikm: ReadOnlySpan_1[int], salt: ReadOnlySpan_1[int], prk: Span_1[int]) -> int:...



class HMAC(KeyedHashAlgorithm):
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashName(self) -> str: ...
    @HashName.setter
    def HashName(self, value: str) -> str: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> HMAC:...
        @typing.overload
        def __call__(self, algorithmName: str) -> HMAC:...



class HMACMD5(HMAC):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: Array_1[int]) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashName(self) -> str: ...
    @HashName.setter
    def HashName(self, value: str) -> str: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...
    @staticmethod
    def TryHashData(key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped HashData due to it being static, abstract and generic.

    HashData : HashData_MethodGroup
    class HashData_MethodGroup:
        @typing.overload
        def __call__(self, key: Array_1[int], source: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], destination: Span_1[int]) -> int:...



class HMACSHA1(HMAC):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: Array_1[int]) -> None: ...
    @typing.overload
    def __init__(self, key: Array_1[int], useManagedSha1: bool) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashName(self) -> str: ...
    @HashName.setter
    def HashName(self, value: str) -> str: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...
    @staticmethod
    def TryHashData(key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped HashData due to it being static, abstract and generic.

    HashData : HashData_MethodGroup
    class HashData_MethodGroup:
        @typing.overload
        def __call__(self, key: Array_1[int], source: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], destination: Span_1[int]) -> int:...



class HMACSHA256(HMAC):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: Array_1[int]) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashName(self) -> str: ...
    @HashName.setter
    def HashName(self, value: str) -> str: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...
    @staticmethod
    def TryHashData(key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped HashData due to it being static, abstract and generic.

    HashData : HashData_MethodGroup
    class HashData_MethodGroup:
        @typing.overload
        def __call__(self, key: Array_1[int], source: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], destination: Span_1[int]) -> int:...



class HMACSHA384(HMAC):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: Array_1[int]) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashName(self) -> str: ...
    @HashName.setter
    def HashName(self, value: str) -> str: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def OutputBlockSize(self) -> int: ...
    @property
    def ProduceLegacyHmacValues(self) -> bool: ...
    @ProduceLegacyHmacValues.setter
    def ProduceLegacyHmacValues(self, value: bool) -> bool: ...
    def Initialize(self) -> None: ...
    @staticmethod
    def TryHashData(key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped HashData due to it being static, abstract and generic.

    HashData : HashData_MethodGroup
    class HashData_MethodGroup:
        @typing.overload
        def __call__(self, key: Array_1[int], source: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], destination: Span_1[int]) -> int:...



class HMACSHA512(HMAC):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: Array_1[int]) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashName(self) -> str: ...
    @HashName.setter
    def HashName(self, value: str) -> str: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def OutputBlockSize(self) -> int: ...
    @property
    def ProduceLegacyHmacValues(self) -> bool: ...
    @ProduceLegacyHmacValues.setter
    def ProduceLegacyHmacValues(self, value: bool) -> bool: ...
    def Initialize(self) -> None: ...
    @staticmethod
    def TryHashData(key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped HashData due to it being static, abstract and generic.

    HashData : HashData_MethodGroup
    class HashData_MethodGroup:
        @typing.overload
        def __call__(self, key: Array_1[int], source: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, key: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], destination: Span_1[int]) -> int:...



class ICryptoTransform(IDisposable, typing.Protocol):
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    @abc.abstractmethod
    def TransformBlock(self, inputBuffer: Array_1[int], inputOffset: int, inputCount: int, outputBuffer: Array_1[int], outputOffset: int) -> int: ...
    @abc.abstractmethod
    def TransformFinalBlock(self, inputBuffer: Array_1[int], inputOffset: int, inputCount: int) -> Array_1[int]: ...


class ICspAsymmetricAlgorithm(typing.Protocol):
    @property
    def CspKeyContainerInfo(self) -> CspKeyContainerInfo: ...
    @abc.abstractmethod
    def ExportCspBlob(self, includePrivateParameters: bool) -> Array_1[int]: ...
    @abc.abstractmethod
    def ImportCspBlob(self, rawData: Array_1[int]) -> None: ...


class IncrementalHash(IDisposable):
    @property
    def AlgorithmName(self) -> HashAlgorithmName: ...
    @property
    def HashLengthInBytes(self) -> int: ...
    @staticmethod
    def CreateHash(hashAlgorithm: HashAlgorithmName) -> IncrementalHash: ...
    def Dispose(self) -> None: ...
    def TryGetCurrentHash(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryGetHashAndReset(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped AppendData due to it being static, abstract and generic.

    AppendData : AppendData_MethodGroup
    class AppendData_MethodGroup:
        @typing.overload
        def __call__(self, data: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int) -> None:...

    # Skipped CreateHMAC due to it being static, abstract and generic.

    CreateHMAC : CreateHMAC_MethodGroup
    class CreateHMAC_MethodGroup:
        @typing.overload
        def __call__(self, hashAlgorithm: HashAlgorithmName, key: Array_1[int]) -> IncrementalHash:...
        @typing.overload
        def __call__(self, hashAlgorithm: HashAlgorithmName, key: ReadOnlySpan_1[int]) -> IncrementalHash:...

    # Skipped GetCurrentHash due to it being static, abstract and generic.

    GetCurrentHash : GetCurrentHash_MethodGroup
    class GetCurrentHash_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[int]:...
        @typing.overload
        def __call__(self, destination: Span_1[int]) -> int:...

    # Skipped GetHashAndReset due to it being static, abstract and generic.

    GetHashAndReset : GetHashAndReset_MethodGroup
    class GetHashAndReset_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[int]:...
        @typing.overload
        def __call__(self, destination: Span_1[int]) -> int:...



class KeyedHashAlgorithm(HashAlgorithm):
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def OutputBlockSize(self) -> int: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> KeyedHashAlgorithm:...
        @typing.overload
        def __call__(self, algName: str) -> KeyedHashAlgorithm:...



class KeyNumber(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Exchange : KeyNumber # 1
    Signature : KeyNumber # 2


class KeySizes:
    def __init__(self, minSize: int, maxSize: int, skipSize: int) -> None: ...
    @property
    def MaxSize(self) -> int: ...
    @MaxSize.setter
    def MaxSize(self, value: int) -> int: ...
    @property
    def MinSize(self) -> int: ...
    @MinSize.setter
    def MinSize(self, value: int) -> int: ...
    @property
    def SkipSize(self) -> int: ...
    @SkipSize.setter
    def SkipSize(self, value: int) -> int: ...


class MaskGenerationMethod(abc.ABC):
    @abc.abstractmethod
    def GenerateMask(self, rgbSeed: Array_1[int], cbReturn: int) -> Array_1[int]: ...


class MD5(HashAlgorithm):
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    @staticmethod
    def TryHashData(source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> MD5:...
        @typing.overload
        def __call__(self, algName: str) -> MD5:...

    # Skipped HashData due to it being static, abstract and generic.

    HashData : HashData_MethodGroup
    class HashData_MethodGroup:
        @typing.overload
        def __call__(self, source: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, source: ReadOnlySpan_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, source: ReadOnlySpan_1[int], destination: Span_1[int]) -> int:...



class MD5CryptoServiceProvider(MD5):
    def __init__(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...


class Oid:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, oid: str) -> None: ...
    @typing.overload
    def __init__(self, oid: Oid) -> None: ...
    @typing.overload
    def __init__(self, value: str, friendlyName: str) -> None: ...
    @property
    def FriendlyName(self) -> str: ...
    @FriendlyName.setter
    def FriendlyName(self, value: str) -> str: ...
    @property
    def Value(self) -> str: ...
    @Value.setter
    def Value(self, value: str) -> str: ...
    @staticmethod
    def FromFriendlyName(friendlyName: str, group: OidGroup) -> Oid: ...
    @staticmethod
    def FromOidValue(oidValue: str, group: OidGroup) -> Oid: ...


class OidCollection(ICollection):
    def __init__(self) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> Oid: ...
    @property
    def Item(self) -> Oid: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def Add(self, oid: Oid) -> int: ...
    def CopyTo(self, array: Array_1[Oid], index: int) -> None: ...
    def GetEnumerator(self) -> OidEnumerator: ...


class OidEnumerator(IEnumerator):
    @property
    def Current(self) -> Oid: ...
    def MoveNext(self) -> bool: ...
    def Reset(self) -> None: ...


class OidGroup(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    All : OidGroup # 0
    HashAlgorithm : OidGroup # 1
    EncryptionAlgorithm : OidGroup # 2
    PublicKeyAlgorithm : OidGroup # 3
    SignatureAlgorithm : OidGroup # 4
    Attribute : OidGroup # 5
    ExtensionOrAttribute : OidGroup # 6
    EnhancedKeyUsage : OidGroup # 7
    Policy : OidGroup # 8
    Template : OidGroup # 9
    KeyDerivationFunction : OidGroup # 10


class PaddingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : PaddingMode # 1
    PKCS7 : PaddingMode # 2
    Zeros : PaddingMode # 3
    ANSIX923 : PaddingMode # 4
    ISO10126 : PaddingMode # 5


class PasswordDeriveBytes(DeriveBytes):
    @typing.overload
    def __init__(self, password: Array_1[int], salt: Array_1[int]) -> None: ...
    @typing.overload
    def __init__(self, password: Array_1[int], salt: Array_1[int], cspParams: CspParameters) -> None: ...
    @typing.overload
    def __init__(self, password: Array_1[int], salt: Array_1[int], hashName: str, iterations: int) -> None: ...
    @typing.overload
    def __init__(self, password: Array_1[int], salt: Array_1[int], hashName: str, iterations: int, cspParams: CspParameters) -> None: ...
    @typing.overload
    def __init__(self, strPassword: str, rgbSalt: Array_1[int]) -> None: ...
    @typing.overload
    def __init__(self, strPassword: str, rgbSalt: Array_1[int], cspParams: CspParameters) -> None: ...
    @typing.overload
    def __init__(self, strPassword: str, rgbSalt: Array_1[int], strHashName: str, iterations: int) -> None: ...
    @typing.overload
    def __init__(self, strPassword: str, rgbSalt: Array_1[int], strHashName: str, iterations: int, cspParams: CspParameters) -> None: ...
    @property
    def HashName(self) -> str: ...
    @HashName.setter
    def HashName(self, value: str) -> str: ...
    @property
    def IterationCount(self) -> int: ...
    @IterationCount.setter
    def IterationCount(self, value: int) -> int: ...
    @property
    def Salt(self) -> Array_1[int]: ...
    @Salt.setter
    def Salt(self, value: Array_1[int]) -> Array_1[int]: ...
    def CryptDeriveKey(self, algname: str, alghashname: str, keySize: int, rgbIV: Array_1[int]) -> Array_1[int]: ...
    def GetBytes(self, cb: int) -> Array_1[int]: ...
    def Reset(self) -> None: ...


class PbeEncryptionAlgorithm(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : PbeEncryptionAlgorithm # 0
    Aes128Cbc : PbeEncryptionAlgorithm # 1
    Aes192Cbc : PbeEncryptionAlgorithm # 2
    Aes256Cbc : PbeEncryptionAlgorithm # 3
    TripleDes3KeyPkcs12 : PbeEncryptionAlgorithm # 4


class PbeParameters:
    def __init__(self, encryptionAlgorithm: PbeEncryptionAlgorithm, hashAlgorithm: HashAlgorithmName, iterationCount: int) -> None: ...
    @property
    def EncryptionAlgorithm(self) -> PbeEncryptionAlgorithm: ...
    @property
    def HashAlgorithm(self) -> HashAlgorithmName: ...
    @property
    def IterationCount(self) -> int: ...


class PemEncoding(abc.ABC):
    @staticmethod
    def Find(pemData: ReadOnlySpan_1[str]) -> PemFields: ...
    @staticmethod
    def GetEncodedSize(labelLength: int, dataLength: int) -> int: ...
    @staticmethod
    def TryFind(pemData: ReadOnlySpan_1[str], fields: clr.Reference[PemFields]) -> bool: ...
    @staticmethod
    def TryWrite(label: ReadOnlySpan_1[str], data: ReadOnlySpan_1[int], destination: Span_1[str], charsWritten: clr.Reference[int]) -> bool: ...
    @staticmethod
    def Write(label: ReadOnlySpan_1[str], data: ReadOnlySpan_1[int]) -> Array_1[str]: ...


class PemFields:
    @property
    def Base64Data(self) -> Range: ...
    @property
    def DecodedDataLength(self) -> int: ...
    @property
    def Label(self) -> Range: ...
    @property
    def Location(self) -> Range: ...


class PKCS1MaskGenerationMethod(MaskGenerationMethod):
    def __init__(self) -> None: ...
    @property
    def HashName(self) -> str: ...
    @HashName.setter
    def HashName(self, value: str) -> str: ...
    def GenerateMask(self, rgbSeed: Array_1[int], cbReturn: int) -> Array_1[int]: ...


class RandomNumberGenerator(IDisposable, abc.ABC):
    def Dispose(self) -> None: ...
    @staticmethod
    def Fill(data: Span_1[int]) -> None: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> RandomNumberGenerator:...
        @typing.overload
        def __call__(self, rngName: str) -> RandomNumberGenerator:...

    # Skipped GetBytes due to it being static, abstract and generic.

    GetBytes : GetBytes_MethodGroup
    class GetBytes_MethodGroup:
        @typing.overload
        def __call__(self, count: int) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, data: Span_1[int]) -> None:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int) -> None:...

    # Skipped GetInt32 due to it being static, abstract and generic.

    GetInt32 : GetInt32_MethodGroup
    class GetInt32_MethodGroup:
        @typing.overload
        def __call__(self, toExclusive: int) -> int:...
        @typing.overload
        def __call__(self, fromInclusive: int, toExclusive: int) -> int:...

    # Skipped GetNonZeroBytes due to it being static, abstract and generic.

    GetNonZeroBytes : GetNonZeroBytes_MethodGroup
    class GetNonZeroBytes_MethodGroup:
        @typing.overload
        def __call__(self, data: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, data: Span_1[int]) -> None:...



class RC2(SymmetricAlgorithm):
    @property
    def BlockSize(self) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> int: ...
    @property
    def EffectiveKeySize(self) -> int: ...
    @EffectiveKeySize.setter
    def EffectiveKeySize(self, value: int) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> int: ...
    @property
    def IV(self) -> Array_1[int]: ...
    @IV.setter
    def IV(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalBlockSizes(self) -> Array_1[KeySizes]: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def Mode(self) -> CipherMode: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> PaddingMode: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> RC2:...
        @typing.overload
        def __call__(self, AlgName: str) -> RC2:...



class RC2CryptoServiceProvider(RC2):
    def __init__(self) -> None: ...
    @property
    def BlockSize(self) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> int: ...
    @property
    def EffectiveKeySize(self) -> int: ...
    @EffectiveKeySize.setter
    def EffectiveKeySize(self, value: int) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> int: ...
    @property
    def IV(self) -> Array_1[int]: ...
    @IV.setter
    def IV(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalBlockSizes(self) -> Array_1[KeySizes]: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def Mode(self) -> CipherMode: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> PaddingMode: ...
    @property
    def UseSalt(self) -> bool: ...
    @UseSalt.setter
    def UseSalt(self, value: bool) -> bool: ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...
    # Skipped CreateDecryptor due to it being static, abstract and generic.

    CreateDecryptor : CreateDecryptor_MethodGroup
    class CreateDecryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...

    # Skipped CreateEncryptor due to it being static, abstract and generic.

    CreateEncryptor : CreateEncryptor_MethodGroup
    class CreateEncryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...



class Rfc2898DeriveBytes(DeriveBytes):
    @typing.overload
    def __init__(self, password: str, salt: Array_1[int]) -> None: ...
    @typing.overload
    def __init__(self, password: Array_1[int], salt: Array_1[int], iterations: int) -> None: ...
    @typing.overload
    def __init__(self, password: str, salt: Array_1[int], iterations: int) -> None: ...
    @typing.overload
    def __init__(self, password: Array_1[int], salt: Array_1[int], iterations: int, hashAlgorithm: HashAlgorithmName) -> None: ...
    @typing.overload
    def __init__(self, password: str, salt: Array_1[int], iterations: int, hashAlgorithm: HashAlgorithmName) -> None: ...
    @typing.overload
    def __init__(self, password: str, saltSize: int) -> None: ...
    @typing.overload
    def __init__(self, password: str, saltSize: int, iterations: int) -> None: ...
    @typing.overload
    def __init__(self, password: str, saltSize: int, iterations: int, hashAlgorithm: HashAlgorithmName) -> None: ...
    @property
    def HashAlgorithm(self) -> HashAlgorithmName: ...
    @property
    def IterationCount(self) -> int: ...
    @IterationCount.setter
    def IterationCount(self, value: int) -> int: ...
    @property
    def Salt(self) -> Array_1[int]: ...
    @Salt.setter
    def Salt(self, value: Array_1[int]) -> Array_1[int]: ...
    def CryptDeriveKey(self, algname: str, alghashname: str, keySize: int, rgbIV: Array_1[int]) -> Array_1[int]: ...
    def GetBytes(self, cb: int) -> Array_1[int]: ...
    def Reset(self) -> None: ...
    # Skipped Pbkdf2 due to it being static, abstract and generic.

    Pbkdf2 : Pbkdf2_MethodGroup
    class Pbkdf2_MethodGroup:
        @typing.overload
        def __call__(self, password: Array_1[int], salt: Array_1[int], iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int) -> Array_1[int]:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[int], salt: ReadOnlySpan_1[int], iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int) -> Array_1[int]:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], salt: ReadOnlySpan_1[int], iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int) -> Array_1[int]:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[int], salt: ReadOnlySpan_1[int], destination: Span_1[int], iterations: int, hashAlgorithm: HashAlgorithmName) -> None:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], salt: ReadOnlySpan_1[int], destination: Span_1[int], iterations: int, hashAlgorithm: HashAlgorithmName) -> None:...
        @typing.overload
        def __call__(self, password: str, salt: Array_1[int], iterations: int, hashAlgorithm: HashAlgorithmName, outputLength: int) -> Array_1[int]:...



class Rijndael(SymmetricAlgorithm):
    @property
    def BlockSize(self) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> int: ...
    @property
    def IV(self) -> Array_1[int]: ...
    @IV.setter
    def IV(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalBlockSizes(self) -> Array_1[KeySizes]: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def Mode(self) -> CipherMode: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> PaddingMode: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> Rijndael:...
        @typing.overload
        def __call__(self, algName: str) -> Rijndael:...



class RijndaelManaged(Rijndael):
    def __init__(self) -> None: ...
    @property
    def BlockSize(self) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> int: ...
    @property
    def IV(self) -> Array_1[int]: ...
    @IV.setter
    def IV(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalBlockSizes(self) -> Array_1[KeySizes]: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def Mode(self) -> CipherMode: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> PaddingMode: ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...
    # Skipped CreateDecryptor due to it being static, abstract and generic.

    CreateDecryptor : CreateDecryptor_MethodGroup
    class CreateDecryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...

    # Skipped CreateEncryptor due to it being static, abstract and generic.

    CreateEncryptor : CreateEncryptor_MethodGroup
    class CreateEncryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...



class RNGCryptoServiceProvider(RandomNumberGenerator):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, cspParams: CspParameters) -> None: ...
    @typing.overload
    def __init__(self, rgb: Array_1[int]) -> None: ...
    @typing.overload
    def __init__(self, str: str) -> None: ...
    # Skipped GetBytes due to it being static, abstract and generic.

    GetBytes : GetBytes_MethodGroup
    class GetBytes_MethodGroup:
        @typing.overload
        def __call__(self, data: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, data: Span_1[int]) -> None:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int) -> None:...

    # Skipped GetNonZeroBytes due to it being static, abstract and generic.

    GetNonZeroBytes : GetNonZeroBytes_MethodGroup
    class GetNonZeroBytes_MethodGroup:
        @typing.overload
        def __call__(self, data: Array_1[int]) -> None:...
        @typing.overload
        def __call__(self, data: Span_1[int]) -> None:...



class RSA(AsymmetricAlgorithm):
    @property
    def KeyExchangeAlgorithm(self) -> str: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def SignatureAlgorithm(self) -> str: ...
    def Decrypt(self, data: Array_1[int], padding: RSAEncryptionPadding) -> Array_1[int]: ...
    def DecryptValue(self, rgb: Array_1[int]) -> Array_1[int]: ...
    def Encrypt(self, data: Array_1[int], padding: RSAEncryptionPadding) -> Array_1[int]: ...
    def EncryptValue(self, rgb: Array_1[int]) -> Array_1[int]: ...
    @abc.abstractmethod
    def ExportParameters(self, includePrivateParameters: bool) -> RSAParameters: ...
    def ExportRSAPrivateKey(self) -> Array_1[int]: ...
    def ExportRSAPublicKey(self) -> Array_1[int]: ...
    def FromXmlString(self, xmlString: str) -> None: ...
    def ImportFromPem(self, input: ReadOnlySpan_1[str]) -> None: ...
    @abc.abstractmethod
    def ImportParameters(self, parameters: RSAParameters) -> None: ...
    def ImportPkcs8PrivateKey(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ImportRSAPrivateKey(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ImportRSAPublicKey(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def ImportSubjectPublicKeyInfo(self, source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None: ...
    def SignHash(self, hash: Array_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> Array_1[int]: ...
    def ToXmlString(self, includePrivateParameters: bool) -> str: ...
    def TryDecrypt(self, data: ReadOnlySpan_1[int], destination: Span_1[int], padding: RSAEncryptionPadding, bytesWritten: clr.Reference[int]) -> bool: ...
    def TryEncrypt(self, data: ReadOnlySpan_1[int], destination: Span_1[int], padding: RSAEncryptionPadding, bytesWritten: clr.Reference[int]) -> bool: ...
    def TryExportPkcs8PrivateKey(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryExportRSAPrivateKey(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryExportRSAPublicKey(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TryExportSubjectPublicKeyInfo(self, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    def TrySignData(self, data: ReadOnlySpan_1[int], destination: Span_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: clr.Reference[int]) -> bool: ...
    def TrySignHash(self, hash: ReadOnlySpan_1[int], destination: Span_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding, bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> RSA:...
        @typing.overload
        def __call__(self, keySizeInBits: int) -> RSA:...
        @typing.overload
        def __call__(self, algName: str) -> RSA:...
        @typing.overload
        def __call__(self, parameters: RSAParameters) -> RSA:...

    # Skipped ImportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    ImportEncryptedPkcs8PrivateKey : ImportEncryptedPkcs8PrivateKey_MethodGroup
    class ImportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...

    # Skipped ImportFromEncryptedPem due to it being static, abstract and generic.

    ImportFromEncryptedPem : ImportFromEncryptedPem_MethodGroup
    class ImportFromEncryptedPem_MethodGroup:
        @typing.overload
        def __call__(self, input: ReadOnlySpan_1[str], password: ReadOnlySpan_1[str]) -> None:...
        @typing.overload
        def __call__(self, input: ReadOnlySpan_1[str], passwordBytes: ReadOnlySpan_1[int]) -> None:...

    # Skipped SignData due to it being static, abstract and generic.

    SignData : SignData_MethodGroup
    class SignData_MethodGroup:
        @typing.overload
        def __call__(self, data: Array_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Stream, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> Array_1[int]:...

    # Skipped TryExportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    TryExportEncryptedPkcs8PrivateKey : TryExportEncryptedPkcs8PrivateKey_MethodGroup
    class TryExportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], pbeParameters: PbeParameters, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], pbeParameters: PbeParameters, destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool:...

    # Skipped VerifyData due to it being static, abstract and generic.

    VerifyData : VerifyData_MethodGroup
    class VerifyData_MethodGroup:
        @typing.overload
        def __call__(self, data: Array_1[int], signature: Array_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> bool:...
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> bool:...
        @typing.overload
        def __call__(self, data: Stream, signature: Array_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, signature: Array_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> bool:...

    # Skipped VerifyHash due to it being static, abstract and generic.

    VerifyHash : VerifyHash_MethodGroup
    class VerifyHash_MethodGroup:
        @typing.overload
        def __call__(self, hash: Array_1[int], signature: Array_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> bool:...
        @typing.overload
        def __call__(self, hash: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> bool:...



class RSACryptoServiceProvider(RSA, ICspAsymmetricAlgorithm):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, dwKeySize: int) -> None: ...
    @typing.overload
    def __init__(self, dwKeySize: int, parameters: CspParameters) -> None: ...
    @typing.overload
    def __init__(self, parameters: CspParameters) -> None: ...
    @property
    def CspKeyContainerInfo(self) -> CspKeyContainerInfo: ...
    @property
    def KeyExchangeAlgorithm(self) -> str: ...
    @property
    def KeySize(self) -> int: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def PersistKeyInCsp(self) -> bool: ...
    @PersistKeyInCsp.setter
    def PersistKeyInCsp(self, value: bool) -> bool: ...
    @property
    def PublicOnly(self) -> bool: ...
    @property
    def SignatureAlgorithm(self) -> str: ...
    @classmethod
    @property
    def UseMachineKeyStore(cls) -> bool: ...
    @classmethod
    @UseMachineKeyStore.setter
    def UseMachineKeyStore(cls, value: bool) -> bool: ...
    def DecryptValue(self, rgb: Array_1[int]) -> Array_1[int]: ...
    def EncryptValue(self, rgb: Array_1[int]) -> Array_1[int]: ...
    def ExportCspBlob(self, includePrivateParameters: bool) -> Array_1[int]: ...
    def ExportParameters(self, includePrivateParameters: bool) -> RSAParameters: ...
    def ImportCspBlob(self, keyBlob: Array_1[int]) -> None: ...
    def ImportParameters(self, parameters: RSAParameters) -> None: ...
    # Skipped Decrypt due to it being static, abstract and generic.

    Decrypt : Decrypt_MethodGroup
    class Decrypt_MethodGroup:
        @typing.overload
        def __call__(self, rgb: Array_1[int], fOAEP: bool) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], padding: RSAEncryptionPadding) -> Array_1[int]:...

    # Skipped Encrypt due to it being static, abstract and generic.

    Encrypt : Encrypt_MethodGroup
    class Encrypt_MethodGroup:
        @typing.overload
        def __call__(self, rgb: Array_1[int], fOAEP: bool) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], padding: RSAEncryptionPadding) -> Array_1[int]:...

    # Skipped ImportEncryptedPkcs8PrivateKey due to it being static, abstract and generic.

    ImportEncryptedPkcs8PrivateKey : ImportEncryptedPkcs8PrivateKey_MethodGroup
    class ImportEncryptedPkcs8PrivateKey_MethodGroup:
        @typing.overload
        def __call__(self, passwordBytes: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...
        @typing.overload
        def __call__(self, password: ReadOnlySpan_1[str], source: ReadOnlySpan_1[int], bytesRead: clr.Reference[int]) -> None:...

    # Skipped SignData due to it being static, abstract and generic.

    SignData : SignData_MethodGroup
    class SignData_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Array_1[int], halg: typing.Any) -> Array_1[int]:...
        @typing.overload
        def __call__(self, inputStream: Stream, halg: typing.Any) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Stream, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> Array_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, halg: typing.Any) -> Array_1[int]:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> Array_1[int]:...

    # Skipped SignHash due to it being static, abstract and generic.

    SignHash : SignHash_MethodGroup
    class SignHash_MethodGroup:
        @typing.overload
        def __call__(self, rgbHash: Array_1[int], str: str) -> Array_1[int]:...
        @typing.overload
        def __call__(self, hash: Array_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> Array_1[int]:...

    # Skipped VerifyData due to it being static, abstract and generic.

    VerifyData : VerifyData_MethodGroup
    class VerifyData_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Array_1[int], halg: typing.Any, signature: Array_1[int]) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], signature: Array_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> bool:...
        @typing.overload
        def __call__(self, data: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> bool:...
        @typing.overload
        def __call__(self, data: Stream, signature: Array_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> bool:...
        @typing.overload
        def __call__(self, data: Array_1[int], offset: int, count: int, signature: Array_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> bool:...

    # Skipped VerifyHash due to it being static, abstract and generic.

    VerifyHash : VerifyHash_MethodGroup
    class VerifyHash_MethodGroup:
        @typing.overload
        def __call__(self, rgbHash: Array_1[int], str: str, rgbSignature: Array_1[int]) -> bool:...
        @typing.overload
        def __call__(self, hash: Array_1[int], signature: Array_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> bool:...
        @typing.overload
        def __call__(self, hash: ReadOnlySpan_1[int], signature: ReadOnlySpan_1[int], hashAlgorithm: HashAlgorithmName, padding: RSASignaturePadding) -> bool:...



class RSAEncryptionPadding(IEquatable_1[RSAEncryptionPadding]):
    @property
    def Mode(self) -> RSAEncryptionPaddingMode: ...
    @property
    def OaepHashAlgorithm(self) -> HashAlgorithmName: ...
    @classmethod
    @property
    def OaepSHA1(cls) -> RSAEncryptionPadding: ...
    @classmethod
    @property
    def OaepSHA256(cls) -> RSAEncryptionPadding: ...
    @classmethod
    @property
    def OaepSHA384(cls) -> RSAEncryptionPadding: ...
    @classmethod
    @property
    def OaepSHA512(cls) -> RSAEncryptionPadding: ...
    @classmethod
    @property
    def Pkcs1(cls) -> RSAEncryptionPadding: ...
    @staticmethod
    def CreateOaep(hashAlgorithm: HashAlgorithmName) -> RSAEncryptionPadding: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: RSAEncryptionPadding, right: RSAEncryptionPadding) -> bool: ...
    def __ne__(self, left: RSAEncryptionPadding, right: RSAEncryptionPadding) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: RSAEncryptionPadding) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class RSAEncryptionPaddingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Pkcs1 : RSAEncryptionPaddingMode # 0
    Oaep : RSAEncryptionPaddingMode # 1


class RSAOAEPKeyExchangeDeformatter(AsymmetricKeyExchangeDeformatter):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: AsymmetricAlgorithm) -> None: ...
    @property
    def Parameters(self) -> str: ...
    @Parameters.setter
    def Parameters(self, value: str) -> str: ...
    def DecryptKeyExchange(self, rgbData: Array_1[int]) -> Array_1[int]: ...
    def SetKey(self, key: AsymmetricAlgorithm) -> None: ...


class RSAOAEPKeyExchangeFormatter(AsymmetricKeyExchangeFormatter):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: AsymmetricAlgorithm) -> None: ...
    @property
    def Parameter(self) -> Array_1[int]: ...
    @Parameter.setter
    def Parameter(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Parameters(self) -> str: ...
    @property
    def Rng(self) -> RandomNumberGenerator: ...
    @Rng.setter
    def Rng(self, value: RandomNumberGenerator) -> RandomNumberGenerator: ...
    def SetKey(self, key: AsymmetricAlgorithm) -> None: ...
    # Skipped CreateKeyExchange due to it being static, abstract and generic.

    CreateKeyExchange : CreateKeyExchange_MethodGroup
    class CreateKeyExchange_MethodGroup:
        @typing.overload
        def __call__(self, rgbData: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, rgbData: Array_1[int], symAlgType: typing.Type[typing.Any]) -> Array_1[int]:...



class RSAParameters:
    D : Array_1[int]
    DP : Array_1[int]
    DQ : Array_1[int]
    Exponent : Array_1[int]
    InverseQ : Array_1[int]
    Modulus : Array_1[int]
    P : Array_1[int]
    Q : Array_1[int]


class RSAPKCS1KeyExchangeDeformatter(AsymmetricKeyExchangeDeformatter):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: AsymmetricAlgorithm) -> None: ...
    @property
    def Parameters(self) -> str: ...
    @Parameters.setter
    def Parameters(self, value: str) -> str: ...
    @property
    def RNG(self) -> RandomNumberGenerator: ...
    @RNG.setter
    def RNG(self, value: RandomNumberGenerator) -> RandomNumberGenerator: ...
    def DecryptKeyExchange(self, rgbIn: Array_1[int]) -> Array_1[int]: ...
    def SetKey(self, key: AsymmetricAlgorithm) -> None: ...


class RSAPKCS1KeyExchangeFormatter(AsymmetricKeyExchangeFormatter):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: AsymmetricAlgorithm) -> None: ...
    @property
    def Parameters(self) -> str: ...
    @property
    def Rng(self) -> RandomNumberGenerator: ...
    @Rng.setter
    def Rng(self, value: RandomNumberGenerator) -> RandomNumberGenerator: ...
    def SetKey(self, key: AsymmetricAlgorithm) -> None: ...
    # Skipped CreateKeyExchange due to it being static, abstract and generic.

    CreateKeyExchange : CreateKeyExchange_MethodGroup
    class CreateKeyExchange_MethodGroup:
        @typing.overload
        def __call__(self, rgbData: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, rgbData: Array_1[int], symAlgType: typing.Type[typing.Any]) -> Array_1[int]:...



class RSAPKCS1SignatureDeformatter(AsymmetricSignatureDeformatter):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: AsymmetricAlgorithm) -> None: ...
    def SetHashAlgorithm(self, strName: str) -> None: ...
    def SetKey(self, key: AsymmetricAlgorithm) -> None: ...
    # Skipped VerifySignature due to it being static, abstract and generic.

    VerifySignature : VerifySignature_MethodGroup
    class VerifySignature_MethodGroup:
        @typing.overload
        def __call__(self, rgbHash: Array_1[int], rgbSignature: Array_1[int]) -> bool:...
        @typing.overload
        def __call__(self, hash: HashAlgorithm, rgbSignature: Array_1[int]) -> bool:...



class RSAPKCS1SignatureFormatter(AsymmetricSignatureFormatter):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, key: AsymmetricAlgorithm) -> None: ...
    def SetHashAlgorithm(self, strName: str) -> None: ...
    def SetKey(self, key: AsymmetricAlgorithm) -> None: ...
    # Skipped CreateSignature due to it being static, abstract and generic.

    CreateSignature : CreateSignature_MethodGroup
    class CreateSignature_MethodGroup:
        @typing.overload
        def __call__(self, rgbHash: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, hash: HashAlgorithm) -> Array_1[int]:...



class RSASignaturePadding(IEquatable_1[RSASignaturePadding]):
    @property
    def Mode(self) -> RSASignaturePaddingMode: ...
    @classmethod
    @property
    def Pkcs1(cls) -> RSASignaturePadding: ...
    @classmethod
    @property
    def Pss(cls) -> RSASignaturePadding: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: RSASignaturePadding, right: RSASignaturePadding) -> bool: ...
    def __ne__(self, left: RSASignaturePadding, right: RSASignaturePadding) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: RSASignaturePadding) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class RSASignaturePaddingMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Pkcs1 : RSASignaturePaddingMode # 0
    Pss : RSASignaturePaddingMode # 1


class SHA1(HashAlgorithm):
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    @staticmethod
    def TryHashData(source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> SHA1:...
        @typing.overload
        def __call__(self, hashName: str) -> SHA1:...

    # Skipped HashData due to it being static, abstract and generic.

    HashData : HashData_MethodGroup
    class HashData_MethodGroup:
        @typing.overload
        def __call__(self, source: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, source: ReadOnlySpan_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, source: ReadOnlySpan_1[int], destination: Span_1[int]) -> int:...



class SHA1CryptoServiceProvider(SHA1):
    def __init__(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...


class SHA1Managed(SHA1):
    def __init__(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...


class SHA256(HashAlgorithm):
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    @staticmethod
    def TryHashData(source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> SHA256:...
        @typing.overload
        def __call__(self, hashName: str) -> SHA256:...

    # Skipped HashData due to it being static, abstract and generic.

    HashData : HashData_MethodGroup
    class HashData_MethodGroup:
        @typing.overload
        def __call__(self, source: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, source: ReadOnlySpan_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, source: ReadOnlySpan_1[int], destination: Span_1[int]) -> int:...



class SHA256CryptoServiceProvider(SHA256):
    def __init__(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...


class SHA256Managed(SHA256):
    def __init__(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...


class SHA384(HashAlgorithm):
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    @staticmethod
    def TryHashData(source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> SHA384:...
        @typing.overload
        def __call__(self, hashName: str) -> SHA384:...

    # Skipped HashData due to it being static, abstract and generic.

    HashData : HashData_MethodGroup
    class HashData_MethodGroup:
        @typing.overload
        def __call__(self, source: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, source: ReadOnlySpan_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, source: ReadOnlySpan_1[int], destination: Span_1[int]) -> int:...



class SHA384CryptoServiceProvider(SHA384):
    def __init__(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...


class SHA384Managed(SHA384):
    def __init__(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...


class SHA512(HashAlgorithm):
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    @staticmethod
    def TryHashData(source: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int]) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> SHA512:...
        @typing.overload
        def __call__(self, hashName: str) -> SHA512:...

    # Skipped HashData due to it being static, abstract and generic.

    HashData : HashData_MethodGroup
    class HashData_MethodGroup:
        @typing.overload
        def __call__(self, source: Array_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, source: ReadOnlySpan_1[int]) -> Array_1[int]:...
        @typing.overload
        def __call__(self, source: ReadOnlySpan_1[int], destination: Span_1[int]) -> int:...



class SHA512CryptoServiceProvider(SHA512):
    def __init__(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...


class SHA512Managed(SHA512):
    def __init__(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def Hash(self) -> Array_1[int]: ...
    @property
    def HashSize(self) -> int: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Initialize(self) -> None: ...


class SignatureDescription:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, el: SecurityElement) -> None: ...
    @property
    def DeformatterAlgorithm(self) -> str: ...
    @DeformatterAlgorithm.setter
    def DeformatterAlgorithm(self, value: str) -> str: ...
    @property
    def DigestAlgorithm(self) -> str: ...
    @DigestAlgorithm.setter
    def DigestAlgorithm(self, value: str) -> str: ...
    @property
    def FormatterAlgorithm(self) -> str: ...
    @FormatterAlgorithm.setter
    def FormatterAlgorithm(self, value: str) -> str: ...
    @property
    def KeyAlgorithm(self) -> str: ...
    @KeyAlgorithm.setter
    def KeyAlgorithm(self, value: str) -> str: ...
    def CreateDeformatter(self, key: AsymmetricAlgorithm) -> AsymmetricSignatureDeformatter: ...
    def CreateDigest(self) -> HashAlgorithm: ...
    def CreateFormatter(self, key: AsymmetricAlgorithm) -> AsymmetricSignatureFormatter: ...


class SymmetricAlgorithm(IDisposable, abc.ABC):
    @property
    def BlockSize(self) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> int: ...
    @property
    def IV(self) -> Array_1[int]: ...
    @IV.setter
    def IV(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalBlockSizes(self) -> Array_1[KeySizes]: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def Mode(self) -> CipherMode: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> PaddingMode: ...
    def Clear(self) -> None: ...
    def Dispose(self) -> None: ...
    @abc.abstractmethod
    def GenerateIV(self) -> None: ...
    @abc.abstractmethod
    def GenerateKey(self) -> None: ...
    def GetCiphertextLengthCbc(self, plaintextLength: int, paddingMode: PaddingMode = ...) -> int: ...
    def GetCiphertextLengthCfb(self, plaintextLength: int, paddingMode: PaddingMode = ..., feedbackSizeInBits: int = ...) -> int: ...
    def GetCiphertextLengthEcb(self, plaintextLength: int, paddingMode: PaddingMode) -> int: ...
    def TryDecryptCbc(self, ciphertext: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int], paddingMode: PaddingMode = ...) -> bool: ...
    def TryDecryptCfb(self, ciphertext: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int], paddingMode: PaddingMode = ..., feedbackSizeInBits: int = ...) -> bool: ...
    def TryDecryptEcb(self, ciphertext: ReadOnlySpan_1[int], destination: Span_1[int], paddingMode: PaddingMode, bytesWritten: clr.Reference[int]) -> bool: ...
    def TryEncryptCbc(self, plaintext: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int], paddingMode: PaddingMode = ...) -> bool: ...
    def TryEncryptCfb(self, plaintext: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], destination: Span_1[int], bytesWritten: clr.Reference[int], paddingMode: PaddingMode = ..., feedbackSizeInBits: int = ...) -> bool: ...
    def TryEncryptEcb(self, plaintext: ReadOnlySpan_1[int], destination: Span_1[int], paddingMode: PaddingMode, bytesWritten: clr.Reference[int]) -> bool: ...
    def ValidKeySize(self, bitLength: int) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> SymmetricAlgorithm:...
        @typing.overload
        def __call__(self, algName: str) -> SymmetricAlgorithm:...

    # Skipped CreateDecryptor due to it being static, abstract and generic.

    CreateDecryptor : CreateDecryptor_MethodGroup
    class CreateDecryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...

    # Skipped CreateEncryptor due to it being static, abstract and generic.

    CreateEncryptor : CreateEncryptor_MethodGroup
    class CreateEncryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...

    # Skipped DecryptCbc due to it being static, abstract and generic.

    DecryptCbc : DecryptCbc_MethodGroup
    class DecryptCbc_MethodGroup:
        @typing.overload
        def __call__(self, ciphertext: Array_1[int], iv: Array_1[int], paddingMode: PaddingMode = ...) -> Array_1[int]:...
        @typing.overload
        def __call__(self, ciphertext: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], paddingMode: PaddingMode = ...) -> Array_1[int]:...
        @typing.overload
        def __call__(self, ciphertext: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], destination: Span_1[int], paddingMode: PaddingMode = ...) -> int:...

    # Skipped DecryptCfb due to it being static, abstract and generic.

    DecryptCfb : DecryptCfb_MethodGroup
    class DecryptCfb_MethodGroup:
        @typing.overload
        def __call__(self, ciphertext: Array_1[int], iv: Array_1[int], paddingMode: PaddingMode = ..., feedbackSizeInBits: int = ...) -> Array_1[int]:...
        @typing.overload
        def __call__(self, ciphertext: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], paddingMode: PaddingMode = ..., feedbackSizeInBits: int = ...) -> Array_1[int]:...
        @typing.overload
        def __call__(self, ciphertext: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], destination: Span_1[int], paddingMode: PaddingMode = ..., feedbackSizeInBits: int = ...) -> int:...

    # Skipped DecryptEcb due to it being static, abstract and generic.

    DecryptEcb : DecryptEcb_MethodGroup
    class DecryptEcb_MethodGroup:
        @typing.overload
        def __call__(self, ciphertext: Array_1[int], paddingMode: PaddingMode) -> Array_1[int]:...
        @typing.overload
        def __call__(self, ciphertext: ReadOnlySpan_1[int], paddingMode: PaddingMode) -> Array_1[int]:...
        @typing.overload
        def __call__(self, ciphertext: ReadOnlySpan_1[int], destination: Span_1[int], paddingMode: PaddingMode) -> int:...

    # Skipped EncryptCbc due to it being static, abstract and generic.

    EncryptCbc : EncryptCbc_MethodGroup
    class EncryptCbc_MethodGroup:
        @typing.overload
        def __call__(self, plaintext: Array_1[int], iv: Array_1[int], paddingMode: PaddingMode = ...) -> Array_1[int]:...
        @typing.overload
        def __call__(self, plaintext: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], paddingMode: PaddingMode = ...) -> Array_1[int]:...
        @typing.overload
        def __call__(self, plaintext: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], destination: Span_1[int], paddingMode: PaddingMode = ...) -> int:...

    # Skipped EncryptCfb due to it being static, abstract and generic.

    EncryptCfb : EncryptCfb_MethodGroup
    class EncryptCfb_MethodGroup:
        @typing.overload
        def __call__(self, plaintext: Array_1[int], iv: Array_1[int], paddingMode: PaddingMode = ..., feedbackSizeInBits: int = ...) -> Array_1[int]:...
        @typing.overload
        def __call__(self, plaintext: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], paddingMode: PaddingMode = ..., feedbackSizeInBits: int = ...) -> Array_1[int]:...
        @typing.overload
        def __call__(self, plaintext: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], destination: Span_1[int], paddingMode: PaddingMode = ..., feedbackSizeInBits: int = ...) -> int:...

    # Skipped EncryptEcb due to it being static, abstract and generic.

    EncryptEcb : EncryptEcb_MethodGroup
    class EncryptEcb_MethodGroup:
        @typing.overload
        def __call__(self, plaintext: Array_1[int], paddingMode: PaddingMode) -> Array_1[int]:...
        @typing.overload
        def __call__(self, plaintext: ReadOnlySpan_1[int], paddingMode: PaddingMode) -> Array_1[int]:...
        @typing.overload
        def __call__(self, plaintext: ReadOnlySpan_1[int], destination: Span_1[int], paddingMode: PaddingMode) -> int:...



class ToBase64Transform(ICryptoTransform):
    def __init__(self) -> None: ...
    @property
    def CanReuseTransform(self) -> bool: ...
    @property
    def CanTransformMultipleBlocks(self) -> bool: ...
    @property
    def InputBlockSize(self) -> int: ...
    @property
    def OutputBlockSize(self) -> int: ...
    def Clear(self) -> None: ...
    def Dispose(self) -> None: ...
    def TransformBlock(self, inputBuffer: Array_1[int], inputOffset: int, inputCount: int, outputBuffer: Array_1[int], outputOffset: int) -> int: ...
    def TransformFinalBlock(self, inputBuffer: Array_1[int], inputOffset: int, inputCount: int) -> Array_1[int]: ...


class TripleDES(SymmetricAlgorithm):
    @property
    def BlockSize(self) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> int: ...
    @property
    def IV(self) -> Array_1[int]: ...
    @IV.setter
    def IV(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalBlockSizes(self) -> Array_1[KeySizes]: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def Mode(self) -> CipherMode: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> PaddingMode: ...
    @staticmethod
    def IsWeakKey(rgbKey: Array_1[int]) -> bool: ...
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        @typing.overload
        def __call__(self) -> TripleDES:...
        @typing.overload
        def __call__(self, str: str) -> TripleDES:...



class TripleDESCryptoServiceProvider(TripleDES):
    def __init__(self) -> None: ...
    @property
    def BlockSize(self) -> int: ...
    @BlockSize.setter
    def BlockSize(self, value: int) -> int: ...
    @property
    def FeedbackSize(self) -> int: ...
    @FeedbackSize.setter
    def FeedbackSize(self, value: int) -> int: ...
    @property
    def IV(self) -> Array_1[int]: ...
    @IV.setter
    def IV(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Key(self) -> Array_1[int]: ...
    @Key.setter
    def Key(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def KeySize(self) -> int: ...
    @KeySize.setter
    def KeySize(self, value: int) -> int: ...
    @property
    def LegalBlockSizes(self) -> Array_1[KeySizes]: ...
    @property
    def LegalKeySizes(self) -> Array_1[KeySizes]: ...
    @property
    def Mode(self) -> CipherMode: ...
    @Mode.setter
    def Mode(self, value: CipherMode) -> CipherMode: ...
    @property
    def Padding(self) -> PaddingMode: ...
    @Padding.setter
    def Padding(self, value: PaddingMode) -> PaddingMode: ...
    def GenerateIV(self) -> None: ...
    def GenerateKey(self) -> None: ...
    # Skipped CreateDecryptor due to it being static, abstract and generic.

    CreateDecryptor : CreateDecryptor_MethodGroup
    class CreateDecryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...

    # Skipped CreateEncryptor due to it being static, abstract and generic.

    CreateEncryptor : CreateEncryptor_MethodGroup
    class CreateEncryptor_MethodGroup:
        @typing.overload
        def __call__(self) -> ICryptoTransform:...
        @typing.overload
        def __call__(self, rgbKey: Array_1[int], rgbIV: Array_1[int]) -> ICryptoTransform:...


