import typing, clr, abc
from System import ICloneable, TimeSpan, DateTimeOffset, Uri, Array_1
from System.Collections.Generic import ICollection_1, IReadOnlyCollection_1, IEnumerator_1, IEnumerable_1, KeyValuePair_2, IReadOnlyDictionary_2

class AuthenticationHeaderValue(ICloneable):
    @typing.overload
    def __init__(self, scheme: str) -> None: ...
    @typing.overload
    def __init__(self, scheme: str, parameter: str) -> None: ...
    @property
    def Parameter(self) -> str: ...
    @property
    def Scheme(self) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> AuthenticationHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[AuthenticationHeaderValue]) -> bool: ...


class CacheControlHeaderValue(ICloneable):
    def __init__(self) -> None: ...
    @property
    def Extensions(self) -> ICollection_1[NameValueHeaderValue]: ...
    @property
    def MaxAge(self) -> typing.Optional[TimeSpan]: ...
    @MaxAge.setter
    def MaxAge(self, value: typing.Optional[TimeSpan]) -> typing.Optional[TimeSpan]: ...
    @property
    def MaxStale(self) -> bool: ...
    @MaxStale.setter
    def MaxStale(self, value: bool) -> bool: ...
    @property
    def MaxStaleLimit(self) -> typing.Optional[TimeSpan]: ...
    @MaxStaleLimit.setter
    def MaxStaleLimit(self, value: typing.Optional[TimeSpan]) -> typing.Optional[TimeSpan]: ...
    @property
    def MinFresh(self) -> typing.Optional[TimeSpan]: ...
    @MinFresh.setter
    def MinFresh(self, value: typing.Optional[TimeSpan]) -> typing.Optional[TimeSpan]: ...
    @property
    def MustRevalidate(self) -> bool: ...
    @MustRevalidate.setter
    def MustRevalidate(self, value: bool) -> bool: ...
    @property
    def NoCache(self) -> bool: ...
    @NoCache.setter
    def NoCache(self, value: bool) -> bool: ...
    @property
    def NoCacheHeaders(self) -> ICollection_1[str]: ...
    @property
    def NoStore(self) -> bool: ...
    @NoStore.setter
    def NoStore(self, value: bool) -> bool: ...
    @property
    def NoTransform(self) -> bool: ...
    @NoTransform.setter
    def NoTransform(self, value: bool) -> bool: ...
    @property
    def OnlyIfCached(self) -> bool: ...
    @OnlyIfCached.setter
    def OnlyIfCached(self, value: bool) -> bool: ...
    @property
    def Private(self) -> bool: ...
    @Private.setter
    def Private(self, value: bool) -> bool: ...
    @property
    def PrivateHeaders(self) -> ICollection_1[str]: ...
    @property
    def ProxyRevalidate(self) -> bool: ...
    @ProxyRevalidate.setter
    def ProxyRevalidate(self, value: bool) -> bool: ...
    @property
    def Public(self) -> bool: ...
    @Public.setter
    def Public(self, value: bool) -> bool: ...
    @property
    def SharedMaxAge(self) -> typing.Optional[TimeSpan]: ...
    @SharedMaxAge.setter
    def SharedMaxAge(self, value: typing.Optional[TimeSpan]) -> typing.Optional[TimeSpan]: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> CacheControlHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[CacheControlHeaderValue]) -> bool: ...


class ContentDispositionHeaderValue(ICloneable):
    def __init__(self, dispositionType: str) -> None: ...
    @property
    def CreationDate(self) -> typing.Optional[DateTimeOffset]: ...
    @CreationDate.setter
    def CreationDate(self, value: typing.Optional[DateTimeOffset]) -> typing.Optional[DateTimeOffset]: ...
    @property
    def DispositionType(self) -> str: ...
    @DispositionType.setter
    def DispositionType(self, value: str) -> str: ...
    @property
    def FileName(self) -> str: ...
    @FileName.setter
    def FileName(self, value: str) -> str: ...
    @property
    def FileNameStar(self) -> str: ...
    @FileNameStar.setter
    def FileNameStar(self, value: str) -> str: ...
    @property
    def ModificationDate(self) -> typing.Optional[DateTimeOffset]: ...
    @ModificationDate.setter
    def ModificationDate(self, value: typing.Optional[DateTimeOffset]) -> typing.Optional[DateTimeOffset]: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Parameters(self) -> ICollection_1[NameValueHeaderValue]: ...
    @property
    def ReadDate(self) -> typing.Optional[DateTimeOffset]: ...
    @ReadDate.setter
    def ReadDate(self, value: typing.Optional[DateTimeOffset]) -> typing.Optional[DateTimeOffset]: ...
    @property
    def Size(self) -> typing.Optional[int]: ...
    @Size.setter
    def Size(self, value: typing.Optional[int]) -> typing.Optional[int]: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> ContentDispositionHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[ContentDispositionHeaderValue]) -> bool: ...


class ContentRangeHeaderValue(ICloneable):
    @typing.overload
    def __init__(self, from_: int, to: int) -> None: ...
    @typing.overload
    def __init__(self, from_: int, to: int, length: int) -> None: ...
    @typing.overload
    def __init__(self, length: int) -> None: ...
    @property
    def From(self) -> typing.Optional[int]: ...
    @property
    def HasLength(self) -> bool: ...
    @property
    def HasRange(self) -> bool: ...
    @property
    def Length(self) -> typing.Optional[int]: ...
    @property
    def To(self) -> typing.Optional[int]: ...
    @property
    def Unit(self) -> str: ...
    @Unit.setter
    def Unit(self, value: str) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> ContentRangeHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[ContentRangeHeaderValue]) -> bool: ...


class EntityTagHeaderValue(ICloneable):
    @typing.overload
    def __init__(self, tag: str) -> None: ...
    @typing.overload
    def __init__(self, tag: str, isWeak: bool) -> None: ...
    @classmethod
    @property
    def Any(cls) -> EntityTagHeaderValue: ...
    @property
    def IsWeak(self) -> bool: ...
    @property
    def Tag(self) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> EntityTagHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[EntityTagHeaderValue]) -> bool: ...


class HeaderStringValues(IReadOnlyCollection_1[str]):
    @property
    def Count(self) -> int: ...
    def GetEnumerator(self) -> HeaderStringValues.Enumerator: ...
    def ToString(self) -> str: ...

    class Enumerator(IEnumerator_1[str]):
        @property
        def Current(self) -> str: ...
        def Dispose(self) -> None: ...
        def MoveNext(self) -> bool: ...



class HttpContentHeaders(HttpHeaders):
    @property
    def Allow(self) -> ICollection_1[str]: ...
    @property
    def ContentDisposition(self) -> ContentDispositionHeaderValue: ...
    @ContentDisposition.setter
    def ContentDisposition(self, value: ContentDispositionHeaderValue) -> ContentDispositionHeaderValue: ...
    @property
    def ContentEncoding(self) -> ICollection_1[str]: ...
    @property
    def ContentLanguage(self) -> ICollection_1[str]: ...
    @property
    def ContentLength(self) -> typing.Optional[int]: ...
    @ContentLength.setter
    def ContentLength(self, value: typing.Optional[int]) -> typing.Optional[int]: ...
    @property
    def ContentLocation(self) -> Uri: ...
    @ContentLocation.setter
    def ContentLocation(self, value: Uri) -> Uri: ...
    @property
    def ContentMD5(self) -> Array_1[int]: ...
    @ContentMD5.setter
    def ContentMD5(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def ContentRange(self) -> ContentRangeHeaderValue: ...
    @ContentRange.setter
    def ContentRange(self, value: ContentRangeHeaderValue) -> ContentRangeHeaderValue: ...
    @property
    def ContentType(self) -> MediaTypeHeaderValue: ...
    @ContentType.setter
    def ContentType(self, value: MediaTypeHeaderValue) -> MediaTypeHeaderValue: ...
    @property
    def Expires(self) -> typing.Optional[DateTimeOffset]: ...
    @Expires.setter
    def Expires(self, value: typing.Optional[DateTimeOffset]) -> typing.Optional[DateTimeOffset]: ...
    @property
    def LastModified(self) -> typing.Optional[DateTimeOffset]: ...
    @LastModified.setter
    def LastModified(self, value: typing.Optional[DateTimeOffset]) -> typing.Optional[DateTimeOffset]: ...
    @property
    def NonValidated(self) -> HttpHeadersNonValidated: ...


class HttpHeaders(IEnumerable_1[KeyValuePair_2[str, IEnumerable_1[str]]], abc.ABC):
    @property
    def NonValidated(self) -> HttpHeadersNonValidated: ...
    def Clear(self) -> None: ...
    def Contains(self, name: str) -> bool: ...
    def GetEnumerator(self) -> IEnumerator_1[KeyValuePair_2[str, IEnumerable_1[str]]]: ...
    def GetValues(self, name: str) -> IEnumerable_1[str]: ...
    def Remove(self, name: str) -> bool: ...
    def ToString(self) -> str: ...
    def TryGetValues(self, name: str, values: clr.Reference[IEnumerable_1[str]]) -> bool: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, name: str, value: str) -> None:...
        @typing.overload
        def __call__(self, name: str, values: IEnumerable_1[str]) -> None:...

    # Skipped TryAddWithoutValidation due to it being static, abstract and generic.

    TryAddWithoutValidation : TryAddWithoutValidation_MethodGroup
    class TryAddWithoutValidation_MethodGroup:
        @typing.overload
        def __call__(self, name: str, value: str) -> bool:...
        @typing.overload
        def __call__(self, name: str, values: IEnumerable_1[str]) -> bool:...



class HttpHeadersNonValidated(IReadOnlyDictionary_2[str, HeaderStringValues]):
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> HeaderStringValues: ...
    def Contains(self, headerName: str) -> bool: ...
    def GetEnumerator(self) -> HttpHeadersNonValidated.Enumerator: ...
    def TryGetValues(self, headerName: str, values: clr.Reference[HeaderStringValues]) -> bool: ...

    class Enumerator(IEnumerator_1[KeyValuePair_2[str, HeaderStringValues]]):
        @property
        def Current(self) -> KeyValuePair_2[str, HeaderStringValues]: ...
        def Dispose(self) -> None: ...
        def MoveNext(self) -> bool: ...



class HttpHeaderValueCollection_GenericClasses(abc.ABCMeta):
    Generic_HttpHeaderValueCollection_GenericClasses_HttpHeaderValueCollection_1_T = typing.TypeVar('Generic_HttpHeaderValueCollection_GenericClasses_HttpHeaderValueCollection_1_T')
    def __getitem__(self, types : typing.Type[Generic_HttpHeaderValueCollection_GenericClasses_HttpHeaderValueCollection_1_T]) -> typing.Type[HttpHeaderValueCollection_1[Generic_HttpHeaderValueCollection_GenericClasses_HttpHeaderValueCollection_1_T]]: ...

HttpHeaderValueCollection : HttpHeaderValueCollection_GenericClasses

HttpHeaderValueCollection_1_T = typing.TypeVar('HttpHeaderValueCollection_1_T')
class HttpHeaderValueCollection_1(typing.Generic[HttpHeaderValueCollection_1_T], ICollection_1[HttpHeaderValueCollection_1_T]):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    def Add(self, item: HttpHeaderValueCollection_1_T) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, item: HttpHeaderValueCollection_1_T) -> bool: ...
    def CopyTo(self, array: Array_1[HttpHeaderValueCollection_1_T], arrayIndex: int) -> None: ...
    def GetEnumerator(self) -> IEnumerator_1[HttpHeaderValueCollection_1_T]: ...
    def ParseAdd(self, input: str) -> None: ...
    def Remove(self, item: HttpHeaderValueCollection_1_T) -> bool: ...
    def ToString(self) -> str: ...
    def TryParseAdd(self, input: str) -> bool: ...


class HttpRequestHeaders(HttpHeaders):
    @property
    def Accept(self) -> HttpHeaderValueCollection_1[MediaTypeWithQualityHeaderValue]: ...
    @property
    def AcceptCharset(self) -> HttpHeaderValueCollection_1[StringWithQualityHeaderValue]: ...
    @property
    def AcceptEncoding(self) -> HttpHeaderValueCollection_1[StringWithQualityHeaderValue]: ...
    @property
    def AcceptLanguage(self) -> HttpHeaderValueCollection_1[StringWithQualityHeaderValue]: ...
    @property
    def Authorization(self) -> AuthenticationHeaderValue: ...
    @Authorization.setter
    def Authorization(self, value: AuthenticationHeaderValue) -> AuthenticationHeaderValue: ...
    @property
    def CacheControl(self) -> CacheControlHeaderValue: ...
    @CacheControl.setter
    def CacheControl(self, value: CacheControlHeaderValue) -> CacheControlHeaderValue: ...
    @property
    def Connection(self) -> HttpHeaderValueCollection_1[str]: ...
    @property
    def ConnectionClose(self) -> typing.Optional[bool]: ...
    @ConnectionClose.setter
    def ConnectionClose(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def Date(self) -> typing.Optional[DateTimeOffset]: ...
    @Date.setter
    def Date(self, value: typing.Optional[DateTimeOffset]) -> typing.Optional[DateTimeOffset]: ...
    @property
    def Expect(self) -> HttpHeaderValueCollection_1[NameValueWithParametersHeaderValue]: ...
    @property
    def ExpectContinue(self) -> typing.Optional[bool]: ...
    @ExpectContinue.setter
    def ExpectContinue(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def From(self) -> str: ...
    @From.setter
    def From(self, value: str) -> str: ...
    @property
    def Host(self) -> str: ...
    @Host.setter
    def Host(self, value: str) -> str: ...
    @property
    def IfMatch(self) -> HttpHeaderValueCollection_1[EntityTagHeaderValue]: ...
    @property
    def IfModifiedSince(self) -> typing.Optional[DateTimeOffset]: ...
    @IfModifiedSince.setter
    def IfModifiedSince(self, value: typing.Optional[DateTimeOffset]) -> typing.Optional[DateTimeOffset]: ...
    @property
    def IfNoneMatch(self) -> HttpHeaderValueCollection_1[EntityTagHeaderValue]: ...
    @property
    def IfRange(self) -> RangeConditionHeaderValue: ...
    @IfRange.setter
    def IfRange(self, value: RangeConditionHeaderValue) -> RangeConditionHeaderValue: ...
    @property
    def IfUnmodifiedSince(self) -> typing.Optional[DateTimeOffset]: ...
    @IfUnmodifiedSince.setter
    def IfUnmodifiedSince(self, value: typing.Optional[DateTimeOffset]) -> typing.Optional[DateTimeOffset]: ...
    @property
    def MaxForwards(self) -> typing.Optional[int]: ...
    @MaxForwards.setter
    def MaxForwards(self, value: typing.Optional[int]) -> typing.Optional[int]: ...
    @property
    def NonValidated(self) -> HttpHeadersNonValidated: ...
    @property
    def Pragma(self) -> HttpHeaderValueCollection_1[NameValueHeaderValue]: ...
    @property
    def ProxyAuthorization(self) -> AuthenticationHeaderValue: ...
    @ProxyAuthorization.setter
    def ProxyAuthorization(self, value: AuthenticationHeaderValue) -> AuthenticationHeaderValue: ...
    @property
    def Range(self) -> RangeHeaderValue: ...
    @Range.setter
    def Range(self, value: RangeHeaderValue) -> RangeHeaderValue: ...
    @property
    def Referrer(self) -> Uri: ...
    @Referrer.setter
    def Referrer(self, value: Uri) -> Uri: ...
    @property
    def TE(self) -> HttpHeaderValueCollection_1[TransferCodingWithQualityHeaderValue]: ...
    @property
    def Trailer(self) -> HttpHeaderValueCollection_1[str]: ...
    @property
    def TransferEncoding(self) -> HttpHeaderValueCollection_1[TransferCodingHeaderValue]: ...
    @property
    def TransferEncodingChunked(self) -> typing.Optional[bool]: ...
    @TransferEncodingChunked.setter
    def TransferEncodingChunked(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def Upgrade(self) -> HttpHeaderValueCollection_1[ProductHeaderValue]: ...
    @property
    def UserAgent(self) -> HttpHeaderValueCollection_1[ProductInfoHeaderValue]: ...
    @property
    def Via(self) -> HttpHeaderValueCollection_1[ViaHeaderValue]: ...
    @property
    def Warning(self) -> HttpHeaderValueCollection_1[WarningHeaderValue]: ...


class HttpResponseHeaders(HttpHeaders):
    @property
    def AcceptRanges(self) -> HttpHeaderValueCollection_1[str]: ...
    @property
    def Age(self) -> typing.Optional[TimeSpan]: ...
    @Age.setter
    def Age(self, value: typing.Optional[TimeSpan]) -> typing.Optional[TimeSpan]: ...
    @property
    def CacheControl(self) -> CacheControlHeaderValue: ...
    @CacheControl.setter
    def CacheControl(self, value: CacheControlHeaderValue) -> CacheControlHeaderValue: ...
    @property
    def Connection(self) -> HttpHeaderValueCollection_1[str]: ...
    @property
    def ConnectionClose(self) -> typing.Optional[bool]: ...
    @ConnectionClose.setter
    def ConnectionClose(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def Date(self) -> typing.Optional[DateTimeOffset]: ...
    @Date.setter
    def Date(self, value: typing.Optional[DateTimeOffset]) -> typing.Optional[DateTimeOffset]: ...
    @property
    def ETag(self) -> EntityTagHeaderValue: ...
    @ETag.setter
    def ETag(self, value: EntityTagHeaderValue) -> EntityTagHeaderValue: ...
    @property
    def Location(self) -> Uri: ...
    @Location.setter
    def Location(self, value: Uri) -> Uri: ...
    @property
    def NonValidated(self) -> HttpHeadersNonValidated: ...
    @property
    def Pragma(self) -> HttpHeaderValueCollection_1[NameValueHeaderValue]: ...
    @property
    def ProxyAuthenticate(self) -> HttpHeaderValueCollection_1[AuthenticationHeaderValue]: ...
    @property
    def RetryAfter(self) -> RetryConditionHeaderValue: ...
    @RetryAfter.setter
    def RetryAfter(self, value: RetryConditionHeaderValue) -> RetryConditionHeaderValue: ...
    @property
    def Server(self) -> HttpHeaderValueCollection_1[ProductInfoHeaderValue]: ...
    @property
    def Trailer(self) -> HttpHeaderValueCollection_1[str]: ...
    @property
    def TransferEncoding(self) -> HttpHeaderValueCollection_1[TransferCodingHeaderValue]: ...
    @property
    def TransferEncodingChunked(self) -> typing.Optional[bool]: ...
    @TransferEncodingChunked.setter
    def TransferEncodingChunked(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def Upgrade(self) -> HttpHeaderValueCollection_1[ProductHeaderValue]: ...
    @property
    def Vary(self) -> HttpHeaderValueCollection_1[str]: ...
    @property
    def Via(self) -> HttpHeaderValueCollection_1[ViaHeaderValue]: ...
    @property
    def Warning(self) -> HttpHeaderValueCollection_1[WarningHeaderValue]: ...
    @property
    def WwwAuthenticate(self) -> HttpHeaderValueCollection_1[AuthenticationHeaderValue]: ...


class MediaTypeHeaderValue(ICloneable):
    def __init__(self, mediaType: str) -> None: ...
    @property
    def CharSet(self) -> str: ...
    @CharSet.setter
    def CharSet(self, value: str) -> str: ...
    @property
    def MediaType(self) -> str: ...
    @MediaType.setter
    def MediaType(self, value: str) -> str: ...
    @property
    def Parameters(self) -> ICollection_1[NameValueHeaderValue]: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> MediaTypeHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[MediaTypeHeaderValue]) -> bool: ...


class MediaTypeWithQualityHeaderValue(MediaTypeHeaderValue):
    @typing.overload
    def __init__(self, mediaType: str) -> None: ...
    @typing.overload
    def __init__(self, mediaType: str, quality: float) -> None: ...
    @property
    def CharSet(self) -> str: ...
    @CharSet.setter
    def CharSet(self, value: str) -> str: ...
    @property
    def MediaType(self) -> str: ...
    @MediaType.setter
    def MediaType(self, value: str) -> str: ...
    @property
    def Parameters(self) -> ICollection_1[NameValueHeaderValue]: ...
    @property
    def Quality(self) -> typing.Optional[float]: ...
    @Quality.setter
    def Quality(self, value: typing.Optional[float]) -> typing.Optional[float]: ...
    @staticmethod
    def Parse(input: str) -> MediaTypeWithQualityHeaderValue: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[MediaTypeWithQualityHeaderValue]) -> bool: ...


class NameValueHeaderValue(ICloneable):
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, value: str) -> None: ...
    @property
    def Name(self) -> str: ...
    @property
    def Value(self) -> str: ...
    @Value.setter
    def Value(self, value: str) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> NameValueHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[NameValueHeaderValue]) -> bool: ...


class NameValueWithParametersHeaderValue(NameValueHeaderValue):
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, value: str) -> None: ...
    @property
    def Name(self) -> str: ...
    @property
    def Parameters(self) -> ICollection_1[NameValueHeaderValue]: ...
    @property
    def Value(self) -> str: ...
    @Value.setter
    def Value(self, value: str) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> NameValueWithParametersHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[NameValueWithParametersHeaderValue]) -> bool: ...


class ProductHeaderValue(ICloneable):
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, version: str) -> None: ...
    @property
    def Name(self) -> str: ...
    @property
    def Version(self) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> ProductHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[ProductHeaderValue]) -> bool: ...


class ProductInfoHeaderValue(ICloneable):
    @typing.overload
    def __init__(self, comment: str) -> None: ...
    @typing.overload
    def __init__(self, product: ProductHeaderValue) -> None: ...
    @typing.overload
    def __init__(self, productName: str, productVersion: str) -> None: ...
    @property
    def Comment(self) -> str: ...
    @property
    def Product(self) -> ProductHeaderValue: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> ProductInfoHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[ProductInfoHeaderValue]) -> bool: ...


class RangeConditionHeaderValue(ICloneable):
    @typing.overload
    def __init__(self, date: DateTimeOffset) -> None: ...
    @typing.overload
    def __init__(self, entityTag: EntityTagHeaderValue) -> None: ...
    @typing.overload
    def __init__(self, entityTag: str) -> None: ...
    @property
    def Date(self) -> typing.Optional[DateTimeOffset]: ...
    @property
    def EntityTag(self) -> EntityTagHeaderValue: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> RangeConditionHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[RangeConditionHeaderValue]) -> bool: ...


class RangeHeaderValue(ICloneable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, from_: typing.Optional[int], to: typing.Optional[int]) -> None: ...
    @property
    def Ranges(self) -> ICollection_1[RangeItemHeaderValue]: ...
    @property
    def Unit(self) -> str: ...
    @Unit.setter
    def Unit(self, value: str) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> RangeHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[RangeHeaderValue]) -> bool: ...


class RangeItemHeaderValue(ICloneable):
    def __init__(self, from_: typing.Optional[int], to: typing.Optional[int]) -> None: ...
    @property
    def From(self) -> typing.Optional[int]: ...
    @property
    def To(self) -> typing.Optional[int]: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def ToString(self) -> str: ...


class RetryConditionHeaderValue(ICloneable):
    @typing.overload
    def __init__(self, date: DateTimeOffset) -> None: ...
    @typing.overload
    def __init__(self, delta: TimeSpan) -> None: ...
    @property
    def Date(self) -> typing.Optional[DateTimeOffset]: ...
    @property
    def Delta(self) -> typing.Optional[TimeSpan]: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> RetryConditionHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[RetryConditionHeaderValue]) -> bool: ...


class StringWithQualityHeaderValue(ICloneable):
    @typing.overload
    def __init__(self, value: str) -> None: ...
    @typing.overload
    def __init__(self, value: str, quality: float) -> None: ...
    @property
    def Quality(self) -> typing.Optional[float]: ...
    @property
    def Value(self) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> StringWithQualityHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[StringWithQualityHeaderValue]) -> bool: ...


class TransferCodingHeaderValue(ICloneable):
    def __init__(self, value: str) -> None: ...
    @property
    def Parameters(self) -> ICollection_1[NameValueHeaderValue]: ...
    @property
    def Value(self) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> TransferCodingHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[TransferCodingHeaderValue]) -> bool: ...


class TransferCodingWithQualityHeaderValue(TransferCodingHeaderValue):
    @typing.overload
    def __init__(self, value: str) -> None: ...
    @typing.overload
    def __init__(self, value: str, quality: float) -> None: ...
    @property
    def Parameters(self) -> ICollection_1[NameValueHeaderValue]: ...
    @property
    def Quality(self) -> typing.Optional[float]: ...
    @Quality.setter
    def Quality(self, value: typing.Optional[float]) -> typing.Optional[float]: ...
    @property
    def Value(self) -> str: ...
    @staticmethod
    def Parse(input: str) -> TransferCodingWithQualityHeaderValue: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[TransferCodingWithQualityHeaderValue]) -> bool: ...


class ViaHeaderValue(ICloneable):
    @typing.overload
    def __init__(self, protocolVersion: str, receivedBy: str) -> None: ...
    @typing.overload
    def __init__(self, protocolVersion: str, receivedBy: str, protocolName: str) -> None: ...
    @typing.overload
    def __init__(self, protocolVersion: str, receivedBy: str, protocolName: str, comment: str) -> None: ...
    @property
    def Comment(self) -> str: ...
    @property
    def ProtocolName(self) -> str: ...
    @property
    def ProtocolVersion(self) -> str: ...
    @property
    def ReceivedBy(self) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> ViaHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[ViaHeaderValue]) -> bool: ...


class WarningHeaderValue(ICloneable):
    @typing.overload
    def __init__(self, code: int, agent: str, text: str) -> None: ...
    @typing.overload
    def __init__(self, code: int, agent: str, text: str, date: DateTimeOffset) -> None: ...
    @property
    def Agent(self) -> str: ...
    @property
    def Code(self) -> int: ...
    @property
    def Date(self) -> typing.Optional[DateTimeOffset]: ...
    @property
    def Text(self) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    @staticmethod
    def Parse(input: str) -> WarningHeaderValue: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryParse(input: str, parsedValue: clr.Reference[WarningHeaderValue]) -> bool: ...

