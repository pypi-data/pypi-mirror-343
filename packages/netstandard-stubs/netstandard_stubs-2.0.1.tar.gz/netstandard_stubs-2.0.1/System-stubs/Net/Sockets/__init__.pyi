import typing, clr, abc
from System.Net import IPAddress, EndPoint, IPEndPoint, SocketAddress
from System.IO import Stream, FileAccess, SeekOrigin, FileStream
from System import IAsyncResult, Array_1, AsyncCallback, Span_1, Memory_1, ReadOnlySpan_1, ReadOnlyMemory_1, IDisposable, ArraySegment_1, EventArgs, Exception, IEquatable_1
from System.Threading.Tasks import Task, ValueTask_1, Task_1, ValueTask
from System.Threading import CancellationToken
from Microsoft.Win32.SafeHandles import SafeHandleMinusOneIsInvalid
from System.Collections import IList, IDictionary
from System.Collections.Generic import IList_1
from System.ComponentModel import Win32Exception
from System.Reflection import MethodBase

class AddressFamily(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unspecified : AddressFamily # 0
    Unix : AddressFamily # 1
    InterNetwork : AddressFamily # 2
    ImpLink : AddressFamily # 3
    Pup : AddressFamily # 4
    Chaos : AddressFamily # 5
    NS : AddressFamily # 6
    Ipx : AddressFamily # 6
    Osi : AddressFamily # 7
    Iso : AddressFamily # 7
    Ecma : AddressFamily # 8
    DataKit : AddressFamily # 9
    Ccitt : AddressFamily # 10
    Sna : AddressFamily # 11
    DecNet : AddressFamily # 12
    DataLink : AddressFamily # 13
    Lat : AddressFamily # 14
    HyperChannel : AddressFamily # 15
    AppleTalk : AddressFamily # 16
    NetBios : AddressFamily # 17
    VoiceView : AddressFamily # 18
    FireFox : AddressFamily # 19
    Banyan : AddressFamily # 21
    Atm : AddressFamily # 22
    InterNetworkV6 : AddressFamily # 23
    Cluster : AddressFamily # 24
    Ieee12844 : AddressFamily # 25
    Irda : AddressFamily # 26
    NetworkDesigners : AddressFamily # 28
    Max : AddressFamily # 29
    Packet : AddressFamily # 65536
    ControllerAreaNetwork : AddressFamily # 65537
    Unknown : AddressFamily # -1


class IOControlCode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    EnableCircularQueuing : IOControlCode # 671088642
    Flush : IOControlCode # 671088644
    AddressListChange : IOControlCode # 671088663
    DataToRead : IOControlCode # 1074030207
    OobDataRead : IOControlCode # 1074033415
    GetBroadcastAddress : IOControlCode # 1207959557
    AddressListQuery : IOControlCode # 1207959574
    QueryTargetPnpHandle : IOControlCode # 1207959576
    AsyncIO : IOControlCode # 2147772029
    NonBlockingIO : IOControlCode # 2147772030
    AssociateHandle : IOControlCode # 2281701377
    MultipointLoopback : IOControlCode # 2281701385
    MulticastScope : IOControlCode # 2281701386
    SetQos : IOControlCode # 2281701387
    SetGroupQos : IOControlCode # 2281701388
    RoutingInterfaceChange : IOControlCode # 2281701397
    NamespaceChange : IOControlCode # 2281701401
    ReceiveAll : IOControlCode # 2550136833
    ReceiveAllMulticast : IOControlCode # 2550136834
    ReceiveAllIgmpMulticast : IOControlCode # 2550136835
    KeepAliveValues : IOControlCode # 2550136836
    AbsorbRouterAlert : IOControlCode # 2550136837
    UnicastInterface : IOControlCode # 2550136838
    LimitBroadcasts : IOControlCode # 2550136839
    BindToInterface : IOControlCode # 2550136840
    MulticastInterface : IOControlCode # 2550136841
    AddMulticastGroupOnInterface : IOControlCode # 2550136842
    DeleteMulticastGroupFromInterface : IOControlCode # 2550136843
    GetExtensionFunctionPointer : IOControlCode # 3355443206
    GetQos : IOControlCode # 3355443207
    GetGroupQos : IOControlCode # 3355443208
    TranslateHandle : IOControlCode # 3355443213
    RoutingInterfaceQuery : IOControlCode # 3355443220
    AddressListSort : IOControlCode # 3355443225


class IPPacketInformation:
    @property
    def Address(self) -> IPAddress: ...
    @property
    def Interface(self) -> int: ...
    def Equals(self, comparand: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, packetInformation1: IPPacketInformation, packetInformation2: IPPacketInformation) -> bool: ...
    def __ne__(self, packetInformation1: IPPacketInformation, packetInformation2: IPPacketInformation) -> bool: ...


class IPProtectionLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unrestricted : IPProtectionLevel # 10
    EdgeRestricted : IPProtectionLevel # 20
    Restricted : IPProtectionLevel # 30
    Unspecified : IPProtectionLevel # -1


class IPv6MulticastOption:
    @typing.overload
    def __init__(self, group: IPAddress) -> None: ...
    @typing.overload
    def __init__(self, group: IPAddress, ifindex: int) -> None: ...
    @property
    def Group(self) -> IPAddress: ...
    @Group.setter
    def Group(self, value: IPAddress) -> IPAddress: ...
    @property
    def InterfaceIndex(self) -> int: ...
    @InterfaceIndex.setter
    def InterfaceIndex(self, value: int) -> int: ...


class LingerOption:
    def __init__(self, enable: bool, seconds: int) -> None: ...
    @property
    def Enabled(self) -> bool: ...
    @Enabled.setter
    def Enabled(self, value: bool) -> bool: ...
    @property
    def LingerTime(self) -> int: ...
    @LingerTime.setter
    def LingerTime(self, value: int) -> int: ...


class MulticastOption:
    @typing.overload
    def __init__(self, group: IPAddress) -> None: ...
    @typing.overload
    def __init__(self, group: IPAddress, interfaceIndex: int) -> None: ...
    @typing.overload
    def __init__(self, group: IPAddress, mcint: IPAddress) -> None: ...
    @property
    def Group(self) -> IPAddress: ...
    @Group.setter
    def Group(self, value: IPAddress) -> IPAddress: ...
    @property
    def InterfaceIndex(self) -> int: ...
    @InterfaceIndex.setter
    def InterfaceIndex(self, value: int) -> int: ...
    @property
    def LocalAddress(self) -> IPAddress: ...
    @LocalAddress.setter
    def LocalAddress(self, value: IPAddress) -> IPAddress: ...


class NetworkStream(Stream):
    @typing.overload
    def __init__(self, socket: Socket) -> None: ...
    @typing.overload
    def __init__(self, socket: Socket, access: FileAccess) -> None: ...
    @typing.overload
    def __init__(self, socket: Socket, access: FileAccess, ownsSocket: bool) -> None: ...
    @typing.overload
    def __init__(self, socket: Socket, ownsSocket: bool) -> None: ...
    @property
    def CanRead(self) -> bool: ...
    @property
    def CanSeek(self) -> bool: ...
    @property
    def CanTimeout(self) -> bool: ...
    @property
    def CanWrite(self) -> bool: ...
    @property
    def DataAvailable(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    @property
    def Position(self) -> int: ...
    @Position.setter
    def Position(self, value: int) -> int: ...
    @property
    def ReadTimeout(self) -> int: ...
    @ReadTimeout.setter
    def ReadTimeout(self, value: int) -> int: ...
    @property
    def Socket(self) -> Socket: ...
    @property
    def WriteTimeout(self) -> int: ...
    @WriteTimeout.setter
    def WriteTimeout(self, value: int) -> int: ...
    def BeginRead(self, buffer: Array_1[int], offset: int, count: int, callback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    def BeginWrite(self, buffer: Array_1[int], offset: int, count: int, callback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    def EndRead(self, asyncResult: IAsyncResult) -> int: ...
    def EndWrite(self, asyncResult: IAsyncResult) -> None: ...
    def Flush(self) -> None: ...
    def ReadByte(self) -> int: ...
    def Seek(self, offset: int, origin: SeekOrigin) -> int: ...
    def SetLength(self, value: int) -> None: ...
    def WriteByte(self, value: int) -> None: ...
    # Skipped Close due to it being static, abstract and generic.

    Close : Close_MethodGroup
    class Close_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, timeout: int) -> None:...

    # Skipped FlushAsync due to it being static, abstract and generic.

    FlushAsync : FlushAsync_MethodGroup
    class FlushAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Task:...

    # Skipped Read due to it being static, abstract and generic.

    Read : Read_MethodGroup
    class Read_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Span_1[int]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> int:...

    # Skipped ReadAsync due to it being static, abstract and generic.

    ReadAsync : ReadAsync_MethodGroup
    class ReadAsync_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Memory_1[int], cancellationToken: CancellationToken) -> ValueTask_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> Task_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, cancellationToken: CancellationToken) -> Task_1[int]:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> None:...

    # Skipped WriteAsync due to it being static, abstract and generic.

    WriteAsync : WriteAsync_MethodGroup
    class WriteAsync_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ReadOnlyMemory_1[int], cancellationToken: CancellationToken) -> ValueTask:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> Task:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, cancellationToken: CancellationToken) -> Task:...



class ProtocolFamily(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unspecified : ProtocolFamily # 0
    Unix : ProtocolFamily # 1
    InterNetwork : ProtocolFamily # 2
    ImpLink : ProtocolFamily # 3
    Pup : ProtocolFamily # 4
    Chaos : ProtocolFamily # 5
    NS : ProtocolFamily # 6
    Ipx : ProtocolFamily # 6
    Osi : ProtocolFamily # 7
    Iso : ProtocolFamily # 7
    Ecma : ProtocolFamily # 8
    DataKit : ProtocolFamily # 9
    Ccitt : ProtocolFamily # 10
    Sna : ProtocolFamily # 11
    DecNet : ProtocolFamily # 12
    DataLink : ProtocolFamily # 13
    Lat : ProtocolFamily # 14
    HyperChannel : ProtocolFamily # 15
    AppleTalk : ProtocolFamily # 16
    NetBios : ProtocolFamily # 17
    VoiceView : ProtocolFamily # 18
    FireFox : ProtocolFamily # 19
    Banyan : ProtocolFamily # 21
    Atm : ProtocolFamily # 22
    InterNetworkV6 : ProtocolFamily # 23
    Cluster : ProtocolFamily # 24
    Ieee12844 : ProtocolFamily # 25
    Irda : ProtocolFamily # 26
    NetworkDesigners : ProtocolFamily # 28
    Max : ProtocolFamily # 29
    Packet : ProtocolFamily # 65536
    ControllerAreaNetwork : ProtocolFamily # 65537
    Unknown : ProtocolFamily # -1


class ProtocolType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    IPv6HopByHopOptions : ProtocolType # 0
    IP : ProtocolType # 0
    Unspecified : ProtocolType # 0
    Icmp : ProtocolType # 1
    Igmp : ProtocolType # 2
    Ggp : ProtocolType # 3
    IPv4 : ProtocolType # 4
    Tcp : ProtocolType # 6
    Pup : ProtocolType # 12
    Udp : ProtocolType # 17
    Idp : ProtocolType # 22
    IPv6 : ProtocolType # 41
    IPv6RoutingHeader : ProtocolType # 43
    IPv6FragmentHeader : ProtocolType # 44
    IPSecEncapsulatingSecurityPayload : ProtocolType # 50
    IPSecAuthenticationHeader : ProtocolType # 51
    IcmpV6 : ProtocolType # 58
    IPv6NoNextHeader : ProtocolType # 59
    IPv6DestinationOptions : ProtocolType # 60
    ND : ProtocolType # 77
    Raw : ProtocolType # 255
    Ipx : ProtocolType # 1000
    Spx : ProtocolType # 1256
    SpxII : ProtocolType # 1257
    Unknown : ProtocolType # -1


class SafeSocketHandle(SafeHandleMinusOneIsInvalid):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, preexistingHandle: int, ownsHandle: bool) -> None: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsInvalid(self) -> bool: ...


class SelectMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    SelectRead : SelectMode # 0
    SelectWrite : SelectMode # 1
    SelectError : SelectMode # 2


class SendPacketsElement:
    # Constructor .ctor(filepath : String, offset : Int64, count : Int32) was skipped since it collides with above method
    # Constructor .ctor(filepath : String, offset : Int64, count : Int32, endOfPacket : Boolean) was skipped since it collides with above method
    @typing.overload
    def __init__(self, buffer: Array_1[int]) -> None: ...
    @typing.overload
    def __init__(self, buffer: ReadOnlyMemory_1[int]) -> None: ...
    @typing.overload
    def __init__(self, buffer: ReadOnlyMemory_1[int], endOfPacket: bool) -> None: ...
    @typing.overload
    def __init__(self, buffer: Array_1[int], offset: int, count: int) -> None: ...
    @typing.overload
    def __init__(self, buffer: Array_1[int], offset: int, count: int, endOfPacket: bool) -> None: ...
    @typing.overload
    def __init__(self, filepath: str) -> None: ...
    @typing.overload
    def __init__(self, filepath: str, offset: int, count: int) -> None: ...
    @typing.overload
    def __init__(self, filepath: str, offset: int, count: int, endOfPacket: bool) -> None: ...
    @typing.overload
    def __init__(self, fileStream: FileStream) -> None: ...
    @typing.overload
    def __init__(self, fileStream: FileStream, offset: int, count: int) -> None: ...
    @typing.overload
    def __init__(self, fileStream: FileStream, offset: int, count: int, endOfPacket: bool) -> None: ...
    @property
    def Buffer(self) -> Array_1[int]: ...
    @Buffer.setter
    def Buffer(self, value: Array_1[int]) -> Array_1[int]: ...
    @property
    def Count(self) -> int: ...
    @Count.setter
    def Count(self, value: int) -> int: ...
    @property
    def EndOfPacket(self) -> bool: ...
    @EndOfPacket.setter
    def EndOfPacket(self, value: bool) -> bool: ...
    @property
    def FilePath(self) -> str: ...
    @FilePath.setter
    def FilePath(self, value: str) -> str: ...
    @property
    def FileStream(self) -> FileStream: ...
    @FileStream.setter
    def FileStream(self, value: FileStream) -> FileStream: ...
    @property
    def MemoryBuffer(self) -> typing.Optional[ReadOnlyMemory_1[int]]: ...
    @MemoryBuffer.setter
    def MemoryBuffer(self, value: typing.Optional[ReadOnlyMemory_1[int]]) -> typing.Optional[ReadOnlyMemory_1[int]]: ...
    @property
    def Offset(self) -> int: ...
    @property
    def OffsetLong(self) -> int: ...
    @OffsetLong.setter
    def OffsetLong(self, value: int) -> int: ...


class Socket(IDisposable):
    @typing.overload
    def __init__(self, addressFamily: AddressFamily, socketType: SocketType, protocolType: ProtocolType) -> None: ...
    @typing.overload
    def __init__(self, handle: SafeSocketHandle) -> None: ...
    @typing.overload
    def __init__(self, socketInformation: SocketInformation) -> None: ...
    @typing.overload
    def __init__(self, socketType: SocketType, protocolType: ProtocolType) -> None: ...
    @property
    def AddressFamily(self) -> AddressFamily: ...
    @property
    def Available(self) -> int: ...
    @property
    def Blocking(self) -> bool: ...
    @Blocking.setter
    def Blocking(self, value: bool) -> bool: ...
    @property
    def Connected(self) -> bool: ...
    @property
    def DontFragment(self) -> bool: ...
    @DontFragment.setter
    def DontFragment(self, value: bool) -> bool: ...
    @property
    def DualMode(self) -> bool: ...
    @DualMode.setter
    def DualMode(self, value: bool) -> bool: ...
    @property
    def EnableBroadcast(self) -> bool: ...
    @EnableBroadcast.setter
    def EnableBroadcast(self, value: bool) -> bool: ...
    @property
    def ExclusiveAddressUse(self) -> bool: ...
    @ExclusiveAddressUse.setter
    def ExclusiveAddressUse(self, value: bool) -> bool: ...
    @property
    def Handle(self) -> int: ...
    @property
    def IsBound(self) -> bool: ...
    @property
    def LingerState(self) -> LingerOption: ...
    @LingerState.setter
    def LingerState(self, value: LingerOption) -> LingerOption: ...
    @property
    def LocalEndPoint(self) -> EndPoint: ...
    @property
    def MulticastLoopback(self) -> bool: ...
    @MulticastLoopback.setter
    def MulticastLoopback(self, value: bool) -> bool: ...
    @property
    def NoDelay(self) -> bool: ...
    @NoDelay.setter
    def NoDelay(self, value: bool) -> bool: ...
    @classmethod
    @property
    def OSSupportsIPv4(cls) -> bool: ...
    @classmethod
    @property
    def OSSupportsIPv6(cls) -> bool: ...
    @classmethod
    @property
    def OSSupportsUnixDomainSockets(cls) -> bool: ...
    @property
    def ProtocolType(self) -> ProtocolType: ...
    @property
    def ReceiveBufferSize(self) -> int: ...
    @ReceiveBufferSize.setter
    def ReceiveBufferSize(self, value: int) -> int: ...
    @property
    def ReceiveTimeout(self) -> int: ...
    @ReceiveTimeout.setter
    def ReceiveTimeout(self, value: int) -> int: ...
    @property
    def RemoteEndPoint(self) -> EndPoint: ...
    @property
    def SafeHandle(self) -> SafeSocketHandle: ...
    @property
    def SendBufferSize(self) -> int: ...
    @SendBufferSize.setter
    def SendBufferSize(self, value: int) -> int: ...
    @property
    def SendTimeout(self) -> int: ...
    @SendTimeout.setter
    def SendTimeout(self, value: int) -> int: ...
    @property
    def SocketType(self) -> SocketType: ...
    @classmethod
    @property
    def SupportsIPv4(cls) -> bool: ...
    @classmethod
    @property
    def SupportsIPv6(cls) -> bool: ...
    @property
    def Ttl(self) -> int: ...
    @Ttl.setter
    def Ttl(self, value: int) -> int: ...
    @property
    def UseOnlyOverlappedIO(self) -> bool: ...
    @UseOnlyOverlappedIO.setter
    def UseOnlyOverlappedIO(self, value: bool) -> bool: ...
    def Accept(self) -> Socket: ...
    def BeginDisconnect(self, reuseSocket: bool, callback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    def BeginReceiveFrom(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags, remoteEP: clr.Reference[EndPoint], callback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    def BeginReceiveMessageFrom(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags, remoteEP: clr.Reference[EndPoint], callback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    def BeginSendTo(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags, remoteEP: EndPoint, callback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    def Bind(self, localEP: EndPoint) -> None: ...
    @staticmethod
    def CancelConnectAsync(e: SocketAsyncEventArgs) -> None: ...
    def Disconnect(self, reuseSocket: bool) -> None: ...
    def Dispose(self) -> None: ...
    def DuplicateAndClose(self, targetProcessId: int) -> SocketInformation: ...
    def EndConnect(self, asyncResult: IAsyncResult) -> None: ...
    def EndDisconnect(self, asyncResult: IAsyncResult) -> None: ...
    def EndReceiveFrom(self, asyncResult: IAsyncResult, endPoint: clr.Reference[EndPoint]) -> int: ...
    def EndReceiveMessageFrom(self, asyncResult: IAsyncResult, socketFlags: clr.Reference[SocketFlags], endPoint: clr.Reference[EndPoint], ipPacketInformation: clr.Reference[IPPacketInformation]) -> int: ...
    def EndSendFile(self, asyncResult: IAsyncResult) -> None: ...
    def EndSendTo(self, asyncResult: IAsyncResult) -> int: ...
    def GetRawSocketOption(self, optionLevel: int, optionName: int, optionValue: Span_1[int]) -> int: ...
    def Poll(self, microSeconds: int, mode: SelectMode) -> bool: ...
    @staticmethod
    def Select(checkRead: IList, checkWrite: IList, checkError: IList, microSeconds: int) -> None: ...
    def SendPacketsAsync(self, e: SocketAsyncEventArgs) -> bool: ...
    def SetIPProtectionLevel(self, level: IPProtectionLevel) -> None: ...
    def SetRawSocketOption(self, optionLevel: int, optionName: int, optionValue: ReadOnlySpan_1[int]) -> None: ...
    def Shutdown(self, how: SocketShutdown) -> None: ...
    # Skipped AcceptAsync due to it being static, abstract and generic.

    AcceptAsync : AcceptAsync_MethodGroup
    class AcceptAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task_1[Socket]:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> ValueTask_1[Socket]:...
        @typing.overload
        def __call__(self, e: SocketAsyncEventArgs) -> bool:...
        @typing.overload
        def __call__(self, acceptSocket: Socket) -> Task_1[Socket]:...
        @typing.overload
        def __call__(self, acceptSocket: Socket, cancellationToken: CancellationToken) -> ValueTask_1[Socket]:...

    # Skipped BeginAccept due to it being static, abstract and generic.

    BeginAccept : BeginAccept_MethodGroup
    class BeginAccept_MethodGroup:
        @typing.overload
        def __call__(self, callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, receiveSize: int, callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, acceptSocket: Socket, receiveSize: int, callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...

    # Skipped BeginConnect due to it being static, abstract and generic.

    BeginConnect : BeginConnect_MethodGroup
    class BeginConnect_MethodGroup:
        @typing.overload
        def __call__(self, remoteEP: EndPoint, callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, addresses: Array_1[IPAddress], port: int, requestCallback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, host: str, port: int, requestCallback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, address: IPAddress, port: int, requestCallback: AsyncCallback, state: typing.Any) -> IAsyncResult:...

    # Skipped BeginReceive due to it being static, abstract and generic.

    BeginReceive : BeginReceive_MethodGroup
    class BeginReceive_MethodGroup:
        @typing.overload
        def __call__(self, buffers: IList_1[ArraySegment_1[int]], socketFlags: SocketFlags, callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, buffers: IList_1[ArraySegment_1[int]], socketFlags: SocketFlags, errorCode: clr.Reference[SocketError], callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags, callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags, errorCode: clr.Reference[SocketError], callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...

    # Skipped BeginSend due to it being static, abstract and generic.

    BeginSend : BeginSend_MethodGroup
    class BeginSend_MethodGroup:
        @typing.overload
        def __call__(self, buffers: IList_1[ArraySegment_1[int]], socketFlags: SocketFlags, callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, buffers: IList_1[ArraySegment_1[int]], socketFlags: SocketFlags, errorCode: clr.Reference[SocketError], callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags, callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags, errorCode: clr.Reference[SocketError], callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...

    # Skipped BeginSendFile due to it being static, abstract and generic.

    BeginSendFile : BeginSendFile_MethodGroup
    class BeginSendFile_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str, callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, fileName: str, preBuffer: Array_1[int], postBuffer: Array_1[int], flags: TransmitFileOptions, callback: AsyncCallback, state: typing.Any) -> IAsyncResult:...

    # Skipped Close due to it being static, abstract and generic.

    Close : Close_MethodGroup
    class Close_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, timeout: int) -> None:...

    # Skipped Connect due to it being static, abstract and generic.

    Connect : Connect_MethodGroup
    class Connect_MethodGroup:
        @typing.overload
        def __call__(self, remoteEP: EndPoint) -> None:...
        @typing.overload
        def __call__(self, addresses: Array_1[IPAddress], port: int) -> None:...
        @typing.overload
        def __call__(self, host: str, port: int) -> None:...
        @typing.overload
        def __call__(self, address: IPAddress, port: int) -> None:...

    # Skipped ConnectAsync due to it being static, abstract and generic.

    ConnectAsync : ConnectAsync_MethodGroup
    class ConnectAsync_MethodGroup:
        @typing.overload
        def __call__(self, e: SocketAsyncEventArgs) -> bool:...
        @typing.overload
        def __call__(self, remoteEP: EndPoint) -> Task:...
        @typing.overload
        def __call__(self, addresses: Array_1[IPAddress], port: int) -> Task:...
        @typing.overload
        def __call__(self, host: str, port: int) -> Task:...
        @typing.overload
        def __call__(self, address: IPAddress, port: int) -> Task:...
        @typing.overload
        def __call__(self, remoteEP: EndPoint, cancellationToken: CancellationToken) -> ValueTask:...
        @typing.overload
        def __call__(self, addresses: Array_1[IPAddress], port: int, cancellationToken: CancellationToken) -> ValueTask:...
        @typing.overload
        def __call__(self, socketType: SocketType, protocolType: ProtocolType, e: SocketAsyncEventArgs) -> bool:...
        @typing.overload
        def __call__(self, host: str, port: int, cancellationToken: CancellationToken) -> ValueTask:...
        @typing.overload
        def __call__(self, address: IPAddress, port: int, cancellationToken: CancellationToken) -> ValueTask:...

    # Skipped DisconnectAsync due to it being static, abstract and generic.

    DisconnectAsync : DisconnectAsync_MethodGroup
    class DisconnectAsync_MethodGroup:
        @typing.overload
        def __call__(self, e: SocketAsyncEventArgs) -> bool:...
        @typing.overload
        def __call__(self, reuseSocket: bool, cancellationToken: CancellationToken = ...) -> ValueTask:...

    # Skipped EndAccept due to it being static, abstract and generic.

    EndAccept : EndAccept_MethodGroup
    class EndAccept_MethodGroup:
        @typing.overload
        def __call__(self, asyncResult: IAsyncResult) -> Socket:...
        @typing.overload
        def __call__(self, buffer: clr.Reference[Array_1[int]], asyncResult: IAsyncResult) -> Socket:...
        @typing.overload
        def __call__(self, buffer: clr.Reference[Array_1[int]], bytesTransferred: clr.Reference[int], asyncResult: IAsyncResult) -> Socket:...

    # Skipped EndReceive due to it being static, abstract and generic.

    EndReceive : EndReceive_MethodGroup
    class EndReceive_MethodGroup:
        @typing.overload
        def __call__(self, asyncResult: IAsyncResult) -> int:...
        @typing.overload
        def __call__(self, asyncResult: IAsyncResult, errorCode: clr.Reference[SocketError]) -> int:...

    # Skipped EndSend due to it being static, abstract and generic.

    EndSend : EndSend_MethodGroup
    class EndSend_MethodGroup:
        @typing.overload
        def __call__(self, asyncResult: IAsyncResult) -> int:...
        @typing.overload
        def __call__(self, asyncResult: IAsyncResult, errorCode: clr.Reference[SocketError]) -> int:...

    # Skipped GetSocketOption due to it being static, abstract and generic.

    GetSocketOption : GetSocketOption_MethodGroup
    class GetSocketOption_MethodGroup:
        @typing.overload
        def __call__(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName) -> typing.Any:...
        @typing.overload
        def __call__(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionLength: int) -> Array_1[int]:...
        @typing.overload
        def __call__(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: Array_1[int]) -> None:...

    # Skipped IOControl due to it being static, abstract and generic.

    IOControl : IOControl_MethodGroup
    class IOControl_MethodGroup:
        @typing.overload
        def __call__(self, ioControlCode: int, optionInValue: Array_1[int], optionOutValue: Array_1[int]) -> int:...
        @typing.overload
        def __call__(self, ioControlCode: IOControlCode, optionInValue: Array_1[int], optionOutValue: Array_1[int]) -> int:...

    # Skipped Listen due to it being static, abstract and generic.

    Listen : Listen_MethodGroup
    class Listen_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, backlog: int) -> None:...

    # Skipped Receive due to it being static, abstract and generic.

    Receive : Receive_MethodGroup
    class Receive_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Array_1[int]) -> int:...
        @typing.overload
        def __call__(self, buffers: IList_1[ArraySegment_1[int]]) -> int:...
        @typing.overload
        def __call__(self, buffer: Span_1[int]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], socketFlags: SocketFlags) -> int:...
        @typing.overload
        def __call__(self, buffers: IList_1[ArraySegment_1[int]], socketFlags: SocketFlags) -> int:...
        @typing.overload
        def __call__(self, buffer: Span_1[int], socketFlags: SocketFlags) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], size: int, socketFlags: SocketFlags) -> int:...
        @typing.overload
        def __call__(self, buffers: IList_1[ArraySegment_1[int]], socketFlags: SocketFlags, errorCode: clr.Reference[SocketError]) -> int:...
        @typing.overload
        def __call__(self, buffer: Span_1[int], socketFlags: SocketFlags, errorCode: clr.Reference[SocketError]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags, errorCode: clr.Reference[SocketError]) -> int:...

    # Skipped ReceiveAsync due to it being static, abstract and generic.

    ReceiveAsync : ReceiveAsync_MethodGroup
    class ReceiveAsync_MethodGroup:
        @typing.overload
        def __call__(self, e: SocketAsyncEventArgs) -> bool:...
        @typing.overload
        def __call__(self, buffer: ArraySegment_1[int], socketFlags: SocketFlags) -> Task_1[int]:...
        @typing.overload
        def __call__(self, buffers: IList_1[ArraySegment_1[int]], socketFlags: SocketFlags) -> Task_1[int]:...
        @typing.overload
        def __call__(self, buffer: Memory_1[int], socketFlags: SocketFlags, cancellationToken: CancellationToken) -> ValueTask_1[int]:...

    # Skipped ReceiveFrom due to it being static, abstract and generic.

    ReceiveFrom : ReceiveFrom_MethodGroup
    class ReceiveFrom_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Array_1[int], remoteEP: clr.Reference[EndPoint]) -> int:...
        @typing.overload
        def __call__(self, buffer: Span_1[int], remoteEP: clr.Reference[EndPoint]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], socketFlags: SocketFlags, remoteEP: clr.Reference[EndPoint]) -> int:...
        @typing.overload
        def __call__(self, buffer: Span_1[int], socketFlags: SocketFlags, remoteEP: clr.Reference[EndPoint]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], size: int, socketFlags: SocketFlags, remoteEP: clr.Reference[EndPoint]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags, remoteEP: clr.Reference[EndPoint]) -> int:...

    # Skipped ReceiveFromAsync due to it being static, abstract and generic.

    ReceiveFromAsync : ReceiveFromAsync_MethodGroup
    class ReceiveFromAsync_MethodGroup:
        @typing.overload
        def __call__(self, e: SocketAsyncEventArgs) -> bool:...
        @typing.overload
        def __call__(self, buffer: ArraySegment_1[int], socketFlags: SocketFlags, remoteEndPoint: EndPoint) -> Task_1[SocketReceiveFromResult]:...
        @typing.overload
        def __call__(self, buffer: Memory_1[int], socketFlags: SocketFlags, remoteEndPoint: EndPoint, cancellationToken: CancellationToken = ...) -> ValueTask_1[SocketReceiveFromResult]:...

    # Skipped ReceiveMessageFrom due to it being static, abstract and generic.

    ReceiveMessageFrom : ReceiveMessageFrom_MethodGroup
    class ReceiveMessageFrom_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Span_1[int], socketFlags: clr.Reference[SocketFlags], remoteEP: clr.Reference[EndPoint], ipPacketInformation: clr.Reference[IPPacketInformation]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, size: int, socketFlags: clr.Reference[SocketFlags], remoteEP: clr.Reference[EndPoint], ipPacketInformation: clr.Reference[IPPacketInformation]) -> int:...

    # Skipped ReceiveMessageFromAsync due to it being static, abstract and generic.

    ReceiveMessageFromAsync : ReceiveMessageFromAsync_MethodGroup
    class ReceiveMessageFromAsync_MethodGroup:
        @typing.overload
        def __call__(self, e: SocketAsyncEventArgs) -> bool:...
        @typing.overload
        def __call__(self, buffer: ArraySegment_1[int], socketFlags: SocketFlags, remoteEndPoint: EndPoint) -> Task_1[SocketReceiveMessageFromResult]:...
        @typing.overload
        def __call__(self, buffer: Memory_1[int], socketFlags: SocketFlags, remoteEndPoint: EndPoint, cancellationToken: CancellationToken = ...) -> ValueTask_1[SocketReceiveMessageFromResult]:...

    # Skipped Send due to it being static, abstract and generic.

    Send : Send_MethodGroup
    class Send_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Array_1[int]) -> int:...
        @typing.overload
        def __call__(self, buffers: IList_1[ArraySegment_1[int]]) -> int:...
        @typing.overload
        def __call__(self, buffer: ReadOnlySpan_1[int]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], socketFlags: SocketFlags) -> int:...
        @typing.overload
        def __call__(self, buffers: IList_1[ArraySegment_1[int]], socketFlags: SocketFlags) -> int:...
        @typing.overload
        def __call__(self, buffer: ReadOnlySpan_1[int], socketFlags: SocketFlags) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], size: int, socketFlags: SocketFlags) -> int:...
        @typing.overload
        def __call__(self, buffers: IList_1[ArraySegment_1[int]], socketFlags: SocketFlags, errorCode: clr.Reference[SocketError]) -> int:...
        @typing.overload
        def __call__(self, buffer: ReadOnlySpan_1[int], socketFlags: SocketFlags, errorCode: clr.Reference[SocketError]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags, errorCode: clr.Reference[SocketError]) -> int:...

    # Skipped SendAsync due to it being static, abstract and generic.

    SendAsync : SendAsync_MethodGroup
    class SendAsync_MethodGroup:
        @typing.overload
        def __call__(self, e: SocketAsyncEventArgs) -> bool:...
        @typing.overload
        def __call__(self, buffer: ArraySegment_1[int], socketFlags: SocketFlags) -> Task_1[int]:...
        @typing.overload
        def __call__(self, buffers: IList_1[ArraySegment_1[int]], socketFlags: SocketFlags) -> Task_1[int]:...
        @typing.overload
        def __call__(self, buffer: ReadOnlyMemory_1[int], socketFlags: SocketFlags, cancellationToken: CancellationToken) -> ValueTask_1[int]:...

    # Skipped SendFile due to it being static, abstract and generic.

    SendFile : SendFile_MethodGroup
    class SendFile_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None:...
        @typing.overload
        def __call__(self, fileName: str, preBuffer: Array_1[int], postBuffer: Array_1[int], flags: TransmitFileOptions) -> None:...
        @typing.overload
        def __call__(self, fileName: str, preBuffer: ReadOnlySpan_1[int], postBuffer: ReadOnlySpan_1[int], flags: TransmitFileOptions) -> None:...

    # Skipped SendFileAsync due to it being static, abstract and generic.

    SendFileAsync : SendFileAsync_MethodGroup
    class SendFileAsync_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str, cancellationToken: CancellationToken = ...) -> ValueTask:...
        @typing.overload
        def __call__(self, fileName: str, preBuffer: ReadOnlyMemory_1[int], postBuffer: ReadOnlyMemory_1[int], flags: TransmitFileOptions, cancellationToken: CancellationToken = ...) -> ValueTask:...

    # Skipped SendTo due to it being static, abstract and generic.

    SendTo : SendTo_MethodGroup
    class SendTo_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Array_1[int], remoteEP: EndPoint) -> int:...
        @typing.overload
        def __call__(self, buffer: ReadOnlySpan_1[int], remoteEP: EndPoint) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], socketFlags: SocketFlags, remoteEP: EndPoint) -> int:...
        @typing.overload
        def __call__(self, buffer: ReadOnlySpan_1[int], socketFlags: SocketFlags, remoteEP: EndPoint) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], size: int, socketFlags: SocketFlags, remoteEP: EndPoint) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, size: int, socketFlags: SocketFlags, remoteEP: EndPoint) -> int:...

    # Skipped SendToAsync due to it being static, abstract and generic.

    SendToAsync : SendToAsync_MethodGroup
    class SendToAsync_MethodGroup:
        @typing.overload
        def __call__(self, e: SocketAsyncEventArgs) -> bool:...
        @typing.overload
        def __call__(self, buffer: ArraySegment_1[int], socketFlags: SocketFlags, remoteEP: EndPoint) -> Task_1[int]:...
        @typing.overload
        def __call__(self, buffer: ReadOnlyMemory_1[int], socketFlags: SocketFlags, remoteEP: EndPoint, cancellationToken: CancellationToken = ...) -> ValueTask_1[int]:...

    # Skipped SetSocketOption due to it being static, abstract and generic.

    SetSocketOption : SetSocketOption_MethodGroup
    class SetSocketOption_MethodGroup:
        @typing.overload
        def __call__(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: int) -> None:...
        @typing.overload
        def __call__(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: Array_1[int]) -> None:...
        # Method SetSocketOption(optionLevel : SocketOptionLevel, optionName : SocketOptionName, optionValue : Boolean) was skipped since it collides with above method
        @typing.overload
        def __call__(self, optionLevel: SocketOptionLevel, optionName: SocketOptionName, optionValue: typing.Any) -> None:...



class SocketAsyncEventArgs(EventArgs, IDisposable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, unsafeSuppressExecutionContextFlow: bool) -> None: ...
    @property
    def AcceptSocket(self) -> Socket: ...
    @AcceptSocket.setter
    def AcceptSocket(self, value: Socket) -> Socket: ...
    @property
    def Buffer(self) -> Array_1[int]: ...
    @property
    def BufferList(self) -> IList_1[ArraySegment_1[int]]: ...
    @BufferList.setter
    def BufferList(self, value: IList_1[ArraySegment_1[int]]) -> IList_1[ArraySegment_1[int]]: ...
    @property
    def BytesTransferred(self) -> int: ...
    @property
    def ConnectByNameError(self) -> Exception: ...
    @property
    def ConnectSocket(self) -> Socket: ...
    @property
    def Count(self) -> int: ...
    @property
    def DisconnectReuseSocket(self) -> bool: ...
    @DisconnectReuseSocket.setter
    def DisconnectReuseSocket(self, value: bool) -> bool: ...
    @property
    def LastOperation(self) -> SocketAsyncOperation: ...
    @property
    def MemoryBuffer(self) -> Memory_1[int]: ...
    @property
    def Offset(self) -> int: ...
    @property
    def ReceiveMessageFromPacketInfo(self) -> IPPacketInformation: ...
    @property
    def RemoteEndPoint(self) -> EndPoint: ...
    @RemoteEndPoint.setter
    def RemoteEndPoint(self, value: EndPoint) -> EndPoint: ...
    @property
    def SendPacketsElements(self) -> Array_1[SendPacketsElement]: ...
    @SendPacketsElements.setter
    def SendPacketsElements(self, value: Array_1[SendPacketsElement]) -> Array_1[SendPacketsElement]: ...
    @property
    def SendPacketsFlags(self) -> TransmitFileOptions: ...
    @SendPacketsFlags.setter
    def SendPacketsFlags(self, value: TransmitFileOptions) -> TransmitFileOptions: ...
    @property
    def SendPacketsSendSize(self) -> int: ...
    @SendPacketsSendSize.setter
    def SendPacketsSendSize(self, value: int) -> int: ...
    @property
    def SocketError(self) -> SocketError: ...
    @SocketError.setter
    def SocketError(self, value: SocketError) -> SocketError: ...
    @property
    def SocketFlags(self) -> SocketFlags: ...
    @SocketFlags.setter
    def SocketFlags(self, value: SocketFlags) -> SocketFlags: ...
    @property
    def UserToken(self) -> typing.Any: ...
    @UserToken.setter
    def UserToken(self, value: typing.Any) -> typing.Any: ...
    def Dispose(self) -> None: ...
    # Skipped SetBuffer due to it being static, abstract and generic.

    SetBuffer : SetBuffer_MethodGroup
    class SetBuffer_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Memory_1[int]) -> None:...
        @typing.overload
        def __call__(self, offset: int, count: int) -> None:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> None:...



class SocketAsyncOperation(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SocketAsyncOperation # 0
    Accept : SocketAsyncOperation # 1
    Connect : SocketAsyncOperation # 2
    Disconnect : SocketAsyncOperation # 3
    Receive : SocketAsyncOperation # 4
    ReceiveFrom : SocketAsyncOperation # 5
    ReceiveMessageFrom : SocketAsyncOperation # 6
    Send : SocketAsyncOperation # 7
    SendPackets : SocketAsyncOperation # 8
    SendTo : SocketAsyncOperation # 9


class SocketError(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Success : SocketError # 0
    OperationAborted : SocketError # 995
    IOPending : SocketError # 997
    Interrupted : SocketError # 10004
    AccessDenied : SocketError # 10013
    Fault : SocketError # 10014
    InvalidArgument : SocketError # 10022
    TooManyOpenSockets : SocketError # 10024
    WouldBlock : SocketError # 10035
    InProgress : SocketError # 10036
    AlreadyInProgress : SocketError # 10037
    NotSocket : SocketError # 10038
    DestinationAddressRequired : SocketError # 10039
    MessageSize : SocketError # 10040
    ProtocolType : SocketError # 10041
    ProtocolOption : SocketError # 10042
    ProtocolNotSupported : SocketError # 10043
    SocketNotSupported : SocketError # 10044
    OperationNotSupported : SocketError # 10045
    ProtocolFamilyNotSupported : SocketError # 10046
    AddressFamilyNotSupported : SocketError # 10047
    AddressAlreadyInUse : SocketError # 10048
    AddressNotAvailable : SocketError # 10049
    NetworkDown : SocketError # 10050
    NetworkUnreachable : SocketError # 10051
    NetworkReset : SocketError # 10052
    ConnectionAborted : SocketError # 10053
    ConnectionReset : SocketError # 10054
    NoBufferSpaceAvailable : SocketError # 10055
    IsConnected : SocketError # 10056
    NotConnected : SocketError # 10057
    Shutdown : SocketError # 10058
    TimedOut : SocketError # 10060
    ConnectionRefused : SocketError # 10061
    HostDown : SocketError # 10064
    HostUnreachable : SocketError # 10065
    ProcessLimit : SocketError # 10067
    SystemNotReady : SocketError # 10091
    VersionNotSupported : SocketError # 10092
    NotInitialized : SocketError # 10093
    Disconnecting : SocketError # 10101
    TypeNotFound : SocketError # 10109
    HostNotFound : SocketError # 11001
    TryAgain : SocketError # 11002
    NoRecovery : SocketError # 11003
    NoData : SocketError # 11004
    SocketError : SocketError # -1


class SocketException(Win32Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, errorCode: int) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def ErrorCode(self) -> int: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def NativeErrorCode(self) -> int: ...
    @property
    def SocketErrorCode(self) -> SocketError: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class SocketFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SocketFlags # 0
    OutOfBand : SocketFlags # 1
    Peek : SocketFlags # 2
    DontRoute : SocketFlags # 4
    Truncated : SocketFlags # 256
    ControlDataTruncated : SocketFlags # 512
    Broadcast : SocketFlags # 1024
    Multicast : SocketFlags # 2048
    Partial : SocketFlags # 32768


class SocketInformation:
    @property
    def Options(self) -> SocketInformationOptions: ...
    @Options.setter
    def Options(self, value: SocketInformationOptions) -> SocketInformationOptions: ...
    @property
    def ProtocolInformation(self) -> Array_1[int]: ...
    @ProtocolInformation.setter
    def ProtocolInformation(self, value: Array_1[int]) -> Array_1[int]: ...


class SocketInformationOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    NonBlocking : SocketInformationOptions # 1
    Connected : SocketInformationOptions # 2
    Listening : SocketInformationOptions # 4
    UseOnlyOverlappedIO : SocketInformationOptions # 8


class SocketOptionLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    IP : SocketOptionLevel # 0
    Tcp : SocketOptionLevel # 6
    Udp : SocketOptionLevel # 17
    IPv6 : SocketOptionLevel # 41
    Socket : SocketOptionLevel # 65535


class SocketOptionName(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    IPOptions : SocketOptionName # 1
    NoChecksum : SocketOptionName # 1
    NoDelay : SocketOptionName # 1
    Debug : SocketOptionName # 1
    HeaderIncluded : SocketOptionName # 2
    AcceptConnection : SocketOptionName # 2
    Expedited : SocketOptionName # 2
    BsdUrgent : SocketOptionName # 2
    TypeOfService : SocketOptionName # 3
    TcpKeepAliveTime : SocketOptionName # 3
    IpTimeToLive : SocketOptionName # 4
    ReuseAddress : SocketOptionName # 4
    KeepAlive : SocketOptionName # 8
    MulticastInterface : SocketOptionName # 9
    MulticastTimeToLive : SocketOptionName # 10
    MulticastLoopback : SocketOptionName # 11
    AddMembership : SocketOptionName # 12
    DropMembership : SocketOptionName # 13
    DontFragment : SocketOptionName # 14
    AddSourceMembership : SocketOptionName # 15
    TcpKeepAliveRetryCount : SocketOptionName # 16
    DontRoute : SocketOptionName # 16
    DropSourceMembership : SocketOptionName # 16
    BlockSource : SocketOptionName # 17
    TcpKeepAliveInterval : SocketOptionName # 17
    UnblockSource : SocketOptionName # 18
    PacketInformation : SocketOptionName # 19
    ChecksumCoverage : SocketOptionName # 20
    HopLimit : SocketOptionName # 21
    IPProtectionLevel : SocketOptionName # 23
    IPv6Only : SocketOptionName # 27
    Broadcast : SocketOptionName # 32
    UseLoopback : SocketOptionName # 64
    Linger : SocketOptionName # 128
    OutOfBandInline : SocketOptionName # 256
    SendBuffer : SocketOptionName # 4097
    ReceiveBuffer : SocketOptionName # 4098
    SendLowWater : SocketOptionName # 4099
    ReceiveLowWater : SocketOptionName # 4100
    SendTimeout : SocketOptionName # 4101
    ReceiveTimeout : SocketOptionName # 4102
    Error : SocketOptionName # 4103
    Type : SocketOptionName # 4104
    ReuseUnicastPort : SocketOptionName # 12295
    UpdateAcceptContext : SocketOptionName # 28683
    UpdateConnectContext : SocketOptionName # 28688
    MaxConnections : SocketOptionName # 2147483647
    DontLinger : SocketOptionName # -129
    ExclusiveAddressUse : SocketOptionName # -5


class SocketReceiveFromResult:
    ReceivedBytes : int
    RemoteEndPoint : EndPoint


class SocketReceiveMessageFromResult:
    PacketInformation : IPPacketInformation
    ReceivedBytes : int
    RemoteEndPoint : EndPoint
    SocketFlags : SocketFlags


class SocketShutdown(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Receive : SocketShutdown # 0
    Send : SocketShutdown # 1
    Both : SocketShutdown # 2


class SocketTaskExtensions(abc.ABC):
    @staticmethod
    def ReceiveFromAsync(socket: Socket, buffer: ArraySegment_1[int], socketFlags: SocketFlags, remoteEndPoint: EndPoint) -> Task_1[SocketReceiveFromResult]: ...
    @staticmethod
    def ReceiveMessageFromAsync(socket: Socket, buffer: ArraySegment_1[int], socketFlags: SocketFlags, remoteEndPoint: EndPoint) -> Task_1[SocketReceiveMessageFromResult]: ...
    @staticmethod
    def SendToAsync(socket: Socket, buffer: ArraySegment_1[int], socketFlags: SocketFlags, remoteEP: EndPoint) -> Task_1[int]: ...
    # Skipped AcceptAsync due to it being static, abstract and generic.

    AcceptAsync : AcceptAsync_MethodGroup
    class AcceptAsync_MethodGroup:
        @typing.overload
        def __call__(self, socket: Socket) -> Task_1[Socket]:...
        @typing.overload
        def __call__(self, socket: Socket, acceptSocket: Socket) -> Task_1[Socket]:...

    # Skipped ConnectAsync due to it being static, abstract and generic.

    ConnectAsync : ConnectAsync_MethodGroup
    class ConnectAsync_MethodGroup:
        @typing.overload
        def __call__(self, socket: Socket, remoteEP: EndPoint) -> Task:...
        @typing.overload
        def __call__(self, socket: Socket, addresses: Array_1[IPAddress], port: int) -> Task:...
        @typing.overload
        def __call__(self, socket: Socket, host: str, port: int) -> Task:...
        @typing.overload
        def __call__(self, socket: Socket, address: IPAddress, port: int) -> Task:...
        @typing.overload
        def __call__(self, socket: Socket, remoteEP: EndPoint, cancellationToken: CancellationToken) -> ValueTask:...
        @typing.overload
        def __call__(self, socket: Socket, addresses: Array_1[IPAddress], port: int, cancellationToken: CancellationToken) -> ValueTask:...
        @typing.overload
        def __call__(self, socket: Socket, host: str, port: int, cancellationToken: CancellationToken) -> ValueTask:...
        @typing.overload
        def __call__(self, socket: Socket, address: IPAddress, port: int, cancellationToken: CancellationToken) -> ValueTask:...

    # Skipped ReceiveAsync due to it being static, abstract and generic.

    ReceiveAsync : ReceiveAsync_MethodGroup
    class ReceiveAsync_MethodGroup:
        @typing.overload
        def __call__(self, socket: Socket, buffer: ArraySegment_1[int], socketFlags: SocketFlags) -> Task_1[int]:...
        @typing.overload
        def __call__(self, socket: Socket, buffers: IList_1[ArraySegment_1[int]], socketFlags: SocketFlags) -> Task_1[int]:...
        @typing.overload
        def __call__(self, socket: Socket, buffer: Memory_1[int], socketFlags: SocketFlags, cancellationToken: CancellationToken = ...) -> ValueTask_1[int]:...

    # Skipped SendAsync due to it being static, abstract and generic.

    SendAsync : SendAsync_MethodGroup
    class SendAsync_MethodGroup:
        @typing.overload
        def __call__(self, socket: Socket, buffer: ArraySegment_1[int], socketFlags: SocketFlags) -> Task_1[int]:...
        @typing.overload
        def __call__(self, socket: Socket, buffers: IList_1[ArraySegment_1[int]], socketFlags: SocketFlags) -> Task_1[int]:...
        @typing.overload
        def __call__(self, socket: Socket, buffer: ReadOnlyMemory_1[int], socketFlags: SocketFlags, cancellationToken: CancellationToken = ...) -> ValueTask_1[int]:...



class SocketType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Stream : SocketType # 1
    Dgram : SocketType # 2
    Raw : SocketType # 3
    Rdm : SocketType # 4
    Seqpacket : SocketType # 5
    Unknown : SocketType # -1


class TcpClient(IDisposable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, family: AddressFamily) -> None: ...
    @typing.overload
    def __init__(self, hostname: str, port: int) -> None: ...
    @typing.overload
    def __init__(self, localEP: IPEndPoint) -> None: ...
    @property
    def Available(self) -> int: ...
    @property
    def Client(self) -> Socket: ...
    @Client.setter
    def Client(self, value: Socket) -> Socket: ...
    @property
    def Connected(self) -> bool: ...
    @property
    def ExclusiveAddressUse(self) -> bool: ...
    @ExclusiveAddressUse.setter
    def ExclusiveAddressUse(self, value: bool) -> bool: ...
    @property
    def LingerState(self) -> LingerOption: ...
    @LingerState.setter
    def LingerState(self, value: LingerOption) -> LingerOption: ...
    @property
    def NoDelay(self) -> bool: ...
    @NoDelay.setter
    def NoDelay(self, value: bool) -> bool: ...
    @property
    def ReceiveBufferSize(self) -> int: ...
    @ReceiveBufferSize.setter
    def ReceiveBufferSize(self, value: int) -> int: ...
    @property
    def ReceiveTimeout(self) -> int: ...
    @ReceiveTimeout.setter
    def ReceiveTimeout(self, value: int) -> int: ...
    @property
    def SendBufferSize(self) -> int: ...
    @SendBufferSize.setter
    def SendBufferSize(self, value: int) -> int: ...
    @property
    def SendTimeout(self) -> int: ...
    @SendTimeout.setter
    def SendTimeout(self, value: int) -> int: ...
    def Close(self) -> None: ...
    def Dispose(self) -> None: ...
    def EndConnect(self, asyncResult: IAsyncResult) -> None: ...
    def GetStream(self) -> NetworkStream: ...
    # Skipped BeginConnect due to it being static, abstract and generic.

    BeginConnect : BeginConnect_MethodGroup
    class BeginConnect_MethodGroup:
        @typing.overload
        def __call__(self, addresses: Array_1[IPAddress], port: int, requestCallback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, host: str, port: int, requestCallback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, address: IPAddress, port: int, requestCallback: AsyncCallback, state: typing.Any) -> IAsyncResult:...

    # Skipped Connect due to it being static, abstract and generic.

    Connect : Connect_MethodGroup
    class Connect_MethodGroup:
        @typing.overload
        def __call__(self, remoteEP: IPEndPoint) -> None:...
        @typing.overload
        def __call__(self, ipAddresses: Array_1[IPAddress], port: int) -> None:...
        @typing.overload
        def __call__(self, hostname: str, port: int) -> None:...
        @typing.overload
        def __call__(self, address: IPAddress, port: int) -> None:...

    # Skipped ConnectAsync due to it being static, abstract and generic.

    ConnectAsync : ConnectAsync_MethodGroup
    class ConnectAsync_MethodGroup:
        @typing.overload
        def __call__(self, remoteEP: IPEndPoint) -> Task:...
        @typing.overload
        def __call__(self, addresses: Array_1[IPAddress], port: int) -> Task:...
        @typing.overload
        def __call__(self, host: str, port: int) -> Task:...
        @typing.overload
        def __call__(self, remoteEP: IPEndPoint, cancellationToken: CancellationToken) -> ValueTask:...
        @typing.overload
        def __call__(self, address: IPAddress, port: int) -> Task:...
        @typing.overload
        def __call__(self, addresses: Array_1[IPAddress], port: int, cancellationToken: CancellationToken) -> ValueTask:...
        @typing.overload
        def __call__(self, host: str, port: int, cancellationToken: CancellationToken) -> ValueTask:...
        @typing.overload
        def __call__(self, address: IPAddress, port: int, cancellationToken: CancellationToken) -> ValueTask:...



class TcpListener:
    @typing.overload
    def __init__(self, localaddr: IPAddress, port: int) -> None: ...
    @typing.overload
    def __init__(self, localEP: IPEndPoint) -> None: ...
    @typing.overload
    def __init__(self, port: int) -> None: ...
    @property
    def ExclusiveAddressUse(self) -> bool: ...
    @ExclusiveAddressUse.setter
    def ExclusiveAddressUse(self, value: bool) -> bool: ...
    @property
    def LocalEndpoint(self) -> EndPoint: ...
    @property
    def Server(self) -> Socket: ...
    def AcceptSocket(self) -> Socket: ...
    def AcceptTcpClient(self) -> TcpClient: ...
    def AllowNatTraversal(self, allowed: bool) -> None: ...
    def BeginAcceptSocket(self, callback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    def BeginAcceptTcpClient(self, callback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    @staticmethod
    def Create(port: int) -> TcpListener: ...
    def EndAcceptSocket(self, asyncResult: IAsyncResult) -> Socket: ...
    def EndAcceptTcpClient(self, asyncResult: IAsyncResult) -> TcpClient: ...
    def Pending(self) -> bool: ...
    def Stop(self) -> None: ...
    # Skipped AcceptSocketAsync due to it being static, abstract and generic.

    AcceptSocketAsync : AcceptSocketAsync_MethodGroup
    class AcceptSocketAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task_1[Socket]:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> ValueTask_1[Socket]:...

    # Skipped AcceptTcpClientAsync due to it being static, abstract and generic.

    AcceptTcpClientAsync : AcceptTcpClientAsync_MethodGroup
    class AcceptTcpClientAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task_1[TcpClient]:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> ValueTask_1[TcpClient]:...

    # Skipped Start due to it being static, abstract and generic.

    Start : Start_MethodGroup
    class Start_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, backlog: int) -> None:...



class TransmitFileOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    UseDefaultWorkerThread : TransmitFileOptions # 0
    Disconnect : TransmitFileOptions # 1
    ReuseSocket : TransmitFileOptions # 2
    WriteBehind : TransmitFileOptions # 4
    UseSystemThread : TransmitFileOptions # 16
    UseKernelApc : TransmitFileOptions # 32


class UdpClient(IDisposable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, family: AddressFamily) -> None: ...
    @typing.overload
    def __init__(self, hostname: str, port: int) -> None: ...
    @typing.overload
    def __init__(self, localEP: IPEndPoint) -> None: ...
    @typing.overload
    def __init__(self, port: int) -> None: ...
    @typing.overload
    def __init__(self, port: int, family: AddressFamily) -> None: ...
    @property
    def Available(self) -> int: ...
    @property
    def Client(self) -> Socket: ...
    @Client.setter
    def Client(self, value: Socket) -> Socket: ...
    @property
    def DontFragment(self) -> bool: ...
    @DontFragment.setter
    def DontFragment(self, value: bool) -> bool: ...
    @property
    def EnableBroadcast(self) -> bool: ...
    @EnableBroadcast.setter
    def EnableBroadcast(self, value: bool) -> bool: ...
    @property
    def ExclusiveAddressUse(self) -> bool: ...
    @ExclusiveAddressUse.setter
    def ExclusiveAddressUse(self, value: bool) -> bool: ...
    @property
    def MulticastLoopback(self) -> bool: ...
    @MulticastLoopback.setter
    def MulticastLoopback(self, value: bool) -> bool: ...
    @property
    def Ttl(self) -> int: ...
    @Ttl.setter
    def Ttl(self, value: int) -> int: ...
    def AllowNatTraversal(self, allowed: bool) -> None: ...
    def BeginReceive(self, requestCallback: AsyncCallback, state: typing.Any) -> IAsyncResult: ...
    def Close(self) -> None: ...
    def Dispose(self) -> None: ...
    def EndReceive(self, asyncResult: IAsyncResult, remoteEP: clr.Reference[IPEndPoint]) -> Array_1[int]: ...
    def EndSend(self, asyncResult: IAsyncResult) -> int: ...
    def Receive(self, remoteEP: clr.Reference[IPEndPoint]) -> Array_1[int]: ...
    # Skipped BeginSend due to it being static, abstract and generic.

    BeginSend : BeginSend_MethodGroup
    class BeginSend_MethodGroup:
        @typing.overload
        def __call__(self, datagram: Array_1[int], bytes: int, requestCallback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, datagram: Array_1[int], bytes: int, endPoint: IPEndPoint, requestCallback: AsyncCallback, state: typing.Any) -> IAsyncResult:...
        @typing.overload
        def __call__(self, datagram: Array_1[int], bytes: int, hostname: str, port: int, requestCallback: AsyncCallback, state: typing.Any) -> IAsyncResult:...

    # Skipped Connect due to it being static, abstract and generic.

    Connect : Connect_MethodGroup
    class Connect_MethodGroup:
        @typing.overload
        def __call__(self, endPoint: IPEndPoint) -> None:...
        @typing.overload
        def __call__(self, hostname: str, port: int) -> None:...
        @typing.overload
        def __call__(self, addr: IPAddress, port: int) -> None:...

    # Skipped DropMulticastGroup due to it being static, abstract and generic.

    DropMulticastGroup : DropMulticastGroup_MethodGroup
    class DropMulticastGroup_MethodGroup:
        @typing.overload
        def __call__(self, multicastAddr: IPAddress) -> None:...
        @typing.overload
        def __call__(self, multicastAddr: IPAddress, ifindex: int) -> None:...

    # Skipped JoinMulticastGroup due to it being static, abstract and generic.

    JoinMulticastGroup : JoinMulticastGroup_MethodGroup
    class JoinMulticastGroup_MethodGroup:
        @typing.overload
        def __call__(self, multicastAddr: IPAddress) -> None:...
        @typing.overload
        def __call__(self, ifindex: int, multicastAddr: IPAddress) -> None:...
        @typing.overload
        def __call__(self, multicastAddr: IPAddress, timeToLive: int) -> None:...
        @typing.overload
        def __call__(self, multicastAddr: IPAddress, localAddress: IPAddress) -> None:...

    # Skipped ReceiveAsync due to it being static, abstract and generic.

    ReceiveAsync : ReceiveAsync_MethodGroup
    class ReceiveAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task_1[UdpReceiveResult]:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> ValueTask_1[UdpReceiveResult]:...

    # Skipped Send due to it being static, abstract and generic.

    Send : Send_MethodGroup
    class Send_MethodGroup:
        @typing.overload
        def __call__(self, datagram: ReadOnlySpan_1[int]) -> int:...
        @typing.overload
        def __call__(self, dgram: Array_1[int], bytes: int) -> int:...
        @typing.overload
        def __call__(self, datagram: ReadOnlySpan_1[int], endPoint: IPEndPoint) -> int:...
        @typing.overload
        def __call__(self, dgram: Array_1[int], bytes: int, endPoint: IPEndPoint) -> int:...
        @typing.overload
        def __call__(self, datagram: ReadOnlySpan_1[int], hostname: str, port: int) -> int:...
        @typing.overload
        def __call__(self, dgram: Array_1[int], bytes: int, hostname: str, port: int) -> int:...

    # Skipped SendAsync due to it being static, abstract and generic.

    SendAsync : SendAsync_MethodGroup
    class SendAsync_MethodGroup:
        @typing.overload
        def __call__(self, datagram: Array_1[int], bytes: int) -> Task_1[int]:...
        @typing.overload
        def __call__(self, datagram: ReadOnlyMemory_1[int], cancellationToken: CancellationToken = ...) -> ValueTask_1[int]:...
        @typing.overload
        def __call__(self, datagram: Array_1[int], bytes: int, endPoint: IPEndPoint) -> Task_1[int]:...
        @typing.overload
        def __call__(self, datagram: ReadOnlyMemory_1[int], endPoint: IPEndPoint, cancellationToken: CancellationToken = ...) -> ValueTask_1[int]:...
        @typing.overload
        def __call__(self, datagram: Array_1[int], bytes: int, hostname: str, port: int) -> Task_1[int]:...
        @typing.overload
        def __call__(self, datagram: ReadOnlyMemory_1[int], hostname: str, port: int, cancellationToken: CancellationToken = ...) -> ValueTask_1[int]:...



class UdpReceiveResult(IEquatable_1[UdpReceiveResult]):
    def __init__(self, buffer: Array_1[int], remoteEndPoint: IPEndPoint) -> None: ...
    @property
    def Buffer(self) -> Array_1[int]: ...
    @property
    def RemoteEndPoint(self) -> IPEndPoint: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: UdpReceiveResult, right: UdpReceiveResult) -> bool: ...
    def __ne__(self, left: UdpReceiveResult, right: UdpReceiveResult) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: UdpReceiveResult) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class UnixDomainSocketEndPoint(EndPoint):
    def __init__(self, path: str) -> None: ...
    @property
    def AddressFamily(self) -> AddressFamily: ...
    def Create(self, socketAddress: SocketAddress) -> EndPoint: ...
    def Serialize(self) -> SocketAddress: ...
    def ToString(self) -> str: ...

