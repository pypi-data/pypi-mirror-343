import typing, abc
from System.IO import Stream
from System.ComponentModel import MemberDescriptor, IContainer, PropertyDescriptorCollection
from System.Collections import ICollection
from System import Attribute, IServiceProvider, EventArgs, MulticastDelegate, IAsyncResult, AsyncCallback, IDisposable
from System.ComponentModel.Design import IDesignerHost
from System.Reflection import MemberInfo, MethodInfo

class ComponentSerializationService(abc.ABC):
    @abc.abstractmethod
    def CreateStore(self) -> SerializationStore: ...
    @abc.abstractmethod
    def LoadStore(self, stream: Stream) -> SerializationStore: ...
    @abc.abstractmethod
    def Serialize(self, store: SerializationStore, value: typing.Any) -> None: ...
    @abc.abstractmethod
    def SerializeAbsolute(self, store: SerializationStore, value: typing.Any) -> None: ...
    @abc.abstractmethod
    def SerializeMember(self, store: SerializationStore, owningObject: typing.Any, member: MemberDescriptor) -> None: ...
    @abc.abstractmethod
    def SerializeMemberAbsolute(self, store: SerializationStore, owningObject: typing.Any, member: MemberDescriptor) -> None: ...
    # Skipped Deserialize due to it being static, abstract and generic.

    Deserialize : Deserialize_MethodGroup
    class Deserialize_MethodGroup:
        @typing.overload
        def __call__(self, store: SerializationStore) -> ICollection:...
        @typing.overload
        def __call__(self, store: SerializationStore, container: IContainer) -> ICollection:...

    # Skipped DeserializeTo due to it being static, abstract and generic.

    DeserializeTo : DeserializeTo_MethodGroup
    class DeserializeTo_MethodGroup:
        @typing.overload
        def __call__(self, store: SerializationStore, container: IContainer) -> None:...
        @typing.overload
        def __call__(self, store: SerializationStore, container: IContainer, validateRecycledTypes: bool) -> None:...
        @typing.overload
        def __call__(self, store: SerializationStore, container: IContainer, validateRecycledTypes: bool, applyDefaults: bool) -> None:...



class ContextStack:
    def __init__(self) -> None: ...
    @property
    def Current(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    def Append(self, context: typing.Any) -> None: ...
    def Pop(self) -> typing.Any: ...
    def Push(self, context: typing.Any) -> None: ...


class DefaultSerializationProviderAttribute(Attribute):
    @typing.overload
    def __init__(self, providerType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, providerTypeName: str) -> None: ...
    @property
    def ProviderTypeName(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DesignerLoader(abc.ABC):
    @property
    def Loading(self) -> bool: ...
    @abc.abstractmethod
    def BeginLoad(self, host: IDesignerLoaderHost) -> None: ...
    @abc.abstractmethod
    def Dispose(self) -> None: ...
    def Flush(self) -> None: ...


class DesignerSerializerAttribute(Attribute):
    @typing.overload
    def __init__(self, serializerType: typing.Type[typing.Any], baseSerializerType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, serializerTypeName: str, baseSerializerType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, serializerTypeName: str, baseSerializerTypeName: str) -> None: ...
    @property
    def SerializerBaseTypeName(self) -> str: ...
    @property
    def SerializerTypeName(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class IDesignerLoaderHost(IDesignerHost, typing.Protocol):
    @abc.abstractmethod
    def EndLoad(self, baseClassName: str, successful: bool, errorCollection: ICollection) -> None: ...
    @abc.abstractmethod
    def Reload(self) -> None: ...


class IDesignerLoaderHost2(IDesignerLoaderHost, typing.Protocol):
    @property
    def CanReloadWithErrors(self) -> bool: ...
    @CanReloadWithErrors.setter
    def CanReloadWithErrors(self, value: bool) -> bool: ...
    @property
    def IgnoreErrorsDuringReload(self) -> bool: ...
    @IgnoreErrorsDuringReload.setter
    def IgnoreErrorsDuringReload(self, value: bool) -> bool: ...


class IDesignerLoaderService(typing.Protocol):
    @abc.abstractmethod
    def AddLoadDependency(self) -> None: ...
    @abc.abstractmethod
    def DependentLoadComplete(self, successful: bool, errorCollection: ICollection) -> None: ...
    @abc.abstractmethod
    def Reload(self) -> bool: ...


class IDesignerSerializationManager(IServiceProvider, typing.Protocol):
    @property
    def Context(self) -> ContextStack: ...
    @property
    def Properties(self) -> PropertyDescriptorCollection: ...
    @abc.abstractmethod
    def AddSerializationProvider(self, provider: IDesignerSerializationProvider) -> None: ...
    @abc.abstractmethod
    def CreateInstance(self, type: typing.Type[typing.Any], arguments: ICollection, name: str, addToContainer: bool) -> typing.Any: ...
    @abc.abstractmethod
    def GetInstance(self, name: str) -> typing.Any: ...
    @abc.abstractmethod
    def GetName(self, value: typing.Any) -> str: ...
    @abc.abstractmethod
    def GetSerializer(self, objectType: typing.Type[typing.Any], serializerType: typing.Type[typing.Any]) -> typing.Any: ...
    @abc.abstractmethod
    def GetType(self, typeName: str) -> typing.Type[typing.Any]: ...
    @abc.abstractmethod
    def RemoveSerializationProvider(self, provider: IDesignerSerializationProvider) -> None: ...
    @abc.abstractmethod
    def ReportError(self, errorInformation: typing.Any) -> None: ...
    @abc.abstractmethod
    def SetName(self, instance: typing.Any, name: str) -> None: ...


class IDesignerSerializationProvider(typing.Protocol):
    @abc.abstractmethod
    def GetSerializer(self, manager: IDesignerSerializationManager, currentSerializer: typing.Any, objectType: typing.Type[typing.Any], serializerType: typing.Type[typing.Any]) -> typing.Any: ...


class IDesignerSerializationService(typing.Protocol):
    @abc.abstractmethod
    def Deserialize(self, serializationData: typing.Any) -> ICollection: ...
    @abc.abstractmethod
    def Serialize(self, objects: ICollection) -> typing.Any: ...


class INameCreationService(typing.Protocol):
    @abc.abstractmethod
    def CreateName(self, container: IContainer, dataType: typing.Type[typing.Any]) -> str: ...
    @abc.abstractmethod
    def IsValidName(self, name: str) -> bool: ...
    @abc.abstractmethod
    def ValidateName(self, name: str) -> None: ...


class InstanceDescriptor:
    @typing.overload
    def __init__(self, member: MemberInfo, arguments: ICollection) -> None: ...
    @typing.overload
    def __init__(self, member: MemberInfo, arguments: ICollection, isComplete: bool) -> None: ...
    @property
    def Arguments(self) -> ICollection: ...
    @property
    def IsComplete(self) -> bool: ...
    @property
    def MemberInfo(self) -> MemberInfo: ...
    def Invoke(self) -> typing.Any: ...


class MemberRelationship:
    def __init__(self, owner: typing.Any, member: MemberDescriptor) -> None: ...
    Empty : MemberRelationship
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def Member(self) -> MemberDescriptor: ...
    @property
    def Owner(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: MemberRelationship, right: MemberRelationship) -> bool: ...
    def __ne__(self, left: MemberRelationship, right: MemberRelationship) -> bool: ...


class MemberRelationshipService(abc.ABC):
    @property
    def Item(self) -> MemberRelationship: ...
    @Item.setter
    def Item(self, value: MemberRelationship) -> MemberRelationship: ...
    @property
    def Item(self) -> MemberRelationship: ...
    @Item.setter
    def Item(self, value: MemberRelationship) -> MemberRelationship: ...
    @abc.abstractmethod
    def SupportsRelationship(self, source: MemberRelationship, relationship: MemberRelationship) -> bool: ...


class ResolveNameEventArgs(EventArgs):
    def __init__(self, name: str) -> None: ...
    @property
    def Name(self) -> str: ...
    @property
    def Value(self) -> typing.Any: ...
    @Value.setter
    def Value(self, value: typing.Any) -> typing.Any: ...


class ResolveNameEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: ResolveNameEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: ResolveNameEventArgs) -> None: ...


class RootDesignerSerializerAttribute(Attribute):
    @typing.overload
    def __init__(self, serializerType: typing.Type[typing.Any], baseSerializerType: typing.Type[typing.Any], reloadable: bool) -> None: ...
    @typing.overload
    def __init__(self, serializerTypeName: str, baseSerializerType: typing.Type[typing.Any], reloadable: bool) -> None: ...
    @typing.overload
    def __init__(self, serializerTypeName: str, baseSerializerTypeName: str, reloadable: bool) -> None: ...
    @property
    def Reloadable(self) -> bool: ...
    @property
    def SerializerBaseTypeName(self) -> str: ...
    @property
    def SerializerTypeName(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class SerializationStore(IDisposable, abc.ABC):
    @property
    def Errors(self) -> ICollection: ...
    @abc.abstractmethod
    def Close(self) -> None: ...
    @abc.abstractmethod
    def Save(self, stream: Stream) -> None: ...

