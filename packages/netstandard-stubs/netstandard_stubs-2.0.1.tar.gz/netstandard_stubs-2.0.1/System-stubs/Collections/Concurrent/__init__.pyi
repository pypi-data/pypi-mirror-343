import typing, clr, abc
from System.Collections.Generic import IReadOnlyCollection_1, IEnumerable_1, IEnumerator_1, IReadOnlyDictionary_2, IDictionary_2, KeyValuePair_2, IEqualityComparer_1, ICollection_1, IList_1
from System.Collections import ICollection, IDictionary
from System import IDisposable, Array_1, TimeSpan, Func_3, Func_4, Func_2, Tuple_2
from System.Threading import CancellationToken

class BlockingCollection_GenericClasses(abc.ABCMeta):
    Generic_BlockingCollection_GenericClasses_BlockingCollection_1_T = typing.TypeVar('Generic_BlockingCollection_GenericClasses_BlockingCollection_1_T')
    def __getitem__(self, types : typing.Type[Generic_BlockingCollection_GenericClasses_BlockingCollection_1_T]) -> typing.Type[BlockingCollection_1[Generic_BlockingCollection_GenericClasses_BlockingCollection_1_T]]: ...

BlockingCollection : BlockingCollection_GenericClasses

BlockingCollection_1_T = typing.TypeVar('BlockingCollection_1_T')
class BlockingCollection_1(typing.Generic[BlockingCollection_1_T], IReadOnlyCollection_1[BlockingCollection_1_T], ICollection, IDisposable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, boundedCapacity: int) -> None: ...
    @typing.overload
    def __init__(self, collection: IProducerConsumerCollection_1[BlockingCollection_1_T]) -> None: ...
    @typing.overload
    def __init__(self, collection: IProducerConsumerCollection_1[BlockingCollection_1_T], boundedCapacity: int) -> None: ...
    @property
    def BoundedCapacity(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsAddingCompleted(self) -> bool: ...
    @property
    def IsCompleted(self) -> bool: ...
    def CompleteAdding(self) -> None: ...
    def CopyTo(self, array: Array_1[BlockingCollection_1_T], index: int) -> None: ...
    def Dispose(self) -> None: ...
    def ToArray(self) -> Array_1[BlockingCollection_1_T]: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup[BlockingCollection_1_T]
    Add_MethodGroup_BlockingCollection_1_T = typing.TypeVar('Add_MethodGroup_BlockingCollection_1_T')
    class Add_MethodGroup(typing.Generic[Add_MethodGroup_BlockingCollection_1_T]):
        Add_MethodGroup_BlockingCollection_1_T = BlockingCollection_1.Add_MethodGroup_BlockingCollection_1_T
        @typing.overload
        def __call__(self, item: Add_MethodGroup_BlockingCollection_1_T) -> None:...
        @typing.overload
        def __call__(self, item: Add_MethodGroup_BlockingCollection_1_T, cancellationToken: CancellationToken) -> None:...

    # Skipped AddToAny due to it being static, abstract and generic.

    AddToAny : AddToAny_MethodGroup[BlockingCollection_1_T]
    AddToAny_MethodGroup_BlockingCollection_1_T = typing.TypeVar('AddToAny_MethodGroup_BlockingCollection_1_T')
    class AddToAny_MethodGroup(typing.Generic[AddToAny_MethodGroup_BlockingCollection_1_T]):
        AddToAny_MethodGroup_BlockingCollection_1_T = BlockingCollection_1.AddToAny_MethodGroup_BlockingCollection_1_T
        @typing.overload
        def __call__(self, collections: Array_1[BlockingCollection_1[AddToAny_MethodGroup_BlockingCollection_1_T]], item: AddToAny_MethodGroup_BlockingCollection_1_T) -> int:...
        @typing.overload
        def __call__(self, collections: Array_1[BlockingCollection_1[AddToAny_MethodGroup_BlockingCollection_1_T]], item: AddToAny_MethodGroup_BlockingCollection_1_T, cancellationToken: CancellationToken) -> int:...

    # Skipped GetConsumingEnumerable due to it being static, abstract and generic.

    GetConsumingEnumerable : GetConsumingEnumerable_MethodGroup[BlockingCollection_1_T]
    GetConsumingEnumerable_MethodGroup_BlockingCollection_1_T = typing.TypeVar('GetConsumingEnumerable_MethodGroup_BlockingCollection_1_T')
    class GetConsumingEnumerable_MethodGroup(typing.Generic[GetConsumingEnumerable_MethodGroup_BlockingCollection_1_T]):
        GetConsumingEnumerable_MethodGroup_BlockingCollection_1_T = BlockingCollection_1.GetConsumingEnumerable_MethodGroup_BlockingCollection_1_T
        @typing.overload
        def __call__(self) -> IEnumerable_1[GetConsumingEnumerable_MethodGroup_BlockingCollection_1_T]:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> IEnumerable_1[GetConsumingEnumerable_MethodGroup_BlockingCollection_1_T]:...

    # Skipped Take due to it being static, abstract and generic.

    Take : Take_MethodGroup[BlockingCollection_1_T]
    Take_MethodGroup_BlockingCollection_1_T = typing.TypeVar('Take_MethodGroup_BlockingCollection_1_T')
    class Take_MethodGroup(typing.Generic[Take_MethodGroup_BlockingCollection_1_T]):
        Take_MethodGroup_BlockingCollection_1_T = BlockingCollection_1.Take_MethodGroup_BlockingCollection_1_T
        @typing.overload
        def __call__(self) -> Take_MethodGroup_BlockingCollection_1_T:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Take_MethodGroup_BlockingCollection_1_T:...

    # Skipped TakeFromAny due to it being static, abstract and generic.

    TakeFromAny : TakeFromAny_MethodGroup[BlockingCollection_1_T]
    TakeFromAny_MethodGroup_BlockingCollection_1_T = typing.TypeVar('TakeFromAny_MethodGroup_BlockingCollection_1_T')
    class TakeFromAny_MethodGroup(typing.Generic[TakeFromAny_MethodGroup_BlockingCollection_1_T]):
        TakeFromAny_MethodGroup_BlockingCollection_1_T = BlockingCollection_1.TakeFromAny_MethodGroup_BlockingCollection_1_T
        @typing.overload
        def __call__(self, collections: Array_1[BlockingCollection_1[TakeFromAny_MethodGroup_BlockingCollection_1_T]], item: clr.Reference[TakeFromAny_MethodGroup_BlockingCollection_1_T]) -> int:...
        @typing.overload
        def __call__(self, collections: Array_1[BlockingCollection_1[TakeFromAny_MethodGroup_BlockingCollection_1_T]], item: clr.Reference[TakeFromAny_MethodGroup_BlockingCollection_1_T], cancellationToken: CancellationToken) -> int:...

    # Skipped TryAdd due to it being static, abstract and generic.

    TryAdd : TryAdd_MethodGroup[BlockingCollection_1_T]
    TryAdd_MethodGroup_BlockingCollection_1_T = typing.TypeVar('TryAdd_MethodGroup_BlockingCollection_1_T')
    class TryAdd_MethodGroup(typing.Generic[TryAdd_MethodGroup_BlockingCollection_1_T]):
        TryAdd_MethodGroup_BlockingCollection_1_T = BlockingCollection_1.TryAdd_MethodGroup_BlockingCollection_1_T
        @typing.overload
        def __call__(self, item: TryAdd_MethodGroup_BlockingCollection_1_T) -> bool:...
        @typing.overload
        def __call__(self, item: TryAdd_MethodGroup_BlockingCollection_1_T, millisecondsTimeout: int) -> bool:...
        @typing.overload
        def __call__(self, item: TryAdd_MethodGroup_BlockingCollection_1_T, timeout: TimeSpan) -> bool:...
        @typing.overload
        def __call__(self, item: TryAdd_MethodGroup_BlockingCollection_1_T, millisecondsTimeout: int, cancellationToken: CancellationToken) -> bool:...

    # Skipped TryAddToAny due to it being static, abstract and generic.

    TryAddToAny : TryAddToAny_MethodGroup[BlockingCollection_1_T]
    TryAddToAny_MethodGroup_BlockingCollection_1_T = typing.TypeVar('TryAddToAny_MethodGroup_BlockingCollection_1_T')
    class TryAddToAny_MethodGroup(typing.Generic[TryAddToAny_MethodGroup_BlockingCollection_1_T]):
        TryAddToAny_MethodGroup_BlockingCollection_1_T = BlockingCollection_1.TryAddToAny_MethodGroup_BlockingCollection_1_T
        @typing.overload
        def __call__(self, collections: Array_1[BlockingCollection_1[TryAddToAny_MethodGroup_BlockingCollection_1_T]], item: TryAddToAny_MethodGroup_BlockingCollection_1_T) -> int:...
        @typing.overload
        def __call__(self, collections: Array_1[BlockingCollection_1[TryAddToAny_MethodGroup_BlockingCollection_1_T]], item: TryAddToAny_MethodGroup_BlockingCollection_1_T, millisecondsTimeout: int) -> int:...
        @typing.overload
        def __call__(self, collections: Array_1[BlockingCollection_1[TryAddToAny_MethodGroup_BlockingCollection_1_T]], item: TryAddToAny_MethodGroup_BlockingCollection_1_T, timeout: TimeSpan) -> int:...
        @typing.overload
        def __call__(self, collections: Array_1[BlockingCollection_1[TryAddToAny_MethodGroup_BlockingCollection_1_T]], item: TryAddToAny_MethodGroup_BlockingCollection_1_T, millisecondsTimeout: int, cancellationToken: CancellationToken) -> int:...

    # Skipped TryTake due to it being static, abstract and generic.

    TryTake : TryTake_MethodGroup[BlockingCollection_1_T]
    TryTake_MethodGroup_BlockingCollection_1_T = typing.TypeVar('TryTake_MethodGroup_BlockingCollection_1_T')
    class TryTake_MethodGroup(typing.Generic[TryTake_MethodGroup_BlockingCollection_1_T]):
        TryTake_MethodGroup_BlockingCollection_1_T = BlockingCollection_1.TryTake_MethodGroup_BlockingCollection_1_T
        @typing.overload
        def __call__(self, item: clr.Reference[TryTake_MethodGroup_BlockingCollection_1_T]) -> bool:...
        @typing.overload
        def __call__(self, item: clr.Reference[TryTake_MethodGroup_BlockingCollection_1_T], millisecondsTimeout: int) -> bool:...
        @typing.overload
        def __call__(self, item: clr.Reference[TryTake_MethodGroup_BlockingCollection_1_T], timeout: TimeSpan) -> bool:...
        @typing.overload
        def __call__(self, item: clr.Reference[TryTake_MethodGroup_BlockingCollection_1_T], millisecondsTimeout: int, cancellationToken: CancellationToken) -> bool:...

    # Skipped TryTakeFromAny due to it being static, abstract and generic.

    TryTakeFromAny : TryTakeFromAny_MethodGroup[BlockingCollection_1_T]
    TryTakeFromAny_MethodGroup_BlockingCollection_1_T = typing.TypeVar('TryTakeFromAny_MethodGroup_BlockingCollection_1_T')
    class TryTakeFromAny_MethodGroup(typing.Generic[TryTakeFromAny_MethodGroup_BlockingCollection_1_T]):
        TryTakeFromAny_MethodGroup_BlockingCollection_1_T = BlockingCollection_1.TryTakeFromAny_MethodGroup_BlockingCollection_1_T
        @typing.overload
        def __call__(self, collections: Array_1[BlockingCollection_1[TryTakeFromAny_MethodGroup_BlockingCollection_1_T]], item: clr.Reference[TryTakeFromAny_MethodGroup_BlockingCollection_1_T]) -> int:...
        @typing.overload
        def __call__(self, collections: Array_1[BlockingCollection_1[TryTakeFromAny_MethodGroup_BlockingCollection_1_T]], item: clr.Reference[TryTakeFromAny_MethodGroup_BlockingCollection_1_T], millisecondsTimeout: int) -> int:...
        @typing.overload
        def __call__(self, collections: Array_1[BlockingCollection_1[TryTakeFromAny_MethodGroup_BlockingCollection_1_T]], item: clr.Reference[TryTakeFromAny_MethodGroup_BlockingCollection_1_T], timeout: TimeSpan) -> int:...
        @typing.overload
        def __call__(self, collections: Array_1[BlockingCollection_1[TryTakeFromAny_MethodGroup_BlockingCollection_1_T]], item: clr.Reference[TryTakeFromAny_MethodGroup_BlockingCollection_1_T], millisecondsTimeout: int, cancellationToken: CancellationToken) -> int:...



class ConcurrentBag_GenericClasses(abc.ABCMeta):
    Generic_ConcurrentBag_GenericClasses_ConcurrentBag_1_T = typing.TypeVar('Generic_ConcurrentBag_GenericClasses_ConcurrentBag_1_T')
    def __getitem__(self, types : typing.Type[Generic_ConcurrentBag_GenericClasses_ConcurrentBag_1_T]) -> typing.Type[ConcurrentBag_1[Generic_ConcurrentBag_GenericClasses_ConcurrentBag_1_T]]: ...

ConcurrentBag : ConcurrentBag_GenericClasses

ConcurrentBag_1_T = typing.TypeVar('ConcurrentBag_1_T')
class ConcurrentBag_1(typing.Generic[ConcurrentBag_1_T], IReadOnlyCollection_1[ConcurrentBag_1_T], IProducerConsumerCollection_1[ConcurrentBag_1_T]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, collection: IEnumerable_1[ConcurrentBag_1_T]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsEmpty(self) -> bool: ...
    def Add(self, item: ConcurrentBag_1_T) -> None: ...
    def Clear(self) -> None: ...
    def CopyTo(self, array: Array_1[ConcurrentBag_1_T], index: int) -> None: ...
    def GetEnumerator(self) -> IEnumerator_1[ConcurrentBag_1_T]: ...
    def ToArray(self) -> Array_1[ConcurrentBag_1_T]: ...
    def TryPeek(self, result: clr.Reference[ConcurrentBag_1_T]) -> bool: ...
    def TryTake(self, result: clr.Reference[ConcurrentBag_1_T]) -> bool: ...


class ConcurrentDictionary_GenericClasses(abc.ABCMeta):
    Generic_ConcurrentDictionary_GenericClasses_ConcurrentDictionary_2_TKey = typing.TypeVar('Generic_ConcurrentDictionary_GenericClasses_ConcurrentDictionary_2_TKey')
    Generic_ConcurrentDictionary_GenericClasses_ConcurrentDictionary_2_TValue = typing.TypeVar('Generic_ConcurrentDictionary_GenericClasses_ConcurrentDictionary_2_TValue')
    def __getitem__(self, types : typing.Tuple[typing.Type[Generic_ConcurrentDictionary_GenericClasses_ConcurrentDictionary_2_TKey], typing.Type[Generic_ConcurrentDictionary_GenericClasses_ConcurrentDictionary_2_TValue]]) -> typing.Type[ConcurrentDictionary_2[Generic_ConcurrentDictionary_GenericClasses_ConcurrentDictionary_2_TKey, Generic_ConcurrentDictionary_GenericClasses_ConcurrentDictionary_2_TValue]]: ...

ConcurrentDictionary : ConcurrentDictionary_GenericClasses

ConcurrentDictionary_2_TKey = typing.TypeVar('ConcurrentDictionary_2_TKey')
ConcurrentDictionary_2_TValue = typing.TypeVar('ConcurrentDictionary_2_TValue')
class ConcurrentDictionary_2(typing.Generic[ConcurrentDictionary_2_TKey, ConcurrentDictionary_2_TValue], IReadOnlyDictionary_2[ConcurrentDictionary_2_TKey, ConcurrentDictionary_2_TValue], IDictionary_2[ConcurrentDictionary_2_TKey, ConcurrentDictionary_2_TValue], IDictionary):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, collection: IEnumerable_1[KeyValuePair_2[ConcurrentDictionary_2_TKey, ConcurrentDictionary_2_TValue]]) -> None: ...
    @typing.overload
    def __init__(self, collection: IEnumerable_1[KeyValuePair_2[ConcurrentDictionary_2_TKey, ConcurrentDictionary_2_TValue]], comparer: IEqualityComparer_1[ConcurrentDictionary_2_TKey]) -> None: ...
    @typing.overload
    def __init__(self, comparer: IEqualityComparer_1[ConcurrentDictionary_2_TKey]) -> None: ...
    @typing.overload
    def __init__(self, concurrencyLevel: int, capacity: int) -> None: ...
    @typing.overload
    def __init__(self, concurrencyLevel: int, capacity: int, comparer: IEqualityComparer_1[ConcurrentDictionary_2_TKey]) -> None: ...
    @typing.overload
    def __init__(self, concurrencyLevel: int, collection: IEnumerable_1[KeyValuePair_2[ConcurrentDictionary_2_TKey, ConcurrentDictionary_2_TValue]], comparer: IEqualityComparer_1[ConcurrentDictionary_2_TKey]) -> None: ...
    @property
    def Comparer(self) -> IEqualityComparer_1[ConcurrentDictionary_2_TKey]: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsEmpty(self) -> bool: ...
    @property
    def Item(self) -> ConcurrentDictionary_2_TValue: ...
    @Item.setter
    def Item(self, value: ConcurrentDictionary_2_TValue) -> ConcurrentDictionary_2_TValue: ...
    @property
    def Keys(self) -> ICollection_1[ConcurrentDictionary_2_TKey]: ...
    @property
    def Values(self) -> ICollection_1[ConcurrentDictionary_2_TValue]: ...
    def Clear(self) -> None: ...
    def ContainsKey(self, key: ConcurrentDictionary_2_TKey) -> bool: ...
    def GetEnumerator(self) -> IEnumerator_1[KeyValuePair_2[ConcurrentDictionary_2_TKey, ConcurrentDictionary_2_TValue]]: ...
    def ToArray(self) -> Array_1[KeyValuePair_2[ConcurrentDictionary_2_TKey, ConcurrentDictionary_2_TValue]]: ...
    def TryAdd(self, key: ConcurrentDictionary_2_TKey, value: ConcurrentDictionary_2_TValue) -> bool: ...
    def TryGetValue(self, key: ConcurrentDictionary_2_TKey, value: clr.Reference[ConcurrentDictionary_2_TValue]) -> bool: ...
    def TryUpdate(self, key: ConcurrentDictionary_2_TKey, newValue: ConcurrentDictionary_2_TValue, comparisonValue: ConcurrentDictionary_2_TValue) -> bool: ...
    # Skipped AddOrUpdate due to it being static, abstract and generic.

    AddOrUpdate : AddOrUpdate_MethodGroup[ConcurrentDictionary_2_TKey, ConcurrentDictionary_2_TValue]
    AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TKey = typing.TypeVar('AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TKey')
    AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue = typing.TypeVar('AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue')
    class AddOrUpdate_MethodGroup(typing.Generic[AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TKey, AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue]):
        AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TKey = ConcurrentDictionary_2.AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TKey
        AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue = ConcurrentDictionary_2.AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue
        def __getitem__(self, t:typing.Type[AddOrUpdate_1_T1]) -> AddOrUpdate_1[AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TKey, AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue, AddOrUpdate_1_T1]: ...

        AddOrUpdate_1_ConcurrentDictionary_2_TKey = typing.TypeVar('AddOrUpdate_1_ConcurrentDictionary_2_TKey')
        AddOrUpdate_1_ConcurrentDictionary_2_TValue = typing.TypeVar('AddOrUpdate_1_ConcurrentDictionary_2_TValue')
        AddOrUpdate_1_T1 = typing.TypeVar('AddOrUpdate_1_T1')
        class AddOrUpdate_1(typing.Generic[AddOrUpdate_1_ConcurrentDictionary_2_TKey, AddOrUpdate_1_ConcurrentDictionary_2_TValue, AddOrUpdate_1_T1]):
            AddOrUpdate_1_ConcurrentDictionary_2_TKey = ConcurrentDictionary_2.AddOrUpdate_MethodGroup.AddOrUpdate_1_ConcurrentDictionary_2_TKey
            AddOrUpdate_1_ConcurrentDictionary_2_TValue = ConcurrentDictionary_2.AddOrUpdate_MethodGroup.AddOrUpdate_1_ConcurrentDictionary_2_TValue
            AddOrUpdate_1_TArg = ConcurrentDictionary_2.AddOrUpdate_MethodGroup.AddOrUpdate_1_T1
            def __call__(self, key: AddOrUpdate_1_ConcurrentDictionary_2_TKey, addValueFactory: Func_3[AddOrUpdate_1_ConcurrentDictionary_2_TKey, AddOrUpdate_1_TArg, AddOrUpdate_1_ConcurrentDictionary_2_TValue], updateValueFactory: Func_4[AddOrUpdate_1_ConcurrentDictionary_2_TKey, AddOrUpdate_1_ConcurrentDictionary_2_TValue, AddOrUpdate_1_TArg, AddOrUpdate_1_ConcurrentDictionary_2_TValue], factoryArgument: AddOrUpdate_1_TArg) -> AddOrUpdate_1_ConcurrentDictionary_2_TValue:...

        @typing.overload
        def __call__(self, key: AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TKey, addValueFactory: Func_2[AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TKey, AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue], updateValueFactory: Func_3[AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TKey, AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue, AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue]) -> AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue:...
        @typing.overload
        def __call__(self, key: AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TKey, addValue: AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue, updateValueFactory: Func_3[AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TKey, AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue, AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue]) -> AddOrUpdate_MethodGroup_ConcurrentDictionary_2_TValue:...

    # Skipped GetOrAdd due to it being static, abstract and generic.

    GetOrAdd : GetOrAdd_MethodGroup[ConcurrentDictionary_2_TKey, ConcurrentDictionary_2_TValue]
    GetOrAdd_MethodGroup_ConcurrentDictionary_2_TKey = typing.TypeVar('GetOrAdd_MethodGroup_ConcurrentDictionary_2_TKey')
    GetOrAdd_MethodGroup_ConcurrentDictionary_2_TValue = typing.TypeVar('GetOrAdd_MethodGroup_ConcurrentDictionary_2_TValue')
    class GetOrAdd_MethodGroup(typing.Generic[GetOrAdd_MethodGroup_ConcurrentDictionary_2_TKey, GetOrAdd_MethodGroup_ConcurrentDictionary_2_TValue]):
        GetOrAdd_MethodGroup_ConcurrentDictionary_2_TKey = ConcurrentDictionary_2.GetOrAdd_MethodGroup_ConcurrentDictionary_2_TKey
        GetOrAdd_MethodGroup_ConcurrentDictionary_2_TValue = ConcurrentDictionary_2.GetOrAdd_MethodGroup_ConcurrentDictionary_2_TValue
        def __getitem__(self, t:typing.Type[GetOrAdd_1_T1]) -> GetOrAdd_1[GetOrAdd_MethodGroup_ConcurrentDictionary_2_TKey, GetOrAdd_MethodGroup_ConcurrentDictionary_2_TValue, GetOrAdd_1_T1]: ...

        GetOrAdd_1_ConcurrentDictionary_2_TKey = typing.TypeVar('GetOrAdd_1_ConcurrentDictionary_2_TKey')
        GetOrAdd_1_ConcurrentDictionary_2_TValue = typing.TypeVar('GetOrAdd_1_ConcurrentDictionary_2_TValue')
        GetOrAdd_1_T1 = typing.TypeVar('GetOrAdd_1_T1')
        class GetOrAdd_1(typing.Generic[GetOrAdd_1_ConcurrentDictionary_2_TKey, GetOrAdd_1_ConcurrentDictionary_2_TValue, GetOrAdd_1_T1]):
            GetOrAdd_1_ConcurrentDictionary_2_TKey = ConcurrentDictionary_2.GetOrAdd_MethodGroup.GetOrAdd_1_ConcurrentDictionary_2_TKey
            GetOrAdd_1_ConcurrentDictionary_2_TValue = ConcurrentDictionary_2.GetOrAdd_MethodGroup.GetOrAdd_1_ConcurrentDictionary_2_TValue
            GetOrAdd_1_TArg = ConcurrentDictionary_2.GetOrAdd_MethodGroup.GetOrAdd_1_T1
            def __call__(self, key: GetOrAdd_1_ConcurrentDictionary_2_TKey, valueFactory: Func_3[GetOrAdd_1_ConcurrentDictionary_2_TKey, GetOrAdd_1_TArg, GetOrAdd_1_ConcurrentDictionary_2_TValue], factoryArgument: GetOrAdd_1_TArg) -> GetOrAdd_1_ConcurrentDictionary_2_TValue:...

        @typing.overload
        def __call__(self, key: GetOrAdd_MethodGroup_ConcurrentDictionary_2_TKey, valueFactory: Func_2[GetOrAdd_MethodGroup_ConcurrentDictionary_2_TKey, GetOrAdd_MethodGroup_ConcurrentDictionary_2_TValue]) -> GetOrAdd_MethodGroup_ConcurrentDictionary_2_TValue:...
        @typing.overload
        def __call__(self, key: GetOrAdd_MethodGroup_ConcurrentDictionary_2_TKey, value: GetOrAdd_MethodGroup_ConcurrentDictionary_2_TValue) -> GetOrAdd_MethodGroup_ConcurrentDictionary_2_TValue:...

    # Skipped TryRemove due to it being static, abstract and generic.

    TryRemove : TryRemove_MethodGroup[ConcurrentDictionary_2_TKey, ConcurrentDictionary_2_TValue]
    TryRemove_MethodGroup_ConcurrentDictionary_2_TKey = typing.TypeVar('TryRemove_MethodGroup_ConcurrentDictionary_2_TKey')
    TryRemove_MethodGroup_ConcurrentDictionary_2_TValue = typing.TypeVar('TryRemove_MethodGroup_ConcurrentDictionary_2_TValue')
    class TryRemove_MethodGroup(typing.Generic[TryRemove_MethodGroup_ConcurrentDictionary_2_TKey, TryRemove_MethodGroup_ConcurrentDictionary_2_TValue]):
        TryRemove_MethodGroup_ConcurrentDictionary_2_TKey = ConcurrentDictionary_2.TryRemove_MethodGroup_ConcurrentDictionary_2_TKey
        TryRemove_MethodGroup_ConcurrentDictionary_2_TValue = ConcurrentDictionary_2.TryRemove_MethodGroup_ConcurrentDictionary_2_TValue
        @typing.overload
        def __call__(self, item: KeyValuePair_2[TryRemove_MethodGroup_ConcurrentDictionary_2_TKey, TryRemove_MethodGroup_ConcurrentDictionary_2_TValue]) -> bool:...
        @typing.overload
        def __call__(self, key: TryRemove_MethodGroup_ConcurrentDictionary_2_TKey, value: clr.Reference[TryRemove_MethodGroup_ConcurrentDictionary_2_TValue]) -> bool:...



class ConcurrentQueue_GenericClasses(abc.ABCMeta):
    Generic_ConcurrentQueue_GenericClasses_ConcurrentQueue_1_T = typing.TypeVar('Generic_ConcurrentQueue_GenericClasses_ConcurrentQueue_1_T')
    def __getitem__(self, types : typing.Type[Generic_ConcurrentQueue_GenericClasses_ConcurrentQueue_1_T]) -> typing.Type[ConcurrentQueue_1[Generic_ConcurrentQueue_GenericClasses_ConcurrentQueue_1_T]]: ...

ConcurrentQueue : ConcurrentQueue_GenericClasses

ConcurrentQueue_1_T = typing.TypeVar('ConcurrentQueue_1_T')
class ConcurrentQueue_1(typing.Generic[ConcurrentQueue_1_T], IReadOnlyCollection_1[ConcurrentQueue_1_T], IProducerConsumerCollection_1[ConcurrentQueue_1_T]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, collection: IEnumerable_1[ConcurrentQueue_1_T]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsEmpty(self) -> bool: ...
    def Clear(self) -> None: ...
    def CopyTo(self, array: Array_1[ConcurrentQueue_1_T], index: int) -> None: ...
    def Enqueue(self, item: ConcurrentQueue_1_T) -> None: ...
    def GetEnumerator(self) -> IEnumerator_1[ConcurrentQueue_1_T]: ...
    def ToArray(self) -> Array_1[ConcurrentQueue_1_T]: ...
    def TryDequeue(self, result: clr.Reference[ConcurrentQueue_1_T]) -> bool: ...
    def TryPeek(self, result: clr.Reference[ConcurrentQueue_1_T]) -> bool: ...


class ConcurrentStack_GenericClasses(abc.ABCMeta):
    Generic_ConcurrentStack_GenericClasses_ConcurrentStack_1_T = typing.TypeVar('Generic_ConcurrentStack_GenericClasses_ConcurrentStack_1_T')
    def __getitem__(self, types : typing.Type[Generic_ConcurrentStack_GenericClasses_ConcurrentStack_1_T]) -> typing.Type[ConcurrentStack_1[Generic_ConcurrentStack_GenericClasses_ConcurrentStack_1_T]]: ...

ConcurrentStack : ConcurrentStack_GenericClasses

ConcurrentStack_1_T = typing.TypeVar('ConcurrentStack_1_T')
class ConcurrentStack_1(typing.Generic[ConcurrentStack_1_T], IReadOnlyCollection_1[ConcurrentStack_1_T], IProducerConsumerCollection_1[ConcurrentStack_1_T]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, collection: IEnumerable_1[ConcurrentStack_1_T]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsEmpty(self) -> bool: ...
    def Clear(self) -> None: ...
    def CopyTo(self, array: Array_1[ConcurrentStack_1_T], index: int) -> None: ...
    def GetEnumerator(self) -> IEnumerator_1[ConcurrentStack_1_T]: ...
    def Push(self, item: ConcurrentStack_1_T) -> None: ...
    def ToArray(self) -> Array_1[ConcurrentStack_1_T]: ...
    def TryPeek(self, result: clr.Reference[ConcurrentStack_1_T]) -> bool: ...
    def TryPop(self, result: clr.Reference[ConcurrentStack_1_T]) -> bool: ...
    # Skipped PushRange due to it being static, abstract and generic.

    PushRange : PushRange_MethodGroup[ConcurrentStack_1_T]
    PushRange_MethodGroup_ConcurrentStack_1_T = typing.TypeVar('PushRange_MethodGroup_ConcurrentStack_1_T')
    class PushRange_MethodGroup(typing.Generic[PushRange_MethodGroup_ConcurrentStack_1_T]):
        PushRange_MethodGroup_ConcurrentStack_1_T = ConcurrentStack_1.PushRange_MethodGroup_ConcurrentStack_1_T
        @typing.overload
        def __call__(self, items: Array_1[PushRange_MethodGroup_ConcurrentStack_1_T]) -> None:...
        @typing.overload
        def __call__(self, items: Array_1[PushRange_MethodGroup_ConcurrentStack_1_T], startIndex: int, count: int) -> None:...

    # Skipped TryPopRange due to it being static, abstract and generic.

    TryPopRange : TryPopRange_MethodGroup[ConcurrentStack_1_T]
    TryPopRange_MethodGroup_ConcurrentStack_1_T = typing.TypeVar('TryPopRange_MethodGroup_ConcurrentStack_1_T')
    class TryPopRange_MethodGroup(typing.Generic[TryPopRange_MethodGroup_ConcurrentStack_1_T]):
        TryPopRange_MethodGroup_ConcurrentStack_1_T = ConcurrentStack_1.TryPopRange_MethodGroup_ConcurrentStack_1_T
        @typing.overload
        def __call__(self, items: Array_1[TryPopRange_MethodGroup_ConcurrentStack_1_T]) -> int:...
        @typing.overload
        def __call__(self, items: Array_1[TryPopRange_MethodGroup_ConcurrentStack_1_T], startIndex: int, count: int) -> int:...



class EnumerablePartitionerOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : EnumerablePartitionerOptions # 0
    NoBuffering : EnumerablePartitionerOptions # 1


class IProducerConsumerCollection_GenericClasses(abc.ABCMeta):
    Generic_IProducerConsumerCollection_GenericClasses_IProducerConsumerCollection_1_T = typing.TypeVar('Generic_IProducerConsumerCollection_GenericClasses_IProducerConsumerCollection_1_T')
    def __getitem__(self, types : typing.Type[Generic_IProducerConsumerCollection_GenericClasses_IProducerConsumerCollection_1_T]) -> typing.Type[IProducerConsumerCollection_1[Generic_IProducerConsumerCollection_GenericClasses_IProducerConsumerCollection_1_T]]: ...

IProducerConsumerCollection : IProducerConsumerCollection_GenericClasses

IProducerConsumerCollection_1_T = typing.TypeVar('IProducerConsumerCollection_1_T')
class IProducerConsumerCollection_1(typing.Generic[IProducerConsumerCollection_1_T], ICollection, IEnumerable_1[IProducerConsumerCollection_1_T], typing.Protocol):
    @abc.abstractmethod
    def CopyTo(self, array: Array_1[IProducerConsumerCollection_1_T], index: int) -> None: ...
    @abc.abstractmethod
    def ToArray(self) -> Array_1[IProducerConsumerCollection_1_T]: ...
    @abc.abstractmethod
    def TryAdd(self, item: IProducerConsumerCollection_1_T) -> bool: ...
    @abc.abstractmethod
    def TryTake(self, item: clr.Reference[IProducerConsumerCollection_1_T]) -> bool: ...


class OrderablePartitioner_GenericClasses(abc.ABCMeta):
    Generic_OrderablePartitioner_GenericClasses_OrderablePartitioner_1_TSource = typing.TypeVar('Generic_OrderablePartitioner_GenericClasses_OrderablePartitioner_1_TSource')
    def __getitem__(self, types : typing.Type[Generic_OrderablePartitioner_GenericClasses_OrderablePartitioner_1_TSource]) -> typing.Type[OrderablePartitioner_1[Generic_OrderablePartitioner_GenericClasses_OrderablePartitioner_1_TSource]]: ...

OrderablePartitioner : OrderablePartitioner_GenericClasses

OrderablePartitioner_1_TSource = typing.TypeVar('OrderablePartitioner_1_TSource')
class OrderablePartitioner_1(typing.Generic[OrderablePartitioner_1_TSource], Partitioner_1[OrderablePartitioner_1_TSource]):
    @property
    def KeysNormalized(self) -> bool: ...
    @KeysNormalized.setter
    def KeysNormalized(self, value: bool) -> bool: ...
    @property
    def KeysOrderedAcrossPartitions(self) -> bool: ...
    @KeysOrderedAcrossPartitions.setter
    def KeysOrderedAcrossPartitions(self, value: bool) -> bool: ...
    @property
    def KeysOrderedInEachPartition(self) -> bool: ...
    @KeysOrderedInEachPartition.setter
    def KeysOrderedInEachPartition(self, value: bool) -> bool: ...
    @property
    def SupportsDynamicPartitions(self) -> bool: ...
    def GetDynamicPartitions(self) -> IEnumerable_1[OrderablePartitioner_1_TSource]: ...
    def GetOrderableDynamicPartitions(self) -> IEnumerable_1[KeyValuePair_2[int, OrderablePartitioner_1_TSource]]: ...
    @abc.abstractmethod
    def GetOrderablePartitions(self, partitionCount: int) -> IList_1[IEnumerator_1[KeyValuePair_2[int, OrderablePartitioner_1_TSource]]]: ...
    def GetPartitions(self, partitionCount: int) -> IList_1[IEnumerator_1[OrderablePartitioner_1_TSource]]: ...


class Partitioner_GenericClasses(abc.ABCMeta):
    Generic_Partitioner_GenericClasses_Partitioner_1_TSource = typing.TypeVar('Generic_Partitioner_GenericClasses_Partitioner_1_TSource')
    def __getitem__(self, types : typing.Type[Generic_Partitioner_GenericClasses_Partitioner_1_TSource]) -> typing.Type[Partitioner_1[Generic_Partitioner_GenericClasses_Partitioner_1_TSource]]: ...

class Partitioner(Partitioner_0, metaclass =Partitioner_GenericClasses): ...

class Partitioner_0(abc.ABC):
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        def __getitem__(self, t:typing.Type[Create_1_T1]) -> Create_1[Create_1_T1]: ...

        Create_1_T1 = typing.TypeVar('Create_1_T1')
        class Create_1(typing.Generic[Create_1_T1]):
            Create_1_TSource = Partitioner_0.Create_MethodGroup.Create_1_T1
            @typing.overload
            def __call__(self, source: IEnumerable_1[Create_1_TSource]) -> OrderablePartitioner_1[Create_1_TSource]:...
            @typing.overload
            def __call__(self, array: Array_1[Create_1_TSource], loadBalance: bool) -> OrderablePartitioner_1[Create_1_TSource]:...
            @typing.overload
            def __call__(self, list: IList_1[Create_1_TSource], loadBalance: bool) -> OrderablePartitioner_1[Create_1_TSource]:...
            @typing.overload
            def __call__(self, source: IEnumerable_1[Create_1_TSource], partitionerOptions: EnumerablePartitionerOptions) -> OrderablePartitioner_1[Create_1_TSource]:...

        @typing.overload
        def __call__(self, fromInclusive: int, toExclusive: int) -> OrderablePartitioner_1[Tuple_2[int, int]]:...
        # Method Create(fromInclusive : Int32, toExclusive : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, fromInclusive: int, toExclusive: int, rangeSize: int) -> OrderablePartitioner_1[Tuple_2[int, int]]:...
        # Method Create(fromInclusive : Int32, toExclusive : Int32, rangeSize : Int32) was skipped since it collides with above method



Partitioner_1_TSource = typing.TypeVar('Partitioner_1_TSource')
class Partitioner_1(typing.Generic[Partitioner_1_TSource], abc.ABC):
    @property
    def SupportsDynamicPartitions(self) -> bool: ...
    def GetDynamicPartitions(self) -> IEnumerable_1[Partitioner_1_TSource]: ...
    @abc.abstractmethod
    def GetPartitions(self, partitionCount: int) -> IList_1[IEnumerator_1[Partitioner_1_TSource]]: ...

