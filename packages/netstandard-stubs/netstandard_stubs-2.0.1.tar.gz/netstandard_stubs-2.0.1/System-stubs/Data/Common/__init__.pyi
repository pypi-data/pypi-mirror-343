import typing, clr, abc
from System.ComponentModel import Component, IContainer, ISite, ICustomTypeDescriptor
from System.Data import IDataAdapter, LoadOption, MissingMappingAction, MissingSchemaAction, DataSet, DataTable, SchemaType, IDataParameter, IColumnMapping, DataColumn, IColumnMappingCollection, ITableMapping, ITableMappingCollection, CommandBehavior, CommandType, IDbCommand, UpdateRowSource, ConflictOption, IDbConnection, ConnectionState, IsolationLevel, IDbDataAdapter, DataRow, IDataReader, IDataRecord, IDbDataParameter, DbType, ParameterDirection, DataRowVersion, IDataParameterCollection, IDbTransaction, StatementType, UpdateStatus
from System import Array, Array_1, MarshalByRefObject, ICloneable, IAsyncDisposable, IDisposable, DateTime, Decimal, Guid, Exception, Attribute, EventArgs
from System.Collections import IEnumerator, IDictionary, ICollection, IEnumerable
from System.Threading.Tasks import ValueTask, Task_1, Task, ValueTask_1
from System.Threading import CancellationToken
from System.Collections.Generic import IList_1, IEnumerator_1, IEnumerable_1
from System.Transactions import Transaction
from System.Text import StringBuilder
from System.Collections.ObjectModel import ReadOnlyCollection_1
from System.IO import Stream, TextReader
from System.Runtime.InteropServices import ExternalException
from System.Reflection import MethodBase

class CatalogLocation(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Start : CatalogLocation # 1
    End : CatalogLocation # 2


class DataAdapter(Component, IDataAdapter):
    @property
    def AcceptChangesDuringFill(self) -> bool: ...
    @AcceptChangesDuringFill.setter
    def AcceptChangesDuringFill(self, value: bool) -> bool: ...
    @property
    def AcceptChangesDuringUpdate(self) -> bool: ...
    @AcceptChangesDuringUpdate.setter
    def AcceptChangesDuringUpdate(self, value: bool) -> bool: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def ContinueUpdateOnError(self) -> bool: ...
    @ContinueUpdateOnError.setter
    def ContinueUpdateOnError(self, value: bool) -> bool: ...
    @property
    def FillLoadOption(self) -> LoadOption: ...
    @FillLoadOption.setter
    def FillLoadOption(self, value: LoadOption) -> LoadOption: ...
    @property
    def MissingMappingAction(self) -> MissingMappingAction: ...
    @MissingMappingAction.setter
    def MissingMappingAction(self, value: MissingMappingAction) -> MissingMappingAction: ...
    @property
    def MissingSchemaAction(self) -> MissingSchemaAction: ...
    @MissingSchemaAction.setter
    def MissingSchemaAction(self, value: MissingSchemaAction) -> MissingSchemaAction: ...
    @property
    def ReturnProviderSpecificTypes(self) -> bool: ...
    @ReturnProviderSpecificTypes.setter
    def ReturnProviderSpecificTypes(self, value: bool) -> bool: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def TableMappings(self) -> DataTableMappingCollection: ...
    def Fill(self, dataSet: DataSet) -> int: ...
    def FillSchema(self, dataSet: DataSet, schemaType: SchemaType) -> Array_1[DataTable]: ...
    def GetFillParameters(self) -> Array_1[IDataParameter]: ...
    def ResetFillLoadOption(self) -> None: ...
    def ShouldSerializeAcceptChangesDuringFill(self) -> bool: ...
    def ShouldSerializeFillLoadOption(self) -> bool: ...
    def Update(self, dataSet: DataSet) -> int: ...


class DataColumnMapping(MarshalByRefObject, ICloneable, IColumnMapping):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, sourceColumn: str, dataSetColumn: str) -> None: ...
    @property
    def DataSetColumn(self) -> str: ...
    @DataSetColumn.setter
    def DataSetColumn(self, value: str) -> str: ...
    @property
    def SourceColumn(self) -> str: ...
    @SourceColumn.setter
    def SourceColumn(self, value: str) -> str: ...
    def ToString(self) -> str: ...
    # Skipped GetDataColumnBySchemaAction due to it being static, abstract and generic.

    GetDataColumnBySchemaAction : GetDataColumnBySchemaAction_MethodGroup
    class GetDataColumnBySchemaAction_MethodGroup:
        @typing.overload
        def __call__(self, dataTable: DataTable, dataType: typing.Type[typing.Any], schemaAction: MissingSchemaAction) -> DataColumn:...
        @typing.overload
        def __call__(self, sourceColumn: str, dataSetColumn: str, dataTable: DataTable, dataType: typing.Type[typing.Any], schemaAction: MissingSchemaAction) -> DataColumn:...



class DataColumnMappingCollection(MarshalByRefObject, IColumnMappingCollection):
    def __init__(self) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> DataColumnMapping: ...
    @Item.setter
    def Item(self, value: DataColumnMapping) -> DataColumnMapping: ...
    @property
    def Item(self) -> DataColumnMapping: ...
    @Item.setter
    def Item(self, value: DataColumnMapping) -> DataColumnMapping: ...
    def Clear(self) -> None: ...
    def GetByDataSetColumn(self, value: str) -> DataColumnMapping: ...
    @staticmethod
    def GetColumnMappingBySchemaAction(columnMappings: DataColumnMappingCollection, sourceColumn: str, mappingAction: MissingMappingAction) -> DataColumnMapping: ...
    @staticmethod
    def GetDataColumn(columnMappings: DataColumnMappingCollection, sourceColumn: str, dataType: typing.Type[typing.Any], dataTable: DataTable, mappingAction: MissingMappingAction, schemaAction: MissingSchemaAction) -> DataColumn: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def IndexOfDataSetColumn(self, dataSetColumn: str) -> int: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> int:...
        @typing.overload
        def __call__(self, sourceColumn: str, dataSetColumn: str) -> DataColumnMapping:...

    # Skipped AddRange due to it being static, abstract and generic.

    AddRange : AddRange_MethodGroup
    class AddRange_MethodGroup:
        @typing.overload
        def __call__(self, values: Array_1[DataColumnMapping]) -> None:...
        @typing.overload
        def __call__(self, values: Array) -> None:...

    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, value: str) -> bool:...
        @typing.overload
        def __call__(self, value: typing.Any) -> bool:...

    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[DataColumnMapping], index: int) -> None:...
        @typing.overload
        def __call__(self, array: Array, index: int) -> None:...

    # Skipped IndexOf due to it being static, abstract and generic.

    IndexOf : IndexOf_MethodGroup
    class IndexOf_MethodGroup:
        @typing.overload
        def __call__(self, sourceColumn: str) -> int:...
        @typing.overload
        def __call__(self, value: typing.Any) -> int:...

    # Skipped Insert due to it being static, abstract and generic.

    Insert : Insert_MethodGroup
    class Insert_MethodGroup:
        @typing.overload
        def __call__(self, index: int, value: DataColumnMapping) -> None:...
        @typing.overload
        def __call__(self, index: int, value: typing.Any) -> None:...

    # Skipped Remove due to it being static, abstract and generic.

    Remove : Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, value: DataColumnMapping) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any) -> None:...

    # Skipped RemoveAt due to it being static, abstract and generic.

    RemoveAt : RemoveAt_MethodGroup
    class RemoveAt_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> None:...
        @typing.overload
        def __call__(self, sourceColumn: str) -> None:...



class DataTableMapping(MarshalByRefObject, ICloneable, ITableMapping):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, sourceTable: str, dataSetTable: str) -> None: ...
    @typing.overload
    def __init__(self, sourceTable: str, dataSetTable: str, columnMappings: Array_1[DataColumnMapping]) -> None: ...
    @property
    def ColumnMappings(self) -> DataColumnMappingCollection: ...
    @property
    def DataSetTable(self) -> str: ...
    @DataSetTable.setter
    def DataSetTable(self, value: str) -> str: ...
    @property
    def SourceTable(self) -> str: ...
    @SourceTable.setter
    def SourceTable(self, value: str) -> str: ...
    def GetColumnMappingBySchemaAction(self, sourceColumn: str, mappingAction: MissingMappingAction) -> DataColumnMapping: ...
    def GetDataColumn(self, sourceColumn: str, dataType: typing.Type[typing.Any], dataTable: DataTable, mappingAction: MissingMappingAction, schemaAction: MissingSchemaAction) -> DataColumn: ...
    def GetDataTableBySchemaAction(self, dataSet: DataSet, schemaAction: MissingSchemaAction) -> DataTable: ...
    def ToString(self) -> str: ...


class DataTableMappingCollection(MarshalByRefObject, ITableMappingCollection):
    def __init__(self) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> DataTableMapping: ...
    @Item.setter
    def Item(self, value: DataTableMapping) -> DataTableMapping: ...
    @property
    def Item(self) -> DataTableMapping: ...
    @Item.setter
    def Item(self, value: DataTableMapping) -> DataTableMapping: ...
    def Clear(self) -> None: ...
    def GetByDataSetTable(self, dataSetTable: str) -> DataTableMapping: ...
    def GetEnumerator(self) -> IEnumerator: ...
    @staticmethod
    def GetTableMappingBySchemaAction(tableMappings: DataTableMappingCollection, sourceTable: str, dataSetTable: str, mappingAction: MissingMappingAction) -> DataTableMapping: ...
    def IndexOfDataSetTable(self, dataSetTable: str) -> int: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> int:...
        @typing.overload
        def __call__(self, sourceTable: str, dataSetTable: str) -> DataTableMapping:...

    # Skipped AddRange due to it being static, abstract and generic.

    AddRange : AddRange_MethodGroup
    class AddRange_MethodGroup:
        @typing.overload
        def __call__(self, values: Array_1[DataTableMapping]) -> None:...
        @typing.overload
        def __call__(self, values: Array) -> None:...

    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, value: str) -> bool:...
        @typing.overload
        def __call__(self, value: typing.Any) -> bool:...

    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[DataTableMapping], index: int) -> None:...
        @typing.overload
        def __call__(self, array: Array, index: int) -> None:...

    # Skipped IndexOf due to it being static, abstract and generic.

    IndexOf : IndexOf_MethodGroup
    class IndexOf_MethodGroup:
        @typing.overload
        def __call__(self, sourceTable: str) -> int:...
        @typing.overload
        def __call__(self, value: typing.Any) -> int:...

    # Skipped Insert due to it being static, abstract and generic.

    Insert : Insert_MethodGroup
    class Insert_MethodGroup:
        @typing.overload
        def __call__(self, index: int, value: DataTableMapping) -> None:...
        @typing.overload
        def __call__(self, index: int, value: typing.Any) -> None:...

    # Skipped Remove due to it being static, abstract and generic.

    Remove : Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, value: DataTableMapping) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any) -> None:...

    # Skipped RemoveAt due to it being static, abstract and generic.

    RemoveAt : RemoveAt_MethodGroup
    class RemoveAt_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> None:...
        @typing.overload
        def __call__(self, sourceTable: str) -> None:...



class DbBatch(IAsyncDisposable, IDisposable, abc.ABC):
    @property
    def BatchCommands(self) -> DbBatchCommandCollection: ...
    @property
    def Connection(self) -> DbConnection: ...
    @Connection.setter
    def Connection(self, value: DbConnection) -> DbConnection: ...
    @property
    def Timeout(self) -> int: ...
    @Timeout.setter
    def Timeout(self, value: int) -> int: ...
    @property
    def Transaction(self) -> DbTransaction: ...
    @Transaction.setter
    def Transaction(self, value: DbTransaction) -> DbTransaction: ...
    @abc.abstractmethod
    def Cancel(self) -> None: ...
    def CreateBatchCommand(self) -> DbBatchCommand: ...
    def Dispose(self) -> None: ...
    def DisposeAsync(self) -> ValueTask: ...
    @abc.abstractmethod
    def ExecuteNonQuery(self) -> int: ...
    @abc.abstractmethod
    def ExecuteNonQueryAsync(self, cancellationToken: CancellationToken = ...) -> Task_1[int]: ...
    def ExecuteReader(self, behavior: CommandBehavior = ...) -> DbDataReader: ...
    @abc.abstractmethod
    def ExecuteScalar(self) -> typing.Any: ...
    @abc.abstractmethod
    def ExecuteScalarAsync(self, cancellationToken: CancellationToken = ...) -> Task_1[typing.Any]: ...
    @abc.abstractmethod
    def Prepare(self) -> None: ...
    @abc.abstractmethod
    def PrepareAsync(self, cancellationToken: CancellationToken = ...) -> Task: ...
    # Skipped ExecuteReaderAsync due to it being static, abstract and generic.

    ExecuteReaderAsync : ExecuteReaderAsync_MethodGroup
    class ExecuteReaderAsync_MethodGroup:
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken = ...) -> Task_1[DbDataReader]:...
        @typing.overload
        def __call__(self, behavior: CommandBehavior, cancellationToken: CancellationToken = ...) -> Task_1[DbDataReader]:...



class DbBatchCommand(abc.ABC):
    @property
    def CommandText(self) -> str: ...
    @CommandText.setter
    def CommandText(self, value: str) -> str: ...
    @property
    def CommandType(self) -> CommandType: ...
    @CommandType.setter
    def CommandType(self, value: CommandType) -> CommandType: ...
    @property
    def Parameters(self) -> DbParameterCollection: ...
    @property
    def RecordsAffected(self) -> int: ...


class DbBatchCommandCollection(IList_1[DbBatchCommand], abc.ABC):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> DbBatchCommand: ...
    @Item.setter
    def Item(self, value: DbBatchCommand) -> DbBatchCommand: ...
    @abc.abstractmethod
    def Add(self, item: DbBatchCommand) -> None: ...
    @abc.abstractmethod
    def Clear(self) -> None: ...
    @abc.abstractmethod
    def Contains(self, item: DbBatchCommand) -> bool: ...
    @abc.abstractmethod
    def CopyTo(self, array: Array_1[DbBatchCommand], arrayIndex: int) -> None: ...
    @abc.abstractmethod
    def GetEnumerator(self) -> IEnumerator_1[DbBatchCommand]: ...
    @abc.abstractmethod
    def IndexOf(self, item: DbBatchCommand) -> int: ...
    @abc.abstractmethod
    def Insert(self, index: int, item: DbBatchCommand) -> None: ...
    @abc.abstractmethod
    def Remove(self, item: DbBatchCommand) -> bool: ...
    @abc.abstractmethod
    def RemoveAt(self, index: int) -> None: ...


class DbColumn(abc.ABC):
    @property
    def AllowDBNull(self) -> typing.Optional[bool]: ...
    @AllowDBNull.setter
    def AllowDBNull(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def BaseCatalogName(self) -> str: ...
    @BaseCatalogName.setter
    def BaseCatalogName(self, value: str) -> str: ...
    @property
    def BaseColumnName(self) -> str: ...
    @BaseColumnName.setter
    def BaseColumnName(self, value: str) -> str: ...
    @property
    def BaseSchemaName(self) -> str: ...
    @BaseSchemaName.setter
    def BaseSchemaName(self, value: str) -> str: ...
    @property
    def BaseServerName(self) -> str: ...
    @BaseServerName.setter
    def BaseServerName(self, value: str) -> str: ...
    @property
    def BaseTableName(self) -> str: ...
    @BaseTableName.setter
    def BaseTableName(self, value: str) -> str: ...
    @property
    def ColumnName(self) -> str: ...
    @ColumnName.setter
    def ColumnName(self, value: str) -> str: ...
    @property
    def ColumnOrdinal(self) -> typing.Optional[int]: ...
    @ColumnOrdinal.setter
    def ColumnOrdinal(self, value: typing.Optional[int]) -> typing.Optional[int]: ...
    @property
    def ColumnSize(self) -> typing.Optional[int]: ...
    @ColumnSize.setter
    def ColumnSize(self, value: typing.Optional[int]) -> typing.Optional[int]: ...
    @property
    def DataType(self) -> typing.Type[typing.Any]: ...
    @DataType.setter
    def DataType(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def DataTypeName(self) -> str: ...
    @DataTypeName.setter
    def DataTypeName(self, value: str) -> str: ...
    @property
    def IsAliased(self) -> typing.Optional[bool]: ...
    @IsAliased.setter
    def IsAliased(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def IsAutoIncrement(self) -> typing.Optional[bool]: ...
    @IsAutoIncrement.setter
    def IsAutoIncrement(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def IsExpression(self) -> typing.Optional[bool]: ...
    @IsExpression.setter
    def IsExpression(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def IsHidden(self) -> typing.Optional[bool]: ...
    @IsHidden.setter
    def IsHidden(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def IsIdentity(self) -> typing.Optional[bool]: ...
    @IsIdentity.setter
    def IsIdentity(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def IsKey(self) -> typing.Optional[bool]: ...
    @IsKey.setter
    def IsKey(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def IsLong(self) -> typing.Optional[bool]: ...
    @IsLong.setter
    def IsLong(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def IsReadOnly(self) -> typing.Optional[bool]: ...
    @IsReadOnly.setter
    def IsReadOnly(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def IsUnique(self) -> typing.Optional[bool]: ...
    @IsUnique.setter
    def IsUnique(self, value: typing.Optional[bool]) -> typing.Optional[bool]: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def NumericPrecision(self) -> typing.Optional[int]: ...
    @NumericPrecision.setter
    def NumericPrecision(self, value: typing.Optional[int]) -> typing.Optional[int]: ...
    @property
    def NumericScale(self) -> typing.Optional[int]: ...
    @NumericScale.setter
    def NumericScale(self, value: typing.Optional[int]) -> typing.Optional[int]: ...
    @property
    def UdtAssemblyQualifiedName(self) -> str: ...
    @UdtAssemblyQualifiedName.setter
    def UdtAssemblyQualifiedName(self, value: str) -> str: ...


class DbCommand(Component, IDbCommand, IAsyncDisposable, abc.ABC):
    @property
    def CommandText(self) -> str: ...
    @CommandText.setter
    def CommandText(self, value: str) -> str: ...
    @property
    def CommandTimeout(self) -> int: ...
    @CommandTimeout.setter
    def CommandTimeout(self, value: int) -> int: ...
    @property
    def CommandType(self) -> CommandType: ...
    @CommandType.setter
    def CommandType(self, value: CommandType) -> CommandType: ...
    @property
    def Connection(self) -> DbConnection: ...
    @Connection.setter
    def Connection(self, value: DbConnection) -> DbConnection: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DesignTimeVisible(self) -> bool: ...
    @DesignTimeVisible.setter
    def DesignTimeVisible(self, value: bool) -> bool: ...
    @property
    def Parameters(self) -> DbParameterCollection: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def Transaction(self) -> DbTransaction: ...
    @Transaction.setter
    def Transaction(self, value: DbTransaction) -> DbTransaction: ...
    @property
    def UpdatedRowSource(self) -> UpdateRowSource: ...
    @UpdatedRowSource.setter
    def UpdatedRowSource(self, value: UpdateRowSource) -> UpdateRowSource: ...
    @abc.abstractmethod
    def Cancel(self) -> None: ...
    def CreateParameter(self) -> DbParameter: ...
    def DisposeAsync(self) -> ValueTask: ...
    @abc.abstractmethod
    def ExecuteNonQuery(self) -> int: ...
    @abc.abstractmethod
    def ExecuteScalar(self) -> typing.Any: ...
    @abc.abstractmethod
    def Prepare(self) -> None: ...
    def PrepareAsync(self, cancellationToken: CancellationToken = ...) -> Task: ...
    # Skipped ExecuteNonQueryAsync due to it being static, abstract and generic.

    ExecuteNonQueryAsync : ExecuteNonQueryAsync_MethodGroup
    class ExecuteNonQueryAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task_1[int]:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Task_1[int]:...

    # Skipped ExecuteReader due to it being static, abstract and generic.

    ExecuteReader : ExecuteReader_MethodGroup
    class ExecuteReader_MethodGroup:
        @typing.overload
        def __call__(self) -> DbDataReader:...
        @typing.overload
        def __call__(self, behavior: CommandBehavior) -> DbDataReader:...

    # Skipped ExecuteReaderAsync due to it being static, abstract and generic.

    ExecuteReaderAsync : ExecuteReaderAsync_MethodGroup
    class ExecuteReaderAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task_1[DbDataReader]:...
        @typing.overload
        def __call__(self, behavior: CommandBehavior) -> Task_1[DbDataReader]:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Task_1[DbDataReader]:...
        @typing.overload
        def __call__(self, behavior: CommandBehavior, cancellationToken: CancellationToken) -> Task_1[DbDataReader]:...

    # Skipped ExecuteScalarAsync due to it being static, abstract and generic.

    ExecuteScalarAsync : ExecuteScalarAsync_MethodGroup
    class ExecuteScalarAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task_1[typing.Any]:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Task_1[typing.Any]:...



class DbCommandBuilder(Component, abc.ABC):
    @property
    def CatalogLocation(self) -> CatalogLocation: ...
    @CatalogLocation.setter
    def CatalogLocation(self, value: CatalogLocation) -> CatalogLocation: ...
    @property
    def CatalogSeparator(self) -> str: ...
    @CatalogSeparator.setter
    def CatalogSeparator(self, value: str) -> str: ...
    @property
    def ConflictOption(self) -> ConflictOption: ...
    @ConflictOption.setter
    def ConflictOption(self, value: ConflictOption) -> ConflictOption: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DataAdapter(self) -> DbDataAdapter: ...
    @DataAdapter.setter
    def DataAdapter(self, value: DbDataAdapter) -> DbDataAdapter: ...
    @property
    def QuotePrefix(self) -> str: ...
    @QuotePrefix.setter
    def QuotePrefix(self, value: str) -> str: ...
    @property
    def QuoteSuffix(self) -> str: ...
    @QuoteSuffix.setter
    def QuoteSuffix(self, value: str) -> str: ...
    @property
    def SchemaSeparator(self) -> str: ...
    @SchemaSeparator.setter
    def SchemaSeparator(self, value: str) -> str: ...
    @property
    def SetAllValues(self) -> bool: ...
    @SetAllValues.setter
    def SetAllValues(self, value: bool) -> bool: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    def QuoteIdentifier(self, unquotedIdentifier: str) -> str: ...
    def RefreshSchema(self) -> None: ...
    def UnquoteIdentifier(self, quotedIdentifier: str) -> str: ...
    # Skipped GetDeleteCommand due to it being static, abstract and generic.

    GetDeleteCommand : GetDeleteCommand_MethodGroup
    class GetDeleteCommand_MethodGroup:
        @typing.overload
        def __call__(self) -> DbCommand:...
        @typing.overload
        def __call__(self, useColumnsForParameterNames: bool) -> DbCommand:...

    # Skipped GetInsertCommand due to it being static, abstract and generic.

    GetInsertCommand : GetInsertCommand_MethodGroup
    class GetInsertCommand_MethodGroup:
        @typing.overload
        def __call__(self) -> DbCommand:...
        @typing.overload
        def __call__(self, useColumnsForParameterNames: bool) -> DbCommand:...

    # Skipped GetUpdateCommand due to it being static, abstract and generic.

    GetUpdateCommand : GetUpdateCommand_MethodGroup
    class GetUpdateCommand_MethodGroup:
        @typing.overload
        def __call__(self) -> DbCommand:...
        @typing.overload
        def __call__(self, useColumnsForParameterNames: bool) -> DbCommand:...



class DbConnection(Component, IDbConnection, IAsyncDisposable, abc.ABC):
    @property
    def CanCreateBatch(self) -> bool: ...
    @property
    def ConnectionString(self) -> str: ...
    @ConnectionString.setter
    def ConnectionString(self, value: str) -> str: ...
    @property
    def ConnectionTimeout(self) -> int: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def Database(self) -> str: ...
    @property
    def DataSource(self) -> str: ...
    @property
    def ServerVersion(self) -> str: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def State(self) -> ConnectionState: ...
    @abc.abstractmethod
    def ChangeDatabase(self, databaseName: str) -> None: ...
    def ChangeDatabaseAsync(self, databaseName: str, cancellationToken: CancellationToken = ...) -> Task: ...
    @abc.abstractmethod
    def Close(self) -> None: ...
    def CloseAsync(self) -> Task: ...
    def CreateBatch(self) -> DbBatch: ...
    def CreateCommand(self) -> DbCommand: ...
    def DisposeAsync(self) -> ValueTask: ...
    def EnlistTransaction(self, transaction: Transaction) -> None: ...
    @abc.abstractmethod
    def Open(self) -> None: ...
    # Skipped BeginTransaction due to it being static, abstract and generic.

    BeginTransaction : BeginTransaction_MethodGroup
    class BeginTransaction_MethodGroup:
        @typing.overload
        def __call__(self) -> DbTransaction:...
        @typing.overload
        def __call__(self, isolationLevel: IsolationLevel) -> DbTransaction:...

    # Skipped BeginTransactionAsync due to it being static, abstract and generic.

    BeginTransactionAsync : BeginTransactionAsync_MethodGroup
    class BeginTransactionAsync_MethodGroup:
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken = ...) -> ValueTask_1[DbTransaction]:...
        @typing.overload
        def __call__(self, isolationLevel: IsolationLevel, cancellationToken: CancellationToken = ...) -> ValueTask_1[DbTransaction]:...

    # Skipped GetSchema due to it being static, abstract and generic.

    GetSchema : GetSchema_MethodGroup
    class GetSchema_MethodGroup:
        @typing.overload
        def __call__(self) -> DataTable:...
        @typing.overload
        def __call__(self, collectionName: str) -> DataTable:...
        @typing.overload
        def __call__(self, collectionName: str, restrictionValues: Array_1[str]) -> DataTable:...

    # Skipped GetSchemaAsync due to it being static, abstract and generic.

    GetSchemaAsync : GetSchemaAsync_MethodGroup
    class GetSchemaAsync_MethodGroup:
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken = ...) -> Task_1[DataTable]:...
        @typing.overload
        def __call__(self, collectionName: str, cancellationToken: CancellationToken = ...) -> Task_1[DataTable]:...
        @typing.overload
        def __call__(self, collectionName: str, restrictionValues: Array_1[str], cancellationToken: CancellationToken = ...) -> Task_1[DataTable]:...

    # Skipped OpenAsync due to it being static, abstract and generic.

    OpenAsync : OpenAsync_MethodGroup
    class OpenAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Task:...



class DbConnectionStringBuilder(IDictionary, ICustomTypeDescriptor):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, useOdbcRules: bool) -> None: ...
    @property
    def BrowsableConnectionString(self) -> bool: ...
    @BrowsableConnectionString.setter
    def BrowsableConnectionString(self, value: bool) -> bool: ...
    @property
    def ConnectionString(self) -> str: ...
    @ConnectionString.setter
    def ConnectionString(self, value: str) -> str: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsFixedSize(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Keys(self) -> ICollection: ...
    @property
    def Values(self) -> ICollection: ...
    def Add(self, keyword: str, value: typing.Any) -> None: ...
    def Clear(self) -> None: ...
    def ContainsKey(self, keyword: str) -> bool: ...
    def EquivalentTo(self, connectionStringBuilder: DbConnectionStringBuilder) -> bool: ...
    def Remove(self, keyword: str) -> bool: ...
    def ShouldSerialize(self, keyword: str) -> bool: ...
    def ToString(self) -> str: ...
    def TryGetValue(self, keyword: str, value: clr.Reference[typing.Any]) -> bool: ...
    # Skipped AppendKeyValuePair due to it being static, abstract and generic.

    AppendKeyValuePair : AppendKeyValuePair_MethodGroup
    class AppendKeyValuePair_MethodGroup:
        @typing.overload
        def __call__(self, builder: StringBuilder, keyword: str, value: str) -> None:...
        @typing.overload
        def __call__(self, builder: StringBuilder, keyword: str, value: str, useOdbcRules: bool) -> None:...



class DbDataAdapter(DataAdapter, IDbDataAdapter, ICloneable, abc.ABC):
    DefaultSourceTableName : str
    @property
    def AcceptChangesDuringFill(self) -> bool: ...
    @AcceptChangesDuringFill.setter
    def AcceptChangesDuringFill(self, value: bool) -> bool: ...
    @property
    def AcceptChangesDuringUpdate(self) -> bool: ...
    @AcceptChangesDuringUpdate.setter
    def AcceptChangesDuringUpdate(self, value: bool) -> bool: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def ContinueUpdateOnError(self) -> bool: ...
    @ContinueUpdateOnError.setter
    def ContinueUpdateOnError(self, value: bool) -> bool: ...
    @property
    def DeleteCommand(self) -> DbCommand: ...
    @DeleteCommand.setter
    def DeleteCommand(self, value: DbCommand) -> DbCommand: ...
    @property
    def FillLoadOption(self) -> LoadOption: ...
    @FillLoadOption.setter
    def FillLoadOption(self, value: LoadOption) -> LoadOption: ...
    @property
    def InsertCommand(self) -> DbCommand: ...
    @InsertCommand.setter
    def InsertCommand(self, value: DbCommand) -> DbCommand: ...
    @property
    def MissingMappingAction(self) -> MissingMappingAction: ...
    @MissingMappingAction.setter
    def MissingMappingAction(self, value: MissingMappingAction) -> MissingMappingAction: ...
    @property
    def MissingSchemaAction(self) -> MissingSchemaAction: ...
    @MissingSchemaAction.setter
    def MissingSchemaAction(self, value: MissingSchemaAction) -> MissingSchemaAction: ...
    @property
    def ReturnProviderSpecificTypes(self) -> bool: ...
    @ReturnProviderSpecificTypes.setter
    def ReturnProviderSpecificTypes(self, value: bool) -> bool: ...
    @property
    def SelectCommand(self) -> DbCommand: ...
    @SelectCommand.setter
    def SelectCommand(self, value: DbCommand) -> DbCommand: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def TableMappings(self) -> DataTableMappingCollection: ...
    @property
    def UpdateBatchSize(self) -> int: ...
    @UpdateBatchSize.setter
    def UpdateBatchSize(self, value: int) -> int: ...
    @property
    def UpdateCommand(self) -> DbCommand: ...
    @UpdateCommand.setter
    def UpdateCommand(self, value: DbCommand) -> DbCommand: ...
    def GetFillParameters(self) -> Array_1[IDataParameter]: ...
    # Skipped Fill due to it being static, abstract and generic.

    Fill : Fill_MethodGroup
    class Fill_MethodGroup:
        @typing.overload
        def __call__(self, dataSet: DataSet) -> int:...
        @typing.overload
        def __call__(self, dataTable: DataTable) -> int:...
        @typing.overload
        def __call__(self, dataSet: DataSet, srcTable: str) -> int:...
        @typing.overload
        def __call__(self, startRecord: int, maxRecords: int, dataTables: Array_1[DataTable]) -> int:...
        @typing.overload
        def __call__(self, dataSet: DataSet, startRecord: int, maxRecords: int, srcTable: str) -> int:...

    # Skipped FillSchema due to it being static, abstract and generic.

    FillSchema : FillSchema_MethodGroup
    class FillSchema_MethodGroup:
        @typing.overload
        def __call__(self, dataSet: DataSet, schemaType: SchemaType) -> Array_1[DataTable]:...
        @typing.overload
        def __call__(self, dataTable: DataTable, schemaType: SchemaType) -> DataTable:...
        @typing.overload
        def __call__(self, dataSet: DataSet, schemaType: SchemaType, srcTable: str) -> Array_1[DataTable]:...

    # Skipped Update due to it being static, abstract and generic.

    Update : Update_MethodGroup
    class Update_MethodGroup:
        @typing.overload
        def __call__(self, dataRows: Array_1[DataRow]) -> int:...
        @typing.overload
        def __call__(self, dataSet: DataSet) -> int:...
        @typing.overload
        def __call__(self, dataTable: DataTable) -> int:...
        @typing.overload
        def __call__(self, dataSet: DataSet, srcTable: str) -> int:...



class DbDataReader(MarshalByRefObject, IDataReader, IAsyncDisposable, IEnumerable):
    @property
    def Depth(self) -> int: ...
    @property
    def FieldCount(self) -> int: ...
    @property
    def HasRows(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def RecordsAffected(self) -> int: ...
    @property
    def VisibleFieldCount(self) -> int: ...
    def Close(self) -> None: ...
    def CloseAsync(self) -> Task: ...
    def Dispose(self) -> None: ...
    def DisposeAsync(self) -> ValueTask: ...
    @abc.abstractmethod
    def GetBoolean(self, ordinal: int) -> bool: ...
    @abc.abstractmethod
    def GetByte(self, ordinal: int) -> int: ...
    @abc.abstractmethod
    def GetBytes(self, ordinal: int, dataOffset: int, buffer: Array_1[int], bufferOffset: int, length: int) -> int: ...
    @abc.abstractmethod
    def GetChar(self, ordinal: int) -> str: ...
    @abc.abstractmethod
    def GetChars(self, ordinal: int, dataOffset: int, buffer: Array_1[str], bufferOffset: int, length: int) -> int: ...
    def GetColumnSchemaAsync(self, cancellationToken: CancellationToken = ...) -> Task_1[ReadOnlyCollection_1[DbColumn]]: ...
    def GetData(self, ordinal: int) -> DbDataReader: ...
    @abc.abstractmethod
    def GetDataTypeName(self, ordinal: int) -> str: ...
    @abc.abstractmethod
    def GetDateTime(self, ordinal: int) -> DateTime: ...
    @abc.abstractmethod
    def GetDecimal(self, ordinal: int) -> Decimal: ...
    @abc.abstractmethod
    def GetDouble(self, ordinal: int) -> float: ...
    @abc.abstractmethod
    def GetEnumerator(self) -> IEnumerator: ...
    @abc.abstractmethod
    def GetFieldType(self, ordinal: int) -> typing.Type[typing.Any]: ...
    @abc.abstractmethod
    def GetFloat(self, ordinal: int) -> float: ...
    @abc.abstractmethod
    def GetGuid(self, ordinal: int) -> Guid: ...
    @abc.abstractmethod
    def GetInt16(self, ordinal: int) -> int: ...
    @abc.abstractmethod
    def GetInt32(self, ordinal: int) -> int: ...
    @abc.abstractmethod
    def GetInt64(self, ordinal: int) -> int: ...
    @abc.abstractmethod
    def GetName(self, ordinal: int) -> str: ...
    @abc.abstractmethod
    def GetOrdinal(self, name: str) -> int: ...
    def GetProviderSpecificFieldType(self, ordinal: int) -> typing.Type[typing.Any]: ...
    def GetProviderSpecificValue(self, ordinal: int) -> typing.Any: ...
    def GetProviderSpecificValues(self, values: Array_1[typing.Any]) -> int: ...
    def GetSchemaTable(self) -> DataTable: ...
    def GetSchemaTableAsync(self, cancellationToken: CancellationToken = ...) -> Task_1[DataTable]: ...
    def GetStream(self, ordinal: int) -> Stream: ...
    @abc.abstractmethod
    def GetString(self, ordinal: int) -> str: ...
    def GetTextReader(self, ordinal: int) -> TextReader: ...
    @abc.abstractmethod
    def GetValue(self, ordinal: int) -> typing.Any: ...
    @abc.abstractmethod
    def GetValues(self, values: Array_1[typing.Any]) -> int: ...
    @abc.abstractmethod
    def IsDBNull(self, ordinal: int) -> bool: ...
    @abc.abstractmethod
    def NextResult(self) -> bool: ...
    @abc.abstractmethod
    def Read(self) -> bool: ...
    # Skipped GetFieldValue due to it being static, abstract and generic.

    GetFieldValue : GetFieldValue_MethodGroup
    class GetFieldValue_MethodGroup:
        def __getitem__(self, t:typing.Type[GetFieldValue_1_T1]) -> GetFieldValue_1[GetFieldValue_1_T1]: ...

        GetFieldValue_1_T1 = typing.TypeVar('GetFieldValue_1_T1')
        class GetFieldValue_1(typing.Generic[GetFieldValue_1_T1]):
            GetFieldValue_1_T = DbDataReader.GetFieldValue_MethodGroup.GetFieldValue_1_T1
            def __call__(self, ordinal: int) -> GetFieldValue_1_T:...


    # Skipped GetFieldValueAsync due to it being static, abstract and generic.

    GetFieldValueAsync : GetFieldValueAsync_MethodGroup
    class GetFieldValueAsync_MethodGroup:
        def __getitem__(self, t:typing.Type[GetFieldValueAsync_1_T1]) -> GetFieldValueAsync_1[GetFieldValueAsync_1_T1]: ...

        GetFieldValueAsync_1_T1 = typing.TypeVar('GetFieldValueAsync_1_T1')
        class GetFieldValueAsync_1(typing.Generic[GetFieldValueAsync_1_T1]):
            GetFieldValueAsync_1_T = DbDataReader.GetFieldValueAsync_MethodGroup.GetFieldValueAsync_1_T1
            @typing.overload
            def __call__(self, ordinal: int) -> Task_1[GetFieldValueAsync_1_T]:...
            @typing.overload
            def __call__(self, ordinal: int, cancellationToken: CancellationToken) -> Task_1[GetFieldValueAsync_1_T]:...


    # Skipped IsDBNullAsync due to it being static, abstract and generic.

    IsDBNullAsync : IsDBNullAsync_MethodGroup
    class IsDBNullAsync_MethodGroup:
        @typing.overload
        def __call__(self, ordinal: int) -> Task_1[bool]:...
        @typing.overload
        def __call__(self, ordinal: int, cancellationToken: CancellationToken) -> Task_1[bool]:...

    # Skipped NextResultAsync due to it being static, abstract and generic.

    NextResultAsync : NextResultAsync_MethodGroup
    class NextResultAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task_1[bool]:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Task_1[bool]:...

    # Skipped ReadAsync due to it being static, abstract and generic.

    ReadAsync : ReadAsync_MethodGroup
    class ReadAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task_1[bool]:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Task_1[bool]:...



class DbDataReaderExtensions(abc.ABC):
    @staticmethod
    def CanGetColumnSchema(reader: DbDataReader) -> bool: ...
    @staticmethod
    def GetColumnSchema(reader: DbDataReader) -> ReadOnlyCollection_1[DbColumn]: ...


class DbDataRecord(IDataRecord, ICustomTypeDescriptor, abc.ABC):
    @property
    def FieldCount(self) -> int: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @abc.abstractmethod
    def GetBoolean(self, i: int) -> bool: ...
    @abc.abstractmethod
    def GetByte(self, i: int) -> int: ...
    @abc.abstractmethod
    def GetBytes(self, i: int, dataIndex: int, buffer: Array_1[int], bufferIndex: int, length: int) -> int: ...
    @abc.abstractmethod
    def GetChar(self, i: int) -> str: ...
    @abc.abstractmethod
    def GetChars(self, i: int, dataIndex: int, buffer: Array_1[str], bufferIndex: int, length: int) -> int: ...
    def GetData(self, i: int) -> IDataReader: ...
    @abc.abstractmethod
    def GetDataTypeName(self, i: int) -> str: ...
    @abc.abstractmethod
    def GetDateTime(self, i: int) -> DateTime: ...
    @abc.abstractmethod
    def GetDecimal(self, i: int) -> Decimal: ...
    @abc.abstractmethod
    def GetDouble(self, i: int) -> float: ...
    @abc.abstractmethod
    def GetFieldType(self, i: int) -> typing.Type[typing.Any]: ...
    @abc.abstractmethod
    def GetFloat(self, i: int) -> float: ...
    @abc.abstractmethod
    def GetGuid(self, i: int) -> Guid: ...
    @abc.abstractmethod
    def GetInt16(self, i: int) -> int: ...
    @abc.abstractmethod
    def GetInt32(self, i: int) -> int: ...
    @abc.abstractmethod
    def GetInt64(self, i: int) -> int: ...
    @abc.abstractmethod
    def GetName(self, i: int) -> str: ...
    @abc.abstractmethod
    def GetOrdinal(self, name: str) -> int: ...
    @abc.abstractmethod
    def GetString(self, i: int) -> str: ...
    @abc.abstractmethod
    def GetValue(self, i: int) -> typing.Any: ...
    @abc.abstractmethod
    def GetValues(self, values: Array_1[typing.Any]) -> int: ...
    @abc.abstractmethod
    def IsDBNull(self, i: int) -> bool: ...


class DbDataSourceEnumerator(abc.ABC):
    @abc.abstractmethod
    def GetDataSources(self) -> DataTable: ...


class DbEnumerator(IEnumerator):
    @typing.overload
    def __init__(self, reader: IDataReader) -> None: ...
    @typing.overload
    def __init__(self, reader: DbDataReader) -> None: ...
    @typing.overload
    def __init__(self, reader: IDataReader, closeReader: bool) -> None: ...
    @typing.overload
    def __init__(self, reader: DbDataReader, closeReader: bool) -> None: ...
    @property
    def Current(self) -> typing.Any: ...
    def MoveNext(self) -> bool: ...
    def Reset(self) -> None: ...


class DbException(ExternalException, abc.ABC):
    @property
    def BatchCommand(self) -> DbBatchCommand: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def ErrorCode(self) -> int: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def IsTransient(self) -> bool: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def SqlState(self) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class DbMetaDataCollectionNames(abc.ABC):
    DataSourceInformation : str
    DataTypes : str
    MetaDataCollections : str
    ReservedWords : str
    Restrictions : str


class DbMetaDataColumnNames(abc.ABC):
    CollectionName : str
    ColumnSize : str
    CompositeIdentifierSeparatorPattern : str
    CreateFormat : str
    CreateParameters : str
    DataSourceProductName : str
    DataSourceProductVersion : str
    DataSourceProductVersionNormalized : str
    DataType : str
    GroupByBehavior : str
    IdentifierCase : str
    IdentifierPattern : str
    IsAutoIncrementable : str
    IsBestMatch : str
    IsCaseSensitive : str
    IsConcurrencyType : str
    IsFixedLength : str
    IsFixedPrecisionScale : str
    IsLiteralSupported : str
    IsLong : str
    IsNullable : str
    IsSearchable : str
    IsSearchableWithLike : str
    IsUnsigned : str
    LiteralPrefix : str
    LiteralSuffix : str
    MaximumScale : str
    MinimumScale : str
    NumberOfIdentifierParts : str
    NumberOfRestrictions : str
    OrderByColumnsInSelect : str
    ParameterMarkerFormat : str
    ParameterMarkerPattern : str
    ParameterNameMaxLength : str
    ParameterNamePattern : str
    ProviderDbType : str
    QuotedIdentifierCase : str
    QuotedIdentifierPattern : str
    ReservedWord : str
    StatementSeparatorPattern : str
    StringLiteralPattern : str
    SupportedJoinOperators : str
    TypeName : str


class DbParameter(MarshalByRefObject, IDbDataParameter):
    @property
    def DbType(self) -> DbType: ...
    @DbType.setter
    def DbType(self, value: DbType) -> DbType: ...
    @property
    def Direction(self) -> ParameterDirection: ...
    @Direction.setter
    def Direction(self, value: ParameterDirection) -> ParameterDirection: ...
    @property
    def IsNullable(self) -> bool: ...
    @IsNullable.setter
    def IsNullable(self, value: bool) -> bool: ...
    @property
    def ParameterName(self) -> str: ...
    @ParameterName.setter
    def ParameterName(self, value: str) -> str: ...
    @property
    def Precision(self) -> int: ...
    @Precision.setter
    def Precision(self, value: int) -> int: ...
    @property
    def Scale(self) -> int: ...
    @Scale.setter
    def Scale(self, value: int) -> int: ...
    @property
    def Size(self) -> int: ...
    @Size.setter
    def Size(self, value: int) -> int: ...
    @property
    def SourceColumn(self) -> str: ...
    @SourceColumn.setter
    def SourceColumn(self, value: str) -> str: ...
    @property
    def SourceColumnNullMapping(self) -> bool: ...
    @SourceColumnNullMapping.setter
    def SourceColumnNullMapping(self, value: bool) -> bool: ...
    @property
    def SourceVersion(self) -> DataRowVersion: ...
    @SourceVersion.setter
    def SourceVersion(self, value: DataRowVersion) -> DataRowVersion: ...
    @property
    def Value(self) -> typing.Any: ...
    @Value.setter
    def Value(self, value: typing.Any) -> typing.Any: ...
    @abc.abstractmethod
    def ResetDbType(self) -> None: ...


class DbParameterCollection(MarshalByRefObject, IDataParameterCollection):
    @property
    def Count(self) -> int: ...
    @property
    def IsFixedSize(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> DbParameter: ...
    @Item.setter
    def Item(self, value: DbParameter) -> DbParameter: ...
    @property
    def Item(self) -> DbParameter: ...
    @Item.setter
    def Item(self, value: DbParameter) -> DbParameter: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    @abc.abstractmethod
    def Add(self, value: typing.Any) -> int: ...
    @abc.abstractmethod
    def AddRange(self, values: Array) -> None: ...
    @abc.abstractmethod
    def Clear(self) -> None: ...
    @abc.abstractmethod
    def CopyTo(self, array: Array, index: int) -> None: ...
    @abc.abstractmethod
    def GetEnumerator(self) -> IEnumerator: ...
    @abc.abstractmethod
    def Insert(self, index: int, value: typing.Any) -> None: ...
    @abc.abstractmethod
    def Remove(self, value: typing.Any) -> None: ...
    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, value: str) -> bool:...
        @typing.overload
        def __call__(self, value: typing.Any) -> bool:...

    # Skipped IndexOf due to it being static, abstract and generic.

    IndexOf : IndexOf_MethodGroup
    class IndexOf_MethodGroup:
        @typing.overload
        def __call__(self, parameterName: str) -> int:...
        @typing.overload
        def __call__(self, value: typing.Any) -> int:...

    # Skipped RemoveAt due to it being static, abstract and generic.

    RemoveAt : RemoveAt_MethodGroup
    class RemoveAt_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> None:...
        @typing.overload
        def __call__(self, parameterName: str) -> None:...



class DbProviderFactories(abc.ABC):
    @staticmethod
    def GetFactoryClasses() -> DataTable: ...
    @staticmethod
    def GetProviderInvariantNames() -> IEnumerable_1[str]: ...
    @staticmethod
    def TryGetFactory(providerInvariantName: str, factory: clr.Reference[DbProviderFactory]) -> bool: ...
    @staticmethod
    def UnregisterFactory(providerInvariantName: str) -> bool: ...
    # Skipped GetFactory due to it being static, abstract and generic.

    GetFactory : GetFactory_MethodGroup
    class GetFactory_MethodGroup:
        @typing.overload
        def __call__(self, connection: DbConnection) -> DbProviderFactory:...
        @typing.overload
        def __call__(self, providerInvariantName: str) -> DbProviderFactory:...
        @typing.overload
        def __call__(self, providerRow: DataRow) -> DbProviderFactory:...

    # Skipped RegisterFactory due to it being static, abstract and generic.

    RegisterFactory : RegisterFactory_MethodGroup
    class RegisterFactory_MethodGroup:
        @typing.overload
        def __call__(self, providerInvariantName: str, factoryTypeAssemblyQualifiedName: str) -> None:...
        @typing.overload
        def __call__(self, providerInvariantName: str, providerFactoryClass: typing.Type[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, providerInvariantName: str, factory: DbProviderFactory) -> None:...



class DbProviderFactory(abc.ABC):
    @property
    def CanCreateBatch(self) -> bool: ...
    @property
    def CanCreateCommandBuilder(self) -> bool: ...
    @property
    def CanCreateDataAdapter(self) -> bool: ...
    @property
    def CanCreateDataSourceEnumerator(self) -> bool: ...
    def CreateBatch(self) -> DbBatch: ...
    def CreateBatchCommand(self) -> DbBatchCommand: ...
    def CreateCommand(self) -> DbCommand: ...
    def CreateCommandBuilder(self) -> DbCommandBuilder: ...
    def CreateConnection(self) -> DbConnection: ...
    def CreateConnectionStringBuilder(self) -> DbConnectionStringBuilder: ...
    def CreateDataAdapter(self) -> DbDataAdapter: ...
    def CreateDataSourceEnumerator(self) -> DbDataSourceEnumerator: ...
    def CreateParameter(self) -> DbParameter: ...


class DbProviderSpecificTypePropertyAttribute(Attribute):
    def __init__(self, isProviderSpecificTypeProperty: bool) -> None: ...
    @property
    def IsProviderSpecificTypeProperty(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DbTransaction(MarshalByRefObject, IDbTransaction, IAsyncDisposable):
    @property
    def Connection(self) -> DbConnection: ...
    @property
    def IsolationLevel(self) -> IsolationLevel: ...
    @property
    def SupportsSavepoints(self) -> bool: ...
    @abc.abstractmethod
    def Commit(self) -> None: ...
    def CommitAsync(self, cancellationToken: CancellationToken = ...) -> Task: ...
    def Dispose(self) -> None: ...
    def DisposeAsync(self) -> ValueTask: ...
    def Release(self, savepointName: str) -> None: ...
    def ReleaseAsync(self, savepointName: str, cancellationToken: CancellationToken = ...) -> Task: ...
    def Save(self, savepointName: str) -> None: ...
    def SaveAsync(self, savepointName: str, cancellationToken: CancellationToken = ...) -> Task: ...
    # Skipped Rollback due to it being static, abstract and generic.

    Rollback : Rollback_MethodGroup
    class Rollback_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, savepointName: str) -> None:...

    # Skipped RollbackAsync due to it being static, abstract and generic.

    RollbackAsync : RollbackAsync_MethodGroup
    class RollbackAsync_MethodGroup:
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken = ...) -> Task:...
        @typing.overload
        def __call__(self, savepointName: str, cancellationToken: CancellationToken = ...) -> Task:...



class GroupByBehavior(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : GroupByBehavior # 0
    NotSupported : GroupByBehavior # 1
    Unrelated : GroupByBehavior # 2
    MustContainAll : GroupByBehavior # 3
    ExactMatch : GroupByBehavior # 4


class IDbColumnSchemaGenerator(typing.Protocol):
    @abc.abstractmethod
    def GetColumnSchema(self) -> ReadOnlyCollection_1[DbColumn]: ...


class IdentifierCase(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : IdentifierCase # 0
    Insensitive : IdentifierCase # 1
    Sensitive : IdentifierCase # 2


class RowUpdatedEventArgs(EventArgs):
    def __init__(self, dataRow: DataRow, command: IDbCommand, statementType: StatementType, tableMapping: DataTableMapping) -> None: ...
    @property
    def Command(self) -> IDbCommand: ...
    @property
    def Errors(self) -> Exception: ...
    @Errors.setter
    def Errors(self, value: Exception) -> Exception: ...
    @property
    def RecordsAffected(self) -> int: ...
    @property
    def Row(self) -> DataRow: ...
    @property
    def RowCount(self) -> int: ...
    @property
    def StatementType(self) -> StatementType: ...
    @property
    def Status(self) -> UpdateStatus: ...
    @Status.setter
    def Status(self, value: UpdateStatus) -> UpdateStatus: ...
    @property
    def TableMapping(self) -> DataTableMapping: ...
    # Skipped CopyToRows due to it being static, abstract and generic.

    CopyToRows : CopyToRows_MethodGroup
    class CopyToRows_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[DataRow]) -> None:...
        @typing.overload
        def __call__(self, array: Array_1[DataRow], arrayIndex: int) -> None:...



class RowUpdatingEventArgs(EventArgs):
    def __init__(self, dataRow: DataRow, command: IDbCommand, statementType: StatementType, tableMapping: DataTableMapping) -> None: ...
    @property
    def Command(self) -> IDbCommand: ...
    @Command.setter
    def Command(self, value: IDbCommand) -> IDbCommand: ...
    @property
    def Errors(self) -> Exception: ...
    @Errors.setter
    def Errors(self, value: Exception) -> Exception: ...
    @property
    def Row(self) -> DataRow: ...
    @property
    def StatementType(self) -> StatementType: ...
    @property
    def Status(self) -> UpdateStatus: ...
    @Status.setter
    def Status(self, value: UpdateStatus) -> UpdateStatus: ...
    @property
    def TableMapping(self) -> DataTableMapping: ...


class SchemaTableColumn(abc.ABC):
    AllowDBNull : str
    BaseColumnName : str
    BaseSchemaName : str
    BaseTableName : str
    ColumnName : str
    ColumnOrdinal : str
    ColumnSize : str
    DataType : str
    IsAliased : str
    IsExpression : str
    IsKey : str
    IsLong : str
    IsUnique : str
    NonVersionedProviderType : str
    NumericPrecision : str
    NumericScale : str
    ProviderType : str


class SchemaTableOptionalColumn(abc.ABC):
    AutoIncrementSeed : str
    AutoIncrementStep : str
    BaseCatalogName : str
    BaseColumnNamespace : str
    BaseServerName : str
    BaseTableNamespace : str
    ColumnMapping : str
    DefaultValue : str
    Expression : str
    IsAutoIncrement : str
    IsHidden : str
    IsReadOnly : str
    IsRowVersion : str
    ProviderSpecificDataType : str


class SupportedJoinOperators(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : SupportedJoinOperators # 0
    Inner : SupportedJoinOperators # 1
    LeftOuter : SupportedJoinOperators # 2
    RightOuter : SupportedJoinOperators # 4
    FullOuter : SupportedJoinOperators # 8

