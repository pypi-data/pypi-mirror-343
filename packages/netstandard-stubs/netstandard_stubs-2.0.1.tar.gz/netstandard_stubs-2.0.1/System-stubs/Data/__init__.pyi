import typing, abc
from System import Array, Array_1, Exception, EventArgs, MulticastDelegate, IAsyncResult, AsyncCallback, SystemException, DateTime, Decimal, Guid, Converter_2, Func_2, IDisposable
from System.Collections import IDictionary, IEnumerator, ICollection, IEnumerable, IList, Hashtable
from System.Reflection import MethodBase, MethodInfo
from System.ComponentModel import MarshalByValueComponent, IContainer, ISite, INotifyPropertyChanged, IDataErrorInfo, IEditableObject, ICustomTypeDescriptor, ISupportInitializeNotification, IListSource, DescriptionAttribute, IBindingListView, ITypedList, IBindingList
from System.Data.Common import DbDataReader
from System.IO import Stream, TextReader, TextWriter
from System.Threading.Tasks import Task_1
from System.Threading import CancellationToken
from System.Collections.Generic import IEqualityComparer_1, IEnumerable_1, IEnumerator_1, IComparer_1
from System.Runtime.Serialization import ISerializable, SerializationInfo, StreamingContext
from System.Xml.Serialization import IXmlSerializable
from System.Globalization import CultureInfo
from System.Xml.Schema import XmlSchemaComplexType, XmlSchemaSet
from System.Xml import XmlReader, XmlWriter

class AcceptRejectRule(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : AcceptRejectRule # 0
    Cascade : AcceptRejectRule # 1


class CommandBehavior(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Default : CommandBehavior # 0
    SingleResult : CommandBehavior # 1
    SchemaOnly : CommandBehavior # 2
    KeyInfo : CommandBehavior # 4
    SingleRow : CommandBehavior # 8
    SequentialAccess : CommandBehavior # 16
    CloseConnection : CommandBehavior # 32


class CommandType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Text : CommandType # 1
    StoredProcedure : CommandType # 4
    TableDirect : CommandType # 512


class ConflictOption(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    CompareAllSearchableValues : ConflictOption # 1
    CompareRowVersion : ConflictOption # 2
    OverwriteChanges : ConflictOption # 3


class ConnectionState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Closed : ConnectionState # 0
    Open : ConnectionState # 1
    Connecting : ConnectionState # 2
    Executing : ConnectionState # 4
    Fetching : ConnectionState # 8
    Broken : ConnectionState # 16


class Constraint(abc.ABC):
    @property
    def ConstraintName(self) -> str: ...
    @ConstraintName.setter
    def ConstraintName(self, value: str) -> str: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def Table(self) -> DataTable: ...
    def ToString(self) -> str: ...


class ConstraintCollection(InternalDataCollectionBase):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> Constraint: ...
    @property
    def Item(self) -> Constraint: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def AddRange(self, constraints: Array_1[Constraint]) -> None: ...
    def CanRemove(self, constraint: Constraint) -> bool: ...
    def Clear(self) -> None: ...
    def Contains(self, name: str) -> bool: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, constraint: Constraint) -> None:...
        @typing.overload
        def __call__(self, name: str, primaryKeyColumns: Array_1[DataColumn], foreignKeyColumns: Array_1[DataColumn]) -> Constraint:...
        @typing.overload
        def __call__(self, name: str, columns: Array_1[DataColumn], primaryKey: bool) -> Constraint:...
        @typing.overload
        def __call__(self, name: str, primaryKeyColumn: DataColumn, foreignKeyColumn: DataColumn) -> Constraint:...
        @typing.overload
        def __call__(self, name: str, column: DataColumn, primaryKey: bool) -> Constraint:...

    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[Constraint], index: int) -> None:...
        @typing.overload
        def __call__(self, ar: Array, index: int) -> None:...

    # Skipped IndexOf due to it being static, abstract and generic.

    IndexOf : IndexOf_MethodGroup
    class IndexOf_MethodGroup:
        @typing.overload
        def __call__(self, constraintName: str) -> int:...
        @typing.overload
        def __call__(self, constraint: Constraint) -> int:...

    # Skipped Remove due to it being static, abstract and generic.

    Remove : Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> None:...
        @typing.overload
        def __call__(self, constraint: Constraint) -> None:...



class ConstraintException(DataException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class DataColumn(MarshalByValueComponent):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, columnName: str) -> None: ...
    @typing.overload
    def __init__(self, columnName: str, dataType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, columnName: str, dataType: typing.Type[typing.Any], expr: str) -> None: ...
    @typing.overload
    def __init__(self, columnName: str, dataType: typing.Type[typing.Any], expr: str, type: MappingType) -> None: ...
    @property
    def AllowDBNull(self) -> bool: ...
    @AllowDBNull.setter
    def AllowDBNull(self, value: bool) -> bool: ...
    @property
    def AutoIncrement(self) -> bool: ...
    @AutoIncrement.setter
    def AutoIncrement(self, value: bool) -> bool: ...
    @property
    def AutoIncrementSeed(self) -> int: ...
    @AutoIncrementSeed.setter
    def AutoIncrementSeed(self, value: int) -> int: ...
    @property
    def AutoIncrementStep(self) -> int: ...
    @AutoIncrementStep.setter
    def AutoIncrementStep(self, value: int) -> int: ...
    @property
    def Caption(self) -> str: ...
    @Caption.setter
    def Caption(self, value: str) -> str: ...
    @property
    def ColumnMapping(self) -> MappingType: ...
    @ColumnMapping.setter
    def ColumnMapping(self, value: MappingType) -> MappingType: ...
    @property
    def ColumnName(self) -> str: ...
    @ColumnName.setter
    def ColumnName(self, value: str) -> str: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DataType(self) -> typing.Type[typing.Any]: ...
    @DataType.setter
    def DataType(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def DateTimeMode(self) -> DataSetDateTime: ...
    @DateTimeMode.setter
    def DateTimeMode(self, value: DataSetDateTime) -> DataSetDateTime: ...
    @property
    def DefaultValue(self) -> typing.Any: ...
    @DefaultValue.setter
    def DefaultValue(self, value: typing.Any) -> typing.Any: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def Expression(self) -> str: ...
    @Expression.setter
    def Expression(self, value: str) -> str: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def MaxLength(self) -> int: ...
    @MaxLength.setter
    def MaxLength(self, value: int) -> int: ...
    @property
    def Namespace(self) -> str: ...
    @Namespace.setter
    def Namespace(self, value: str) -> str: ...
    @property
    def Ordinal(self) -> int: ...
    @property
    def Prefix(self) -> str: ...
    @Prefix.setter
    def Prefix(self, value: str) -> str: ...
    @property
    def ReadOnly(self) -> bool: ...
    @ReadOnly.setter
    def ReadOnly(self, value: bool) -> bool: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def Table(self) -> DataTable: ...
    @property
    def Unique(self) -> bool: ...
    @Unique.setter
    def Unique(self, value: bool) -> bool: ...
    def SetOrdinal(self, ordinal: int) -> None: ...
    def ToString(self) -> str: ...


class DataColumnChangeEventArgs(EventArgs):
    def __init__(self, row: DataRow, column: DataColumn, value: typing.Any) -> None: ...
    @property
    def Column(self) -> DataColumn: ...
    @property
    def ProposedValue(self) -> typing.Any: ...
    @ProposedValue.setter
    def ProposedValue(self, value: typing.Any) -> typing.Any: ...
    @property
    def Row(self) -> DataRow: ...


class DataColumnChangeEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: DataColumnChangeEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: DataColumnChangeEventArgs) -> None: ...


class DataColumnCollection(InternalDataCollectionBase):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> DataColumn: ...
    @property
    def Item(self) -> DataColumn: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def AddRange(self, columns: Array_1[DataColumn]) -> None: ...
    def CanRemove(self, column: DataColumn) -> bool: ...
    def Clear(self) -> None: ...
    def Contains(self, name: str) -> bool: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self) -> DataColumn:...
        @typing.overload
        def __call__(self, column: DataColumn) -> None:...
        @typing.overload
        def __call__(self, columnName: str) -> DataColumn:...
        @typing.overload
        def __call__(self, columnName: str, type: typing.Type[typing.Any]) -> DataColumn:...
        @typing.overload
        def __call__(self, columnName: str, type: typing.Type[typing.Any], expression: str) -> DataColumn:...

    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[DataColumn], index: int) -> None:...
        @typing.overload
        def __call__(self, ar: Array, index: int) -> None:...

    # Skipped IndexOf due to it being static, abstract and generic.

    IndexOf : IndexOf_MethodGroup
    class IndexOf_MethodGroup:
        @typing.overload
        def __call__(self, column: DataColumn) -> int:...
        @typing.overload
        def __call__(self, columnName: str) -> int:...

    # Skipped Remove due to it being static, abstract and generic.

    Remove : Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, column: DataColumn) -> None:...
        @typing.overload
        def __call__(self, name: str) -> None:...



class DataException(SystemException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @typing.overload
    def __init__(self, s: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class DataReaderExtensions(abc.ABC):
    @staticmethod
    def GetBoolean(reader: DbDataReader, name: str) -> bool: ...
    @staticmethod
    def GetByte(reader: DbDataReader, name: str) -> int: ...
    @staticmethod
    def GetBytes(reader: DbDataReader, name: str, dataOffset: int, buffer: Array_1[int], bufferOffset: int, length: int) -> int: ...
    @staticmethod
    def GetChar(reader: DbDataReader, name: str) -> str: ...
    @staticmethod
    def GetChars(reader: DbDataReader, name: str, dataOffset: int, buffer: Array_1[str], bufferOffset: int, length: int) -> int: ...
    @staticmethod
    def GetData(reader: DbDataReader, name: str) -> DbDataReader: ...
    @staticmethod
    def GetDataTypeName(reader: DbDataReader, name: str) -> str: ...
    @staticmethod
    def GetDateTime(reader: DbDataReader, name: str) -> DateTime: ...
    @staticmethod
    def GetDecimal(reader: DbDataReader, name: str) -> Decimal: ...
    @staticmethod
    def GetDouble(reader: DbDataReader, name: str) -> float: ...
    @staticmethod
    def GetFieldType(reader: DbDataReader, name: str) -> typing.Type[typing.Any]: ...
    @staticmethod
    def GetFloat(reader: DbDataReader, name: str) -> float: ...
    @staticmethod
    def GetGuid(reader: DbDataReader, name: str) -> Guid: ...
    @staticmethod
    def GetInt16(reader: DbDataReader, name: str) -> int: ...
    @staticmethod
    def GetInt32(reader: DbDataReader, name: str) -> int: ...
    @staticmethod
    def GetInt64(reader: DbDataReader, name: str) -> int: ...
    @staticmethod
    def GetProviderSpecificFieldType(reader: DbDataReader, name: str) -> typing.Type[typing.Any]: ...
    @staticmethod
    def GetProviderSpecificValue(reader: DbDataReader, name: str) -> typing.Any: ...
    @staticmethod
    def GetStream(reader: DbDataReader, name: str) -> Stream: ...
    @staticmethod
    def GetString(reader: DbDataReader, name: str) -> str: ...
    @staticmethod
    def GetTextReader(reader: DbDataReader, name: str) -> TextReader: ...
    @staticmethod
    def GetValue(reader: DbDataReader, name: str) -> typing.Any: ...
    @staticmethod
    def IsDBNull(reader: DbDataReader, name: str) -> bool: ...
    @staticmethod
    def IsDBNullAsync(reader: DbDataReader, name: str, cancellationToken: CancellationToken = ...) -> Task_1[bool]: ...
    # Skipped GetFieldValue due to it being static, abstract and generic.

    GetFieldValue : GetFieldValue_MethodGroup
    class GetFieldValue_MethodGroup:
        def __getitem__(self, t:typing.Type[GetFieldValue_1_T1]) -> GetFieldValue_1[GetFieldValue_1_T1]: ...

        GetFieldValue_1_T1 = typing.TypeVar('GetFieldValue_1_T1')
        class GetFieldValue_1(typing.Generic[GetFieldValue_1_T1]):
            GetFieldValue_1_T = DataReaderExtensions.GetFieldValue_MethodGroup.GetFieldValue_1_T1
            def __call__(self, reader: DbDataReader, name: str) -> GetFieldValue_1_T:...


    # Skipped GetFieldValueAsync due to it being static, abstract and generic.

    GetFieldValueAsync : GetFieldValueAsync_MethodGroup
    class GetFieldValueAsync_MethodGroup:
        def __getitem__(self, t:typing.Type[GetFieldValueAsync_1_T1]) -> GetFieldValueAsync_1[GetFieldValueAsync_1_T1]: ...

        GetFieldValueAsync_1_T1 = typing.TypeVar('GetFieldValueAsync_1_T1')
        class GetFieldValueAsync_1(typing.Generic[GetFieldValueAsync_1_T1]):
            GetFieldValueAsync_1_T = DataReaderExtensions.GetFieldValueAsync_MethodGroup.GetFieldValueAsync_1_T1
            def __call__(self, reader: DbDataReader, name: str, cancellationToken: CancellationToken = ...) -> Task_1[GetFieldValueAsync_1_T]:...




class DataRelation:
    @typing.overload
    def __init__(self, relationName: str, parentColumn: DataColumn, childColumn: DataColumn) -> None: ...
    @typing.overload
    def __init__(self, relationName: str, parentColumn: DataColumn, childColumn: DataColumn, createConstraints: bool) -> None: ...
    @typing.overload
    def __init__(self, relationName: str, parentColumns: Array_1[DataColumn], childColumns: Array_1[DataColumn]) -> None: ...
    @typing.overload
    def __init__(self, relationName: str, parentColumns: Array_1[DataColumn], childColumns: Array_1[DataColumn], createConstraints: bool) -> None: ...
    @typing.overload
    def __init__(self, relationName: str, parentTableName: str, childTableName: str, parentColumnNames: Array_1[str], childColumnNames: Array_1[str], nested: bool) -> None: ...
    @typing.overload
    def __init__(self, relationName: str, parentTableName: str, parentTableNamespace: str, childTableName: str, childTableNamespace: str, parentColumnNames: Array_1[str], childColumnNames: Array_1[str], nested: bool) -> None: ...
    @property
    def ChildColumns(self) -> Array_1[DataColumn]: ...
    @property
    def ChildKeyConstraint(self) -> ForeignKeyConstraint: ...
    @property
    def ChildTable(self) -> DataTable: ...
    @property
    def DataSet(self) -> DataSet: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def Nested(self) -> bool: ...
    @Nested.setter
    def Nested(self, value: bool) -> bool: ...
    @property
    def ParentColumns(self) -> Array_1[DataColumn]: ...
    @property
    def ParentKeyConstraint(self) -> UniqueConstraint: ...
    @property
    def ParentTable(self) -> DataTable: ...
    @property
    def RelationName(self) -> str: ...
    @RelationName.setter
    def RelationName(self, value: str) -> str: ...
    def ToString(self) -> str: ...


class DataRelationCollection(InternalDataCollectionBase, abc.ABC):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> DataRelation: ...
    @property
    def Item(self) -> DataRelation: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def AddRange(self, relations: Array_1[DataRelation]) -> None: ...
    def CanRemove(self, relation: DataRelation) -> bool: ...
    def Clear(self) -> None: ...
    def Contains(self, name: str) -> bool: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, relation: DataRelation) -> None:...
        @typing.overload
        def __call__(self, parentColumns: Array_1[DataColumn], childColumns: Array_1[DataColumn]) -> DataRelation:...
        @typing.overload
        def __call__(self, parentColumn: DataColumn, childColumn: DataColumn) -> DataRelation:...
        @typing.overload
        def __call__(self, name: str, parentColumns: Array_1[DataColumn], childColumns: Array_1[DataColumn]) -> DataRelation:...
        @typing.overload
        def __call__(self, name: str, parentColumn: DataColumn, childColumn: DataColumn) -> DataRelation:...
        @typing.overload
        def __call__(self, name: str, parentColumns: Array_1[DataColumn], childColumns: Array_1[DataColumn], createConstraints: bool) -> DataRelation:...
        @typing.overload
        def __call__(self, name: str, parentColumn: DataColumn, childColumn: DataColumn, createConstraints: bool) -> DataRelation:...

    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[DataRelation], index: int) -> None:...
        @typing.overload
        def __call__(self, ar: Array, index: int) -> None:...

    # Skipped IndexOf due to it being static, abstract and generic.

    IndexOf : IndexOf_MethodGroup
    class IndexOf_MethodGroup:
        @typing.overload
        def __call__(self, relationName: str) -> int:...
        @typing.overload
        def __call__(self, relation: DataRelation) -> int:...

    # Skipped Remove due to it being static, abstract and generic.

    Remove : Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> None:...
        @typing.overload
        def __call__(self, relation: DataRelation) -> None:...



class DataRow:
    @property
    def HasErrors(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def ItemArray(self) -> Array_1[typing.Any]: ...
    @ItemArray.setter
    def ItemArray(self, value: Array_1[typing.Any]) -> Array_1[typing.Any]: ...
    @property
    def RowError(self) -> str: ...
    @RowError.setter
    def RowError(self, value: str) -> str: ...
    @property
    def RowState(self) -> DataRowState: ...
    @property
    def Table(self) -> DataTable: ...
    def AcceptChanges(self) -> None: ...
    def BeginEdit(self) -> None: ...
    def CancelEdit(self) -> None: ...
    def ClearErrors(self) -> None: ...
    def Delete(self) -> None: ...
    def EndEdit(self) -> None: ...
    def GetColumnsInError(self) -> Array_1[DataColumn]: ...
    def HasVersion(self, version: DataRowVersion) -> bool: ...
    def RejectChanges(self) -> None: ...
    def SetAdded(self) -> None: ...
    def SetModified(self) -> None: ...
    # Skipped GetChildRows due to it being static, abstract and generic.

    GetChildRows : GetChildRows_MethodGroup
    class GetChildRows_MethodGroup:
        @typing.overload
        def __call__(self, relationName: str) -> Array_1[DataRow]:...
        @typing.overload
        def __call__(self, relation: DataRelation) -> Array_1[DataRow]:...
        @typing.overload
        def __call__(self, relationName: str, version: DataRowVersion) -> Array_1[DataRow]:...
        @typing.overload
        def __call__(self, relation: DataRelation, version: DataRowVersion) -> Array_1[DataRow]:...

    # Skipped GetColumnError due to it being static, abstract and generic.

    GetColumnError : GetColumnError_MethodGroup
    class GetColumnError_MethodGroup:
        @typing.overload
        def __call__(self, columnIndex: int) -> str:...
        @typing.overload
        def __call__(self, column: DataColumn) -> str:...
        @typing.overload
        def __call__(self, columnName: str) -> str:...

    # Skipped GetParentRow due to it being static, abstract and generic.

    GetParentRow : GetParentRow_MethodGroup
    class GetParentRow_MethodGroup:
        @typing.overload
        def __call__(self, relationName: str) -> DataRow:...
        @typing.overload
        def __call__(self, relation: DataRelation) -> DataRow:...
        @typing.overload
        def __call__(self, relationName: str, version: DataRowVersion) -> DataRow:...
        @typing.overload
        def __call__(self, relation: DataRelation, version: DataRowVersion) -> DataRow:...

    # Skipped GetParentRows due to it being static, abstract and generic.

    GetParentRows : GetParentRows_MethodGroup
    class GetParentRows_MethodGroup:
        @typing.overload
        def __call__(self, relationName: str) -> Array_1[DataRow]:...
        @typing.overload
        def __call__(self, relation: DataRelation) -> Array_1[DataRow]:...
        @typing.overload
        def __call__(self, relationName: str, version: DataRowVersion) -> Array_1[DataRow]:...
        @typing.overload
        def __call__(self, relation: DataRelation, version: DataRowVersion) -> Array_1[DataRow]:...

    # Skipped IsNull due to it being static, abstract and generic.

    IsNull : IsNull_MethodGroup
    class IsNull_MethodGroup:
        @typing.overload
        def __call__(self, columnIndex: int) -> bool:...
        @typing.overload
        def __call__(self, column: DataColumn) -> bool:...
        @typing.overload
        def __call__(self, columnName: str) -> bool:...
        @typing.overload
        def __call__(self, column: DataColumn, version: DataRowVersion) -> bool:...

    # Skipped SetColumnError due to it being static, abstract and generic.

    SetColumnError : SetColumnError_MethodGroup
    class SetColumnError_MethodGroup:
        @typing.overload
        def __call__(self, columnIndex: int, error: str) -> None:...
        @typing.overload
        def __call__(self, column: DataColumn, error: str) -> None:...
        @typing.overload
        def __call__(self, columnName: str, error: str) -> None:...

    # Skipped SetParentRow due to it being static, abstract and generic.

    SetParentRow : SetParentRow_MethodGroup
    class SetParentRow_MethodGroup:
        @typing.overload
        def __call__(self, parentRow: DataRow) -> None:...
        @typing.overload
        def __call__(self, parentRow: DataRow, relation: DataRelation) -> None:...



class DataRowAction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Nothing : DataRowAction # 0
    Delete : DataRowAction # 1
    Change : DataRowAction # 2
    Rollback : DataRowAction # 4
    Commit : DataRowAction # 8
    Add : DataRowAction # 16
    ChangeOriginal : DataRowAction # 32
    ChangeCurrentAndOriginal : DataRowAction # 64


class DataRowBuilder:
    pass


class DataRowChangeEventArgs(EventArgs):
    def __init__(self, row: DataRow, action: DataRowAction) -> None: ...
    @property
    def Action(self) -> DataRowAction: ...
    @property
    def Row(self) -> DataRow: ...


class DataRowChangeEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: DataRowChangeEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: DataRowChangeEventArgs) -> None: ...


class DataRowCollection(InternalDataCollectionBase):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> DataRow: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def Clear(self) -> None: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def IndexOf(self, row: DataRow) -> int: ...
    def InsertAt(self, row: DataRow, pos: int) -> None: ...
    def Remove(self, row: DataRow) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, values: Array_1[typing.Any]) -> DataRow:...
        @typing.overload
        def __call__(self, row: DataRow) -> None:...

    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, keys: Array_1[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, key: typing.Any) -> bool:...

    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[DataRow], index: int) -> None:...
        @typing.overload
        def __call__(self, ar: Array, index: int) -> None:...

    # Skipped Find due to it being static, abstract and generic.

    Find : Find_MethodGroup
    class Find_MethodGroup:
        @typing.overload
        def __call__(self, keys: Array_1[typing.Any]) -> DataRow:...
        @typing.overload
        def __call__(self, key: typing.Any) -> DataRow:...



class DataRowComparer_GenericClasses(abc.ABCMeta):
    Generic_DataRowComparer_GenericClasses_DataRowComparer_1_TRow = typing.TypeVar('Generic_DataRowComparer_GenericClasses_DataRowComparer_1_TRow')
    def __getitem__(self, types : typing.Type[Generic_DataRowComparer_GenericClasses_DataRowComparer_1_TRow]) -> typing.Type[DataRowComparer_1[Generic_DataRowComparer_GenericClasses_DataRowComparer_1_TRow]]: ...

class DataRowComparer(DataRowComparer_0, metaclass =DataRowComparer_GenericClasses): ...

class DataRowComparer_0(abc.ABC):
    @classmethod
    @property
    def Default(cls) -> DataRowComparer_1[DataRow]: ...


DataRowComparer_1_TRow = typing.TypeVar('DataRowComparer_1_TRow')
class DataRowComparer_1(typing.Generic[DataRowComparer_1_TRow], IEqualityComparer_1[DataRowComparer_1_TRow]):
    @classmethod
    @property
    def Default(cls) -> DataRowComparer_1[DataRowComparer_1_TRow]: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup[DataRowComparer_1_TRow]
    Equals_MethodGroup_DataRowComparer_1_TRow = typing.TypeVar('Equals_MethodGroup_DataRowComparer_1_TRow')
    class Equals_MethodGroup(typing.Generic[Equals_MethodGroup_DataRowComparer_1_TRow]):
        Equals_MethodGroup_DataRowComparer_1_TRow = DataRowComparer_1.Equals_MethodGroup_DataRowComparer_1_TRow
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, leftRow: Equals_MethodGroup_DataRowComparer_1_TRow, rightRow: Equals_MethodGroup_DataRowComparer_1_TRow) -> bool:...

    # Skipped GetHashCode due to it being static, abstract and generic.

    GetHashCode : GetHashCode_MethodGroup[DataRowComparer_1_TRow]
    GetHashCode_MethodGroup_DataRowComparer_1_TRow = typing.TypeVar('GetHashCode_MethodGroup_DataRowComparer_1_TRow')
    class GetHashCode_MethodGroup(typing.Generic[GetHashCode_MethodGroup_DataRowComparer_1_TRow]):
        GetHashCode_MethodGroup_DataRowComparer_1_TRow = DataRowComparer_1.GetHashCode_MethodGroup_DataRowComparer_1_TRow
        @typing.overload
        def __call__(self) -> int:...
        @typing.overload
        def __call__(self, row: GetHashCode_MethodGroup_DataRowComparer_1_TRow) -> int:...



class DataRowExtensions(abc.ABC):
    # Skipped Field due to it being static, abstract and generic.

    Field : Field_MethodGroup
    class Field_MethodGroup:
        def __getitem__(self, t:typing.Type[Field_1_T1]) -> Field_1[Field_1_T1]: ...

        Field_1_T1 = typing.TypeVar('Field_1_T1')
        class Field_1(typing.Generic[Field_1_T1]):
            Field_1_T = DataRowExtensions.Field_MethodGroup.Field_1_T1
            @typing.overload
            def __call__(self, row: DataRow, columnIndex: int) -> Field_1_T:...
            @typing.overload
            def __call__(self, row: DataRow, column: DataColumn) -> Field_1_T:...
            @typing.overload
            def __call__(self, row: DataRow, columnName: str) -> Field_1_T:...
            @typing.overload
            def __call__(self, row: DataRow, columnIndex: int, version: DataRowVersion) -> Field_1_T:...
            @typing.overload
            def __call__(self, row: DataRow, column: DataColumn, version: DataRowVersion) -> Field_1_T:...
            @typing.overload
            def __call__(self, row: DataRow, columnName: str, version: DataRowVersion) -> Field_1_T:...


    # Skipped SetField due to it being static, abstract and generic.

    SetField : SetField_MethodGroup
    class SetField_MethodGroup:
        def __getitem__(self, t:typing.Type[SetField_1_T1]) -> SetField_1[SetField_1_T1]: ...

        SetField_1_T1 = typing.TypeVar('SetField_1_T1')
        class SetField_1(typing.Generic[SetField_1_T1]):
            SetField_1_T = DataRowExtensions.SetField_MethodGroup.SetField_1_T1
            @typing.overload
            def __call__(self, row: DataRow, columnIndex: int, value: SetField_1_T) -> None:...
            @typing.overload
            def __call__(self, row: DataRow, column: DataColumn, value: SetField_1_T) -> None:...
            @typing.overload
            def __call__(self, row: DataRow, columnName: str, value: SetField_1_T) -> None:...




class DataRowState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Detached : DataRowState # 1
    Unchanged : DataRowState # 2
    Added : DataRowState # 4
    Deleted : DataRowState # 8
    Modified : DataRowState # 16


class DataRowVersion(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Original : DataRowVersion # 256
    Current : DataRowVersion # 512
    Proposed : DataRowVersion # 1024
    Default : DataRowVersion # 1536


class DataRowView(INotifyPropertyChanged, IDataErrorInfo, IEditableObject, ICustomTypeDescriptor):
    @property
    def DataView(self) -> DataView: ...
    @property
    def IsEdit(self) -> bool: ...
    @property
    def IsNew(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Row(self) -> DataRow: ...
    @property
    def RowVersion(self) -> DataRowVersion: ...
    def BeginEdit(self) -> None: ...
    def CancelEdit(self) -> None: ...
    def Delete(self) -> None: ...
    def EndEdit(self) -> None: ...
    def Equals(self, other: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    # Skipped CreateChildView due to it being static, abstract and generic.

    CreateChildView : CreateChildView_MethodGroup
    class CreateChildView_MethodGroup:
        @typing.overload
        def __call__(self, relationName: str) -> DataView:...
        @typing.overload
        def __call__(self, relation: DataRelation) -> DataView:...
        @typing.overload
        def __call__(self, relationName: str, followParent: bool) -> DataView:...
        @typing.overload
        def __call__(self, relation: DataRelation, followParent: bool) -> DataView:...



class DataSet(MarshalByValueComponent, ISupportInitializeNotification, ISerializable, IXmlSerializable, IListSource):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, dataSetName: str) -> None: ...
    @property
    def CaseSensitive(self) -> bool: ...
    @CaseSensitive.setter
    def CaseSensitive(self, value: bool) -> bool: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DataSetName(self) -> str: ...
    @DataSetName.setter
    def DataSetName(self, value: str) -> str: ...
    @property
    def DefaultViewManager(self) -> DataViewManager: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def EnforceConstraints(self) -> bool: ...
    @EnforceConstraints.setter
    def EnforceConstraints(self, value: bool) -> bool: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def HasErrors(self) -> bool: ...
    @property
    def IsInitialized(self) -> bool: ...
    @property
    def Locale(self) -> CultureInfo: ...
    @Locale.setter
    def Locale(self, value: CultureInfo) -> CultureInfo: ...
    @property
    def Namespace(self) -> str: ...
    @Namespace.setter
    def Namespace(self, value: str) -> str: ...
    @property
    def Prefix(self) -> str: ...
    @Prefix.setter
    def Prefix(self, value: str) -> str: ...
    @property
    def Relations(self) -> DataRelationCollection: ...
    @property
    def RemotingFormat(self) -> SerializationFormat: ...
    @RemotingFormat.setter
    def RemotingFormat(self, value: SerializationFormat) -> SerializationFormat: ...
    @property
    def SchemaSerializationMode(self) -> SchemaSerializationMode: ...
    @SchemaSerializationMode.setter
    def SchemaSerializationMode(self, value: SchemaSerializationMode) -> SchemaSerializationMode: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def Tables(self) -> DataTableCollection: ...
    def AcceptChanges(self) -> None: ...
    def BeginInit(self) -> None: ...
    def Clear(self) -> None: ...
    def Clone(self) -> DataSet: ...
    def Copy(self) -> DataSet: ...
    def EndInit(self) -> None: ...
    @staticmethod
    def GetDataSetSchema(schemaSet: XmlSchemaSet) -> XmlSchemaComplexType: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def GetXml(self) -> str: ...
    def GetXmlSchema(self) -> str: ...
    def RejectChanges(self) -> None: ...
    def Reset(self) -> None: ...
    # Skipped CreateDataReader due to it being static, abstract and generic.

    CreateDataReader : CreateDataReader_MethodGroup
    class CreateDataReader_MethodGroup:
        @typing.overload
        def __call__(self) -> DataTableReader:...
        @typing.overload
        def __call__(self, dataTables: Array_1[DataTable]) -> DataTableReader:...

    # Skipped GetChanges due to it being static, abstract and generic.

    GetChanges : GetChanges_MethodGroup
    class GetChanges_MethodGroup:
        @typing.overload
        def __call__(self) -> DataSet:...
        @typing.overload
        def __call__(self, rowStates: DataRowState) -> DataSet:...

    # Skipped HasChanges due to it being static, abstract and generic.

    HasChanges : HasChanges_MethodGroup
    class HasChanges_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, rowStates: DataRowState) -> bool:...

    # Skipped InferXmlSchema due to it being static, abstract and generic.

    InferXmlSchema : InferXmlSchema_MethodGroup
    class InferXmlSchema_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str, nsArray: Array_1[str]) -> None:...
        @typing.overload
        def __call__(self, reader: TextReader, nsArray: Array_1[str]) -> None:...
        @typing.overload
        def __call__(self, stream: Stream, nsArray: Array_1[str]) -> None:...
        @typing.overload
        def __call__(self, reader: XmlReader, nsArray: Array_1[str]) -> None:...

    # Skipped Load due to it being static, abstract and generic.

    Load : Load_MethodGroup
    class Load_MethodGroup:
        @typing.overload
        def __call__(self, reader: IDataReader, loadOption: LoadOption, tables: Array_1[DataTable]) -> None:...
        @typing.overload
        def __call__(self, reader: IDataReader, loadOption: LoadOption, tables: Array_1[str]) -> None:...
        @typing.overload
        def __call__(self, reader: IDataReader, loadOption: LoadOption, errorHandler: FillErrorEventHandler, tables: Array_1[DataTable]) -> None:...

    # Skipped Merge due to it being static, abstract and generic.

    Merge : Merge_MethodGroup
    class Merge_MethodGroup:
        @typing.overload
        def __call__(self, rows: Array_1[DataRow]) -> None:...
        @typing.overload
        def __call__(self, dataSet: DataSet) -> None:...
        @typing.overload
        def __call__(self, table: DataTable) -> None:...
        @typing.overload
        def __call__(self, dataSet: DataSet, preserveChanges: bool) -> None:...
        @typing.overload
        def __call__(self, rows: Array_1[DataRow], preserveChanges: bool, missingSchemaAction: MissingSchemaAction) -> None:...
        @typing.overload
        def __call__(self, dataSet: DataSet, preserveChanges: bool, missingSchemaAction: MissingSchemaAction) -> None:...
        @typing.overload
        def __call__(self, table: DataTable, preserveChanges: bool, missingSchemaAction: MissingSchemaAction) -> None:...

    # Skipped ReadXml due to it being static, abstract and generic.

    ReadXml : ReadXml_MethodGroup
    class ReadXml_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> XmlReadMode:...
        @typing.overload
        def __call__(self, reader: TextReader) -> XmlReadMode:...
        @typing.overload
        def __call__(self, stream: Stream) -> XmlReadMode:...
        @typing.overload
        def __call__(self, reader: XmlReader) -> XmlReadMode:...
        @typing.overload
        def __call__(self, fileName: str, mode: XmlReadMode) -> XmlReadMode:...
        @typing.overload
        def __call__(self, reader: TextReader, mode: XmlReadMode) -> XmlReadMode:...
        @typing.overload
        def __call__(self, stream: Stream, mode: XmlReadMode) -> XmlReadMode:...
        @typing.overload
        def __call__(self, reader: XmlReader, mode: XmlReadMode) -> XmlReadMode:...

    # Skipped ReadXmlSchema due to it being static, abstract and generic.

    ReadXmlSchema : ReadXmlSchema_MethodGroup
    class ReadXmlSchema_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None:...
        @typing.overload
        def __call__(self, reader: TextReader) -> None:...
        @typing.overload
        def __call__(self, stream: Stream) -> None:...
        @typing.overload
        def __call__(self, reader: XmlReader) -> None:...

    # Skipped WriteXml due to it being static, abstract and generic.

    WriteXml : WriteXml_MethodGroup
    class WriteXml_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None:...
        @typing.overload
        def __call__(self, stream: Stream) -> None:...
        @typing.overload
        def __call__(self, writer: TextWriter) -> None:...
        @typing.overload
        def __call__(self, writer: XmlWriter) -> None:...
        @typing.overload
        def __call__(self, fileName: str, mode: XmlWriteMode) -> None:...
        @typing.overload
        def __call__(self, stream: Stream, mode: XmlWriteMode) -> None:...
        @typing.overload
        def __call__(self, writer: TextWriter, mode: XmlWriteMode) -> None:...
        @typing.overload
        def __call__(self, writer: XmlWriter, mode: XmlWriteMode) -> None:...

    # Skipped WriteXmlSchema due to it being static, abstract and generic.

    WriteXmlSchema : WriteXmlSchema_MethodGroup
    class WriteXmlSchema_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None:...
        @typing.overload
        def __call__(self, stream: Stream) -> None:...
        @typing.overload
        def __call__(self, writer: TextWriter) -> None:...
        @typing.overload
        def __call__(self, writer: XmlWriter) -> None:...
        @typing.overload
        def __call__(self, fileName: str, multipleTargetConverter: Converter_2[typing.Type[typing.Any], str]) -> None:...
        @typing.overload
        def __call__(self, stream: Stream, multipleTargetConverter: Converter_2[typing.Type[typing.Any], str]) -> None:...
        @typing.overload
        def __call__(self, writer: TextWriter, multipleTargetConverter: Converter_2[typing.Type[typing.Any], str]) -> None:...
        @typing.overload
        def __call__(self, writer: XmlWriter, multipleTargetConverter: Converter_2[typing.Type[typing.Any], str]) -> None:...



class DataSetDateTime(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Local : DataSetDateTime # 1
    Unspecified : DataSetDateTime # 2
    UnspecifiedLocal : DataSetDateTime # 3
    Utc : DataSetDateTime # 4


class DataSysDescriptionAttribute(DescriptionAttribute):
    def __init__(self, description: str) -> None: ...
    @property
    def Description(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DataTable(MarshalByValueComponent, ISupportInitializeNotification, IXmlSerializable, ISerializable, IListSource):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, tableName: str) -> None: ...
    @typing.overload
    def __init__(self, tableName: str, tableNamespace: str) -> None: ...
    @property
    def CaseSensitive(self) -> bool: ...
    @CaseSensitive.setter
    def CaseSensitive(self, value: bool) -> bool: ...
    @property
    def ChildRelations(self) -> DataRelationCollection: ...
    @property
    def Columns(self) -> DataColumnCollection: ...
    @property
    def Constraints(self) -> ConstraintCollection: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DataSet(self) -> DataSet: ...
    @property
    def DefaultView(self) -> DataView: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def DisplayExpression(self) -> str: ...
    @DisplayExpression.setter
    def DisplayExpression(self, value: str) -> str: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def HasErrors(self) -> bool: ...
    @property
    def IsInitialized(self) -> bool: ...
    @property
    def Locale(self) -> CultureInfo: ...
    @Locale.setter
    def Locale(self, value: CultureInfo) -> CultureInfo: ...
    @property
    def MinimumCapacity(self) -> int: ...
    @MinimumCapacity.setter
    def MinimumCapacity(self, value: int) -> int: ...
    @property
    def Namespace(self) -> str: ...
    @Namespace.setter
    def Namespace(self, value: str) -> str: ...
    @property
    def ParentRelations(self) -> DataRelationCollection: ...
    @property
    def Prefix(self) -> str: ...
    @Prefix.setter
    def Prefix(self, value: str) -> str: ...
    @property
    def PrimaryKey(self) -> Array_1[DataColumn]: ...
    @PrimaryKey.setter
    def PrimaryKey(self, value: Array_1[DataColumn]) -> Array_1[DataColumn]: ...
    @property
    def RemotingFormat(self) -> SerializationFormat: ...
    @RemotingFormat.setter
    def RemotingFormat(self, value: SerializationFormat) -> SerializationFormat: ...
    @property
    def Rows(self) -> DataRowCollection: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def TableName(self) -> str: ...
    @TableName.setter
    def TableName(self, value: str) -> str: ...
    def AcceptChanges(self) -> None: ...
    def BeginInit(self) -> None: ...
    def BeginLoadData(self) -> None: ...
    def Clear(self) -> None: ...
    def Clone(self) -> DataTable: ...
    def Compute(self, expression: str, filter: str) -> typing.Any: ...
    def Copy(self) -> DataTable: ...
    def CreateDataReader(self) -> DataTableReader: ...
    def EndInit(self) -> None: ...
    def EndLoadData(self) -> None: ...
    @staticmethod
    def GetDataTableSchema(schemaSet: XmlSchemaSet) -> XmlSchemaComplexType: ...
    def GetErrors(self) -> Array_1[DataRow]: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def ImportRow(self, row: DataRow) -> None: ...
    def NewRow(self) -> DataRow: ...
    def RejectChanges(self) -> None: ...
    def Reset(self) -> None: ...
    def ToString(self) -> str: ...
    # Skipped GetChanges due to it being static, abstract and generic.

    GetChanges : GetChanges_MethodGroup
    class GetChanges_MethodGroup:
        @typing.overload
        def __call__(self) -> DataTable:...
        @typing.overload
        def __call__(self, rowStates: DataRowState) -> DataTable:...

    # Skipped Load due to it being static, abstract and generic.

    Load : Load_MethodGroup
    class Load_MethodGroup:
        @typing.overload
        def __call__(self, reader: IDataReader) -> None:...
        @typing.overload
        def __call__(self, reader: IDataReader, loadOption: LoadOption) -> None:...
        @typing.overload
        def __call__(self, reader: IDataReader, loadOption: LoadOption, errorHandler: FillErrorEventHandler) -> None:...

    # Skipped LoadDataRow due to it being static, abstract and generic.

    LoadDataRow : LoadDataRow_MethodGroup
    class LoadDataRow_MethodGroup:
        @typing.overload
        def __call__(self, values: Array_1[typing.Any], loadOption: LoadOption) -> DataRow:...
        @typing.overload
        def __call__(self, values: Array_1[typing.Any], fAcceptChanges: bool) -> DataRow:...

    # Skipped Merge due to it being static, abstract and generic.

    Merge : Merge_MethodGroup
    class Merge_MethodGroup:
        @typing.overload
        def __call__(self, table: DataTable) -> None:...
        @typing.overload
        def __call__(self, table: DataTable, preserveChanges: bool) -> None:...
        @typing.overload
        def __call__(self, table: DataTable, preserveChanges: bool, missingSchemaAction: MissingSchemaAction) -> None:...

    # Skipped ReadXml due to it being static, abstract and generic.

    ReadXml : ReadXml_MethodGroup
    class ReadXml_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> XmlReadMode:...
        @typing.overload
        def __call__(self, reader: TextReader) -> XmlReadMode:...
        @typing.overload
        def __call__(self, stream: Stream) -> XmlReadMode:...
        @typing.overload
        def __call__(self, reader: XmlReader) -> XmlReadMode:...

    # Skipped ReadXmlSchema due to it being static, abstract and generic.

    ReadXmlSchema : ReadXmlSchema_MethodGroup
    class ReadXmlSchema_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None:...
        @typing.overload
        def __call__(self, reader: TextReader) -> None:...
        @typing.overload
        def __call__(self, stream: Stream) -> None:...
        @typing.overload
        def __call__(self, reader: XmlReader) -> None:...

    # Skipped Select due to it being static, abstract and generic.

    Select : Select_MethodGroup
    class Select_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[DataRow]:...
        @typing.overload
        def __call__(self, filterExpression: str) -> Array_1[DataRow]:...
        @typing.overload
        def __call__(self, filterExpression: str, sort: str) -> Array_1[DataRow]:...
        @typing.overload
        def __call__(self, filterExpression: str, sort: str, recordStates: DataViewRowState) -> Array_1[DataRow]:...

    # Skipped WriteXml due to it being static, abstract and generic.

    WriteXml : WriteXml_MethodGroup
    class WriteXml_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None:...
        @typing.overload
        def __call__(self, stream: Stream) -> None:...
        @typing.overload
        def __call__(self, writer: TextWriter) -> None:...
        @typing.overload
        def __call__(self, writer: XmlWriter) -> None:...
        @typing.overload
        def __call__(self, fileName: str, mode: XmlWriteMode) -> None:...
        @typing.overload
        def __call__(self, stream: Stream, mode: XmlWriteMode) -> None:...
        @typing.overload
        def __call__(self, writer: TextWriter, mode: XmlWriteMode) -> None:...
        @typing.overload
        def __call__(self, fileName: str, writeHierarchy: bool) -> None:...
        @typing.overload
        def __call__(self, stream: Stream, writeHierarchy: bool) -> None:...
        @typing.overload
        def __call__(self, writer: TextWriter, writeHierarchy: bool) -> None:...
        @typing.overload
        def __call__(self, writer: XmlWriter, mode: XmlWriteMode) -> None:...
        @typing.overload
        def __call__(self, writer: XmlWriter, writeHierarchy: bool) -> None:...
        @typing.overload
        def __call__(self, fileName: str, mode: XmlWriteMode, writeHierarchy: bool) -> None:...
        @typing.overload
        def __call__(self, stream: Stream, mode: XmlWriteMode, writeHierarchy: bool) -> None:...
        @typing.overload
        def __call__(self, writer: TextWriter, mode: XmlWriteMode, writeHierarchy: bool) -> None:...
        @typing.overload
        def __call__(self, writer: XmlWriter, mode: XmlWriteMode, writeHierarchy: bool) -> None:...

    # Skipped WriteXmlSchema due to it being static, abstract and generic.

    WriteXmlSchema : WriteXmlSchema_MethodGroup
    class WriteXmlSchema_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> None:...
        @typing.overload
        def __call__(self, stream: Stream) -> None:...
        @typing.overload
        def __call__(self, writer: TextWriter) -> None:...
        @typing.overload
        def __call__(self, writer: XmlWriter) -> None:...
        @typing.overload
        def __call__(self, fileName: str, writeHierarchy: bool) -> None:...
        @typing.overload
        def __call__(self, stream: Stream, writeHierarchy: bool) -> None:...
        @typing.overload
        def __call__(self, writer: TextWriter, writeHierarchy: bool) -> None:...
        @typing.overload
        def __call__(self, writer: XmlWriter, writeHierarchy: bool) -> None:...



class DataTableClearEventArgs(EventArgs):
    def __init__(self, dataTable: DataTable) -> None: ...
    @property
    def Table(self) -> DataTable: ...
    @property
    def TableName(self) -> str: ...
    @property
    def TableNamespace(self) -> str: ...


class DataTableClearEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: DataTableClearEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: DataTableClearEventArgs) -> None: ...


class DataTableCollection(InternalDataCollectionBase):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> DataTable: ...
    @property
    def Item(self) -> DataTable: ...
    @property
    def Item(self) -> DataTable: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def AddRange(self, tables: Array_1[DataTable]) -> None: ...
    def CanRemove(self, table: DataTable) -> bool: ...
    def Clear(self) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self) -> DataTable:...
        @typing.overload
        def __call__(self, table: DataTable) -> None:...
        @typing.overload
        def __call__(self, name: str) -> DataTable:...
        @typing.overload
        def __call__(self, name: str, tableNamespace: str) -> DataTable:...

    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> bool:...
        @typing.overload
        def __call__(self, name: str, tableNamespace: str) -> bool:...

    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[DataTable], index: int) -> None:...
        @typing.overload
        def __call__(self, ar: Array, index: int) -> None:...

    # Skipped IndexOf due to it being static, abstract and generic.

    IndexOf : IndexOf_MethodGroup
    class IndexOf_MethodGroup:
        @typing.overload
        def __call__(self, table: DataTable) -> int:...
        @typing.overload
        def __call__(self, tableName: str) -> int:...
        @typing.overload
        def __call__(self, tableName: str, tableNamespace: str) -> int:...

    # Skipped Remove due to it being static, abstract and generic.

    Remove : Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, table: DataTable) -> None:...
        @typing.overload
        def __call__(self, name: str) -> None:...
        @typing.overload
        def __call__(self, name: str, tableNamespace: str) -> None:...



class DataTableExtensions(abc.ABC):
    @staticmethod
    def AsEnumerable(source: DataTable) -> EnumerableRowCollection_1[DataRow]: ...
    # Skipped AsDataView due to it being static, abstract and generic.

    AsDataView : AsDataView_MethodGroup
    class AsDataView_MethodGroup:
        def __getitem__(self, t:typing.Type[AsDataView_1_T1]) -> AsDataView_1[AsDataView_1_T1]: ...

        AsDataView_1_T1 = typing.TypeVar('AsDataView_1_T1')
        class AsDataView_1(typing.Generic[AsDataView_1_T1]):
            AsDataView_1_T = DataTableExtensions.AsDataView_MethodGroup.AsDataView_1_T1
            def __call__(self, source: EnumerableRowCollection_1[AsDataView_1_T]) -> DataView:...

        def __call__(self, table: DataTable) -> DataView:...

    # Skipped CopyToDataTable due to it being static, abstract and generic.

    CopyToDataTable : CopyToDataTable_MethodGroup
    class CopyToDataTable_MethodGroup:
        def __getitem__(self, t:typing.Type[CopyToDataTable_1_T1]) -> CopyToDataTable_1[CopyToDataTable_1_T1]: ...

        CopyToDataTable_1_T1 = typing.TypeVar('CopyToDataTable_1_T1')
        class CopyToDataTable_1(typing.Generic[CopyToDataTable_1_T1]):
            CopyToDataTable_1_T = DataTableExtensions.CopyToDataTable_MethodGroup.CopyToDataTable_1_T1
            @typing.overload
            def __call__(self, source: IEnumerable_1[CopyToDataTable_1_T]) -> DataTable:...
            @typing.overload
            def __call__(self, source: IEnumerable_1[CopyToDataTable_1_T], table: DataTable, options: LoadOption) -> None:...
            @typing.overload
            def __call__(self, source: IEnumerable_1[CopyToDataTable_1_T], table: DataTable, options: LoadOption, errorHandler: FillErrorEventHandler) -> None:...




class DataTableNewRowEventArgs(EventArgs):
    def __init__(self, dataRow: DataRow) -> None: ...
    @property
    def Row(self) -> DataRow: ...


class DataTableNewRowEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: DataTableNewRowEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: DataTableNewRowEventArgs) -> None: ...


class DataTableReader(DbDataReader):
    @typing.overload
    def __init__(self, dataTable: DataTable) -> None: ...
    @typing.overload
    def __init__(self, dataTables: Array_1[DataTable]) -> None: ...
    @property
    def Depth(self) -> int: ...
    @property
    def FieldCount(self) -> int: ...
    @property
    def HasRows(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def RecordsAffected(self) -> int: ...
    @property
    def VisibleFieldCount(self) -> int: ...
    def Close(self) -> None: ...
    def GetBoolean(self, ordinal: int) -> bool: ...
    def GetByte(self, ordinal: int) -> int: ...
    def GetBytes(self, ordinal: int, dataIndex: int, buffer: Array_1[int], bufferIndex: int, length: int) -> int: ...
    def GetChar(self, ordinal: int) -> str: ...
    def GetChars(self, ordinal: int, dataIndex: int, buffer: Array_1[str], bufferIndex: int, length: int) -> int: ...
    def GetDataTypeName(self, ordinal: int) -> str: ...
    def GetDateTime(self, ordinal: int) -> DateTime: ...
    def GetDecimal(self, ordinal: int) -> Decimal: ...
    def GetDouble(self, ordinal: int) -> float: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetFieldType(self, ordinal: int) -> typing.Type[typing.Any]: ...
    def GetFloat(self, ordinal: int) -> float: ...
    def GetGuid(self, ordinal: int) -> Guid: ...
    def GetInt16(self, ordinal: int) -> int: ...
    def GetInt32(self, ordinal: int) -> int: ...
    def GetInt64(self, ordinal: int) -> int: ...
    def GetName(self, ordinal: int) -> str: ...
    def GetOrdinal(self, name: str) -> int: ...
    def GetProviderSpecificFieldType(self, ordinal: int) -> typing.Type[typing.Any]: ...
    def GetProviderSpecificValue(self, ordinal: int) -> typing.Any: ...
    def GetProviderSpecificValues(self, values: Array_1[typing.Any]) -> int: ...
    def GetSchemaTable(self) -> DataTable: ...
    def GetString(self, ordinal: int) -> str: ...
    def GetValue(self, ordinal: int) -> typing.Any: ...
    def GetValues(self, values: Array_1[typing.Any]) -> int: ...
    def IsDBNull(self, ordinal: int) -> bool: ...
    def NextResult(self) -> bool: ...
    def Read(self) -> bool: ...


class DataView(MarshalByValueComponent, IBindingListView, ISupportInitializeNotification, ITypedList):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, table: DataTable) -> None: ...
    @typing.overload
    def __init__(self, table: DataTable, RowFilter: str, Sort: str, RowState: DataViewRowState) -> None: ...
    @property
    def AllowDelete(self) -> bool: ...
    @AllowDelete.setter
    def AllowDelete(self, value: bool) -> bool: ...
    @property
    def AllowEdit(self) -> bool: ...
    @AllowEdit.setter
    def AllowEdit(self, value: bool) -> bool: ...
    @property
    def AllowNew(self) -> bool: ...
    @AllowNew.setter
    def AllowNew(self, value: bool) -> bool: ...
    @property
    def ApplyDefaultSort(self) -> bool: ...
    @ApplyDefaultSort.setter
    def ApplyDefaultSort(self, value: bool) -> bool: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def Count(self) -> int: ...
    @property
    def DataViewManager(self) -> DataViewManager: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def IsInitialized(self) -> bool: ...
    @property
    def Item(self) -> DataRowView: ...
    @property
    def RowFilter(self) -> str: ...
    @RowFilter.setter
    def RowFilter(self, value: str) -> str: ...
    @property
    def RowStateFilter(self) -> DataViewRowState: ...
    @RowStateFilter.setter
    def RowStateFilter(self, value: DataViewRowState) -> DataViewRowState: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def Sort(self) -> str: ...
    @Sort.setter
    def Sort(self, value: str) -> str: ...
    @property
    def Table(self) -> DataTable: ...
    @Table.setter
    def Table(self, value: DataTable) -> DataTable: ...
    def AddNew(self) -> DataRowView: ...
    def BeginInit(self) -> None: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    def Delete(self, index: int) -> None: ...
    def EndInit(self) -> None: ...
    def GetEnumerator(self) -> IEnumerator: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, view: DataView) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...

    # Skipped Find due to it being static, abstract and generic.

    Find : Find_MethodGroup
    class Find_MethodGroup:
        @typing.overload
        def __call__(self, key: Array_1[typing.Any]) -> int:...
        @typing.overload
        def __call__(self, key: typing.Any) -> int:...

    # Skipped FindRows due to it being static, abstract and generic.

    FindRows : FindRows_MethodGroup
    class FindRows_MethodGroup:
        @typing.overload
        def __call__(self, key: Array_1[typing.Any]) -> Array_1[DataRowView]:...
        @typing.overload
        def __call__(self, key: typing.Any) -> Array_1[DataRowView]:...

    # Skipped ToTable due to it being static, abstract and generic.

    ToTable : ToTable_MethodGroup
    class ToTable_MethodGroup:
        @typing.overload
        def __call__(self) -> DataTable:...
        @typing.overload
        def __call__(self, tableName: str) -> DataTable:...
        @typing.overload
        def __call__(self, distinct: bool, columnNames: Array_1[str]) -> DataTable:...
        @typing.overload
        def __call__(self, tableName: str, distinct: bool, columnNames: Array_1[str]) -> DataTable:...



class DataViewManager(MarshalByValueComponent, IBindingList, ITypedList):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, dataSet: DataSet) -> None: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DataSet(self) -> DataSet: ...
    @DataSet.setter
    def DataSet(self, value: DataSet) -> DataSet: ...
    @property
    def DataViewSettingCollectionString(self) -> str: ...
    @DataViewSettingCollectionString.setter
    def DataViewSettingCollectionString(self, value: str) -> str: ...
    @property
    def DataViewSettings(self) -> DataViewSettingCollection: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    def CreateDataView(self, table: DataTable) -> DataView: ...


class DataViewRowState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : DataViewRowState # 0
    Unchanged : DataViewRowState # 2
    Added : DataViewRowState # 4
    Deleted : DataViewRowState # 8
    ModifiedCurrent : DataViewRowState # 16
    CurrentRows : DataViewRowState # 22
    ModifiedOriginal : DataViewRowState # 32
    OriginalRows : DataViewRowState # 42


class DataViewSetting:
    @property
    def ApplyDefaultSort(self) -> bool: ...
    @ApplyDefaultSort.setter
    def ApplyDefaultSort(self, value: bool) -> bool: ...
    @property
    def DataViewManager(self) -> DataViewManager: ...
    @property
    def RowFilter(self) -> str: ...
    @RowFilter.setter
    def RowFilter(self, value: str) -> str: ...
    @property
    def RowStateFilter(self) -> DataViewRowState: ...
    @RowStateFilter.setter
    def RowStateFilter(self, value: DataViewRowState) -> DataViewRowState: ...
    @property
    def Sort(self) -> str: ...
    @Sort.setter
    def Sort(self, value: str) -> str: ...
    @property
    def Table(self) -> DataTable: ...


class DataViewSettingCollection(ICollection):
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> DataViewSetting: ...
    @Item.setter
    def Item(self, value: DataViewSetting) -> DataViewSetting: ...
    @property
    def Item(self) -> DataViewSetting: ...
    @property
    def Item(self) -> DataViewSetting: ...
    @Item.setter
    def Item(self, value: DataViewSetting) -> DataViewSetting: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def GetEnumerator(self) -> IEnumerator: ...
    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, ar: Array_1[DataViewSetting], index: int) -> None:...
        @typing.overload
        def __call__(self, ar: Array, index: int) -> None:...



class DBConcurrencyException(SystemException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, inner: Exception) -> None: ...
    @typing.overload
    def __init__(self, message: str, inner: Exception, dataRows: Array_1[DataRow]) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Row(self) -> DataRow: ...
    @Row.setter
    def Row(self, value: DataRow) -> DataRow: ...
    @property
    def RowCount(self) -> int: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    # Skipped CopyToRows due to it being static, abstract and generic.

    CopyToRows : CopyToRows_MethodGroup
    class CopyToRows_MethodGroup:
        @typing.overload
        def __call__(self, array: Array_1[DataRow]) -> None:...
        @typing.overload
        def __call__(self, array: Array_1[DataRow], arrayIndex: int) -> None:...



class DbType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    AnsiString : DbType # 0
    Binary : DbType # 1
    Byte : DbType # 2
    Boolean : DbType # 3
    Currency : DbType # 4
    Date : DbType # 5
    DateTime : DbType # 6
    Decimal : DbType # 7
    Double : DbType # 8
    Guid : DbType # 9
    Int16 : DbType # 10
    Int32 : DbType # 11
    Int64 : DbType # 12
    Object : DbType # 13
    SByte : DbType # 14
    Single : DbType # 15
    String : DbType # 16
    Time : DbType # 17
    UInt16 : DbType # 18
    UInt32 : DbType # 19
    UInt64 : DbType # 20
    VarNumeric : DbType # 21
    AnsiStringFixedLength : DbType # 22
    StringFixedLength : DbType # 23
    Xml : DbType # 25
    DateTime2 : DbType # 26
    DateTimeOffset : DbType # 27


class DeletedRowInaccessibleException(DataException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class DuplicateNameException(DataException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class EnumerableRowCollection_GenericClasses(abc.ABCMeta):
    Generic_EnumerableRowCollection_GenericClasses_EnumerableRowCollection_1_TRow = typing.TypeVar('Generic_EnumerableRowCollection_GenericClasses_EnumerableRowCollection_1_TRow')
    def __getitem__(self, types : typing.Type[Generic_EnumerableRowCollection_GenericClasses_EnumerableRowCollection_1_TRow]) -> typing.Type[EnumerableRowCollection_1[Generic_EnumerableRowCollection_GenericClasses_EnumerableRowCollection_1_TRow]]: ...

class EnumerableRowCollection(EnumerableRowCollection_0, metaclass =EnumerableRowCollection_GenericClasses): ...

class EnumerableRowCollection_0(IEnumerable, abc.ABC):
    pass


EnumerableRowCollection_1_TRow = typing.TypeVar('EnumerableRowCollection_1_TRow')
class EnumerableRowCollection_1(typing.Generic[EnumerableRowCollection_1_TRow], EnumerableRowCollection_0, IEnumerable_1[EnumerableRowCollection_1_TRow]):
    def GetEnumerator(self) -> IEnumerator_1[EnumerableRowCollection_1_TRow]: ...


class EnumerableRowCollectionExtensions(abc.ABC):
    # Skipped Cast due to it being static, abstract and generic.

    Cast : Cast_MethodGroup
    class Cast_MethodGroup:
        def __getitem__(self, t:typing.Type[Cast_1_T1]) -> Cast_1[Cast_1_T1]: ...

        Cast_1_T1 = typing.TypeVar('Cast_1_T1')
        class Cast_1(typing.Generic[Cast_1_T1]):
            Cast_1_TResult = EnumerableRowCollectionExtensions.Cast_MethodGroup.Cast_1_T1
            def __call__(self, source: EnumerableRowCollection) -> EnumerableRowCollection_1[Cast_1_TResult]:...


    # Skipped OrderBy due to it being static, abstract and generic.

    OrderBy : OrderBy_MethodGroup
    class OrderBy_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[OrderBy_2_T1], typing.Type[OrderBy_2_T2]]) -> OrderBy_2[OrderBy_2_T1, OrderBy_2_T2]: ...

        OrderBy_2_T1 = typing.TypeVar('OrderBy_2_T1')
        OrderBy_2_T2 = typing.TypeVar('OrderBy_2_T2')
        class OrderBy_2(typing.Generic[OrderBy_2_T1, OrderBy_2_T2]):
            OrderBy_2_TRow = EnumerableRowCollectionExtensions.OrderBy_MethodGroup.OrderBy_2_T1
            OrderBy_2_TKey = EnumerableRowCollectionExtensions.OrderBy_MethodGroup.OrderBy_2_T2
            @typing.overload
            def __call__(self, source: EnumerableRowCollection_1[OrderBy_2_TRow], keySelector: Func_2[OrderBy_2_TRow, OrderBy_2_TKey]) -> OrderedEnumerableRowCollection_1[OrderBy_2_TRow]:...
            @typing.overload
            def __call__(self, source: EnumerableRowCollection_1[OrderBy_2_TRow], keySelector: Func_2[OrderBy_2_TRow, OrderBy_2_TKey], comparer: IComparer_1[OrderBy_2_TKey]) -> OrderedEnumerableRowCollection_1[OrderBy_2_TRow]:...


    # Skipped OrderByDescending due to it being static, abstract and generic.

    OrderByDescending : OrderByDescending_MethodGroup
    class OrderByDescending_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[OrderByDescending_2_T1], typing.Type[OrderByDescending_2_T2]]) -> OrderByDescending_2[OrderByDescending_2_T1, OrderByDescending_2_T2]: ...

        OrderByDescending_2_T1 = typing.TypeVar('OrderByDescending_2_T1')
        OrderByDescending_2_T2 = typing.TypeVar('OrderByDescending_2_T2')
        class OrderByDescending_2(typing.Generic[OrderByDescending_2_T1, OrderByDescending_2_T2]):
            OrderByDescending_2_TRow = EnumerableRowCollectionExtensions.OrderByDescending_MethodGroup.OrderByDescending_2_T1
            OrderByDescending_2_TKey = EnumerableRowCollectionExtensions.OrderByDescending_MethodGroup.OrderByDescending_2_T2
            @typing.overload
            def __call__(self, source: EnumerableRowCollection_1[OrderByDescending_2_TRow], keySelector: Func_2[OrderByDescending_2_TRow, OrderByDescending_2_TKey]) -> OrderedEnumerableRowCollection_1[OrderByDescending_2_TRow]:...
            @typing.overload
            def __call__(self, source: EnumerableRowCollection_1[OrderByDescending_2_TRow], keySelector: Func_2[OrderByDescending_2_TRow, OrderByDescending_2_TKey], comparer: IComparer_1[OrderByDescending_2_TKey]) -> OrderedEnumerableRowCollection_1[OrderByDescending_2_TRow]:...


    # Skipped Select due to it being static, abstract and generic.

    Select : Select_MethodGroup
    class Select_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[Select_2_T1], typing.Type[Select_2_T2]]) -> Select_2[Select_2_T1, Select_2_T2]: ...

        Select_2_T1 = typing.TypeVar('Select_2_T1')
        Select_2_T2 = typing.TypeVar('Select_2_T2')
        class Select_2(typing.Generic[Select_2_T1, Select_2_T2]):
            Select_2_TRow = EnumerableRowCollectionExtensions.Select_MethodGroup.Select_2_T1
            Select_2_S = EnumerableRowCollectionExtensions.Select_MethodGroup.Select_2_T2
            def __call__(self, source: EnumerableRowCollection_1[Select_2_TRow], selector: Func_2[Select_2_TRow, Select_2_S]) -> EnumerableRowCollection_1[Select_2_S]:...


    # Skipped ThenBy due to it being static, abstract and generic.

    ThenBy : ThenBy_MethodGroup
    class ThenBy_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[ThenBy_2_T1], typing.Type[ThenBy_2_T2]]) -> ThenBy_2[ThenBy_2_T1, ThenBy_2_T2]: ...

        ThenBy_2_T1 = typing.TypeVar('ThenBy_2_T1')
        ThenBy_2_T2 = typing.TypeVar('ThenBy_2_T2')
        class ThenBy_2(typing.Generic[ThenBy_2_T1, ThenBy_2_T2]):
            ThenBy_2_TRow = EnumerableRowCollectionExtensions.ThenBy_MethodGroup.ThenBy_2_T1
            ThenBy_2_TKey = EnumerableRowCollectionExtensions.ThenBy_MethodGroup.ThenBy_2_T2
            @typing.overload
            def __call__(self, source: OrderedEnumerableRowCollection_1[ThenBy_2_TRow], keySelector: Func_2[ThenBy_2_TRow, ThenBy_2_TKey]) -> OrderedEnumerableRowCollection_1[ThenBy_2_TRow]:...
            @typing.overload
            def __call__(self, source: OrderedEnumerableRowCollection_1[ThenBy_2_TRow], keySelector: Func_2[ThenBy_2_TRow, ThenBy_2_TKey], comparer: IComparer_1[ThenBy_2_TKey]) -> OrderedEnumerableRowCollection_1[ThenBy_2_TRow]:...


    # Skipped ThenByDescending due to it being static, abstract and generic.

    ThenByDescending : ThenByDescending_MethodGroup
    class ThenByDescending_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[ThenByDescending_2_T1], typing.Type[ThenByDescending_2_T2]]) -> ThenByDescending_2[ThenByDescending_2_T1, ThenByDescending_2_T2]: ...

        ThenByDescending_2_T1 = typing.TypeVar('ThenByDescending_2_T1')
        ThenByDescending_2_T2 = typing.TypeVar('ThenByDescending_2_T2')
        class ThenByDescending_2(typing.Generic[ThenByDescending_2_T1, ThenByDescending_2_T2]):
            ThenByDescending_2_TRow = EnumerableRowCollectionExtensions.ThenByDescending_MethodGroup.ThenByDescending_2_T1
            ThenByDescending_2_TKey = EnumerableRowCollectionExtensions.ThenByDescending_MethodGroup.ThenByDescending_2_T2
            @typing.overload
            def __call__(self, source: OrderedEnumerableRowCollection_1[ThenByDescending_2_TRow], keySelector: Func_2[ThenByDescending_2_TRow, ThenByDescending_2_TKey]) -> OrderedEnumerableRowCollection_1[ThenByDescending_2_TRow]:...
            @typing.overload
            def __call__(self, source: OrderedEnumerableRowCollection_1[ThenByDescending_2_TRow], keySelector: Func_2[ThenByDescending_2_TRow, ThenByDescending_2_TKey], comparer: IComparer_1[ThenByDescending_2_TKey]) -> OrderedEnumerableRowCollection_1[ThenByDescending_2_TRow]:...


    # Skipped Where due to it being static, abstract and generic.

    Where : Where_MethodGroup
    class Where_MethodGroup:
        def __getitem__(self, t:typing.Type[Where_1_T1]) -> Where_1[Where_1_T1]: ...

        Where_1_T1 = typing.TypeVar('Where_1_T1')
        class Where_1(typing.Generic[Where_1_T1]):
            Where_1_TRow = EnumerableRowCollectionExtensions.Where_MethodGroup.Where_1_T1
            def __call__(self, source: EnumerableRowCollection_1[Where_1_TRow], predicate: Func_2[Where_1_TRow, bool]) -> EnumerableRowCollection_1[Where_1_TRow]:...




class EvaluateException(InvalidExpressionException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class FillErrorEventArgs(EventArgs):
    def __init__(self, dataTable: DataTable, values: Array_1[typing.Any]) -> None: ...
    @property
    def Continue(self) -> bool: ...
    @Continue.setter
    def Continue(self, value: bool) -> bool: ...
    @property
    def DataTable(self) -> DataTable: ...
    @property
    def Errors(self) -> Exception: ...
    @Errors.setter
    def Errors(self, value: Exception) -> Exception: ...
    @property
    def Values(self) -> Array_1[typing.Any]: ...


class FillErrorEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: FillErrorEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: FillErrorEventArgs) -> None: ...


class ForeignKeyConstraint(Constraint):
    @typing.overload
    def __init__(self, constraintName: str, parentColumn: DataColumn, childColumn: DataColumn) -> None: ...
    @typing.overload
    def __init__(self, constraintName: str, parentColumns: Array_1[DataColumn], childColumns: Array_1[DataColumn]) -> None: ...
    @typing.overload
    def __init__(self, constraintName: str, parentTableName: str, parentColumnNames: Array_1[str], childColumnNames: Array_1[str], acceptRejectRule: AcceptRejectRule, deleteRule: Rule, updateRule: Rule) -> None: ...
    @typing.overload
    def __init__(self, constraintName: str, parentTableName: str, parentTableNamespace: str, parentColumnNames: Array_1[str], childColumnNames: Array_1[str], acceptRejectRule: AcceptRejectRule, deleteRule: Rule, updateRule: Rule) -> None: ...
    @typing.overload
    def __init__(self, parentColumn: DataColumn, childColumn: DataColumn) -> None: ...
    @typing.overload
    def __init__(self, parentColumns: Array_1[DataColumn], childColumns: Array_1[DataColumn]) -> None: ...
    @property
    def AcceptRejectRule(self) -> AcceptRejectRule: ...
    @AcceptRejectRule.setter
    def AcceptRejectRule(self, value: AcceptRejectRule) -> AcceptRejectRule: ...
    @property
    def Columns(self) -> Array_1[DataColumn]: ...
    @property
    def ConstraintName(self) -> str: ...
    @ConstraintName.setter
    def ConstraintName(self, value: str) -> str: ...
    @property
    def DeleteRule(self) -> Rule: ...
    @DeleteRule.setter
    def DeleteRule(self, value: Rule) -> Rule: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def RelatedColumns(self) -> Array_1[DataColumn]: ...
    @property
    def RelatedTable(self) -> DataTable: ...
    @property
    def Table(self) -> DataTable: ...
    @property
    def UpdateRule(self) -> Rule: ...
    @UpdateRule.setter
    def UpdateRule(self, value: Rule) -> Rule: ...
    def Equals(self, key: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class IColumnMapping(typing.Protocol):
    @property
    def DataSetColumn(self) -> str: ...
    @DataSetColumn.setter
    def DataSetColumn(self, value: str) -> str: ...
    @property
    def SourceColumn(self) -> str: ...
    @SourceColumn.setter
    def SourceColumn(self, value: str) -> str: ...


class IColumnMappingCollection(IList, typing.Protocol):
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @abc.abstractmethod
    def Add(self, sourceColumnName: str, dataSetColumnName: str) -> IColumnMapping: ...
    @abc.abstractmethod
    def Contains(self, sourceColumnName: str) -> bool: ...
    @abc.abstractmethod
    def GetByDataSetColumn(self, dataSetColumnName: str) -> IColumnMapping: ...
    @abc.abstractmethod
    def IndexOf(self, sourceColumnName: str) -> int: ...
    @abc.abstractmethod
    def RemoveAt(self, sourceColumnName: str) -> None: ...


class IDataAdapter(typing.Protocol):
    @property
    def MissingMappingAction(self) -> MissingMappingAction: ...
    @MissingMappingAction.setter
    def MissingMappingAction(self, value: MissingMappingAction) -> MissingMappingAction: ...
    @property
    def MissingSchemaAction(self) -> MissingSchemaAction: ...
    @MissingSchemaAction.setter
    def MissingSchemaAction(self, value: MissingSchemaAction) -> MissingSchemaAction: ...
    @property
    def TableMappings(self) -> ITableMappingCollection: ...
    @abc.abstractmethod
    def Fill(self, dataSet: DataSet) -> int: ...
    @abc.abstractmethod
    def FillSchema(self, dataSet: DataSet, schemaType: SchemaType) -> Array_1[DataTable]: ...
    @abc.abstractmethod
    def GetFillParameters(self) -> Array_1[IDataParameter]: ...
    @abc.abstractmethod
    def Update(self, dataSet: DataSet) -> int: ...


class IDataParameter(typing.Protocol):
    @property
    def DbType(self) -> DbType: ...
    @DbType.setter
    def DbType(self, value: DbType) -> DbType: ...
    @property
    def Direction(self) -> ParameterDirection: ...
    @Direction.setter
    def Direction(self, value: ParameterDirection) -> ParameterDirection: ...
    @property
    def IsNullable(self) -> bool: ...
    @property
    def ParameterName(self) -> str: ...
    @ParameterName.setter
    def ParameterName(self, value: str) -> str: ...
    @property
    def SourceColumn(self) -> str: ...
    @SourceColumn.setter
    def SourceColumn(self, value: str) -> str: ...
    @property
    def SourceVersion(self) -> DataRowVersion: ...
    @SourceVersion.setter
    def SourceVersion(self, value: DataRowVersion) -> DataRowVersion: ...
    @property
    def Value(self) -> typing.Any: ...
    @Value.setter
    def Value(self, value: typing.Any) -> typing.Any: ...


class IDataParameterCollection(IList, typing.Protocol):
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @abc.abstractmethod
    def Contains(self, parameterName: str) -> bool: ...
    @abc.abstractmethod
    def IndexOf(self, parameterName: str) -> int: ...
    @abc.abstractmethod
    def RemoveAt(self, parameterName: str) -> None: ...


class IDataReader(IDataRecord, IDisposable, typing.Protocol):
    @property
    def Depth(self) -> int: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def RecordsAffected(self) -> int: ...
    @abc.abstractmethod
    def Close(self) -> None: ...
    @abc.abstractmethod
    def GetSchemaTable(self) -> DataTable: ...
    @abc.abstractmethod
    def NextResult(self) -> bool: ...
    @abc.abstractmethod
    def Read(self) -> bool: ...


class IDataRecord(typing.Protocol):
    @property
    def FieldCount(self) -> int: ...
    @property
    def Item(self) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @abc.abstractmethod
    def GetBoolean(self, i: int) -> bool: ...
    @abc.abstractmethod
    def GetByte(self, i: int) -> int: ...
    @abc.abstractmethod
    def GetBytes(self, i: int, fieldOffset: int, buffer: Array_1[int], bufferoffset: int, length: int) -> int: ...
    @abc.abstractmethod
    def GetChar(self, i: int) -> str: ...
    @abc.abstractmethod
    def GetChars(self, i: int, fieldoffset: int, buffer: Array_1[str], bufferoffset: int, length: int) -> int: ...
    @abc.abstractmethod
    def GetData(self, i: int) -> IDataReader: ...
    @abc.abstractmethod
    def GetDataTypeName(self, i: int) -> str: ...
    @abc.abstractmethod
    def GetDateTime(self, i: int) -> DateTime: ...
    @abc.abstractmethod
    def GetDecimal(self, i: int) -> Decimal: ...
    @abc.abstractmethod
    def GetDouble(self, i: int) -> float: ...
    @abc.abstractmethod
    def GetFieldType(self, i: int) -> typing.Type[typing.Any]: ...
    @abc.abstractmethod
    def GetFloat(self, i: int) -> float: ...
    @abc.abstractmethod
    def GetGuid(self, i: int) -> Guid: ...
    @abc.abstractmethod
    def GetInt16(self, i: int) -> int: ...
    @abc.abstractmethod
    def GetInt32(self, i: int) -> int: ...
    @abc.abstractmethod
    def GetInt64(self, i: int) -> int: ...
    @abc.abstractmethod
    def GetName(self, i: int) -> str: ...
    @abc.abstractmethod
    def GetOrdinal(self, name: str) -> int: ...
    @abc.abstractmethod
    def GetString(self, i: int) -> str: ...
    @abc.abstractmethod
    def GetValue(self, i: int) -> typing.Any: ...
    @abc.abstractmethod
    def GetValues(self, values: Array_1[typing.Any]) -> int: ...
    @abc.abstractmethod
    def IsDBNull(self, i: int) -> bool: ...


class IDbCommand(IDisposable, typing.Protocol):
    @property
    def CommandText(self) -> str: ...
    @CommandText.setter
    def CommandText(self, value: str) -> str: ...
    @property
    def CommandTimeout(self) -> int: ...
    @CommandTimeout.setter
    def CommandTimeout(self, value: int) -> int: ...
    @property
    def CommandType(self) -> CommandType: ...
    @CommandType.setter
    def CommandType(self, value: CommandType) -> CommandType: ...
    @property
    def Connection(self) -> IDbConnection: ...
    @Connection.setter
    def Connection(self, value: IDbConnection) -> IDbConnection: ...
    @property
    def Parameters(self) -> IDataParameterCollection: ...
    @property
    def Transaction(self) -> IDbTransaction: ...
    @Transaction.setter
    def Transaction(self, value: IDbTransaction) -> IDbTransaction: ...
    @property
    def UpdatedRowSource(self) -> UpdateRowSource: ...
    @UpdatedRowSource.setter
    def UpdatedRowSource(self, value: UpdateRowSource) -> UpdateRowSource: ...
    @abc.abstractmethod
    def Cancel(self) -> None: ...
    @abc.abstractmethod
    def CreateParameter(self) -> IDbDataParameter: ...
    @abc.abstractmethod
    def ExecuteNonQuery(self) -> int: ...
    @abc.abstractmethod
    def ExecuteScalar(self) -> typing.Any: ...
    @abc.abstractmethod
    def Prepare(self) -> None: ...
    # Skipped ExecuteReader due to it being static, abstract and generic.

    ExecuteReader : ExecuteReader_MethodGroup
    class ExecuteReader_MethodGroup:
        @typing.overload
        def __call__(self) -> IDataReader:...
        @typing.overload
        def __call__(self, behavior: CommandBehavior) -> IDataReader:...



class IDbConnection(IDisposable, typing.Protocol):
    @property
    def ConnectionString(self) -> str: ...
    @ConnectionString.setter
    def ConnectionString(self, value: str) -> str: ...
    @property
    def ConnectionTimeout(self) -> int: ...
    @property
    def Database(self) -> str: ...
    @property
    def State(self) -> ConnectionState: ...
    @abc.abstractmethod
    def ChangeDatabase(self, databaseName: str) -> None: ...
    @abc.abstractmethod
    def Close(self) -> None: ...
    @abc.abstractmethod
    def CreateCommand(self) -> IDbCommand: ...
    @abc.abstractmethod
    def Open(self) -> None: ...
    # Skipped BeginTransaction due to it being static, abstract and generic.

    BeginTransaction : BeginTransaction_MethodGroup
    class BeginTransaction_MethodGroup:
        @typing.overload
        def __call__(self) -> IDbTransaction:...
        @typing.overload
        def __call__(self, il: IsolationLevel) -> IDbTransaction:...



class IDbDataAdapter(IDataAdapter, typing.Protocol):
    @property
    def DeleteCommand(self) -> IDbCommand: ...
    @DeleteCommand.setter
    def DeleteCommand(self, value: IDbCommand) -> IDbCommand: ...
    @property
    def InsertCommand(self) -> IDbCommand: ...
    @InsertCommand.setter
    def InsertCommand(self, value: IDbCommand) -> IDbCommand: ...
    @property
    def SelectCommand(self) -> IDbCommand: ...
    @SelectCommand.setter
    def SelectCommand(self, value: IDbCommand) -> IDbCommand: ...
    @property
    def UpdateCommand(self) -> IDbCommand: ...
    @UpdateCommand.setter
    def UpdateCommand(self, value: IDbCommand) -> IDbCommand: ...


class IDbDataParameter(IDataParameter, typing.Protocol):
    @property
    def Precision(self) -> int: ...
    @Precision.setter
    def Precision(self, value: int) -> int: ...
    @property
    def Scale(self) -> int: ...
    @Scale.setter
    def Scale(self, value: int) -> int: ...
    @property
    def Size(self) -> int: ...
    @Size.setter
    def Size(self, value: int) -> int: ...


class IDbTransaction(IDisposable, typing.Protocol):
    @property
    def Connection(self) -> IDbConnection: ...
    @property
    def IsolationLevel(self) -> IsolationLevel: ...
    @abc.abstractmethod
    def Commit(self) -> None: ...
    @abc.abstractmethod
    def Rollback(self) -> None: ...


class InRowChangingEventException(DataException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class InternalDataCollectionBase(ICollection):
    def __init__(self) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def CopyTo(self, ar: Array, index: int) -> None: ...
    def GetEnumerator(self) -> IEnumerator: ...


class InvalidConstraintException(DataException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class InvalidExpressionException(DataException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class IsolationLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Chaos : IsolationLevel # 16
    ReadUncommitted : IsolationLevel # 256
    ReadCommitted : IsolationLevel # 4096
    RepeatableRead : IsolationLevel # 65536
    Serializable : IsolationLevel # 1048576
    Snapshot : IsolationLevel # 16777216
    Unspecified : IsolationLevel # -1


class ITableMapping(typing.Protocol):
    @property
    def ColumnMappings(self) -> IColumnMappingCollection: ...
    @property
    def DataSetTable(self) -> str: ...
    @DataSetTable.setter
    def DataSetTable(self, value: str) -> str: ...
    @property
    def SourceTable(self) -> str: ...
    @SourceTable.setter
    def SourceTable(self, value: str) -> str: ...


class ITableMappingCollection(IList, typing.Protocol):
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @abc.abstractmethod
    def Add(self, sourceTableName: str, dataSetTableName: str) -> ITableMapping: ...
    @abc.abstractmethod
    def Contains(self, sourceTableName: str) -> bool: ...
    @abc.abstractmethod
    def GetByDataSetTable(self, dataSetTableName: str) -> ITableMapping: ...
    @abc.abstractmethod
    def IndexOf(self, sourceTableName: str) -> int: ...
    @abc.abstractmethod
    def RemoveAt(self, sourceTableName: str) -> None: ...


class KeyRestrictionBehavior(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    AllowOnly : KeyRestrictionBehavior # 0
    PreventUsage : KeyRestrictionBehavior # 1


class LoadOption(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    OverwriteChanges : LoadOption # 1
    PreserveChanges : LoadOption # 2
    Upsert : LoadOption # 3


class MappingType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Element : MappingType # 1
    Attribute : MappingType # 2
    SimpleContent : MappingType # 3
    Hidden : MappingType # 4


class MergeFailedEventArgs(EventArgs):
    def __init__(self, table: DataTable, conflict: str) -> None: ...
    @property
    def Conflict(self) -> str: ...
    @property
    def Table(self) -> DataTable: ...


class MergeFailedEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: MergeFailedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: MergeFailedEventArgs) -> None: ...


class MissingMappingAction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Passthrough : MissingMappingAction # 1
    Ignore : MissingMappingAction # 2
    Error : MissingMappingAction # 3


class MissingPrimaryKeyException(DataException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class MissingSchemaAction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Add : MissingSchemaAction # 1
    Ignore : MissingSchemaAction # 2
    Error : MissingSchemaAction # 3
    AddWithKey : MissingSchemaAction # 4


class NoNullAllowedException(DataException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class OrderedEnumerableRowCollection_GenericClasses(abc.ABCMeta):
    Generic_OrderedEnumerableRowCollection_GenericClasses_OrderedEnumerableRowCollection_1_TRow = typing.TypeVar('Generic_OrderedEnumerableRowCollection_GenericClasses_OrderedEnumerableRowCollection_1_TRow')
    def __getitem__(self, types : typing.Type[Generic_OrderedEnumerableRowCollection_GenericClasses_OrderedEnumerableRowCollection_1_TRow]) -> typing.Type[OrderedEnumerableRowCollection_1[Generic_OrderedEnumerableRowCollection_GenericClasses_OrderedEnumerableRowCollection_1_TRow]]: ...

OrderedEnumerableRowCollection : OrderedEnumerableRowCollection_GenericClasses

OrderedEnumerableRowCollection_1_TRow = typing.TypeVar('OrderedEnumerableRowCollection_1_TRow')
class OrderedEnumerableRowCollection_1(typing.Generic[OrderedEnumerableRowCollection_1_TRow], EnumerableRowCollection_1[OrderedEnumerableRowCollection_1_TRow]):
    pass


class ParameterDirection(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Input : ParameterDirection # 1
    Output : ParameterDirection # 2
    InputOutput : ParameterDirection # 3
    ReturnValue : ParameterDirection # 6


class PropertyCollection(Hashtable):
    def __init__(self) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsFixedSize(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Keys(self) -> ICollection: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    @property
    def Values(self) -> ICollection: ...
    def Clone(self) -> typing.Any: ...


class ReadOnlyException(DataException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class RowNotInTableException(DataException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class Rule(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : Rule # 0
    Cascade : Rule # 1
    SetNull : Rule # 2
    SetDefault : Rule # 3


class SchemaSerializationMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    IncludeSchema : SchemaSerializationMode # 1
    ExcludeSchema : SchemaSerializationMode # 2


class SchemaType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Source : SchemaType # 1
    Mapped : SchemaType # 2


class SerializationFormat(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Xml : SerializationFormat # 0
    Binary : SerializationFormat # 1


class SqlDbType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    BigInt : SqlDbType # 0
    Binary : SqlDbType # 1
    Bit : SqlDbType # 2
    Char : SqlDbType # 3
    DateTime : SqlDbType # 4
    Decimal : SqlDbType # 5
    Float : SqlDbType # 6
    Image : SqlDbType # 7
    Int : SqlDbType # 8
    Money : SqlDbType # 9
    NChar : SqlDbType # 10
    NText : SqlDbType # 11
    NVarChar : SqlDbType # 12
    Real : SqlDbType # 13
    UniqueIdentifier : SqlDbType # 14
    SmallDateTime : SqlDbType # 15
    SmallInt : SqlDbType # 16
    SmallMoney : SqlDbType # 17
    Text : SqlDbType # 18
    Timestamp : SqlDbType # 19
    TinyInt : SqlDbType # 20
    VarBinary : SqlDbType # 21
    VarChar : SqlDbType # 22
    Variant : SqlDbType # 23
    Xml : SqlDbType # 25
    Udt : SqlDbType # 29
    Structured : SqlDbType # 30
    Date : SqlDbType # 31
    Time : SqlDbType # 32
    DateTime2 : SqlDbType # 33
    DateTimeOffset : SqlDbType # 34


class StateChangeEventArgs(EventArgs):
    def __init__(self, originalState: ConnectionState, currentState: ConnectionState) -> None: ...
    @property
    def CurrentState(self) -> ConnectionState: ...
    @property
    def OriginalState(self) -> ConnectionState: ...


class StateChangeEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: StateChangeEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: StateChangeEventArgs) -> None: ...


class StatementCompletedEventArgs(EventArgs):
    def __init__(self, recordCount: int) -> None: ...
    @property
    def RecordCount(self) -> int: ...


class StatementCompletedEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: StatementCompletedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: StatementCompletedEventArgs) -> None: ...


class StatementType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Select : StatementType # 0
    Insert : StatementType # 1
    Update : StatementType # 2
    Delete : StatementType # 3
    Batch : StatementType # 4


class StrongTypingException(DataException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, s: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class SyntaxErrorException(InvalidExpressionException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class TypedTableBase_GenericClasses(abc.ABCMeta):
    Generic_TypedTableBase_GenericClasses_TypedTableBase_1_T = typing.TypeVar('Generic_TypedTableBase_GenericClasses_TypedTableBase_1_T')
    def __getitem__(self, types : typing.Type[Generic_TypedTableBase_GenericClasses_TypedTableBase_1_T]) -> typing.Type[TypedTableBase_1[Generic_TypedTableBase_GenericClasses_TypedTableBase_1_T]]: ...

TypedTableBase : TypedTableBase_GenericClasses

TypedTableBase_1_T = typing.TypeVar('TypedTableBase_1_T')
class TypedTableBase_1(typing.Generic[TypedTableBase_1_T], DataTable, IEnumerable_1[TypedTableBase_1_T], abc.ABC):
    @property
    def CaseSensitive(self) -> bool: ...
    @CaseSensitive.setter
    def CaseSensitive(self, value: bool) -> bool: ...
    @property
    def ChildRelations(self) -> DataRelationCollection: ...
    @property
    def Columns(self) -> DataColumnCollection: ...
    @property
    def Constraints(self) -> ConstraintCollection: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DataSet(self) -> DataSet: ...
    @property
    def DefaultView(self) -> DataView: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def DisplayExpression(self) -> str: ...
    @DisplayExpression.setter
    def DisplayExpression(self, value: str) -> str: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def HasErrors(self) -> bool: ...
    @property
    def IsInitialized(self) -> bool: ...
    @property
    def Locale(self) -> CultureInfo: ...
    @Locale.setter
    def Locale(self, value: CultureInfo) -> CultureInfo: ...
    @property
    def MinimumCapacity(self) -> int: ...
    @MinimumCapacity.setter
    def MinimumCapacity(self, value: int) -> int: ...
    @property
    def Namespace(self) -> str: ...
    @Namespace.setter
    def Namespace(self, value: str) -> str: ...
    @property
    def ParentRelations(self) -> DataRelationCollection: ...
    @property
    def Prefix(self) -> str: ...
    @Prefix.setter
    def Prefix(self, value: str) -> str: ...
    @property
    def PrimaryKey(self) -> Array_1[DataColumn]: ...
    @PrimaryKey.setter
    def PrimaryKey(self, value: Array_1[DataColumn]) -> Array_1[DataColumn]: ...
    @property
    def RemotingFormat(self) -> SerializationFormat: ...
    @RemotingFormat.setter
    def RemotingFormat(self, value: SerializationFormat) -> SerializationFormat: ...
    @property
    def Rows(self) -> DataRowCollection: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def TableName(self) -> str: ...
    @TableName.setter
    def TableName(self, value: str) -> str: ...
    def GetEnumerator(self) -> IEnumerator_1[TypedTableBase_1_T]: ...
    # Skipped Cast due to it being static, abstract and generic.

    Cast : Cast_MethodGroup[TypedTableBase_1_T]
    Cast_MethodGroup_TypedTableBase_1_T = typing.TypeVar('Cast_MethodGroup_TypedTableBase_1_T')
    class Cast_MethodGroup(typing.Generic[Cast_MethodGroup_TypedTableBase_1_T]):
        Cast_MethodGroup_TypedTableBase_1_T = TypedTableBase_1.Cast_MethodGroup_TypedTableBase_1_T
        def __getitem__(self, t:typing.Type[Cast_1_T1]) -> Cast_1[Cast_MethodGroup_TypedTableBase_1_T, Cast_1_T1]: ...

        Cast_1_TypedTableBase_1_T = typing.TypeVar('Cast_1_TypedTableBase_1_T')
        Cast_1_T1 = typing.TypeVar('Cast_1_T1')
        class Cast_1(typing.Generic[Cast_1_TypedTableBase_1_T, Cast_1_T1]):
            Cast_1_TypedTableBase_1_T = TypedTableBase_1.Cast_MethodGroup.Cast_1_TypedTableBase_1_T
            Cast_1_TResult = TypedTableBase_1.Cast_MethodGroup.Cast_1_T1
            def __call__(self) -> EnumerableRowCollection_1[Cast_1_TResult]:...




class TypedTableBaseExtensions(abc.ABC):
    # Skipped AsEnumerable due to it being static, abstract and generic.

    AsEnumerable : AsEnumerable_MethodGroup
    class AsEnumerable_MethodGroup:
        def __getitem__(self, t:typing.Type[AsEnumerable_1_T1]) -> AsEnumerable_1[AsEnumerable_1_T1]: ...

        AsEnumerable_1_T1 = typing.TypeVar('AsEnumerable_1_T1')
        class AsEnumerable_1(typing.Generic[AsEnumerable_1_T1]):
            AsEnumerable_1_TRow = TypedTableBaseExtensions.AsEnumerable_MethodGroup.AsEnumerable_1_T1
            def __call__(self, source: TypedTableBase_1[AsEnumerable_1_TRow]) -> EnumerableRowCollection_1[AsEnumerable_1_TRow]:...


    # Skipped ElementAtOrDefault due to it being static, abstract and generic.

    ElementAtOrDefault : ElementAtOrDefault_MethodGroup
    class ElementAtOrDefault_MethodGroup:
        def __getitem__(self, t:typing.Type[ElementAtOrDefault_1_T1]) -> ElementAtOrDefault_1[ElementAtOrDefault_1_T1]: ...

        ElementAtOrDefault_1_T1 = typing.TypeVar('ElementAtOrDefault_1_T1')
        class ElementAtOrDefault_1(typing.Generic[ElementAtOrDefault_1_T1]):
            ElementAtOrDefault_1_TRow = TypedTableBaseExtensions.ElementAtOrDefault_MethodGroup.ElementAtOrDefault_1_T1
            def __call__(self, source: TypedTableBase_1[ElementAtOrDefault_1_TRow], index: int) -> ElementAtOrDefault_1_TRow:...


    # Skipped OrderBy due to it being static, abstract and generic.

    OrderBy : OrderBy_MethodGroup
    class OrderBy_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[OrderBy_2_T1], typing.Type[OrderBy_2_T2]]) -> OrderBy_2[OrderBy_2_T1, OrderBy_2_T2]: ...

        OrderBy_2_T1 = typing.TypeVar('OrderBy_2_T1')
        OrderBy_2_T2 = typing.TypeVar('OrderBy_2_T2')
        class OrderBy_2(typing.Generic[OrderBy_2_T1, OrderBy_2_T2]):
            OrderBy_2_TRow = TypedTableBaseExtensions.OrderBy_MethodGroup.OrderBy_2_T1
            OrderBy_2_TKey = TypedTableBaseExtensions.OrderBy_MethodGroup.OrderBy_2_T2
            @typing.overload
            def __call__(self, source: TypedTableBase_1[OrderBy_2_TRow], keySelector: Func_2[OrderBy_2_TRow, OrderBy_2_TKey]) -> OrderedEnumerableRowCollection_1[OrderBy_2_TRow]:...
            @typing.overload
            def __call__(self, source: TypedTableBase_1[OrderBy_2_TRow], keySelector: Func_2[OrderBy_2_TRow, OrderBy_2_TKey], comparer: IComparer_1[OrderBy_2_TKey]) -> OrderedEnumerableRowCollection_1[OrderBy_2_TRow]:...


    # Skipped OrderByDescending due to it being static, abstract and generic.

    OrderByDescending : OrderByDescending_MethodGroup
    class OrderByDescending_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[OrderByDescending_2_T1], typing.Type[OrderByDescending_2_T2]]) -> OrderByDescending_2[OrderByDescending_2_T1, OrderByDescending_2_T2]: ...

        OrderByDescending_2_T1 = typing.TypeVar('OrderByDescending_2_T1')
        OrderByDescending_2_T2 = typing.TypeVar('OrderByDescending_2_T2')
        class OrderByDescending_2(typing.Generic[OrderByDescending_2_T1, OrderByDescending_2_T2]):
            OrderByDescending_2_TRow = TypedTableBaseExtensions.OrderByDescending_MethodGroup.OrderByDescending_2_T1
            OrderByDescending_2_TKey = TypedTableBaseExtensions.OrderByDescending_MethodGroup.OrderByDescending_2_T2
            @typing.overload
            def __call__(self, source: TypedTableBase_1[OrderByDescending_2_TRow], keySelector: Func_2[OrderByDescending_2_TRow, OrderByDescending_2_TKey]) -> OrderedEnumerableRowCollection_1[OrderByDescending_2_TRow]:...
            @typing.overload
            def __call__(self, source: TypedTableBase_1[OrderByDescending_2_TRow], keySelector: Func_2[OrderByDescending_2_TRow, OrderByDescending_2_TKey], comparer: IComparer_1[OrderByDescending_2_TKey]) -> OrderedEnumerableRowCollection_1[OrderByDescending_2_TRow]:...


    # Skipped Select due to it being static, abstract and generic.

    Select : Select_MethodGroup
    class Select_MethodGroup:
        def __getitem__(self, t:typing.Tuple[typing.Type[Select_2_T1], typing.Type[Select_2_T2]]) -> Select_2[Select_2_T1, Select_2_T2]: ...

        Select_2_T1 = typing.TypeVar('Select_2_T1')
        Select_2_T2 = typing.TypeVar('Select_2_T2')
        class Select_2(typing.Generic[Select_2_T1, Select_2_T2]):
            Select_2_TRow = TypedTableBaseExtensions.Select_MethodGroup.Select_2_T1
            Select_2_S = TypedTableBaseExtensions.Select_MethodGroup.Select_2_T2
            def __call__(self, source: TypedTableBase_1[Select_2_TRow], selector: Func_2[Select_2_TRow, Select_2_S]) -> EnumerableRowCollection_1[Select_2_S]:...


    # Skipped Where due to it being static, abstract and generic.

    Where : Where_MethodGroup
    class Where_MethodGroup:
        def __getitem__(self, t:typing.Type[Where_1_T1]) -> Where_1[Where_1_T1]: ...

        Where_1_T1 = typing.TypeVar('Where_1_T1')
        class Where_1(typing.Generic[Where_1_T1]):
            Where_1_TRow = TypedTableBaseExtensions.Where_MethodGroup.Where_1_T1
            def __call__(self, source: TypedTableBase_1[Where_1_TRow], predicate: Func_2[Where_1_TRow, bool]) -> EnumerableRowCollection_1[Where_1_TRow]:...




class UniqueConstraint(Constraint):
    @typing.overload
    def __init__(self, column: DataColumn) -> None: ...
    @typing.overload
    def __init__(self, column: DataColumn, isPrimaryKey: bool) -> None: ...
    @typing.overload
    def __init__(self, columns: Array_1[DataColumn]) -> None: ...
    @typing.overload
    def __init__(self, columns: Array_1[DataColumn], isPrimaryKey: bool) -> None: ...
    @typing.overload
    def __init__(self, name: str, column: DataColumn) -> None: ...
    @typing.overload
    def __init__(self, name: str, column: DataColumn, isPrimaryKey: bool) -> None: ...
    @typing.overload
    def __init__(self, name: str, columnNames: Array_1[str], isPrimaryKey: bool) -> None: ...
    @typing.overload
    def __init__(self, name: str, columns: Array_1[DataColumn]) -> None: ...
    @typing.overload
    def __init__(self, name: str, columns: Array_1[DataColumn], isPrimaryKey: bool) -> None: ...
    @property
    def Columns(self) -> Array_1[DataColumn]: ...
    @property
    def ConstraintName(self) -> str: ...
    @ConstraintName.setter
    def ConstraintName(self, value: str) -> str: ...
    @property
    def ExtendedProperties(self) -> PropertyCollection: ...
    @property
    def IsPrimaryKey(self) -> bool: ...
    @property
    def Table(self) -> DataTable: ...
    def Equals(self, key2: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class UpdateRowSource(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : UpdateRowSource # 0
    OutputParameters : UpdateRowSource # 1
    FirstReturnedRecord : UpdateRowSource # 2
    Both : UpdateRowSource # 3


class UpdateStatus(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Continue : UpdateStatus # 0
    ErrorsOccurred : UpdateStatus # 1
    SkipCurrentRow : UpdateStatus # 2
    SkipAllRemainingRows : UpdateStatus # 3


class VersionNotFoundException(DataException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, s: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class XmlReadMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Auto : XmlReadMode # 0
    ReadSchema : XmlReadMode # 1
    IgnoreSchema : XmlReadMode # 2
    InferSchema : XmlReadMode # 3
    DiffGram : XmlReadMode # 4
    Fragment : XmlReadMode # 5
    InferTypedSchema : XmlReadMode # 6


class XmlWriteMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    WriteSchema : XmlWriteMode # 0
    IgnoreSchema : XmlWriteMode # 1
    DiffGram : XmlWriteMode # 2

