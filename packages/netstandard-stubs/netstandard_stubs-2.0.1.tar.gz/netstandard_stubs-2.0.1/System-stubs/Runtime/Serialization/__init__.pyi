import typing, clr, abc
from System import Attribute, IDisposable, DateTime, Decimal, TypeCode, Array_1, Exception, EventArgs, MulticastDelegate, IAsyncResult, AsyncCallback, SystemException
from System.IO import Stream
from System.Runtime.Serialization.Formatters import TypeFilterLevel
from System.Reflection import MemberInfo, Assembly, MethodBase, MethodInfo
from System.Collections import IDictionary, IEnumerator

class CollectionDataContractAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def IsItemNameSetExplicitly(self) -> bool: ...
    @property
    def IsKeyNameSetExplicitly(self) -> bool: ...
    @property
    def IsNameSetExplicitly(self) -> bool: ...
    @property
    def IsNamespaceSetExplicitly(self) -> bool: ...
    @property
    def IsReference(self) -> bool: ...
    @IsReference.setter
    def IsReference(self, value: bool) -> bool: ...
    @property
    def IsReferenceSetExplicitly(self) -> bool: ...
    @property
    def IsValueNameSetExplicitly(self) -> bool: ...
    @property
    def ItemName(self) -> str: ...
    @ItemName.setter
    def ItemName(self, value: str) -> str: ...
    @property
    def KeyName(self) -> str: ...
    @KeyName.setter
    def KeyName(self, value: str) -> str: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Namespace(self) -> str: ...
    @Namespace.setter
    def Namespace(self, value: str) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def ValueName(self) -> str: ...
    @ValueName.setter
    def ValueName(self, value: str) -> str: ...


class ContractNamespaceAttribute(Attribute):
    def __init__(self, contractNamespace: str) -> None: ...
    @property
    def ClrNamespace(self) -> str: ...
    @ClrNamespace.setter
    def ClrNamespace(self, value: str) -> str: ...
    @property
    def ContractNamespace(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DataContractAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def IsNameSetExplicitly(self) -> bool: ...
    @property
    def IsNamespaceSetExplicitly(self) -> bool: ...
    @property
    def IsReference(self) -> bool: ...
    @IsReference.setter
    def IsReference(self, value: bool) -> bool: ...
    @property
    def IsReferenceSetExplicitly(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Namespace(self) -> str: ...
    @Namespace.setter
    def Namespace(self, value: str) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DataMemberAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def EmitDefaultValue(self) -> bool: ...
    @EmitDefaultValue.setter
    def EmitDefaultValue(self, value: bool) -> bool: ...
    @property
    def IsNameSetExplicitly(self) -> bool: ...
    @property
    def IsRequired(self) -> bool: ...
    @IsRequired.setter
    def IsRequired(self, value: bool) -> bool: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Order(self) -> int: ...
    @Order.setter
    def Order(self, value: int) -> int: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DeserializationToken(IDisposable):
    def Dispose(self) -> None: ...


class EnumMemberAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def IsValueSetExplicitly(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def Value(self) -> str: ...
    @Value.setter
    def Value(self, value: str) -> str: ...


class Formatter(IFormatter, abc.ABC):
    @property
    def Binder(self) -> SerializationBinder: ...
    @Binder.setter
    def Binder(self, value: SerializationBinder) -> SerializationBinder: ...
    @property
    def Context(self) -> StreamingContext: ...
    @Context.setter
    def Context(self, value: StreamingContext) -> StreamingContext: ...
    @property
    def SurrogateSelector(self) -> ISurrogateSelector: ...
    @SurrogateSelector.setter
    def SurrogateSelector(self, value: ISurrogateSelector) -> ISurrogateSelector: ...
    @abc.abstractmethod
    def Deserialize(self, serializationStream: Stream) -> typing.Any: ...
    @abc.abstractmethod
    def Serialize(self, serializationStream: Stream, graph: typing.Any) -> None: ...


class FormatterConverter(IFormatterConverter):
    def __init__(self) -> None: ...
    def ToBoolean(self, value: typing.Any) -> bool: ...
    def ToByte(self, value: typing.Any) -> int: ...
    def ToChar(self, value: typing.Any) -> str: ...
    def ToDateTime(self, value: typing.Any) -> DateTime: ...
    def ToDecimal(self, value: typing.Any) -> Decimal: ...
    def ToDouble(self, value: typing.Any) -> float: ...
    def ToInt16(self, value: typing.Any) -> int: ...
    def ToInt32(self, value: typing.Any) -> int: ...
    def ToInt64(self, value: typing.Any) -> int: ...
    def ToSByte(self, value: typing.Any) -> int: ...
    def ToSingle(self, value: typing.Any) -> float: ...
    def ToUInt16(self, value: typing.Any) -> int: ...
    def ToUInt32(self, value: typing.Any) -> int: ...
    def ToUInt64(self, value: typing.Any) -> int: ...
    # Skipped Convert due to it being static, abstract and generic.

    Convert : Convert_MethodGroup
    class Convert_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, typeCode: TypeCode) -> typing.Any:...
        @typing.overload
        def __call__(self, value: typing.Any, type: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, value: typing.Any) -> str:...



class FormatterServices(abc.ABC):
    @staticmethod
    def CheckTypeSecurity(t: typing.Type[typing.Any], securityLevel: TypeFilterLevel) -> None: ...
    @staticmethod
    def GetObjectData(obj: typing.Any, members: Array_1[MemberInfo]) -> Array_1[typing.Any]: ...
    @staticmethod
    def GetSafeUninitializedObject(type: typing.Type[typing.Any]) -> typing.Any: ...
    @staticmethod
    def GetSurrogateForCyclicalReference(innerSurrogate: ISerializationSurrogate) -> ISerializationSurrogate: ...
    @staticmethod
    def GetTypeFromAssembly(assem: Assembly, name: str) -> typing.Type[typing.Any]: ...
    @staticmethod
    def GetUninitializedObject(type: typing.Type[typing.Any]) -> typing.Any: ...
    @staticmethod
    def PopulateObjectMembers(obj: typing.Any, members: Array_1[MemberInfo], data: Array_1[typing.Any]) -> typing.Any: ...
    # Skipped GetSerializableMembers due to it being static, abstract and generic.

    GetSerializableMembers : GetSerializableMembers_MethodGroup
    class GetSerializableMembers_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> Array_1[MemberInfo]:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], context: StreamingContext) -> Array_1[MemberInfo]:...



class IDeserializationCallback(typing.Protocol):
    @abc.abstractmethod
    def OnDeserialization(self, sender: typing.Any) -> None: ...


class IFormatter(typing.Protocol):
    @property
    def Binder(self) -> SerializationBinder: ...
    @Binder.setter
    def Binder(self, value: SerializationBinder) -> SerializationBinder: ...
    @property
    def Context(self) -> StreamingContext: ...
    @Context.setter
    def Context(self, value: StreamingContext) -> StreamingContext: ...
    @property
    def SurrogateSelector(self) -> ISurrogateSelector: ...
    @SurrogateSelector.setter
    def SurrogateSelector(self, value: ISurrogateSelector) -> ISurrogateSelector: ...
    @abc.abstractmethod
    def Deserialize(self, serializationStream: Stream) -> typing.Any: ...
    @abc.abstractmethod
    def Serialize(self, serializationStream: Stream, graph: typing.Any) -> None: ...


class IFormatterConverter(typing.Protocol):
    @abc.abstractmethod
    def ToBoolean(self, value: typing.Any) -> bool: ...
    @abc.abstractmethod
    def ToByte(self, value: typing.Any) -> int: ...
    @abc.abstractmethod
    def ToChar(self, value: typing.Any) -> str: ...
    @abc.abstractmethod
    def ToDateTime(self, value: typing.Any) -> DateTime: ...
    @abc.abstractmethod
    def ToDecimal(self, value: typing.Any) -> Decimal: ...
    @abc.abstractmethod
    def ToDouble(self, value: typing.Any) -> float: ...
    @abc.abstractmethod
    def ToInt16(self, value: typing.Any) -> int: ...
    @abc.abstractmethod
    def ToInt32(self, value: typing.Any) -> int: ...
    @abc.abstractmethod
    def ToInt64(self, value: typing.Any) -> int: ...
    @abc.abstractmethod
    def ToSByte(self, value: typing.Any) -> int: ...
    @abc.abstractmethod
    def ToSingle(self, value: typing.Any) -> float: ...
    @abc.abstractmethod
    def ToString(self, value: typing.Any) -> str: ...
    @abc.abstractmethod
    def ToUInt16(self, value: typing.Any) -> int: ...
    @abc.abstractmethod
    def ToUInt32(self, value: typing.Any) -> int: ...
    @abc.abstractmethod
    def ToUInt64(self, value: typing.Any) -> int: ...
    # Skipped Convert due to it being static, abstract and generic.

    Convert : Convert_MethodGroup
    class Convert_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, typeCode: TypeCode) -> typing.Any:...
        @typing.overload
        def __call__(self, value: typing.Any, type: typing.Type[typing.Any]) -> typing.Any:...



class IgnoreDataMemberAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class InvalidDataContractException(Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class IObjectReference(typing.Protocol):
    @abc.abstractmethod
    def GetRealObject(self, context: StreamingContext) -> typing.Any: ...


class ISafeSerializationData(typing.Protocol):
    @abc.abstractmethod
    def CompleteDeserialization(self, deserialized: typing.Any) -> None: ...


class ISerializable(typing.Protocol):
    @abc.abstractmethod
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...


class ISerializationSurrogate(typing.Protocol):
    @abc.abstractmethod
    def GetObjectData(self, obj: typing.Any, info: SerializationInfo, context: StreamingContext) -> None: ...
    @abc.abstractmethod
    def SetObjectData(self, obj: typing.Any, info: SerializationInfo, context: StreamingContext, selector: ISurrogateSelector) -> typing.Any: ...


class ISerializationSurrogateProvider(typing.Protocol):
    @abc.abstractmethod
    def GetDeserializedObject(self, obj: typing.Any, targetType: typing.Type[typing.Any]) -> typing.Any: ...
    @abc.abstractmethod
    def GetObjectToSerialize(self, obj: typing.Any, targetType: typing.Type[typing.Any]) -> typing.Any: ...
    @abc.abstractmethod
    def GetSurrogateType(self, type: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...


class ISurrogateSelector(typing.Protocol):
    @abc.abstractmethod
    def ChainSelector(self, selector: ISurrogateSelector) -> None: ...
    @abc.abstractmethod
    def GetNextSelector(self) -> ISurrogateSelector: ...
    @abc.abstractmethod
    def GetSurrogate(self, type: typing.Type[typing.Any], context: StreamingContext, selector: clr.Reference[ISurrogateSelector]) -> ISerializationSurrogate: ...


class KnownTypeAttribute(Attribute):
    @typing.overload
    def __init__(self, methodName: str) -> None: ...
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    @property
    def MethodName(self) -> str: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ObjectIDGenerator:
    def __init__(self) -> None: ...
    def GetId(self, obj: typing.Any, firstTime: clr.Reference[bool]) -> int: ...
    def HasId(self, obj: typing.Any, firstTime: clr.Reference[bool]) -> int: ...


class ObjectManager:
    def __init__(self, selector: ISurrogateSelector, context: StreamingContext) -> None: ...
    def DoFixups(self) -> None: ...
    def GetObject(self, objectID: int) -> typing.Any: ...
    def RaiseDeserializationEvent(self) -> None: ...
    def RaiseOnDeserializingEvent(self, obj: typing.Any) -> None: ...
    def RecordDelayedFixup(self, objectToBeFixed: int, memberName: str, objectRequired: int) -> None: ...
    def RecordFixup(self, objectToBeFixed: int, member: MemberInfo, objectRequired: int) -> None: ...
    # Skipped RecordArrayElementFixup due to it being static, abstract and generic.

    RecordArrayElementFixup : RecordArrayElementFixup_MethodGroup
    class RecordArrayElementFixup_MethodGroup:
        @typing.overload
        def __call__(self, arrayToBeFixed: int, index: int, objectRequired: int) -> None:...
        @typing.overload
        def __call__(self, arrayToBeFixed: int, indices: Array_1[int], objectRequired: int) -> None:...

    # Skipped RegisterObject due to it being static, abstract and generic.

    RegisterObject : RegisterObject_MethodGroup
    class RegisterObject_MethodGroup:
        @typing.overload
        def __call__(self, obj: typing.Any, objectID: int) -> None:...
        @typing.overload
        def __call__(self, obj: typing.Any, objectID: int, info: SerializationInfo) -> None:...
        @typing.overload
        def __call__(self, obj: typing.Any, objectID: int, info: SerializationInfo, idOfContainingObj: int, member: MemberInfo) -> None:...
        @typing.overload
        def __call__(self, obj: typing.Any, objectID: int, info: SerializationInfo, idOfContainingObj: int, member: MemberInfo, arrayIndex: Array_1[int]) -> None:...



class OnDeserializedAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class OnDeserializingAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class OnSerializedAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class OnSerializingAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class OptionalFieldAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def VersionAdded(self) -> int: ...
    @VersionAdded.setter
    def VersionAdded(self, value: int) -> int: ...


class SafeSerializationEventArgs(EventArgs):
    @property
    def StreamingContext(self) -> StreamingContext: ...
    def AddSerializedState(self, serializedState: ISafeSerializationData) -> None: ...


class SerializationBinder(abc.ABC):
    def BindToName(self, serializedType: typing.Type[typing.Any], assemblyName: clr.Reference[str], typeName: clr.Reference[str]) -> None: ...
    @abc.abstractmethod
    def BindToType(self, assemblyName: str, typeName: str) -> typing.Type[typing.Any]: ...


class SerializationEntry:
    @property
    def Name(self) -> str: ...
    @property
    def ObjectType(self) -> typing.Type[typing.Any]: ...
    @property
    def Value(self) -> typing.Any: ...


class SerializationEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, context: StreamingContext, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, context: StreamingContext) -> None: ...


class SerializationException(SystemException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class SerializationInfo:
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any], converter: IFormatterConverter) -> None: ...
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any], converter: IFormatterConverter, requireSameTokenInPartialTrust: bool) -> None: ...
    @property
    def AssemblyName(self) -> str: ...
    @AssemblyName.setter
    def AssemblyName(self, value: str) -> str: ...
    @classmethod
    @property
    def DeserializationInProgress(cls) -> bool: ...
    @property
    def FullTypeName(self) -> str: ...
    @FullTypeName.setter
    def FullTypeName(self, value: str) -> str: ...
    @property
    def IsAssemblyNameSetExplicit(self) -> bool: ...
    @IsAssemblyNameSetExplicit.setter
    def IsAssemblyNameSetExplicit(self, value: bool) -> bool: ...
    @property
    def IsFullTypeNameSetExplicit(self) -> bool: ...
    @IsFullTypeNameSetExplicit.setter
    def IsFullTypeNameSetExplicit(self, value: bool) -> bool: ...
    @property
    def MemberCount(self) -> int: ...
    @property
    def ObjectType(self) -> typing.Type[typing.Any]: ...
    def GetBoolean(self, name: str) -> bool: ...
    def GetByte(self, name: str) -> int: ...
    def GetChar(self, name: str) -> str: ...
    def GetDateTime(self, name: str) -> DateTime: ...
    def GetDecimal(self, name: str) -> Decimal: ...
    def GetDouble(self, name: str) -> float: ...
    def GetEnumerator(self) -> SerializationInfoEnumerator: ...
    def GetInt16(self, name: str) -> int: ...
    def GetInt32(self, name: str) -> int: ...
    def GetInt64(self, name: str) -> int: ...
    def GetSByte(self, name: str) -> int: ...
    def GetSingle(self, name: str) -> float: ...
    def GetString(self, name: str) -> str: ...
    def GetUInt16(self, name: str) -> int: ...
    def GetUInt32(self, name: str) -> int: ...
    def GetUInt64(self, name: str) -> int: ...
    def GetValue(self, name: str, type: typing.Type[typing.Any]) -> typing.Any: ...
    def SetType(self, type: typing.Type[typing.Any]) -> None: ...
    @staticmethod
    def StartDeserialization() -> DeserializationToken: ...
    def UpdateValue(self, name: str, value: typing.Any, type: typing.Type[typing.Any]) -> None: ...
    # Skipped AddValue due to it being static, abstract and generic.

    AddValue : AddValue_MethodGroup
    class AddValue_MethodGroup:
        @typing.overload
        def __call__(self, name: str, value: float) -> None:...
        # Method AddValue(name : String, value : Double) was skipped since it collides with above method
        @typing.overload
        def __call__(self, name: str, value: str) -> None:...
        # Method AddValue(name : String, value : SByte) was skipped since it collides with above method
        # Method AddValue(name : String, value : Byte) was skipped since it collides with above method
        # Method AddValue(name : String, value : Int16) was skipped since it collides with above method
        # Method AddValue(name : String, value : UInt16) was skipped since it collides with above method
        # Method AddValue(name : String, value : Int32) was skipped since it collides with above method
        # Method AddValue(name : String, value : UInt32) was skipped since it collides with above method
        # Method AddValue(name : String, value : Int64) was skipped since it collides with above method
        # Method AddValue(name : String, value : UInt64) was skipped since it collides with above method
        @typing.overload
        def __call__(self, name: str, value: Decimal) -> None:...
        @typing.overload
        def __call__(self, name: str, value: DateTime) -> None:...
        # Method AddValue(name : String, value : Boolean) was skipped since it collides with above method
        @typing.overload
        def __call__(self, name: str, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, name: str, value: typing.Any, type: typing.Type[typing.Any]) -> None:...

    # Skipped ThrowIfDeserializationInProgress due to it being static, abstract and generic.

    ThrowIfDeserializationInProgress : ThrowIfDeserializationInProgress_MethodGroup
    class ThrowIfDeserializationInProgress_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, switchSuffix: str, cachedValue: clr.Reference[int]) -> None:...



class SerializationInfoEnumerator(IEnumerator):
    @property
    def Current(self) -> SerializationEntry: ...
    @property
    def Name(self) -> str: ...
    @property
    def ObjectType(self) -> typing.Type[typing.Any]: ...
    @property
    def Value(self) -> typing.Any: ...
    def MoveNext(self) -> bool: ...
    def Reset(self) -> None: ...


class SerializationObjectManager:
    def __init__(self, context: StreamingContext) -> None: ...
    def RaiseOnSerializedEvent(self) -> None: ...
    def RegisterObject(self, obj: typing.Any) -> None: ...


class StreamingContext:
    @typing.overload
    def __init__(self, state: StreamingContextStates) -> None: ...
    @typing.overload
    def __init__(self, state: StreamingContextStates, additional: typing.Any) -> None: ...
    @property
    def Context(self) -> typing.Any: ...
    @property
    def State(self) -> StreamingContextStates: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class StreamingContextStates(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    CrossProcess : StreamingContextStates # 1
    CrossMachine : StreamingContextStates # 2
    File : StreamingContextStates # 4
    Persistence : StreamingContextStates # 8
    Remoting : StreamingContextStates # 16
    Other : StreamingContextStates # 32
    Clone : StreamingContextStates # 64
    CrossAppDomain : StreamingContextStates # 128
    All : StreamingContextStates # 255


class SurrogateSelector(ISurrogateSelector):
    def __init__(self) -> None: ...
    def AddSurrogate(self, type: typing.Type[typing.Any], context: StreamingContext, surrogate: ISerializationSurrogate) -> None: ...
    def ChainSelector(self, selector: ISurrogateSelector) -> None: ...
    def GetNextSelector(self) -> ISurrogateSelector: ...
    def GetSurrogate(self, type: typing.Type[typing.Any], context: StreamingContext, selector: clr.Reference[ISurrogateSelector]) -> ISerializationSurrogate: ...
    def RemoveSurrogate(self, type: typing.Type[typing.Any], context: StreamingContext) -> None: ...


class TypeLoadExceptionHolder:
    pass

