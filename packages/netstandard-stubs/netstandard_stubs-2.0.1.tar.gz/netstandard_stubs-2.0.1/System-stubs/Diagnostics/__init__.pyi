import typing, clr, abc
from System import IDisposable, TimeSpan, DateTime, Func_1, IEquatable_1, DateTimeOffset, Action_1, Func_2, Span_1, ReadOnlySpan_1, Array_1, Attribute, Guid, EventArgs, MulticastDelegate, IAsyncResult, AsyncCallback, Exception, MarshalByRefObject
from System.Collections.Generic import IEnumerable_1, KeyValuePair_2, IDictionary_2, ICollection_1, IEnumerator_1, IReadOnlyCollection_1
from System.Collections.Specialized import StringDictionary
from System.IO import TextWriter, Stream, StreamReader, StreamWriter
from System.Collections import Stack, ReadOnlyCollectionBase, IList, IEnumerator
from System.Reflection import MethodInfo, MethodBase, Assembly
from System.ComponentModel import DescriptionAttribute, Component, IContainer, ISite, ISynchronizeInvoke
from Microsoft.Win32.SafeHandles import SafeProcessHandle
from System.Threading.Tasks import Task
from System.Threading import CancellationToken
from System.Security import SecureString
from System.Collections.ObjectModel import Collection_1
from System.Text import Encoding

class Activity(IDisposable):
    def __init__(self, operationName: str) -> None: ...
    @property
    def ActivityTraceFlags(self) -> ActivityTraceFlags: ...
    @ActivityTraceFlags.setter
    def ActivityTraceFlags(self, value: ActivityTraceFlags) -> ActivityTraceFlags: ...
    @property
    def Baggage(self) -> IEnumerable_1[KeyValuePair_2[str, str]]: ...
    @property
    def Context(self) -> ActivityContext: ...
    @classmethod
    @property
    def Current(cls) -> Activity: ...
    @classmethod
    @Current.setter
    def Current(cls, value: Activity) -> Activity: ...
    @classmethod
    @property
    def DefaultIdFormat(cls) -> ActivityIdFormat: ...
    @classmethod
    @DefaultIdFormat.setter
    def DefaultIdFormat(cls, value: ActivityIdFormat) -> ActivityIdFormat: ...
    @property
    def DisplayName(self) -> str: ...
    @DisplayName.setter
    def DisplayName(self, value: str) -> str: ...
    @property
    def Duration(self) -> TimeSpan: ...
    @Duration.setter
    def Duration(self, value: TimeSpan) -> TimeSpan: ...
    @property
    def Events(self) -> IEnumerable_1[ActivityEvent]: ...
    @classmethod
    @property
    def ForceDefaultIdFormat(cls) -> bool: ...
    @classmethod
    @ForceDefaultIdFormat.setter
    def ForceDefaultIdFormat(cls, value: bool) -> bool: ...
    @property
    def Id(self) -> str: ...
    @property
    def IdFormat(self) -> ActivityIdFormat: ...
    @IdFormat.setter
    def IdFormat(self, value: ActivityIdFormat) -> ActivityIdFormat: ...
    @property
    def IsAllDataRequested(self) -> bool: ...
    @IsAllDataRequested.setter
    def IsAllDataRequested(self, value: bool) -> bool: ...
    @property
    def Kind(self) -> ActivityKind: ...
    @Kind.setter
    def Kind(self, value: ActivityKind) -> ActivityKind: ...
    @property
    def Links(self) -> IEnumerable_1[ActivityLink]: ...
    @property
    def OperationName(self) -> str: ...
    @property
    def Parent(self) -> Activity: ...
    @Parent.setter
    def Parent(self, value: Activity) -> Activity: ...
    @property
    def ParentId(self) -> str: ...
    @property
    def ParentSpanId(self) -> ActivitySpanId: ...
    @property
    def Recorded(self) -> bool: ...
    @property
    def RootId(self) -> str: ...
    @property
    def Source(self) -> ActivitySource: ...
    @Source.setter
    def Source(self, value: ActivitySource) -> ActivitySource: ...
    @property
    def SpanId(self) -> ActivitySpanId: ...
    @property
    def StartTimeUtc(self) -> DateTime: ...
    @StartTimeUtc.setter
    def StartTimeUtc(self, value: DateTime) -> DateTime: ...
    @property
    def Status(self) -> ActivityStatusCode: ...
    @property
    def StatusDescription(self) -> str: ...
    @property
    def TagObjects(self) -> IEnumerable_1[KeyValuePair_2[str, typing.Any]]: ...
    @property
    def Tags(self) -> IEnumerable_1[KeyValuePair_2[str, str]]: ...
    @property
    def TraceId(self) -> ActivityTraceId: ...
    @classmethod
    @property
    def TraceIdGenerator(cls) -> Func_1[ActivityTraceId]: ...
    @classmethod
    @TraceIdGenerator.setter
    def TraceIdGenerator(cls, value: Func_1[ActivityTraceId]) -> Func_1[ActivityTraceId]: ...
    @property
    def TraceStateString(self) -> str: ...
    @TraceStateString.setter
    def TraceStateString(self, value: str) -> str: ...
    def AddBaggage(self, key: str, value: str) -> Activity: ...
    def AddEvent(self, e: ActivityEvent) -> Activity: ...
    def Dispose(self) -> None: ...
    def GetBaggageItem(self, key: str) -> str: ...
    def GetCustomProperty(self, propertyName: str) -> typing.Any: ...
    def GetTagItem(self, key: str) -> typing.Any: ...
    def SetBaggage(self, key: str, value: str) -> Activity: ...
    def SetCustomProperty(self, propertyName: str, propertyValue: typing.Any) -> None: ...
    def SetEndTime(self, endTimeUtc: DateTime) -> Activity: ...
    def SetIdFormat(self, format: ActivityIdFormat) -> Activity: ...
    def SetStartTime(self, startTimeUtc: DateTime) -> Activity: ...
    def SetStatus(self, code: ActivityStatusCode, description: str = ...) -> Activity: ...
    def SetTag(self, key: str, value: typing.Any) -> Activity: ...
    def Start(self) -> Activity: ...
    def Stop(self) -> None: ...
    # Skipped AddTag due to it being static, abstract and generic.

    AddTag : AddTag_MethodGroup
    class AddTag_MethodGroup:
        @typing.overload
        def __call__(self, key: str, value: str) -> Activity:...
        @typing.overload
        def __call__(self, key: str, value: typing.Any) -> Activity:...

    # Skipped SetParentId due to it being static, abstract and generic.

    SetParentId : SetParentId_MethodGroup
    class SetParentId_MethodGroup:
        @typing.overload
        def __call__(self, parentId: str) -> Activity:...
        @typing.overload
        def __call__(self, traceId: ActivityTraceId, spanId: ActivitySpanId, activityTraceFlags: ActivityTraceFlags = ...) -> Activity:...



class ActivityContext(IEquatable_1[ActivityContext]):
    def __init__(self, traceId: ActivityTraceId, spanId: ActivitySpanId, traceFlags: ActivityTraceFlags, traceState: str = ..., isRemote: bool = ...) -> None: ...
    @property
    def IsRemote(self) -> bool: ...
    @property
    def SpanId(self) -> ActivitySpanId: ...
    @property
    def TraceFlags(self) -> ActivityTraceFlags: ...
    @property
    def TraceId(self) -> ActivityTraceId: ...
    @property
    def TraceState(self) -> str: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: ActivityContext, right: ActivityContext) -> bool: ...
    def __ne__(self, left: ActivityContext, right: ActivityContext) -> bool: ...
    @staticmethod
    def Parse(traceParent: str, traceState: str) -> ActivityContext: ...
    @staticmethod
    def TryParse(traceParent: str, traceState: str, context: clr.Reference[ActivityContext]) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: ActivityContext) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class ActivityCreationOptions_GenericClasses(abc.ABCMeta):
    Generic_ActivityCreationOptions_GenericClasses_ActivityCreationOptions_1_T = typing.TypeVar('Generic_ActivityCreationOptions_GenericClasses_ActivityCreationOptions_1_T')
    def __getitem__(self, types : typing.Type[Generic_ActivityCreationOptions_GenericClasses_ActivityCreationOptions_1_T]) -> typing.Type[ActivityCreationOptions_1[Generic_ActivityCreationOptions_GenericClasses_ActivityCreationOptions_1_T]]: ...

ActivityCreationOptions : ActivityCreationOptions_GenericClasses

ActivityCreationOptions_1_T = typing.TypeVar('ActivityCreationOptions_1_T')
class ActivityCreationOptions_1(typing.Generic[ActivityCreationOptions_1_T]):
    @property
    def Kind(self) -> ActivityKind: ...
    @property
    def Links(self) -> IEnumerable_1[ActivityLink]: ...
    @property
    def Name(self) -> str: ...
    @property
    def Parent(self) -> ActivityCreationOptions_1_T: ...
    @property
    def SamplingTags(self) -> ActivityTagsCollection: ...
    @property
    def Source(self) -> ActivitySource: ...
    @property
    def Tags(self) -> IEnumerable_1[KeyValuePair_2[str, typing.Any]]: ...
    @property
    def TraceId(self) -> ActivityTraceId: ...


class ActivityEvent:
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, timestamp: DateTimeOffset = ..., tags: ActivityTagsCollection = ...) -> None: ...
    @property
    def Name(self) -> str: ...
    @property
    def Tags(self) -> IEnumerable_1[KeyValuePair_2[str, typing.Any]]: ...
    @property
    def Timestamp(self) -> DateTimeOffset: ...


class ActivityIdFormat(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : ActivityIdFormat # 0
    Hierarchical : ActivityIdFormat # 1
    W3C : ActivityIdFormat # 2


class ActivityKind(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Internal : ActivityKind # 0
    Server : ActivityKind # 1
    Client : ActivityKind # 2
    Producer : ActivityKind # 3
    Consumer : ActivityKind # 4


class ActivityLink(IEquatable_1[ActivityLink]):
    def __init__(self, context: ActivityContext, tags: ActivityTagsCollection = ...) -> None: ...
    @property
    def Context(self) -> ActivityContext: ...
    @property
    def Tags(self) -> IEnumerable_1[KeyValuePair_2[str, typing.Any]]: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: ActivityLink, right: ActivityLink) -> bool: ...
    def __ne__(self, left: ActivityLink, right: ActivityLink) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, value: ActivityLink) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class ActivityListener(IDisposable):
    def __init__(self) -> None: ...
    @property
    def ActivityStarted(self) -> Action_1[Activity]: ...
    @ActivityStarted.setter
    def ActivityStarted(self, value: Action_1[Activity]) -> Action_1[Activity]: ...
    @property
    def ActivityStopped(self) -> Action_1[Activity]: ...
    @ActivityStopped.setter
    def ActivityStopped(self, value: Action_1[Activity]) -> Action_1[Activity]: ...
    @property
    def Sample(self) -> SampleActivity_1[ActivityContext]: ...
    @Sample.setter
    def Sample(self, value: SampleActivity_1[ActivityContext]) -> SampleActivity_1[ActivityContext]: ...
    @property
    def SampleUsingParentId(self) -> SampleActivity_1[str]: ...
    @SampleUsingParentId.setter
    def SampleUsingParentId(self, value: SampleActivity_1[str]) -> SampleActivity_1[str]: ...
    @property
    def ShouldListenTo(self) -> Func_2[ActivitySource, bool]: ...
    @ShouldListenTo.setter
    def ShouldListenTo(self, value: Func_2[ActivitySource, bool]) -> Func_2[ActivitySource, bool]: ...
    def Dispose(self) -> None: ...


class ActivitySamplingResult(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ActivitySamplingResult # 0
    PropagationData : ActivitySamplingResult # 1
    AllData : ActivitySamplingResult # 2
    AllDataAndRecorded : ActivitySamplingResult # 3


class ActivitySource(IDisposable):
    def __init__(self, name: str, version: str = ...) -> None: ...
    @property
    def Name(self) -> str: ...
    @property
    def Version(self) -> str: ...
    @staticmethod
    def AddActivityListener(listener: ActivityListener) -> None: ...
    def Dispose(self) -> None: ...
    def HasListeners(self) -> bool: ...
    # Skipped CreateActivity due to it being static, abstract and generic.

    CreateActivity : CreateActivity_MethodGroup
    class CreateActivity_MethodGroup:
        @typing.overload
        def __call__(self, name: str, kind: ActivityKind) -> Activity:...
        @typing.overload
        def __call__(self, name: str, kind: ActivityKind, parentContext: ActivityContext, tags: IEnumerable_1[KeyValuePair_2[str, typing.Any]] = ..., links: IEnumerable_1[ActivityLink] = ..., idFormat: ActivityIdFormat = ...) -> Activity:...
        @typing.overload
        def __call__(self, name: str, kind: ActivityKind, parentId: str, tags: IEnumerable_1[KeyValuePair_2[str, typing.Any]] = ..., links: IEnumerable_1[ActivityLink] = ..., idFormat: ActivityIdFormat = ...) -> Activity:...

    # Skipped StartActivity due to it being static, abstract and generic.

    StartActivity : StartActivity_MethodGroup
    class StartActivity_MethodGroup:
        @typing.overload
        def __call__(self, name: str = ..., kind: ActivityKind = ...) -> Activity:...
        @typing.overload
        def __call__(self, kind: ActivityKind, parentContext: ActivityContext = ..., tags: IEnumerable_1[KeyValuePair_2[str, typing.Any]] = ..., links: IEnumerable_1[ActivityLink] = ..., startTime: DateTimeOffset = ..., name: str = ...) -> Activity:...
        @typing.overload
        def __call__(self, name: str, kind: ActivityKind, parentContext: ActivityContext, tags: IEnumerable_1[KeyValuePair_2[str, typing.Any]] = ..., links: IEnumerable_1[ActivityLink] = ..., startTime: DateTimeOffset = ...) -> Activity:...
        @typing.overload
        def __call__(self, name: str, kind: ActivityKind, parentId: str, tags: IEnumerable_1[KeyValuePair_2[str, typing.Any]] = ..., links: IEnumerable_1[ActivityLink] = ..., startTime: DateTimeOffset = ...) -> Activity:...



class ActivitySpanId(IEquatable_1[ActivitySpanId]):
    def CopyTo(self, destination: Span_1[int]) -> None: ...
    @staticmethod
    def CreateFromBytes(idData: ReadOnlySpan_1[int]) -> ActivitySpanId: ...
    @staticmethod
    def CreateFromString(idData: ReadOnlySpan_1[str]) -> ActivitySpanId: ...
    @staticmethod
    def CreateFromUtf8String(idData: ReadOnlySpan_1[int]) -> ActivitySpanId: ...
    @staticmethod
    def CreateRandom() -> ActivitySpanId: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, spanId1: ActivitySpanId, spandId2: ActivitySpanId) -> bool: ...
    def __ne__(self, spanId1: ActivitySpanId, spandId2: ActivitySpanId) -> bool: ...
    def ToHexString(self) -> str: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, spanId: ActivitySpanId) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class ActivityStatusCode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unset : ActivityStatusCode # 0
    Ok : ActivityStatusCode # 1
    Error : ActivityStatusCode # 2


class ActivityTagsCollection(IDictionary_2[str, typing.Any]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, list: IEnumerable_1[KeyValuePair_2[str, typing.Any]]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Keys(self) -> ICollection_1[str]: ...
    @property
    def Values(self) -> ICollection_1[typing.Any]: ...
    def Clear(self) -> None: ...
    def Contains(self, item: KeyValuePair_2[str, typing.Any]) -> bool: ...
    def ContainsKey(self, key: str) -> bool: ...
    def CopyTo(self, array: Array_1[KeyValuePair_2[str, typing.Any]], arrayIndex: int) -> None: ...
    def GetEnumerator(self) -> ActivityTagsCollection.Enumerator: ...
    def TryGetValue(self, key: str, value: clr.Reference[typing.Any]) -> bool: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, item: KeyValuePair_2[str, typing.Any]) -> None:...
        @typing.overload
        def __call__(self, key: str, value: typing.Any) -> None:...

    # Skipped Remove due to it being static, abstract and generic.

    Remove : Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, item: KeyValuePair_2[str, typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, key: str) -> bool:...


    class Enumerator(IEnumerator_1[KeyValuePair_2[str, typing.Any]]):
        @property
        def Current(self) -> KeyValuePair_2[str, typing.Any]: ...
        def Dispose(self) -> None: ...
        def MoveNext(self) -> bool: ...



class ActivityTraceFlags(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : ActivityTraceFlags # 0
    Recorded : ActivityTraceFlags # 1


class ActivityTraceId(IEquatable_1[ActivityTraceId]):
    def CopyTo(self, destination: Span_1[int]) -> None: ...
    @staticmethod
    def CreateFromBytes(idData: ReadOnlySpan_1[int]) -> ActivityTraceId: ...
    @staticmethod
    def CreateFromString(idData: ReadOnlySpan_1[str]) -> ActivityTraceId: ...
    @staticmethod
    def CreateFromUtf8String(idData: ReadOnlySpan_1[int]) -> ActivityTraceId: ...
    @staticmethod
    def CreateRandom() -> ActivityTraceId: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, traceId1: ActivityTraceId, traceId2: ActivityTraceId) -> bool: ...
    def __ne__(self, traceId1: ActivityTraceId, traceId2: ActivityTraceId) -> bool: ...
    def ToHexString(self) -> str: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, traceId: ActivityTraceId) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class BooleanSwitch(Switch):
    @typing.overload
    def __init__(self, displayName: str, description: str) -> None: ...
    @typing.overload
    def __init__(self, displayName: str, description: str, defaultSwitchValue: str) -> None: ...
    @property
    def Attributes(self) -> StringDictionary: ...
    @property
    def Description(self) -> str: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def Enabled(self) -> bool: ...
    @Enabled.setter
    def Enabled(self, value: bool) -> bool: ...


class ConditionalAttribute(Attribute):
    def __init__(self, conditionString: str) -> None: ...
    @property
    def ConditionString(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class ConsoleTraceListener(TextWriterTraceListener):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, useErrorStream: bool) -> None: ...
    @property
    def Attributes(self) -> StringDictionary: ...
    @property
    def Filter(self) -> TraceFilter: ...
    @Filter.setter
    def Filter(self, value: TraceFilter) -> TraceFilter: ...
    @property
    def IndentLevel(self) -> int: ...
    @IndentLevel.setter
    def IndentLevel(self, value: int) -> int: ...
    @property
    def IndentSize(self) -> int: ...
    @IndentSize.setter
    def IndentSize(self, value: int) -> int: ...
    @property
    def IsThreadSafe(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def TraceOutputOptions(self) -> TraceOptions: ...
    @TraceOutputOptions.setter
    def TraceOutputOptions(self, value: TraceOptions) -> TraceOptions: ...
    @property
    def Writer(self) -> TextWriter: ...
    @Writer.setter
    def Writer(self, value: TextWriter) -> TextWriter: ...
    def Close(self) -> None: ...


class CorrelationManager:
    @property
    def ActivityId(self) -> Guid: ...
    @ActivityId.setter
    def ActivityId(self, value: Guid) -> Guid: ...
    @property
    def LogicalOperationStack(self) -> Stack: ...
    def StopLogicalOperation(self) -> None: ...
    # Skipped StartLogicalOperation due to it being static, abstract and generic.

    StartLogicalOperation : StartLogicalOperation_MethodGroup
    class StartLogicalOperation_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, operationId: typing.Any) -> None:...



class DataReceivedEventArgs(EventArgs):
    @property
    def Data(self) -> str: ...


class DataReceivedEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: DataReceivedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: DataReceivedEventArgs) -> None: ...


class Debug(abc.ABC):
    @classmethod
    @property
    def AutoFlush(cls) -> bool: ...
    @classmethod
    @AutoFlush.setter
    def AutoFlush(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def IndentLevel(cls) -> int: ...
    @classmethod
    @IndentLevel.setter
    def IndentLevel(cls, value: int) -> int: ...
    @classmethod
    @property
    def IndentSize(cls) -> int: ...
    @classmethod
    @IndentSize.setter
    def IndentSize(cls, value: int) -> int: ...
    @staticmethod
    def Close() -> None: ...
    @staticmethod
    def Flush() -> None: ...
    @staticmethod
    def Indent() -> None: ...
    @staticmethod
    def SetProvider(provider: DebugProvider) -> DebugProvider: ...
    @staticmethod
    def Unindent() -> None: ...
    # Skipped Assert due to it being static, abstract and generic.

    Assert : Assert_MethodGroup
    class Assert_MethodGroup:
        @typing.overload
        def __call__(self, condition: bool) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: clr.Reference[Debug.AssertInterpolatedStringHandler]) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str, detailMessage: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: clr.Reference[Debug.AssertInterpolatedStringHandler], detailMessage: clr.Reference[Debug.AssertInterpolatedStringHandler]) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str, detailMessageFormat: str, args: Array_1[typing.Any]) -> None:...

    # Skipped Fail due to it being static, abstract and generic.

    Fail : Fail_MethodGroup
    class Fail_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, message: str, detailMessage: str) -> None:...

    # Skipped Print due to it being static, abstract and generic.

    Print : Print_MethodGroup
    class Print_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any, category: str) -> None:...

    # Skipped WriteIf due to it being static, abstract and generic.

    WriteIf : WriteIf_MethodGroup
    class WriteIf_MethodGroup:
        @typing.overload
        def __call__(self, condition: bool, message: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: clr.Reference[Debug.WriteIfInterpolatedStringHandler]) -> None:...
        @typing.overload
        def __call__(self, condition: bool, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: clr.Reference[Debug.WriteIfInterpolatedStringHandler], category: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, value: typing.Any, category: str) -> None:...

    # Skipped WriteLine due to it being static, abstract and generic.

    WriteLine : WriteLine_MethodGroup
    class WriteLine_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any, category: str) -> None:...

    # Skipped WriteLineIf due to it being static, abstract and generic.

    WriteLineIf : WriteLineIf_MethodGroup
    class WriteLineIf_MethodGroup:
        @typing.overload
        def __call__(self, condition: bool, message: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: clr.Reference[Debug.WriteIfInterpolatedStringHandler]) -> None:...
        @typing.overload
        def __call__(self, condition: bool, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: clr.Reference[Debug.WriteIfInterpolatedStringHandler], category: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, value: typing.Any, category: str) -> None:...


    class AssertInterpolatedStringHandler:
        def __init__(self, literalLength: int, formattedCount: int, condition: bool, shouldAppend: clr.Reference[bool]) -> None: ...
        def AppendLiteral(self, value: str) -> None: ...
        # Skipped AppendFormatted due to it being static, abstract and generic.

        AppendFormatted : AppendFormatted_MethodGroup
        class AppendFormatted_MethodGroup:
            def __getitem__(self, t:typing.Type[AppendFormatted_1_T1]) -> AppendFormatted_1[AppendFormatted_1_T1]: ...

            AppendFormatted_1_T1 = typing.TypeVar('AppendFormatted_1_T1')
            class AppendFormatted_1(typing.Generic[AppendFormatted_1_T1]):
                AppendFormatted_1_T = Debug.AssertInterpolatedStringHandler.AppendFormatted_MethodGroup.AppendFormatted_1_T1
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T) -> None:...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, alignment: int) -> None:...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, format: str) -> None:...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, alignment: int, format: str) -> None:...

            @typing.overload
            def __call__(self, value: ReadOnlySpan_1[str]) -> None:...
            @typing.overload
            def __call__(self, value: str) -> None:...
            @typing.overload
            def __call__(self, value: ReadOnlySpan_1[str], alignment: int = ..., format: str = ...) -> None:...
            @typing.overload
            def __call__(self, value: str, alignment: int = ..., format: str = ...) -> None:...
            @typing.overload
            def __call__(self, value: typing.Any, alignment: int = ..., format: str = ...) -> None:...



    class WriteIfInterpolatedStringHandler:
        def __init__(self, literalLength: int, formattedCount: int, condition: bool, shouldAppend: clr.Reference[bool]) -> None: ...
        def AppendLiteral(self, value: str) -> None: ...
        # Skipped AppendFormatted due to it being static, abstract and generic.

        AppendFormatted : AppendFormatted_MethodGroup
        class AppendFormatted_MethodGroup:
            def __getitem__(self, t:typing.Type[AppendFormatted_1_T1]) -> AppendFormatted_1[AppendFormatted_1_T1]: ...

            AppendFormatted_1_T1 = typing.TypeVar('AppendFormatted_1_T1')
            class AppendFormatted_1(typing.Generic[AppendFormatted_1_T1]):
                AppendFormatted_1_T = Debug.WriteIfInterpolatedStringHandler.AppendFormatted_MethodGroup.AppendFormatted_1_T1
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T) -> None:...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, alignment: int) -> None:...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, format: str) -> None:...
                @typing.overload
                def __call__(self, value: AppendFormatted_1_T, alignment: int, format: str) -> None:...

            @typing.overload
            def __call__(self, value: ReadOnlySpan_1[str]) -> None:...
            @typing.overload
            def __call__(self, value: str) -> None:...
            @typing.overload
            def __call__(self, value: ReadOnlySpan_1[str], alignment: int = ..., format: str = ...) -> None:...
            @typing.overload
            def __call__(self, value: str, alignment: int = ..., format: str = ...) -> None:...
            @typing.overload
            def __call__(self, value: typing.Any, alignment: int = ..., format: str = ...) -> None:...




class DebuggableAttribute(Attribute):
    @typing.overload
    def __init__(self, isJITTrackingEnabled: bool, isJITOptimizerDisabled: bool) -> None: ...
    @typing.overload
    def __init__(self, modes: DebuggableAttribute.DebuggingModes) -> None: ...
    @property
    def DebuggingFlags(self) -> DebuggableAttribute.DebuggingModes: ...
    @property
    def IsJITOptimizerDisabled(self) -> bool: ...
    @property
    def IsJITTrackingEnabled(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...

    class DebuggingModes(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : DebuggableAttribute.DebuggingModes # 0
        Default : DebuggableAttribute.DebuggingModes # 1
        IgnoreSymbolStoreSequencePoints : DebuggableAttribute.DebuggingModes # 2
        EnableEditAndContinue : DebuggableAttribute.DebuggingModes # 4
        DisableOptimizations : DebuggableAttribute.DebuggingModes # 256



class Debugger(abc.ABC):
    DefaultCategory : str
    @classmethod
    @property
    def IsAttached(cls) -> bool: ...
    @staticmethod
    def Break() -> None: ...
    @staticmethod
    def IsLogging() -> bool: ...
    @staticmethod
    def Launch() -> bool: ...
    @staticmethod
    def Log(level: int, category: str, message: str) -> None: ...
    @staticmethod
    def NotifyOfCrossThreadDependency() -> None: ...


class DebuggerBrowsableAttribute(Attribute):
    def __init__(self, state: DebuggerBrowsableState) -> None: ...
    @property
    def State(self) -> DebuggerBrowsableState: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DebuggerBrowsableState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Never : DebuggerBrowsableState # 0
    Collapsed : DebuggerBrowsableState # 2
    RootHidden : DebuggerBrowsableState # 3


class DebuggerDisplayAttribute(Attribute):
    def __init__(self, value: str) -> None: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def Target(self) -> typing.Type[typing.Any]: ...
    @Target.setter
    def Target(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def TargetTypeName(self) -> str: ...
    @TargetTypeName.setter
    def TargetTypeName(self, value: str) -> str: ...
    @property
    def Type(self) -> str: ...
    @Type.setter
    def Type(self, value: str) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def Value(self) -> str: ...


class DebuggerHiddenAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DebuggerNonUserCodeAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DebuggerStepperBoundaryAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DebuggerStepThroughAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DebuggerTypeProxyAttribute(Attribute):
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, typeName: str) -> None: ...
    @property
    def ProxyTypeName(self) -> str: ...
    @property
    def Target(self) -> typing.Type[typing.Any]: ...
    @Target.setter
    def Target(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def TargetTypeName(self) -> str: ...
    @TargetTypeName.setter
    def TargetTypeName(self, value: str) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class DebuggerVisualizerAttribute(Attribute):
    @typing.overload
    def __init__(self, visualizer: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, visualizer: typing.Type[typing.Any], visualizerObjectSource: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, visualizer: typing.Type[typing.Any], visualizerObjectSourceTypeName: str) -> None: ...
    @typing.overload
    def __init__(self, visualizerTypeName: str) -> None: ...
    @typing.overload
    def __init__(self, visualizerTypeName: str, visualizerObjectSource: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, visualizerTypeName: str, visualizerObjectSourceTypeName: str) -> None: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Target(self) -> typing.Type[typing.Any]: ...
    @Target.setter
    def Target(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def TargetTypeName(self) -> str: ...
    @TargetTypeName.setter
    def TargetTypeName(self, value: str) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def VisualizerObjectSourceTypeName(self) -> str: ...
    @property
    def VisualizerTypeName(self) -> str: ...


class DebugProvider:
    def __init__(self) -> None: ...
    def Fail(self, message: str, detailMessage: str) -> None: ...
    @staticmethod
    def FailCore(stackTrace: str, message: str, detailMessage: str, errorSource: str) -> None: ...
    def OnIndentLevelChanged(self, indentLevel: int) -> None: ...
    def OnIndentSizeChanged(self, indentSize: int) -> None: ...
    def Write(self, message: str) -> None: ...
    @staticmethod
    def WriteCore(message: str) -> None: ...
    def WriteLine(self, message: str) -> None: ...


class DefaultTraceListener(TraceListener):
    def __init__(self) -> None: ...
    @property
    def AssertUiEnabled(self) -> bool: ...
    @AssertUiEnabled.setter
    def AssertUiEnabled(self, value: bool) -> bool: ...
    @property
    def Attributes(self) -> StringDictionary: ...
    @property
    def Filter(self) -> TraceFilter: ...
    @Filter.setter
    def Filter(self, value: TraceFilter) -> TraceFilter: ...
    @property
    def IndentLevel(self) -> int: ...
    @IndentLevel.setter
    def IndentLevel(self, value: int) -> int: ...
    @property
    def IndentSize(self) -> int: ...
    @IndentSize.setter
    def IndentSize(self, value: int) -> int: ...
    @property
    def IsThreadSafe(self) -> bool: ...
    @property
    def LogFileName(self) -> str: ...
    @LogFileName.setter
    def LogFileName(self, value: str) -> str: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def TraceOutputOptions(self) -> TraceOptions: ...
    @TraceOutputOptions.setter
    def TraceOutputOptions(self, value: TraceOptions) -> TraceOptions: ...
    # Skipped Fail due to it being static, abstract and generic.

    Fail : Fail_MethodGroup
    class Fail_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, message: str, detailMessage: str) -> None:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any, category: str) -> None:...

    # Skipped WriteLine due to it being static, abstract and generic.

    WriteLine : WriteLine_MethodGroup
    class WriteLine_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any, category: str) -> None:...



class DelimitedListTraceListener(TextWriterTraceListener):
    @typing.overload
    def __init__(self, fileName: str) -> None: ...
    @typing.overload
    def __init__(self, fileName: str, name: str) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, name: str) -> None: ...
    @typing.overload
    def __init__(self, writer: TextWriter) -> None: ...
    @typing.overload
    def __init__(self, writer: TextWriter, name: str) -> None: ...
    @property
    def Attributes(self) -> StringDictionary: ...
    @property
    def Delimiter(self) -> str: ...
    @Delimiter.setter
    def Delimiter(self, value: str) -> str: ...
    @property
    def Filter(self) -> TraceFilter: ...
    @Filter.setter
    def Filter(self, value: TraceFilter) -> TraceFilter: ...
    @property
    def IndentLevel(self) -> int: ...
    @IndentLevel.setter
    def IndentLevel(self, value: int) -> int: ...
    @property
    def IndentSize(self) -> int: ...
    @IndentSize.setter
    def IndentSize(self, value: int) -> int: ...
    @property
    def IsThreadSafe(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def TraceOutputOptions(self) -> TraceOptions: ...
    @TraceOutputOptions.setter
    def TraceOutputOptions(self, value: TraceOptions) -> TraceOptions: ...
    @property
    def Writer(self) -> TextWriter: ...
    @Writer.setter
    def Writer(self, value: TextWriter) -> TextWriter: ...
    # Skipped TraceData due to it being static, abstract and generic.

    TraceData : TraceData_MethodGroup
    class TraceData_MethodGroup:
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int, data: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int, data: typing.Any) -> None:...

    # Skipped TraceEvent due to it being static, abstract and generic.

    TraceEvent : TraceEvent_MethodGroup
    class TraceEvent_MethodGroup:
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int) -> None:...
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int, message: str) -> None:...
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int, format: str, args: Array_1[typing.Any]) -> None:...



class DistributedContextPropagator(abc.ABC):
    @classmethod
    @property
    def Current(cls) -> DistributedContextPropagator: ...
    @classmethod
    @Current.setter
    def Current(cls, value: DistributedContextPropagator) -> DistributedContextPropagator: ...
    @property
    def Fields(self) -> IReadOnlyCollection_1[str]: ...
    @staticmethod
    def CreateDefaultPropagator() -> DistributedContextPropagator: ...
    @staticmethod
    def CreateNoOutputPropagator() -> DistributedContextPropagator: ...
    @staticmethod
    def CreatePassThroughPropagator() -> DistributedContextPropagator: ...
    @abc.abstractmethod
    def ExtractBaggage(self, carrier: typing.Any, getter: DistributedContextPropagator.PropagatorGetterCallback) -> IEnumerable_1[KeyValuePair_2[str, str]]: ...
    @abc.abstractmethod
    def ExtractTraceIdAndState(self, carrier: typing.Any, getter: DistributedContextPropagator.PropagatorGetterCallback, traceId: clr.Reference[str], traceState: clr.Reference[str]) -> None: ...
    @abc.abstractmethod
    def Inject(self, activity: Activity, carrier: typing.Any, setter: DistributedContextPropagator.PropagatorSetterCallback) -> None: ...

    class PropagatorGetterCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, carrier: typing.Any, fieldName: str, fieldValue: clr.Reference[str], fieldValues: clr.Reference[IEnumerable_1[str]], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, fieldValue: clr.Reference[str], fieldValues: clr.Reference[IEnumerable_1[str]], result: IAsyncResult) -> None: ...
        def Invoke(self, carrier: typing.Any, fieldName: str, fieldValue: clr.Reference[str], fieldValues: clr.Reference[IEnumerable_1[str]]) -> None: ...


    class PropagatorSetterCallback(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, carrier: typing.Any, fieldName: str, fieldValue: str, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> None: ...
        def Invoke(self, carrier: typing.Any, fieldName: str, fieldValue: str) -> None: ...



class EventTypeFilter(TraceFilter):
    def __init__(self, level: SourceLevels) -> None: ...
    @property
    def EventType(self) -> SourceLevels: ...
    @EventType.setter
    def EventType(self, value: SourceLevels) -> SourceLevels: ...
    def ShouldTrace(self, cache: TraceEventCache, source: str, eventType: TraceEventType, id: int, formatOrMessage: str, args: Array_1[typing.Any], data1: typing.Any, data: Array_1[typing.Any]) -> bool: ...


class FileVersionInfo:
    @property
    def Comments(self) -> str: ...
    @property
    def CompanyName(self) -> str: ...
    @property
    def FileBuildPart(self) -> int: ...
    @property
    def FileDescription(self) -> str: ...
    @property
    def FileMajorPart(self) -> int: ...
    @property
    def FileMinorPart(self) -> int: ...
    @property
    def FileName(self) -> str: ...
    @property
    def FilePrivatePart(self) -> int: ...
    @property
    def FileVersion(self) -> str: ...
    @property
    def InternalName(self) -> str: ...
    @property
    def IsDebug(self) -> bool: ...
    @property
    def IsPatched(self) -> bool: ...
    @property
    def IsPreRelease(self) -> bool: ...
    @property
    def IsPrivateBuild(self) -> bool: ...
    @property
    def IsSpecialBuild(self) -> bool: ...
    @property
    def Language(self) -> str: ...
    @property
    def LegalCopyright(self) -> str: ...
    @property
    def LegalTrademarks(self) -> str: ...
    @property
    def OriginalFilename(self) -> str: ...
    @property
    def PrivateBuild(self) -> str: ...
    @property
    def ProductBuildPart(self) -> int: ...
    @property
    def ProductMajorPart(self) -> int: ...
    @property
    def ProductMinorPart(self) -> int: ...
    @property
    def ProductName(self) -> str: ...
    @property
    def ProductPrivatePart(self) -> int: ...
    @property
    def ProductVersion(self) -> str: ...
    @property
    def SpecialBuild(self) -> str: ...
    @staticmethod
    def GetVersionInfo(fileName: str) -> FileVersionInfo: ...
    def ToString(self) -> str: ...


class MonitoringDescriptionAttribute(DescriptionAttribute):
    def __init__(self, description: str) -> None: ...
    @property
    def Description(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class Process(Component):
    def __init__(self) -> None: ...
    @property
    def BasePriority(self) -> int: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def EnableRaisingEvents(self) -> bool: ...
    @EnableRaisingEvents.setter
    def EnableRaisingEvents(self, value: bool) -> bool: ...
    @property
    def ExitCode(self) -> int: ...
    @property
    def ExitTime(self) -> DateTime: ...
    @property
    def Handle(self) -> int: ...
    @property
    def HandleCount(self) -> int: ...
    @property
    def HasExited(self) -> bool: ...
    @property
    def Id(self) -> int: ...
    @property
    def MachineName(self) -> str: ...
    @property
    def MainModule(self) -> ProcessModule: ...
    @property
    def MainWindowHandle(self) -> int: ...
    @property
    def MainWindowTitle(self) -> str: ...
    @property
    def MaxWorkingSet(self) -> int: ...
    @MaxWorkingSet.setter
    def MaxWorkingSet(self, value: int) -> int: ...
    @property
    def MinWorkingSet(self) -> int: ...
    @MinWorkingSet.setter
    def MinWorkingSet(self, value: int) -> int: ...
    @property
    def Modules(self) -> ProcessModuleCollection: ...
    @property
    def NonpagedSystemMemorySize(self) -> int: ...
    @property
    def NonpagedSystemMemorySize64(self) -> int: ...
    @property
    def PagedMemorySize(self) -> int: ...
    @property
    def PagedMemorySize64(self) -> int: ...
    @property
    def PagedSystemMemorySize(self) -> int: ...
    @property
    def PagedSystemMemorySize64(self) -> int: ...
    @property
    def PeakPagedMemorySize(self) -> int: ...
    @property
    def PeakPagedMemorySize64(self) -> int: ...
    @property
    def PeakVirtualMemorySize(self) -> int: ...
    @property
    def PeakVirtualMemorySize64(self) -> int: ...
    @property
    def PeakWorkingSet(self) -> int: ...
    @property
    def PeakWorkingSet64(self) -> int: ...
    @property
    def PriorityBoostEnabled(self) -> bool: ...
    @PriorityBoostEnabled.setter
    def PriorityBoostEnabled(self, value: bool) -> bool: ...
    @property
    def PriorityClass(self) -> ProcessPriorityClass: ...
    @PriorityClass.setter
    def PriorityClass(self, value: ProcessPriorityClass) -> ProcessPriorityClass: ...
    @property
    def PrivateMemorySize(self) -> int: ...
    @property
    def PrivateMemorySize64(self) -> int: ...
    @property
    def PrivilegedProcessorTime(self) -> TimeSpan: ...
    @property
    def ProcessName(self) -> str: ...
    @property
    def ProcessorAffinity(self) -> int: ...
    @ProcessorAffinity.setter
    def ProcessorAffinity(self, value: int) -> int: ...
    @property
    def Responding(self) -> bool: ...
    @property
    def SafeHandle(self) -> SafeProcessHandle: ...
    @property
    def SessionId(self) -> int: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def StandardError(self) -> StreamReader: ...
    @property
    def StandardInput(self) -> StreamWriter: ...
    @property
    def StandardOutput(self) -> StreamReader: ...
    @property
    def StartInfo(self) -> ProcessStartInfo: ...
    @StartInfo.setter
    def StartInfo(self, value: ProcessStartInfo) -> ProcessStartInfo: ...
    @property
    def StartTime(self) -> DateTime: ...
    @property
    def SynchronizingObject(self) -> ISynchronizeInvoke: ...
    @SynchronizingObject.setter
    def SynchronizingObject(self, value: ISynchronizeInvoke) -> ISynchronizeInvoke: ...
    @property
    def Threads(self) -> ProcessThreadCollection: ...
    @property
    def TotalProcessorTime(self) -> TimeSpan: ...
    @property
    def UserProcessorTime(self) -> TimeSpan: ...
    @property
    def VirtualMemorySize(self) -> int: ...
    @property
    def VirtualMemorySize64(self) -> int: ...
    @property
    def WorkingSet(self) -> int: ...
    @property
    def WorkingSet64(self) -> int: ...
    def BeginErrorReadLine(self) -> None: ...
    def BeginOutputReadLine(self) -> None: ...
    def CancelErrorRead(self) -> None: ...
    def CancelOutputRead(self) -> None: ...
    def Close(self) -> None: ...
    def CloseMainWindow(self) -> bool: ...
    @staticmethod
    def EnterDebugMode() -> None: ...
    @staticmethod
    def GetCurrentProcess() -> Process: ...
    @staticmethod
    def LeaveDebugMode() -> None: ...
    def Refresh(self) -> None: ...
    def ToString(self) -> str: ...
    def WaitForExitAsync(self, cancellationToken: CancellationToken = ...) -> Task: ...
    # Skipped GetProcessById due to it being static, abstract and generic.

    GetProcessById : GetProcessById_MethodGroup
    class GetProcessById_MethodGroup:
        @typing.overload
        def __call__(self, processId: int) -> Process:...
        @typing.overload
        def __call__(self, processId: int, machineName: str) -> Process:...

    # Skipped GetProcesses due to it being static, abstract and generic.

    GetProcesses : GetProcesses_MethodGroup
    class GetProcesses_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[Process]:...
        @typing.overload
        def __call__(self, machineName: str) -> Array_1[Process]:...

    # Skipped GetProcessesByName due to it being static, abstract and generic.

    GetProcessesByName : GetProcessesByName_MethodGroup
    class GetProcessesByName_MethodGroup:
        @typing.overload
        def __call__(self, processName: str) -> Array_1[Process]:...
        @typing.overload
        def __call__(self, processName: str, machineName: str) -> Array_1[Process]:...

    # Skipped Kill due to it being static, abstract and generic.

    Kill : Kill_MethodGroup
    class Kill_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, entireProcessTree: bool) -> None:...

    # Skipped Start due to it being static, abstract and generic.

    Start : Start_MethodGroup
    class Start_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, fileName: str) -> Process:...
        @typing.overload
        def __call__(self, startInfo: ProcessStartInfo) -> Process:...
        @typing.overload
        def __call__(self, fileName: str, arguments: str) -> Process:...
        @typing.overload
        def __call__(self, fileName: str, arguments: IEnumerable_1[str]) -> Process:...
        @typing.overload
        def __call__(self, fileName: str, userName: str, password: SecureString, domain: str) -> Process:...
        @typing.overload
        def __call__(self, fileName: str, arguments: str, userName: str, password: SecureString, domain: str) -> Process:...

    # Skipped WaitForExit due to it being static, abstract and generic.

    WaitForExit : WaitForExit_MethodGroup
    class WaitForExit_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, milliseconds: int) -> bool:...

    # Skipped WaitForInputIdle due to it being static, abstract and generic.

    WaitForInputIdle : WaitForInputIdle_MethodGroup
    class WaitForInputIdle_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, milliseconds: int) -> bool:...



class ProcessModule(Component):
    @property
    def BaseAddress(self) -> int: ...
    @BaseAddress.setter
    def BaseAddress(self, value: int) -> int: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def EntryPointAddress(self) -> int: ...
    @EntryPointAddress.setter
    def EntryPointAddress(self, value: int) -> int: ...
    @property
    def FileName(self) -> str: ...
    @FileName.setter
    def FileName(self, value: str) -> str: ...
    @property
    def FileVersionInfo(self) -> FileVersionInfo: ...
    @property
    def ModuleMemorySize(self) -> int: ...
    @ModuleMemorySize.setter
    def ModuleMemorySize(self, value: int) -> int: ...
    @property
    def ModuleName(self) -> str: ...
    @ModuleName.setter
    def ModuleName(self, value: str) -> str: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    def ToString(self) -> str: ...


class ProcessModuleCollection(ReadOnlyCollectionBase):
    def __init__(self, processModules: Array_1[ProcessModule]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> ProcessModule: ...
    def Contains(self, module: ProcessModule) -> bool: ...
    def CopyTo(self, array: Array_1[ProcessModule], index: int) -> None: ...
    def IndexOf(self, module: ProcessModule) -> int: ...


class ProcessPriorityClass(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Normal : ProcessPriorityClass # 32
    Idle : ProcessPriorityClass # 64
    High : ProcessPriorityClass # 128
    RealTime : ProcessPriorityClass # 256
    BelowNormal : ProcessPriorityClass # 16384
    AboveNormal : ProcessPriorityClass # 32768


class ProcessStartInfo:
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, fileName: str) -> None: ...
    @typing.overload
    def __init__(self, fileName: str, arguments: str) -> None: ...
    @property
    def ArgumentList(self) -> Collection_1[str]: ...
    @property
    def Arguments(self) -> str: ...
    @Arguments.setter
    def Arguments(self, value: str) -> str: ...
    @property
    def CreateNoWindow(self) -> bool: ...
    @CreateNoWindow.setter
    def CreateNoWindow(self, value: bool) -> bool: ...
    @property
    def Domain(self) -> str: ...
    @Domain.setter
    def Domain(self, value: str) -> str: ...
    @property
    def Environment(self) -> IDictionary_2[str, str]: ...
    @property
    def EnvironmentVariables(self) -> StringDictionary: ...
    @property
    def ErrorDialog(self) -> bool: ...
    @ErrorDialog.setter
    def ErrorDialog(self, value: bool) -> bool: ...
    @property
    def ErrorDialogParentHandle(self) -> int: ...
    @ErrorDialogParentHandle.setter
    def ErrorDialogParentHandle(self, value: int) -> int: ...
    @property
    def FileName(self) -> str: ...
    @FileName.setter
    def FileName(self, value: str) -> str: ...
    @property
    def LoadUserProfile(self) -> bool: ...
    @LoadUserProfile.setter
    def LoadUserProfile(self, value: bool) -> bool: ...
    @property
    def Password(self) -> SecureString: ...
    @Password.setter
    def Password(self, value: SecureString) -> SecureString: ...
    @property
    def PasswordInClearText(self) -> str: ...
    @PasswordInClearText.setter
    def PasswordInClearText(self, value: str) -> str: ...
    @property
    def RedirectStandardError(self) -> bool: ...
    @RedirectStandardError.setter
    def RedirectStandardError(self, value: bool) -> bool: ...
    @property
    def RedirectStandardInput(self) -> bool: ...
    @RedirectStandardInput.setter
    def RedirectStandardInput(self, value: bool) -> bool: ...
    @property
    def RedirectStandardOutput(self) -> bool: ...
    @RedirectStandardOutput.setter
    def RedirectStandardOutput(self, value: bool) -> bool: ...
    @property
    def StandardErrorEncoding(self) -> Encoding: ...
    @StandardErrorEncoding.setter
    def StandardErrorEncoding(self, value: Encoding) -> Encoding: ...
    @property
    def StandardInputEncoding(self) -> Encoding: ...
    @StandardInputEncoding.setter
    def StandardInputEncoding(self, value: Encoding) -> Encoding: ...
    @property
    def StandardOutputEncoding(self) -> Encoding: ...
    @StandardOutputEncoding.setter
    def StandardOutputEncoding(self, value: Encoding) -> Encoding: ...
    @property
    def UserName(self) -> str: ...
    @UserName.setter
    def UserName(self, value: str) -> str: ...
    @property
    def UseShellExecute(self) -> bool: ...
    @UseShellExecute.setter
    def UseShellExecute(self, value: bool) -> bool: ...
    @property
    def Verb(self) -> str: ...
    @Verb.setter
    def Verb(self, value: str) -> str: ...
    @property
    def Verbs(self) -> Array_1[str]: ...
    @property
    def WindowStyle(self) -> ProcessWindowStyle: ...
    @WindowStyle.setter
    def WindowStyle(self, value: ProcessWindowStyle) -> ProcessWindowStyle: ...
    @property
    def WorkingDirectory(self) -> str: ...
    @WorkingDirectory.setter
    def WorkingDirectory(self, value: str) -> str: ...


class ProcessThread(Component):
    @property
    def BasePriority(self) -> int: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def CurrentPriority(self) -> int: ...
    @property
    def Id(self) -> int: ...
    @property
    def IdealProcessor(self) -> None: ...
    @IdealProcessor.setter
    def IdealProcessor(self, value: int) -> None: ...
    @property
    def PriorityBoostEnabled(self) -> bool: ...
    @PriorityBoostEnabled.setter
    def PriorityBoostEnabled(self, value: bool) -> bool: ...
    @property
    def PriorityLevel(self) -> ThreadPriorityLevel: ...
    @PriorityLevel.setter
    def PriorityLevel(self, value: ThreadPriorityLevel) -> ThreadPriorityLevel: ...
    @property
    def PrivilegedProcessorTime(self) -> TimeSpan: ...
    @property
    def ProcessorAffinity(self) -> None: ...
    @ProcessorAffinity.setter
    def ProcessorAffinity(self, value: int) -> None: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def StartAddress(self) -> int: ...
    @property
    def StartTime(self) -> DateTime: ...
    @property
    def ThreadState(self) -> ThreadState: ...
    @property
    def TotalProcessorTime(self) -> TimeSpan: ...
    @property
    def UserProcessorTime(self) -> TimeSpan: ...
    @property
    def WaitReason(self) -> ThreadWaitReason: ...
    def ResetIdealProcessor(self) -> None: ...


class ProcessThreadCollection(ReadOnlyCollectionBase):
    def __init__(self, processThreads: Array_1[ProcessThread]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> ProcessThread: ...
    def Add(self, thread: ProcessThread) -> int: ...
    def Contains(self, thread: ProcessThread) -> bool: ...
    def CopyTo(self, array: Array_1[ProcessThread], index: int) -> None: ...
    def IndexOf(self, thread: ProcessThread) -> int: ...
    def Insert(self, index: int, thread: ProcessThread) -> None: ...
    def Remove(self, thread: ProcessThread) -> None: ...


class ProcessWindowStyle(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Normal : ProcessWindowStyle # 0
    Hidden : ProcessWindowStyle # 1
    Minimized : ProcessWindowStyle # 2
    Maximized : ProcessWindowStyle # 3


class SampleActivity_GenericClasses(abc.ABCMeta):
    Generic_SampleActivity_GenericClasses_SampleActivity_1_T = typing.TypeVar('Generic_SampleActivity_GenericClasses_SampleActivity_1_T')
    def __getitem__(self, types : typing.Type[Generic_SampleActivity_GenericClasses_SampleActivity_1_T]) -> typing.Type[SampleActivity_1[Generic_SampleActivity_GenericClasses_SampleActivity_1_T]]: ...

SampleActivity : SampleActivity_GenericClasses

SampleActivity_1_T = typing.TypeVar('SampleActivity_1_T')
class SampleActivity_1(typing.Generic[SampleActivity_1_T], MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, options: clr.Reference[ActivityCreationOptions_1[SampleActivity_1_T]], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, options: clr.Reference[ActivityCreationOptions_1[SampleActivity_1_T]], result: IAsyncResult) -> ActivitySamplingResult: ...
    def Invoke(self, options: clr.Reference[ActivityCreationOptions_1[SampleActivity_1_T]]) -> ActivitySamplingResult: ...


class SourceFilter(TraceFilter):
    def __init__(self, source: str) -> None: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    def ShouldTrace(self, cache: TraceEventCache, source: str, eventType: TraceEventType, id: int, formatOrMessage: str, args: Array_1[typing.Any], data1: typing.Any, data: Array_1[typing.Any]) -> bool: ...


class SourceLevels(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Off : SourceLevels # 0
    Critical : SourceLevels # 1
    Error : SourceLevels # 3
    Warning : SourceLevels # 7
    Information : SourceLevels # 15
    Verbose : SourceLevels # 31
    ActivityTracing : SourceLevels # 65280
    All : SourceLevels # -1


class SourceSwitch(Switch):
    @typing.overload
    def __init__(self, displayName: str, defaultSwitchValue: str) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @property
    def Attributes(self) -> StringDictionary: ...
    @property
    def Description(self) -> str: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def Level(self) -> SourceLevels: ...
    @Level.setter
    def Level(self, value: SourceLevels) -> SourceLevels: ...
    def ShouldTrace(self, eventType: TraceEventType) -> bool: ...


class StackFrame:
    # Constructor .ctor(skipFrames : Int32) was skipped since it collides with above method
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, fileName: str, lineNumber: int) -> None: ...
    @typing.overload
    def __init__(self, fileName: str, lineNumber: int, colNumber: int) -> None: ...
    @typing.overload
    def __init__(self, needFileInfo: bool) -> None: ...
    @typing.overload
    def __init__(self, skipFrames: int, needFileInfo: bool) -> None: ...
    OFFSET_UNKNOWN : int
    def GetFileColumnNumber(self) -> int: ...
    def GetFileLineNumber(self) -> int: ...
    def GetFileName(self) -> str: ...
    def GetILOffset(self) -> int: ...
    def GetMethod(self) -> MethodBase: ...
    def GetNativeOffset(self) -> int: ...
    def ToString(self) -> str: ...


class StackFrameExtensions(abc.ABC):
    @staticmethod
    def GetNativeImageBase(stackFrame: StackFrame) -> int: ...
    @staticmethod
    def GetNativeIP(stackFrame: StackFrame) -> int: ...
    @staticmethod
    def HasILOffset(stackFrame: StackFrame) -> bool: ...
    @staticmethod
    def HasMethod(stackFrame: StackFrame) -> bool: ...
    @staticmethod
    def HasNativeImage(stackFrame: StackFrame) -> bool: ...
    @staticmethod
    def HasSource(stackFrame: StackFrame) -> bool: ...


class StackTrace:
    # Constructor .ctor(e : Exception, skipFrames : Int32) was skipped since it collides with above method
    # Constructor .ctor(skipFrames : Int32) was skipped since it collides with above method
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, e: Exception) -> None: ...
    @typing.overload
    def __init__(self, e: Exception, fNeedFileInfo: bool) -> None: ...
    @typing.overload
    def __init__(self, e: Exception, skipFrames: int, fNeedFileInfo: bool) -> None: ...
    @typing.overload
    def __init__(self, fNeedFileInfo: bool) -> None: ...
    @typing.overload
    def __init__(self, frame: StackFrame) -> None: ...
    @typing.overload
    def __init__(self, skipFrames: int, fNeedFileInfo: bool) -> None: ...
    METHODS_TO_SKIP : int
    @property
    def FrameCount(self) -> int: ...
    def GetFrame(self, index: int) -> StackFrame: ...
    def GetFrames(self) -> Array_1[StackFrame]: ...
    def ToString(self) -> str: ...


class StackTraceHiddenAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...


class Stopwatch:
    def __init__(self) -> None: ...
    Frequency : int
    IsHighResolution : bool
    @property
    def Elapsed(self) -> TimeSpan: ...
    @property
    def ElapsedMilliseconds(self) -> int: ...
    @property
    def ElapsedTicks(self) -> int: ...
    @property
    def IsRunning(self) -> bool: ...
    @staticmethod
    def GetTimestamp() -> int: ...
    def Reset(self) -> None: ...
    def Restart(self) -> None: ...
    def Start(self) -> None: ...
    @staticmethod
    def StartNew() -> Stopwatch: ...
    def Stop(self) -> None: ...


class Switch(abc.ABC):
    @property
    def Attributes(self) -> StringDictionary: ...
    @property
    def Description(self) -> str: ...
    @property
    def DisplayName(self) -> str: ...


class SwitchAttribute(Attribute):
    def __init__(self, switchName: str, switchType: typing.Type[typing.Any]) -> None: ...
    @property
    def SwitchDescription(self) -> str: ...
    @SwitchDescription.setter
    def SwitchDescription(self, value: str) -> str: ...
    @property
    def SwitchName(self) -> str: ...
    @SwitchName.setter
    def SwitchName(self, value: str) -> str: ...
    @property
    def SwitchType(self) -> typing.Type[typing.Any]: ...
    @SwitchType.setter
    def SwitchType(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @staticmethod
    def GetAll(assembly: Assembly) -> Array_1[SwitchAttribute]: ...


class SwitchLevelAttribute(Attribute):
    def __init__(self, switchLevelType: typing.Type[typing.Any]) -> None: ...
    @property
    def SwitchLevelType(self) -> typing.Type[typing.Any]: ...
    @SwitchLevelType.setter
    def SwitchLevelType(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def TypeId(self) -> typing.Any: ...


class TextWriterTraceListener(TraceListener):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, fileName: str) -> None: ...
    @typing.overload
    def __init__(self, fileName: str, name: str) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, name: str) -> None: ...
    @typing.overload
    def __init__(self, writer: TextWriter) -> None: ...
    @typing.overload
    def __init__(self, writer: TextWriter, name: str) -> None: ...
    @property
    def Attributes(self) -> StringDictionary: ...
    @property
    def Filter(self) -> TraceFilter: ...
    @Filter.setter
    def Filter(self, value: TraceFilter) -> TraceFilter: ...
    @property
    def IndentLevel(self) -> int: ...
    @IndentLevel.setter
    def IndentLevel(self, value: int) -> int: ...
    @property
    def IndentSize(self) -> int: ...
    @IndentSize.setter
    def IndentSize(self, value: int) -> int: ...
    @property
    def IsThreadSafe(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def TraceOutputOptions(self) -> TraceOptions: ...
    @TraceOutputOptions.setter
    def TraceOutputOptions(self, value: TraceOptions) -> TraceOptions: ...
    @property
    def Writer(self) -> TextWriter: ...
    @Writer.setter
    def Writer(self, value: TextWriter) -> TextWriter: ...
    def Close(self) -> None: ...
    def Flush(self) -> None: ...
    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any, category: str) -> None:...

    # Skipped WriteLine due to it being static, abstract and generic.

    WriteLine : WriteLine_MethodGroup
    class WriteLine_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any, category: str) -> None:...



class ThreadPriorityLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Normal : ThreadPriorityLevel # 0
    AboveNormal : ThreadPriorityLevel # 1
    Highest : ThreadPriorityLevel # 2
    TimeCritical : ThreadPriorityLevel # 15
    Idle : ThreadPriorityLevel # -15
    Lowest : ThreadPriorityLevel # -2
    BelowNormal : ThreadPriorityLevel # -1


class ThreadState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Initialized : ThreadState # 0
    Ready : ThreadState # 1
    Running : ThreadState # 2
    Standby : ThreadState # 3
    Terminated : ThreadState # 4
    Wait : ThreadState # 5
    Transition : ThreadState # 6
    Unknown : ThreadState # 7


class ThreadWaitReason(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Executive : ThreadWaitReason # 0
    FreePage : ThreadWaitReason # 1
    PageIn : ThreadWaitReason # 2
    SystemAllocation : ThreadWaitReason # 3
    ExecutionDelay : ThreadWaitReason # 4
    Suspended : ThreadWaitReason # 5
    UserRequest : ThreadWaitReason # 6
    EventPairHigh : ThreadWaitReason # 7
    EventPairLow : ThreadWaitReason # 8
    LpcReceive : ThreadWaitReason # 9
    LpcReply : ThreadWaitReason # 10
    VirtualMemory : ThreadWaitReason # 11
    PageOut : ThreadWaitReason # 12
    Unknown : ThreadWaitReason # 13


class Trace:
    @classmethod
    @property
    def AutoFlush(cls) -> bool: ...
    @classmethod
    @AutoFlush.setter
    def AutoFlush(cls, value: bool) -> bool: ...
    @classmethod
    @property
    def CorrelationManager(cls) -> CorrelationManager: ...
    @classmethod
    @property
    def IndentLevel(cls) -> int: ...
    @classmethod
    @IndentLevel.setter
    def IndentLevel(cls, value: int) -> int: ...
    @classmethod
    @property
    def IndentSize(cls) -> int: ...
    @classmethod
    @IndentSize.setter
    def IndentSize(cls, value: int) -> int: ...
    @classmethod
    @property
    def Listeners(cls) -> TraceListenerCollection: ...
    @classmethod
    @property
    def UseGlobalLock(cls) -> bool: ...
    @classmethod
    @UseGlobalLock.setter
    def UseGlobalLock(cls, value: bool) -> bool: ...
    @staticmethod
    def Close() -> None: ...
    @staticmethod
    def Flush() -> None: ...
    @staticmethod
    def Indent() -> None: ...
    @staticmethod
    def Refresh() -> None: ...
    @staticmethod
    def Unindent() -> None: ...
    # Skipped Assert due to it being static, abstract and generic.

    Assert : Assert_MethodGroup
    class Assert_MethodGroup:
        @typing.overload
        def __call__(self, condition: bool) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str, detailMessage: str) -> None:...

    # Skipped Fail due to it being static, abstract and generic.

    Fail : Fail_MethodGroup
    class Fail_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, message: str, detailMessage: str) -> None:...

    # Skipped TraceError due to it being static, abstract and generic.

    TraceError : TraceError_MethodGroup
    class TraceError_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped TraceInformation due to it being static, abstract and generic.

    TraceInformation : TraceInformation_MethodGroup
    class TraceInformation_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped TraceWarning due to it being static, abstract and generic.

    TraceWarning : TraceWarning_MethodGroup
    class TraceWarning_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any, category: str) -> None:...

    # Skipped WriteIf due to it being static, abstract and generic.

    WriteIf : WriteIf_MethodGroup
    class WriteIf_MethodGroup:
        @typing.overload
        def __call__(self, condition: bool, message: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, value: typing.Any, category: str) -> None:...

    # Skipped WriteLine due to it being static, abstract and generic.

    WriteLine : WriteLine_MethodGroup
    class WriteLine_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any, category: str) -> None:...

    # Skipped WriteLineIf due to it being static, abstract and generic.

    WriteLineIf : WriteLineIf_MethodGroup
    class WriteLineIf_MethodGroup:
        @typing.overload
        def __call__(self, condition: bool, message: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, value: typing.Any) -> None:...
        @typing.overload
        def __call__(self, condition: bool, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, condition: bool, value: typing.Any, category: str) -> None:...



class TraceEventCache:
    def __init__(self) -> None: ...
    @property
    def Callstack(self) -> str: ...
    @property
    def DateTime(self) -> DateTime: ...
    @property
    def LogicalOperationStack(self) -> Stack: ...
    @property
    def ProcessId(self) -> int: ...
    @property
    def ThreadId(self) -> str: ...
    @property
    def Timestamp(self) -> int: ...


class TraceEventType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Critical : TraceEventType # 1
    Error : TraceEventType # 2
    Warning : TraceEventType # 4
    Information : TraceEventType # 8
    Verbose : TraceEventType # 16
    Start : TraceEventType # 256
    Stop : TraceEventType # 512
    Suspend : TraceEventType # 1024
    Resume : TraceEventType # 2048
    Transfer : TraceEventType # 4096


class TraceFilter(abc.ABC):
    @abc.abstractmethod
    def ShouldTrace(self, cache: TraceEventCache, source: str, eventType: TraceEventType, id: int, formatOrMessage: str, args: Array_1[typing.Any], data1: typing.Any, data: Array_1[typing.Any]) -> bool: ...


class TraceLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Off : TraceLevel # 0
    Error : TraceLevel # 1
    Warning : TraceLevel # 2
    Info : TraceLevel # 3
    Verbose : TraceLevel # 4


class TraceListener(MarshalByRefObject, IDisposable):
    @property
    def Attributes(self) -> StringDictionary: ...
    @property
    def Filter(self) -> TraceFilter: ...
    @Filter.setter
    def Filter(self, value: TraceFilter) -> TraceFilter: ...
    @property
    def IndentLevel(self) -> int: ...
    @IndentLevel.setter
    def IndentLevel(self, value: int) -> int: ...
    @property
    def IndentSize(self) -> int: ...
    @IndentSize.setter
    def IndentSize(self, value: int) -> int: ...
    @property
    def IsThreadSafe(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def TraceOutputOptions(self) -> TraceOptions: ...
    @TraceOutputOptions.setter
    def TraceOutputOptions(self, value: TraceOptions) -> TraceOptions: ...
    def Close(self) -> None: ...
    def Dispose(self) -> None: ...
    def Flush(self) -> None: ...
    def TraceTransfer(self, eventCache: TraceEventCache, source: str, id: int, message: str, relatedActivityId: Guid) -> None: ...
    # Skipped Fail due to it being static, abstract and generic.

    Fail : Fail_MethodGroup
    class Fail_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, message: str, detailMessage: str) -> None:...

    # Skipped TraceData due to it being static, abstract and generic.

    TraceData : TraceData_MethodGroup
    class TraceData_MethodGroup:
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int, data: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int, data: typing.Any) -> None:...

    # Skipped TraceEvent due to it being static, abstract and generic.

    TraceEvent : TraceEvent_MethodGroup
    class TraceEvent_MethodGroup:
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int) -> None:...
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int, message: str) -> None:...
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any, category: str) -> None:...

    # Skipped WriteLine due to it being static, abstract and generic.

    WriteLine : WriteLine_MethodGroup
    class WriteLine_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any, category: str) -> None:...



class TraceListenerCollection(IList):
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> TraceListener: ...
    @Item.setter
    def Item(self, value: TraceListener) -> TraceListener: ...
    @property
    def Item(self) -> TraceListener: ...
    def Add(self, listener: TraceListener) -> int: ...
    def Clear(self) -> None: ...
    def Contains(self, listener: TraceListener) -> bool: ...
    def CopyTo(self, listeners: Array_1[TraceListener], index: int) -> None: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def IndexOf(self, listener: TraceListener) -> int: ...
    def Insert(self, index: int, listener: TraceListener) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped AddRange due to it being static, abstract and generic.

    AddRange : AddRange_MethodGroup
    class AddRange_MethodGroup:
        @typing.overload
        def __call__(self, value: Array_1[TraceListener]) -> None:...
        @typing.overload
        def __call__(self, value: TraceListenerCollection) -> None:...

    # Skipped Remove due to it being static, abstract and generic.

    Remove : Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self, listener: TraceListener) -> None:...
        @typing.overload
        def __call__(self, name: str) -> None:...



class TraceOptions(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : TraceOptions # 0
    LogicalOperationStack : TraceOptions # 1
    DateTime : TraceOptions # 2
    Timestamp : TraceOptions # 4
    ProcessId : TraceOptions # 8
    ThreadId : TraceOptions # 16
    Callstack : TraceOptions # 32


class TraceSource:
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, defaultLevel: SourceLevels) -> None: ...
    @property
    def Attributes(self) -> StringDictionary: ...
    @property
    def Listeners(self) -> TraceListenerCollection: ...
    @property
    def Name(self) -> str: ...
    @property
    def Switch(self) -> SourceSwitch: ...
    @Switch.setter
    def Switch(self, value: SourceSwitch) -> SourceSwitch: ...
    def Close(self) -> None: ...
    def Flush(self) -> None: ...
    def TraceTransfer(self, id: int, message: str, relatedActivityId: Guid) -> None: ...
    # Skipped TraceData due to it being static, abstract and generic.

    TraceData : TraceData_MethodGroup
    class TraceData_MethodGroup:
        @typing.overload
        def __call__(self, eventType: TraceEventType, id: int, data: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, eventType: TraceEventType, id: int, data: typing.Any) -> None:...

    # Skipped TraceEvent due to it being static, abstract and generic.

    TraceEvent : TraceEvent_MethodGroup
    class TraceEvent_MethodGroup:
        @typing.overload
        def __call__(self, eventType: TraceEventType, id: int) -> None:...
        @typing.overload
        def __call__(self, eventType: TraceEventType, id: int, message: str) -> None:...
        @typing.overload
        def __call__(self, eventType: TraceEventType, id: int, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped TraceInformation due to it being static, abstract and generic.

    TraceInformation : TraceInformation_MethodGroup
    class TraceInformation_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, format: str, args: Array_1[typing.Any]) -> None:...



class TraceSwitch(Switch):
    @typing.overload
    def __init__(self, displayName: str, description: str) -> None: ...
    @typing.overload
    def __init__(self, displayName: str, description: str, defaultSwitchValue: str) -> None: ...
    @property
    def Attributes(self) -> StringDictionary: ...
    @property
    def Description(self) -> str: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def Level(self) -> TraceLevel: ...
    @Level.setter
    def Level(self, value: TraceLevel) -> TraceLevel: ...
    @property
    def TraceError(self) -> bool: ...
    @property
    def TraceInfo(self) -> bool: ...
    @property
    def TraceVerbose(self) -> bool: ...
    @property
    def TraceWarning(self) -> bool: ...


class XmlWriterTraceListener(TextWriterTraceListener):
    @typing.overload
    def __init__(self, filename: str) -> None: ...
    @typing.overload
    def __init__(self, filename: str, name: str) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, name: str) -> None: ...
    @typing.overload
    def __init__(self, writer: TextWriter) -> None: ...
    @typing.overload
    def __init__(self, writer: TextWriter, name: str) -> None: ...
    @property
    def Attributes(self) -> StringDictionary: ...
    @property
    def Filter(self) -> TraceFilter: ...
    @Filter.setter
    def Filter(self, value: TraceFilter) -> TraceFilter: ...
    @property
    def IndentLevel(self) -> int: ...
    @IndentLevel.setter
    def IndentLevel(self, value: int) -> int: ...
    @property
    def IndentSize(self) -> int: ...
    @IndentSize.setter
    def IndentSize(self, value: int) -> int: ...
    @property
    def IsThreadSafe(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...
    @property
    def TraceOutputOptions(self) -> TraceOptions: ...
    @TraceOutputOptions.setter
    def TraceOutputOptions(self, value: TraceOptions) -> TraceOptions: ...
    @property
    def Writer(self) -> TextWriter: ...
    @Writer.setter
    def Writer(self, value: TextWriter) -> TextWriter: ...
    def Close(self) -> None: ...
    def TraceTransfer(self, eventCache: TraceEventCache, source: str, id: int, message: str, relatedActivityId: Guid) -> None: ...
    # Skipped Fail due to it being static, abstract and generic.

    Fail : Fail_MethodGroup
    class Fail_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, message: str, detailMessage: str) -> None:...

    # Skipped TraceData due to it being static, abstract and generic.

    TraceData : TraceData_MethodGroup
    class TraceData_MethodGroup:
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int, data: Array_1[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int, data: typing.Any) -> None:...

    # Skipped TraceEvent due to it being static, abstract and generic.

    TraceEvent : TraceEvent_MethodGroup
    class TraceEvent_MethodGroup:
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int) -> None:...
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int, message: str) -> None:...
        @typing.overload
        def __call__(self, eventCache: TraceEventCache, source: str, eventType: TraceEventType, id: int, format: str, args: Array_1[typing.Any]) -> None:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any, category: str) -> None:...

    # Skipped WriteLine due to it being static, abstract and generic.

    WriteLine : WriteLine_MethodGroup
    class WriteLine_MethodGroup:
        @typing.overload
        def __call__(self, message: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any) -> None:...
        @typing.overload
        def __call__(self, message: str, category: str) -> None:...
        @typing.overload
        def __call__(self, o: typing.Any, category: str) -> None:...


