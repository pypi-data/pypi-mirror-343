import typing, clr, abc
from System.Reflection import MethodInfo, PropertyInfo, MemberInfo, FieldInfo, ConstructorInfo
from System.Collections.ObjectModel import ReadOnlyCollection_1
from System.Collections.Generic import IEnumerable_1
from System.Runtime.CompilerServices import CallSiteBinder, DebugInfoGenerator
from System import Array_1, Guid, Delegate, Func_2

class BinaryExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Conversion(self) -> LambdaExpression: ...
    @property
    def IsLifted(self) -> bool: ...
    @property
    def IsLiftedToNull(self) -> bool: ...
    @property
    def Left(self) -> Expression: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Right(self) -> Expression: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def Reduce(self) -> Expression: ...
    def Update(self, left: Expression, conversion: LambdaExpression, right: Expression) -> BinaryExpression: ...


class BlockExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Expressions(self) -> ReadOnlyCollection_1[Expression]: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Result(self) -> Expression: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    @property
    def Variables(self) -> ReadOnlyCollection_1[ParameterExpression]: ...
    def Update(self, variables: IEnumerable_1[ParameterExpression], expressions: IEnumerable_1[Expression]) -> BlockExpression: ...


class CatchBlock:
    @property
    def Body(self) -> Expression: ...
    @property
    def Filter(self) -> Expression: ...
    @property
    def Test(self) -> typing.Type[typing.Any]: ...
    @property
    def Variable(self) -> ParameterExpression: ...
    def ToString(self) -> str: ...
    def Update(self, variable: ParameterExpression, filter: Expression, body: Expression) -> CatchBlock: ...


class ConditionalExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def IfFalse(self) -> Expression: ...
    @property
    def IfTrue(self) -> Expression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Test(self) -> Expression: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def Update(self, test: Expression, ifTrue: Expression, ifFalse: Expression) -> ConditionalExpression: ...


class ConstantExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    @property
    def Value(self) -> typing.Any: ...


class DebugInfoExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Document(self) -> SymbolDocumentInfo: ...
    @property
    def EndColumn(self) -> int: ...
    @property
    def EndLine(self) -> int: ...
    @property
    def IsClear(self) -> bool: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def StartColumn(self) -> int: ...
    @property
    def StartLine(self) -> int: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...


class DefaultExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...


class DynamicExpression(Expression_0, IDynamicExpression):
    @property
    def Arguments(self) -> ReadOnlyCollection_1[Expression]: ...
    @property
    def Binder(self) -> CallSiteBinder: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def DelegateType(self) -> typing.Type[typing.Any]: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def Reduce(self) -> Expression: ...
    def Update(self, arguments: IEnumerable_1[Expression]) -> DynamicExpression: ...
    # Skipped Dynamic due to it being static, abstract and generic.

    Dynamic : Dynamic_MethodGroup
    class Dynamic_MethodGroup:
        @typing.overload
        def __call__(self, binder: CallSiteBinder, returnType: typing.Type[typing.Any], arguments: Array_1[Expression]) -> DynamicExpression:...
        @typing.overload
        def __call__(self, binder: CallSiteBinder, returnType: typing.Type[typing.Any], arguments: IEnumerable_1[Expression]) -> DynamicExpression:...
        @typing.overload
        def __call__(self, binder: CallSiteBinder, returnType: typing.Type[typing.Any], arg0: Expression) -> DynamicExpression:...
        @typing.overload
        def __call__(self, binder: CallSiteBinder, returnType: typing.Type[typing.Any], arg0: Expression, arg1: Expression) -> DynamicExpression:...
        @typing.overload
        def __call__(self, binder: CallSiteBinder, returnType: typing.Type[typing.Any], arg0: Expression, arg1: Expression, arg2: Expression) -> DynamicExpression:...
        @typing.overload
        def __call__(self, binder: CallSiteBinder, returnType: typing.Type[typing.Any], arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> DynamicExpression:...

    # Skipped MakeDynamic due to it being static, abstract and generic.

    MakeDynamic : MakeDynamic_MethodGroup
    class MakeDynamic_MethodGroup:
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], binder: CallSiteBinder, arguments: Array_1[Expression]) -> DynamicExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], binder: CallSiteBinder, arguments: IEnumerable_1[Expression]) -> DynamicExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], binder: CallSiteBinder, arg0: Expression) -> DynamicExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], binder: CallSiteBinder, arg0: Expression, arg1: Expression) -> DynamicExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression) -> DynamicExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> DynamicExpression:...



class DynamicExpressionVisitor(ExpressionVisitor):
    def __init__(self) -> None: ...


class ElementInit(IArgumentProvider):
    @property
    def AddMethod(self) -> MethodInfo: ...
    @property
    def ArgumentCount(self) -> int: ...
    @property
    def Arguments(self) -> ReadOnlyCollection_1[Expression]: ...
    def GetArgument(self, index: int) -> Expression: ...
    def ToString(self) -> str: ...
    def Update(self, arguments: IEnumerable_1[Expression]) -> ElementInit: ...


class Expression_GenericClasses(abc.ABCMeta):
    Generic_Expression_GenericClasses_Expression_1_TDelegate = typing.TypeVar('Generic_Expression_GenericClasses_Expression_1_TDelegate')
    def __getitem__(self, types : typing.Type[Generic_Expression_GenericClasses_Expression_1_TDelegate]) -> typing.Type[Expression_1[Generic_Expression_GenericClasses_Expression_1_TDelegate]]: ...

class Expression(Expression_0, metaclass =Expression_GenericClasses): ...

class Expression_0(abc.ABC):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    @staticmethod
    def ArrayLength(array: Expression) -> UnaryExpression: ...
    @staticmethod
    def Assign(left: Expression, right: Expression) -> BinaryExpression: ...
    @staticmethod
    def ClearDebugInfo(document: SymbolDocumentInfo) -> DebugInfoExpression: ...
    @staticmethod
    def DebugInfo(document: SymbolDocumentInfo, startLine: int, startColumn: int, endLine: int, endColumn: int) -> DebugInfoExpression: ...
    @staticmethod
    def Default(type: typing.Type[typing.Any]) -> DefaultExpression: ...
    @staticmethod
    def Empty() -> DefaultExpression: ...
    @staticmethod
    def GetActionType(typeArgs: Array_1[typing.Type[typing.Any]]) -> typing.Type[typing.Any]: ...
    @staticmethod
    def GetDelegateType(typeArgs: Array_1[typing.Type[typing.Any]]) -> typing.Type[typing.Any]: ...
    @staticmethod
    def GetFuncType(typeArgs: Array_1[typing.Type[typing.Any]]) -> typing.Type[typing.Any]: ...
    @staticmethod
    def IfThen(test: Expression, ifTrue: Expression) -> ConditionalExpression: ...
    @staticmethod
    def IfThenElse(test: Expression, ifTrue: Expression, ifFalse: Expression) -> ConditionalExpression: ...
    @staticmethod
    def MakeCatchBlock(type: typing.Type[typing.Any], variable: ParameterExpression, body: Expression, filter: Expression) -> CatchBlock: ...
    @staticmethod
    def MakeGoto(kind: GotoExpressionKind, target: LabelTarget, value: Expression, type: typing.Type[typing.Any]) -> GotoExpression: ...
    @staticmethod
    def MakeIndex(instance: Expression, indexer: PropertyInfo, arguments: IEnumerable_1[Expression]) -> IndexExpression: ...
    @staticmethod
    def MakeMemberAccess(expression: Expression, member: MemberInfo) -> MemberExpression: ...
    # FIXME: Document "finally" rename
    @staticmethod
    def MakeTry(type: typing.Type[typing.Any], body: Expression, finally_: Expression, fault: Expression, handlers: IEnumerable_1[CatchBlock]) -> TryExpression: ...
    @staticmethod
    def PropertyOrField(expression: Expression, propertyOrFieldName: str) -> MemberExpression: ...
    @staticmethod
    def Quote(expression: Expression) -> UnaryExpression: ...
    def Reduce(self) -> Expression: ...
    def ReduceAndCheck(self) -> Expression: ...
    def ReduceExtensions(self) -> Expression: ...
    @staticmethod
    def ReferenceEqual(left: Expression, right: Expression) -> BinaryExpression: ...
    @staticmethod
    def ReferenceNotEqual(left: Expression, right: Expression) -> BinaryExpression: ...
    def ToString(self) -> str: ...
    @staticmethod
    def TryCatch(body: Expression, handlers: Array_1[CatchBlock]) -> TryExpression: ...
    # FIXME: Document "finally" rename
    @staticmethod
    def TryCatchFinally(body: Expression, finally_: Expression, handlers: Array_1[CatchBlock]) -> TryExpression: ...
    @staticmethod
    def TryFault(body: Expression, fault: Expression) -> TryExpression: ...
    # FIXME: Document "finally" rename
    @staticmethod
    def TryFinally(body: Expression, finally_: Expression) -> TryExpression: ...
    @staticmethod
    def TryGetActionType(typeArgs: Array_1[typing.Type[typing.Any]], actionType: clr.Reference[typing.Type[typing.Any]]) -> bool: ...
    @staticmethod
    def TryGetFuncType(typeArgs: Array_1[typing.Type[typing.Any]], funcType: clr.Reference[typing.Type[typing.Any]]) -> bool: ...
    @staticmethod
    def TypeAs(expression: Expression, type: typing.Type[typing.Any]) -> UnaryExpression: ...
    @staticmethod
    def TypeEqual(expression: Expression, type: typing.Type[typing.Any]) -> TypeBinaryExpression: ...
    @staticmethod
    def TypeIs(expression: Expression, type: typing.Type[typing.Any]) -> TypeBinaryExpression: ...
    @staticmethod
    def Unbox(expression: Expression, type: typing.Type[typing.Any]) -> UnaryExpression: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped AddAssign due to it being static, abstract and generic.

    AddAssign : AddAssign_MethodGroup
    class AddAssign_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped AddAssignChecked due to it being static, abstract and generic.

    AddAssignChecked : AddAssignChecked_MethodGroup
    class AddAssignChecked_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped AddChecked due to it being static, abstract and generic.

    AddChecked : AddChecked_MethodGroup
    class AddChecked_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped And due to it being static, abstract and generic.

    And : And_MethodGroup
    class And_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped AndAlso due to it being static, abstract and generic.

    AndAlso : AndAlso_MethodGroup
    class AndAlso_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped AndAssign due to it being static, abstract and generic.

    AndAssign : AndAssign_MethodGroup
    class AndAssign_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped ArrayAccess due to it being static, abstract and generic.

    ArrayAccess : ArrayAccess_MethodGroup
    class ArrayAccess_MethodGroup:
        @typing.overload
        def __call__(self, array: Expression, indexes: Array_1[Expression]) -> IndexExpression:...
        @typing.overload
        def __call__(self, array: Expression, indexes: IEnumerable_1[Expression]) -> IndexExpression:...

    # Skipped ArrayIndex due to it being static, abstract and generic.

    ArrayIndex : ArrayIndex_MethodGroup
    class ArrayIndex_MethodGroup:
        @typing.overload
        def __call__(self, array: Expression, indexes: Array_1[Expression]) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, array: Expression, indexes: IEnumerable_1[Expression]) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, array: Expression, index: Expression) -> BinaryExpression:...

    # Skipped Bind due to it being static, abstract and generic.

    Bind : Bind_MethodGroup
    class Bind_MethodGroup:
        @typing.overload
        def __call__(self, propertyAccessor: MethodInfo, expression: Expression) -> MemberAssignment:...
        @typing.overload
        def __call__(self, member: MemberInfo, expression: Expression) -> MemberAssignment:...

    # Skipped Block due to it being static, abstract and generic.

    Block : Block_MethodGroup
    class Block_MethodGroup:
        @typing.overload
        def __call__(self, expressions: Array_1[Expression]) -> BlockExpression:...
        @typing.overload
        def __call__(self, expressions: IEnumerable_1[Expression]) -> BlockExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], expressions: Array_1[Expression]) -> BlockExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], expressions: IEnumerable_1[Expression]) -> BlockExpression:...
        @typing.overload
        def __call__(self, variables: IEnumerable_1[ParameterExpression], expressions: Array_1[Expression]) -> BlockExpression:...
        @typing.overload
        def __call__(self, variables: IEnumerable_1[ParameterExpression], expressions: IEnumerable_1[Expression]) -> BlockExpression:...
        @typing.overload
        def __call__(self, arg0: Expression, arg1: Expression) -> BlockExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], variables: IEnumerable_1[ParameterExpression], expressions: Array_1[Expression]) -> BlockExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], variables: IEnumerable_1[ParameterExpression], expressions: IEnumerable_1[Expression]) -> BlockExpression:...
        @typing.overload
        def __call__(self, arg0: Expression, arg1: Expression, arg2: Expression) -> BlockExpression:...
        @typing.overload
        def __call__(self, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> BlockExpression:...
        @typing.overload
        def __call__(self, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression) -> BlockExpression:...

    # Skipped Break due to it being static, abstract and generic.

    Break : Break_MethodGroup
    class Break_MethodGroup:
        @typing.overload
        def __call__(self, target: LabelTarget) -> GotoExpression:...
        @typing.overload
        def __call__(self, target: LabelTarget, type: typing.Type[typing.Any]) -> GotoExpression:...
        @typing.overload
        def __call__(self, target: LabelTarget, value: Expression) -> GotoExpression:...
        @typing.overload
        def __call__(self, target: LabelTarget, value: Expression, type: typing.Type[typing.Any]) -> GotoExpression:...

    # Skipped Call due to it being static, abstract and generic.

    Call : Call_MethodGroup
    class Call_MethodGroup:
        @typing.overload
        def __call__(self, method: MethodInfo, arguments: Array_1[Expression]) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, method: MethodInfo, arguments: IEnumerable_1[Expression]) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, method: MethodInfo, arg0: Expression) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, instance: Expression, method: MethodInfo) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, method: MethodInfo, arg0: Expression, arg1: Expression) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, instance: Expression, method: MethodInfo, arguments: Array_1[Expression]) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, instance: Expression, method: MethodInfo, arguments: IEnumerable_1[Expression]) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], methodName: str, typeArguments: Array_1[typing.Type[typing.Any]], arguments: Array_1[Expression]) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, instance: Expression, method: MethodInfo, arg0: Expression, arg1: Expression) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, instance: Expression, methodName: str, typeArguments: Array_1[typing.Type[typing.Any]], arguments: Array_1[Expression]) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, instance: Expression, method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression) -> MethodCallExpression:...
        @typing.overload
        def __call__(self, method: MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression) -> MethodCallExpression:...

    # Skipped Catch due to it being static, abstract and generic.

    Catch : Catch_MethodGroup
    class Catch_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], body: Expression) -> CatchBlock:...
        @typing.overload
        def __call__(self, variable: ParameterExpression, body: Expression) -> CatchBlock:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], body: Expression, filter: Expression) -> CatchBlock:...
        @typing.overload
        def __call__(self, variable: ParameterExpression, body: Expression, filter: Expression) -> CatchBlock:...

    # Skipped Coalesce due to it being static, abstract and generic.

    Coalesce : Coalesce_MethodGroup
    class Coalesce_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped Condition due to it being static, abstract and generic.

    Condition : Condition_MethodGroup
    class Condition_MethodGroup:
        @typing.overload
        def __call__(self, test: Expression, ifTrue: Expression, ifFalse: Expression) -> ConditionalExpression:...
        @typing.overload
        def __call__(self, test: Expression, ifTrue: Expression, ifFalse: Expression, type: typing.Type[typing.Any]) -> ConditionalExpression:...

    # Skipped Constant due to it being static, abstract and generic.

    Constant : Constant_MethodGroup
    class Constant_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> ConstantExpression:...
        @typing.overload
        def __call__(self, value: typing.Any, type: typing.Type[typing.Any]) -> ConstantExpression:...

    # Skipped Continue due to it being static, abstract and generic.

    Continue : Continue_MethodGroup
    class Continue_MethodGroup:
        @typing.overload
        def __call__(self, target: LabelTarget) -> GotoExpression:...
        @typing.overload
        def __call__(self, target: LabelTarget, type: typing.Type[typing.Any]) -> GotoExpression:...

    # Skipped Convert due to it being static, abstract and generic.

    Convert : Convert_MethodGroup
    class Convert_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression, type: typing.Type[typing.Any]) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, type: typing.Type[typing.Any], method: MethodInfo) -> UnaryExpression:...

    # Skipped ConvertChecked due to it being static, abstract and generic.

    ConvertChecked : ConvertChecked_MethodGroup
    class ConvertChecked_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression, type: typing.Type[typing.Any]) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, type: typing.Type[typing.Any], method: MethodInfo) -> UnaryExpression:...

    # Skipped Decrement due to it being static, abstract and generic.

    Decrement : Decrement_MethodGroup
    class Decrement_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped Divide due to it being static, abstract and generic.

    Divide : Divide_MethodGroup
    class Divide_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped DivideAssign due to it being static, abstract and generic.

    DivideAssign : DivideAssign_MethodGroup
    class DivideAssign_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped Dynamic due to it being static, abstract and generic.

    Dynamic : Dynamic_MethodGroup
    class Dynamic_MethodGroup:
        @typing.overload
        def __call__(self, binder: CallSiteBinder, returnType: typing.Type[typing.Any], arguments: Array_1[Expression]) -> DynamicExpression:...
        @typing.overload
        def __call__(self, binder: CallSiteBinder, returnType: typing.Type[typing.Any], arguments: IEnumerable_1[Expression]) -> DynamicExpression:...
        @typing.overload
        def __call__(self, binder: CallSiteBinder, returnType: typing.Type[typing.Any], arg0: Expression) -> DynamicExpression:...
        @typing.overload
        def __call__(self, binder: CallSiteBinder, returnType: typing.Type[typing.Any], arg0: Expression, arg1: Expression) -> DynamicExpression:...
        @typing.overload
        def __call__(self, binder: CallSiteBinder, returnType: typing.Type[typing.Any], arg0: Expression, arg1: Expression, arg2: Expression) -> DynamicExpression:...
        @typing.overload
        def __call__(self, binder: CallSiteBinder, returnType: typing.Type[typing.Any], arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> DynamicExpression:...

    # Skipped ElementInit due to it being static, abstract and generic.

    ElementInit : ElementInit_MethodGroup
    class ElementInit_MethodGroup:
        @typing.overload
        def __call__(self, addMethod: MethodInfo, arguments: Array_1[Expression]) -> ElementInit:...
        @typing.overload
        def __call__(self, addMethod: MethodInfo, arguments: IEnumerable_1[Expression]) -> ElementInit:...

    # Skipped Equal due to it being static, abstract and generic.

    Equal : Equal_MethodGroup
    class Equal_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, liftToNull: bool, method: MethodInfo) -> BinaryExpression:...

    # Skipped ExclusiveOr due to it being static, abstract and generic.

    ExclusiveOr : ExclusiveOr_MethodGroup
    class ExclusiveOr_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped ExclusiveOrAssign due to it being static, abstract and generic.

    ExclusiveOrAssign : ExclusiveOrAssign_MethodGroup
    class ExclusiveOrAssign_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped Field due to it being static, abstract and generic.

    Field : Field_MethodGroup
    class Field_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression, field: FieldInfo) -> MemberExpression:...
        @typing.overload
        def __call__(self, expression: Expression, fieldName: str) -> MemberExpression:...
        @typing.overload
        def __call__(self, expression: Expression, type: typing.Type[typing.Any], fieldName: str) -> MemberExpression:...

    # Skipped Goto due to it being static, abstract and generic.

    Goto : Goto_MethodGroup
    class Goto_MethodGroup:
        @typing.overload
        def __call__(self, target: LabelTarget) -> GotoExpression:...
        @typing.overload
        def __call__(self, target: LabelTarget, type: typing.Type[typing.Any]) -> GotoExpression:...
        @typing.overload
        def __call__(self, target: LabelTarget, value: Expression) -> GotoExpression:...
        @typing.overload
        def __call__(self, target: LabelTarget, value: Expression, type: typing.Type[typing.Any]) -> GotoExpression:...

    # Skipped GreaterThan due to it being static, abstract and generic.

    GreaterThan : GreaterThan_MethodGroup
    class GreaterThan_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, liftToNull: bool, method: MethodInfo) -> BinaryExpression:...

    # Skipped GreaterThanOrEqual due to it being static, abstract and generic.

    GreaterThanOrEqual : GreaterThanOrEqual_MethodGroup
    class GreaterThanOrEqual_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, liftToNull: bool, method: MethodInfo) -> BinaryExpression:...

    # Skipped Increment due to it being static, abstract and generic.

    Increment : Increment_MethodGroup
    class Increment_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped Invoke due to it being static, abstract and generic.

    Invoke : Invoke_MethodGroup
    class Invoke_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression, arguments: Array_1[Expression]) -> InvocationExpression:...
        @typing.overload
        def __call__(self, expression: Expression, arguments: IEnumerable_1[Expression]) -> InvocationExpression:...

    # Skipped IsFalse due to it being static, abstract and generic.

    IsFalse : IsFalse_MethodGroup
    class IsFalse_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped IsTrue due to it being static, abstract and generic.

    IsTrue : IsTrue_MethodGroup
    class IsTrue_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped Label due to it being static, abstract and generic.

    Label : Label_MethodGroup
    class Label_MethodGroup:
        @typing.overload
        def __call__(self) -> LabelTarget:...
        @typing.overload
        def __call__(self, name: str) -> LabelTarget:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> LabelTarget:...
        @typing.overload
        def __call__(self, target: LabelTarget) -> LabelExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], name: str) -> LabelTarget:...
        @typing.overload
        def __call__(self, target: LabelTarget, defaultValue: Expression) -> LabelExpression:...

    # Skipped Lambda due to it being static, abstract and generic.

    Lambda : Lambda_MethodGroup
    class Lambda_MethodGroup:
        def __getitem__(self, t:typing.Type[Lambda_1_T1]) -> Lambda_1[Lambda_1_T1]: ...

        Lambda_1_T1 = typing.TypeVar('Lambda_1_T1')
        class Lambda_1(typing.Generic[Lambda_1_T1]):
            Lambda_1_TDelegate = Expression_0.Lambda_MethodGroup.Lambda_1_T1
            @typing.overload
            def __call__(self, body: Expression, parameters: Array_1[ParameterExpression]) -> Expression_1[Lambda_1_TDelegate]:...
            @typing.overload
            def __call__(self, body: Expression, parameters: IEnumerable_1[ParameterExpression]) -> Expression_1[Lambda_1_TDelegate]:...
            @typing.overload
            def __call__(self, body: Expression, tailCall: bool, parameters: Array_1[ParameterExpression]) -> Expression_1[Lambda_1_TDelegate]:...
            @typing.overload
            def __call__(self, body: Expression, name: str, parameters: IEnumerable_1[ParameterExpression]) -> Expression_1[Lambda_1_TDelegate]:...
            @typing.overload
            def __call__(self, body: Expression, tailCall: bool, parameters: IEnumerable_1[ParameterExpression]) -> Expression_1[Lambda_1_TDelegate]:...
            @typing.overload
            def __call__(self, body: Expression, name: str, tailCall: bool, parameters: IEnumerable_1[ParameterExpression]) -> Expression_1[Lambda_1_TDelegate]:...

        @typing.overload
        def __call__(self, body: Expression, parameters: Array_1[ParameterExpression]) -> LambdaExpression:...
        @typing.overload
        def __call__(self, body: Expression, parameters: IEnumerable_1[ParameterExpression]) -> LambdaExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], body: Expression, parameters: Array_1[ParameterExpression]) -> LambdaExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], body: Expression, parameters: IEnumerable_1[ParameterExpression]) -> LambdaExpression:...
        @typing.overload
        def __call__(self, body: Expression, tailCall: bool, parameters: Array_1[ParameterExpression]) -> LambdaExpression:...
        @typing.overload
        def __call__(self, body: Expression, name: str, parameters: IEnumerable_1[ParameterExpression]) -> LambdaExpression:...
        @typing.overload
        def __call__(self, body: Expression, tailCall: bool, parameters: IEnumerable_1[ParameterExpression]) -> LambdaExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], body: Expression, tailCall: bool, parameters: Array_1[ParameterExpression]) -> LambdaExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], body: Expression, name: str, parameters: IEnumerable_1[ParameterExpression]) -> LambdaExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], body: Expression, tailCall: bool, parameters: IEnumerable_1[ParameterExpression]) -> LambdaExpression:...
        @typing.overload
        def __call__(self, body: Expression, name: str, tailCall: bool, parameters: IEnumerable_1[ParameterExpression]) -> LambdaExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], body: Expression, name: str, tailCall: bool, parameters: IEnumerable_1[ParameterExpression]) -> LambdaExpression:...

    # Skipped LeftShift due to it being static, abstract and generic.

    LeftShift : LeftShift_MethodGroup
    class LeftShift_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped LeftShiftAssign due to it being static, abstract and generic.

    LeftShiftAssign : LeftShiftAssign_MethodGroup
    class LeftShiftAssign_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped LessThan due to it being static, abstract and generic.

    LessThan : LessThan_MethodGroup
    class LessThan_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, liftToNull: bool, method: MethodInfo) -> BinaryExpression:...

    # Skipped LessThanOrEqual due to it being static, abstract and generic.

    LessThanOrEqual : LessThanOrEqual_MethodGroup
    class LessThanOrEqual_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, liftToNull: bool, method: MethodInfo) -> BinaryExpression:...

    # Skipped ListBind due to it being static, abstract and generic.

    ListBind : ListBind_MethodGroup
    class ListBind_MethodGroup:
        @typing.overload
        def __call__(self, propertyAccessor: MethodInfo, initializers: Array_1[ElementInit]) -> MemberListBinding:...
        @typing.overload
        def __call__(self, propertyAccessor: MethodInfo, initializers: IEnumerable_1[ElementInit]) -> MemberListBinding:...
        @typing.overload
        def __call__(self, member: MemberInfo, initializers: Array_1[ElementInit]) -> MemberListBinding:...
        @typing.overload
        def __call__(self, member: MemberInfo, initializers: IEnumerable_1[ElementInit]) -> MemberListBinding:...

    # Skipped ListInit due to it being static, abstract and generic.

    ListInit : ListInit_MethodGroup
    class ListInit_MethodGroup:
        @typing.overload
        def __call__(self, newExpression: NewExpression, initializers: Array_1[Expression]) -> ListInitExpression:...
        @typing.overload
        def __call__(self, newExpression: NewExpression, initializers: Array_1[ElementInit]) -> ListInitExpression:...
        @typing.overload
        def __call__(self, newExpression: NewExpression, initializers: IEnumerable_1[ElementInit]) -> ListInitExpression:...
        @typing.overload
        def __call__(self, newExpression: NewExpression, initializers: IEnumerable_1[Expression]) -> ListInitExpression:...
        @typing.overload
        def __call__(self, newExpression: NewExpression, addMethod: MethodInfo, initializers: Array_1[Expression]) -> ListInitExpression:...
        @typing.overload
        def __call__(self, newExpression: NewExpression, addMethod: MethodInfo, initializers: IEnumerable_1[Expression]) -> ListInitExpression:...

    # Skipped Loop due to it being static, abstract and generic.

    Loop : Loop_MethodGroup
    class Loop_MethodGroup:
        @typing.overload
        def __call__(self, body: Expression) -> LoopExpression:...
        # FIXME: Document "break" rename
        @typing.overload
        def __call__(self, body: Expression, break_: LabelTarget) -> LoopExpression:...
        # FIXME: Document "break" and "continue" rename
        @typing.overload
        def __call__(self, body: Expression, break_: LabelTarget, continue_: LabelTarget) -> LoopExpression:...

    # Skipped MakeBinary due to it being static, abstract and generic.

    MakeBinary : MakeBinary_MethodGroup
    class MakeBinary_MethodGroup:
        @typing.overload
        def __call__(self, binaryType: ExpressionType, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: bool, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: bool, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped MakeDynamic due to it being static, abstract and generic.

    MakeDynamic : MakeDynamic_MethodGroup
    class MakeDynamic_MethodGroup:
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], binder: CallSiteBinder, arguments: Array_1[Expression]) -> DynamicExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], binder: CallSiteBinder, arguments: IEnumerable_1[Expression]) -> DynamicExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], binder: CallSiteBinder, arg0: Expression) -> DynamicExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], binder: CallSiteBinder, arg0: Expression, arg1: Expression) -> DynamicExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression) -> DynamicExpression:...
        @typing.overload
        def __call__(self, delegateType: typing.Type[typing.Any], binder: CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> DynamicExpression:...

    # Skipped MakeUnary due to it being static, abstract and generic.

    MakeUnary : MakeUnary_MethodGroup
    class MakeUnary_MethodGroup:
        @typing.overload
        def __call__(self, unaryType: ExpressionType, operand: Expression, type: typing.Type[typing.Any]) -> UnaryExpression:...
        @typing.overload
        def __call__(self, unaryType: ExpressionType, operand: Expression, type: typing.Type[typing.Any], method: MethodInfo) -> UnaryExpression:...

    # Skipped MemberBind due to it being static, abstract and generic.

    MemberBind : MemberBind_MethodGroup
    class MemberBind_MethodGroup:
        @typing.overload
        def __call__(self, propertyAccessor: MethodInfo, bindings: Array_1[MemberBinding]) -> MemberMemberBinding:...
        @typing.overload
        def __call__(self, propertyAccessor: MethodInfo, bindings: IEnumerable_1[MemberBinding]) -> MemberMemberBinding:...
        @typing.overload
        def __call__(self, member: MemberInfo, bindings: Array_1[MemberBinding]) -> MemberMemberBinding:...
        @typing.overload
        def __call__(self, member: MemberInfo, bindings: IEnumerable_1[MemberBinding]) -> MemberMemberBinding:...

    # Skipped MemberInit due to it being static, abstract and generic.

    MemberInit : MemberInit_MethodGroup
    class MemberInit_MethodGroup:
        @typing.overload
        def __call__(self, newExpression: NewExpression, bindings: Array_1[MemberBinding]) -> MemberInitExpression:...
        @typing.overload
        def __call__(self, newExpression: NewExpression, bindings: IEnumerable_1[MemberBinding]) -> MemberInitExpression:...

    # Skipped Modulo due to it being static, abstract and generic.

    Modulo : Modulo_MethodGroup
    class Modulo_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped ModuloAssign due to it being static, abstract and generic.

    ModuloAssign : ModuloAssign_MethodGroup
    class ModuloAssign_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped Multiply due to it being static, abstract and generic.

    Multiply : Multiply_MethodGroup
    class Multiply_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped MultiplyAssign due to it being static, abstract and generic.

    MultiplyAssign : MultiplyAssign_MethodGroup
    class MultiplyAssign_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped MultiplyAssignChecked due to it being static, abstract and generic.

    MultiplyAssignChecked : MultiplyAssignChecked_MethodGroup
    class MultiplyAssignChecked_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped MultiplyChecked due to it being static, abstract and generic.

    MultiplyChecked : MultiplyChecked_MethodGroup
    class MultiplyChecked_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped Negate due to it being static, abstract and generic.

    Negate : Negate_MethodGroup
    class Negate_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped NegateChecked due to it being static, abstract and generic.

    NegateChecked : NegateChecked_MethodGroup
    class NegateChecked_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped New due to it being static, abstract and generic.

    New : New_MethodGroup
    class New_MethodGroup:
        @typing.overload
        def __call__(self, constructor: ConstructorInfo) -> NewExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> NewExpression:...
        @typing.overload
        def __call__(self, constructor: ConstructorInfo, arguments: Array_1[Expression]) -> NewExpression:...
        @typing.overload
        def __call__(self, constructor: ConstructorInfo, arguments: IEnumerable_1[Expression]) -> NewExpression:...
        @typing.overload
        def __call__(self, constructor: ConstructorInfo, arguments: IEnumerable_1[Expression], members: Array_1[MemberInfo]) -> NewExpression:...
        @typing.overload
        def __call__(self, constructor: ConstructorInfo, arguments: IEnumerable_1[Expression], members: IEnumerable_1[MemberInfo]) -> NewExpression:...

    # Skipped NewArrayBounds due to it being static, abstract and generic.

    NewArrayBounds : NewArrayBounds_MethodGroup
    class NewArrayBounds_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], bounds: Array_1[Expression]) -> NewArrayExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], bounds: IEnumerable_1[Expression]) -> NewArrayExpression:...

    # Skipped NewArrayInit due to it being static, abstract and generic.

    NewArrayInit : NewArrayInit_MethodGroup
    class NewArrayInit_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], initializers: Array_1[Expression]) -> NewArrayExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], initializers: IEnumerable_1[Expression]) -> NewArrayExpression:...

    # Skipped Not due to it being static, abstract and generic.

    Not : Not_MethodGroup
    class Not_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped NotEqual due to it being static, abstract and generic.

    NotEqual : NotEqual_MethodGroup
    class NotEqual_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, liftToNull: bool, method: MethodInfo) -> BinaryExpression:...

    # Skipped OnesComplement due to it being static, abstract and generic.

    OnesComplement : OnesComplement_MethodGroup
    class OnesComplement_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped Or due to it being static, abstract and generic.

    Or : Or_MethodGroup
    class Or_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped OrAssign due to it being static, abstract and generic.

    OrAssign : OrAssign_MethodGroup
    class OrAssign_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped OrElse due to it being static, abstract and generic.

    OrElse : OrElse_MethodGroup
    class OrElse_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped Parameter due to it being static, abstract and generic.

    Parameter : Parameter_MethodGroup
    class Parameter_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> ParameterExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], name: str) -> ParameterExpression:...

    # Skipped PostDecrementAssign due to it being static, abstract and generic.

    PostDecrementAssign : PostDecrementAssign_MethodGroup
    class PostDecrementAssign_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped PostIncrementAssign due to it being static, abstract and generic.

    PostIncrementAssign : PostIncrementAssign_MethodGroup
    class PostIncrementAssign_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped Power due to it being static, abstract and generic.

    Power : Power_MethodGroup
    class Power_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped PowerAssign due to it being static, abstract and generic.

    PowerAssign : PowerAssign_MethodGroup
    class PowerAssign_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped PreDecrementAssign due to it being static, abstract and generic.

    PreDecrementAssign : PreDecrementAssign_MethodGroup
    class PreDecrementAssign_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped PreIncrementAssign due to it being static, abstract and generic.

    PreIncrementAssign : PreIncrementAssign_MethodGroup
    class PreIncrementAssign_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped Property due to it being static, abstract and generic.

    Property : Property_MethodGroup
    class Property_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression, propertyAccessor: MethodInfo) -> MemberExpression:...
        @typing.overload
        def __call__(self, expression: Expression, property: PropertyInfo) -> MemberExpression:...
        @typing.overload
        def __call__(self, expression: Expression, propertyName: str) -> MemberExpression:...
        @typing.overload
        def __call__(self, instance: Expression, indexer: PropertyInfo, arguments: Array_1[Expression]) -> IndexExpression:...
        @typing.overload
        def __call__(self, instance: Expression, propertyName: str, arguments: Array_1[Expression]) -> IndexExpression:...
        @typing.overload
        def __call__(self, expression: Expression, type: typing.Type[typing.Any], propertyName: str) -> MemberExpression:...
        @typing.overload
        def __call__(self, instance: Expression, indexer: PropertyInfo, arguments: IEnumerable_1[Expression]) -> IndexExpression:...

    # Skipped Rethrow due to it being static, abstract and generic.

    Rethrow : Rethrow_MethodGroup
    class Rethrow_MethodGroup:
        @typing.overload
        def __call__(self) -> UnaryExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> UnaryExpression:...

    # Skipped Return due to it being static, abstract and generic.

    Return : Return_MethodGroup
    class Return_MethodGroup:
        @typing.overload
        def __call__(self, target: LabelTarget) -> GotoExpression:...
        @typing.overload
        def __call__(self, target: LabelTarget, type: typing.Type[typing.Any]) -> GotoExpression:...
        @typing.overload
        def __call__(self, target: LabelTarget, value: Expression) -> GotoExpression:...
        @typing.overload
        def __call__(self, target: LabelTarget, value: Expression, type: typing.Type[typing.Any]) -> GotoExpression:...

    # Skipped RightShift due to it being static, abstract and generic.

    RightShift : RightShift_MethodGroup
    class RightShift_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped RightShiftAssign due to it being static, abstract and generic.

    RightShiftAssign : RightShiftAssign_MethodGroup
    class RightShiftAssign_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped RuntimeVariables due to it being static, abstract and generic.

    RuntimeVariables : RuntimeVariables_MethodGroup
    class RuntimeVariables_MethodGroup:
        @typing.overload
        def __call__(self, variables: Array_1[ParameterExpression]) -> RuntimeVariablesExpression:...
        @typing.overload
        def __call__(self, variables: IEnumerable_1[ParameterExpression]) -> RuntimeVariablesExpression:...

    # Skipped Subtract due to it being static, abstract and generic.

    Subtract : Subtract_MethodGroup
    class Subtract_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped SubtractAssign due to it being static, abstract and generic.

    SubtractAssign : SubtractAssign_MethodGroup
    class SubtractAssign_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped SubtractAssignChecked due to it being static, abstract and generic.

    SubtractAssignChecked : SubtractAssignChecked_MethodGroup
    class SubtractAssignChecked_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo, conversion: LambdaExpression) -> BinaryExpression:...

    # Skipped SubtractChecked due to it being static, abstract and generic.

    SubtractChecked : SubtractChecked_MethodGroup
    class SubtractChecked_MethodGroup:
        @typing.overload
        def __call__(self, left: Expression, right: Expression) -> BinaryExpression:...
        @typing.overload
        def __call__(self, left: Expression, right: Expression, method: MethodInfo) -> BinaryExpression:...

    # Skipped Switch due to it being static, abstract and generic.

    Switch : Switch_MethodGroup
    class Switch_MethodGroup:
        @typing.overload
        def __call__(self, switchValue: Expression, cases: Array_1[SwitchCase]) -> SwitchExpression:...
        @typing.overload
        def __call__(self, switchValue: Expression, defaultBody: Expression, cases: Array_1[SwitchCase]) -> SwitchExpression:...
        @typing.overload
        def __call__(self, switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: Array_1[SwitchCase]) -> SwitchExpression:...
        @typing.overload
        def __call__(self, switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: IEnumerable_1[SwitchCase]) -> SwitchExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: Array_1[SwitchCase]) -> SwitchExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], switchValue: Expression, defaultBody: Expression, comparison: MethodInfo, cases: IEnumerable_1[SwitchCase]) -> SwitchExpression:...

    # Skipped SwitchCase due to it being static, abstract and generic.

    SwitchCase : SwitchCase_MethodGroup
    class SwitchCase_MethodGroup:
        @typing.overload
        def __call__(self, body: Expression, testValues: Array_1[Expression]) -> SwitchCase:...
        @typing.overload
        def __call__(self, body: Expression, testValues: IEnumerable_1[Expression]) -> SwitchCase:...

    # Skipped SymbolDocument due to it being static, abstract and generic.

    SymbolDocument : SymbolDocument_MethodGroup
    class SymbolDocument_MethodGroup:
        @typing.overload
        def __call__(self, fileName: str) -> SymbolDocumentInfo:...
        @typing.overload
        def __call__(self, fileName: str, language: Guid) -> SymbolDocumentInfo:...
        @typing.overload
        def __call__(self, fileName: str, language: Guid, languageVendor: Guid) -> SymbolDocumentInfo:...
        @typing.overload
        def __call__(self, fileName: str, language: Guid, languageVendor: Guid, documentType: Guid) -> SymbolDocumentInfo:...

    # Skipped Throw due to it being static, abstract and generic.

    Throw : Throw_MethodGroup
    class Throw_MethodGroup:
        @typing.overload
        def __call__(self, value: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, value: Expression, type: typing.Type[typing.Any]) -> UnaryExpression:...

    # Skipped UnaryPlus due to it being static, abstract and generic.

    UnaryPlus : UnaryPlus_MethodGroup
    class UnaryPlus_MethodGroup:
        @typing.overload
        def __call__(self, expression: Expression) -> UnaryExpression:...
        @typing.overload
        def __call__(self, expression: Expression, method: MethodInfo) -> UnaryExpression:...

    # Skipped Variable due to it being static, abstract and generic.

    Variable : Variable_MethodGroup
    class Variable_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> ParameterExpression:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], name: str) -> ParameterExpression:...



Expression_1_TDelegate = typing.TypeVar('Expression_1_TDelegate')
class Expression_1(typing.Generic[Expression_1_TDelegate], LambdaExpression):
    @property
    def Body(self) -> Expression: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Parameters(self) -> ReadOnlyCollection_1[ParameterExpression]: ...
    @property
    def ReturnType(self) -> typing.Type[typing.Any]: ...
    @property
    def TailCall(self) -> bool: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def Update(self, body: Expression, parameters: IEnumerable_1[ParameterExpression]) -> Expression_1[Expression_1_TDelegate]: ...
    # Skipped Compile due to it being static, abstract and generic.

    Compile : Compile_MethodGroup[Expression_1_TDelegate]
    Compile_MethodGroup_Expression_1_TDelegate = typing.TypeVar('Compile_MethodGroup_Expression_1_TDelegate')
    class Compile_MethodGroup(typing.Generic[Compile_MethodGroup_Expression_1_TDelegate]):
        Compile_MethodGroup_Expression_1_TDelegate = Expression_1.Compile_MethodGroup_Expression_1_TDelegate
        @typing.overload
        def __call__(self) -> Compile_MethodGroup_Expression_1_TDelegate:...
        # Method Compile() was skipped since it collides with above method
        @typing.overload
        def __call__(self, preferInterpretation: bool) -> Compile_MethodGroup_Expression_1_TDelegate:...
        # Method Compile(preferInterpretation : Boolean) was skipped since it collides with above method
        @typing.overload
        def __call__(self, debugInfoGenerator: DebugInfoGenerator) -> Compile_MethodGroup_Expression_1_TDelegate:...
        # Method Compile(debugInfoGenerator : DebugInfoGenerator) was skipped since it collides with above method



class ExpressionType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Add : ExpressionType # 0
    AddChecked : ExpressionType # 1
    And : ExpressionType # 2
    AndAlso : ExpressionType # 3
    ArrayLength : ExpressionType # 4
    ArrayIndex : ExpressionType # 5
    Call : ExpressionType # 6
    Coalesce : ExpressionType # 7
    Conditional : ExpressionType # 8
    Constant : ExpressionType # 9
    Convert : ExpressionType # 10
    ConvertChecked : ExpressionType # 11
    Divide : ExpressionType # 12
    Equal : ExpressionType # 13
    ExclusiveOr : ExpressionType # 14
    GreaterThan : ExpressionType # 15
    GreaterThanOrEqual : ExpressionType # 16
    Invoke : ExpressionType # 17
    Lambda : ExpressionType # 18
    LeftShift : ExpressionType # 19
    LessThan : ExpressionType # 20
    LessThanOrEqual : ExpressionType # 21
    ListInit : ExpressionType # 22
    MemberAccess : ExpressionType # 23
    MemberInit : ExpressionType # 24
    Modulo : ExpressionType # 25
    Multiply : ExpressionType # 26
    MultiplyChecked : ExpressionType # 27
    Negate : ExpressionType # 28
    UnaryPlus : ExpressionType # 29
    NegateChecked : ExpressionType # 30
    New : ExpressionType # 31
    NewArrayInit : ExpressionType # 32
    NewArrayBounds : ExpressionType # 33
    Not : ExpressionType # 34
    NotEqual : ExpressionType # 35
    Or : ExpressionType # 36
    OrElse : ExpressionType # 37
    Parameter : ExpressionType # 38
    Power : ExpressionType # 39
    Quote : ExpressionType # 40
    RightShift : ExpressionType # 41
    Subtract : ExpressionType # 42
    SubtractChecked : ExpressionType # 43
    TypeAs : ExpressionType # 44
    TypeIs : ExpressionType # 45
    Assign : ExpressionType # 46
    Block : ExpressionType # 47
    DebugInfo : ExpressionType # 48
    Decrement : ExpressionType # 49
    Dynamic : ExpressionType # 50
    Default : ExpressionType # 51
    Extension : ExpressionType # 52
    Goto : ExpressionType # 53
    Increment : ExpressionType # 54
    Index : ExpressionType # 55
    Label : ExpressionType # 56
    RuntimeVariables : ExpressionType # 57
    Loop : ExpressionType # 58
    Switch : ExpressionType # 59
    Throw : ExpressionType # 60
    Try : ExpressionType # 61
    Unbox : ExpressionType # 62
    AddAssign : ExpressionType # 63
    AndAssign : ExpressionType # 64
    DivideAssign : ExpressionType # 65
    ExclusiveOrAssign : ExpressionType # 66
    LeftShiftAssign : ExpressionType # 67
    ModuloAssign : ExpressionType # 68
    MultiplyAssign : ExpressionType # 69
    OrAssign : ExpressionType # 70
    PowerAssign : ExpressionType # 71
    RightShiftAssign : ExpressionType # 72
    SubtractAssign : ExpressionType # 73
    AddAssignChecked : ExpressionType # 74
    MultiplyAssignChecked : ExpressionType # 75
    SubtractAssignChecked : ExpressionType # 76
    PreIncrementAssign : ExpressionType # 77
    PreDecrementAssign : ExpressionType # 78
    PostIncrementAssign : ExpressionType # 79
    PostDecrementAssign : ExpressionType # 80
    TypeEqual : ExpressionType # 81
    OnesComplement : ExpressionType # 82
    IsTrue : ExpressionType # 83
    IsFalse : ExpressionType # 84


class ExpressionVisitor(abc.ABC):
    # Skipped Visit due to it being static, abstract and generic.

    Visit : Visit_MethodGroup
    class Visit_MethodGroup:
        def __getitem__(self, t:typing.Type[Visit_1_T1]) -> Visit_1[Visit_1_T1]: ...

        Visit_1_T1 = typing.TypeVar('Visit_1_T1')
        class Visit_1(typing.Generic[Visit_1_T1]):
            Visit_1_T = ExpressionVisitor.Visit_MethodGroup.Visit_1_T1
            def __call__(self, nodes: ReadOnlyCollection_1[Visit_1_T], elementVisitor: Func_2[Visit_1_T, Visit_1_T]) -> ReadOnlyCollection_1[Visit_1_T]:...

        @typing.overload
        def __call__(self, nodes: ReadOnlyCollection_1[Expression]) -> ReadOnlyCollection_1[Expression]:...
        @typing.overload
        def __call__(self, node: Expression) -> Expression:...

    # Skipped VisitAndConvert due to it being static, abstract and generic.

    VisitAndConvert : VisitAndConvert_MethodGroup
    class VisitAndConvert_MethodGroup:
        def __getitem__(self, t:typing.Type[VisitAndConvert_1_T1]) -> VisitAndConvert_1[VisitAndConvert_1_T1]: ...

        VisitAndConvert_1_T1 = typing.TypeVar('VisitAndConvert_1_T1')
        class VisitAndConvert_1(typing.Generic[VisitAndConvert_1_T1]):
            VisitAndConvert_1_T = ExpressionVisitor.VisitAndConvert_MethodGroup.VisitAndConvert_1_T1
            @typing.overload
            def __call__(self, nodes: ReadOnlyCollection_1[VisitAndConvert_1_T], callerName: str) -> ReadOnlyCollection_1[VisitAndConvert_1_T]:...
            @typing.overload
            def __call__(self, node: VisitAndConvert_1_T, callerName: str) -> VisitAndConvert_1_T:...




class GotoExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Kind(self) -> GotoExpressionKind: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Target(self) -> LabelTarget: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    @property
    def Value(self) -> Expression: ...
    def Update(self, target: LabelTarget, value: Expression) -> GotoExpression: ...


class GotoExpressionKind(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Goto : GotoExpressionKind # 0
    Return : GotoExpressionKind # 1
    Break : GotoExpressionKind # 2
    Continue : GotoExpressionKind # 3


class IArgumentProvider(typing.Protocol):
    @property
    def ArgumentCount(self) -> int: ...
    @abc.abstractmethod
    def GetArgument(self, index: int) -> Expression: ...


class IDynamicExpression(IArgumentProvider, typing.Protocol):
    @property
    def DelegateType(self) -> typing.Type[typing.Any]: ...
    @abc.abstractmethod
    def CreateCallSite(self) -> typing.Any: ...
    @abc.abstractmethod
    def Rewrite(self, args: Array_1[Expression]) -> Expression: ...


class IndexExpression(Expression_0, IArgumentProvider):
    @property
    def ArgumentCount(self) -> int: ...
    @property
    def Arguments(self) -> ReadOnlyCollection_1[Expression]: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Indexer(self) -> PropertyInfo: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Object(self) -> Expression: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def GetArgument(self, index: int) -> Expression: ...
    def Update(self, object: Expression, arguments: IEnumerable_1[Expression]) -> IndexExpression: ...


class InvocationExpression(Expression_0, IArgumentProvider):
    @property
    def ArgumentCount(self) -> int: ...
    @property
    def Arguments(self) -> ReadOnlyCollection_1[Expression]: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Expression(self) -> Expression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def GetArgument(self, index: int) -> Expression: ...
    def Update(self, expression: Expression, arguments: IEnumerable_1[Expression]) -> InvocationExpression: ...


class LabelExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def DefaultValue(self) -> Expression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Target(self) -> LabelTarget: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def Update(self, target: LabelTarget, defaultValue: Expression) -> LabelExpression: ...


class LabelTarget:
    @property
    def Name(self) -> str: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def ToString(self) -> str: ...


class LambdaExpression(Expression_0):
    @property
    def Body(self) -> Expression: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Parameters(self) -> ReadOnlyCollection_1[ParameterExpression]: ...
    @property
    def ReturnType(self) -> typing.Type[typing.Any]: ...
    @property
    def TailCall(self) -> bool: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    # Skipped Compile due to it being static, abstract and generic.

    Compile : Compile_MethodGroup
    class Compile_MethodGroup:
        @typing.overload
        def __call__(self) -> Delegate:...
        @typing.overload
        def __call__(self, preferInterpretation: bool) -> Delegate:...
        @typing.overload
        def __call__(self, debugInfoGenerator: DebugInfoGenerator) -> Delegate:...



class ListInitExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Initializers(self) -> ReadOnlyCollection_1[ElementInit]: ...
    @property
    def NewExpression(self) -> NewExpression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def Reduce(self) -> Expression: ...
    def Update(self, newExpression: NewExpression, initializers: IEnumerable_1[ElementInit]) -> ListInitExpression: ...


class LoopExpression(Expression_0):
    @property
    def Body(self) -> Expression: ...
    @property
    def BreakLabel(self) -> LabelTarget: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def ContinueLabel(self) -> LabelTarget: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def Update(self, breakLabel: LabelTarget, continueLabel: LabelTarget, body: Expression) -> LoopExpression: ...


class MemberAssignment(MemberBinding):
    @property
    def BindingType(self) -> MemberBindingType: ...
    @property
    def Expression(self) -> Expression: ...
    @property
    def Member(self) -> MemberInfo: ...
    def Update(self, expression: Expression) -> MemberAssignment: ...


class MemberBinding(abc.ABC):
    @property
    def BindingType(self) -> MemberBindingType: ...
    @property
    def Member(self) -> MemberInfo: ...
    def ToString(self) -> str: ...


class MemberBindingType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Assignment : MemberBindingType # 0
    MemberBinding : MemberBindingType # 1
    ListBinding : MemberBindingType # 2


class MemberExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Expression(self) -> Expression: ...
    @property
    def Member(self) -> MemberInfo: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def Update(self, expression: Expression) -> MemberExpression: ...


class MemberInitExpression(Expression_0):
    @property
    def Bindings(self) -> ReadOnlyCollection_1[MemberBinding]: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def NewExpression(self) -> NewExpression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def Reduce(self) -> Expression: ...
    def Update(self, newExpression: NewExpression, bindings: IEnumerable_1[MemberBinding]) -> MemberInitExpression: ...


class MemberListBinding(MemberBinding):
    @property
    def BindingType(self) -> MemberBindingType: ...
    @property
    def Initializers(self) -> ReadOnlyCollection_1[ElementInit]: ...
    @property
    def Member(self) -> MemberInfo: ...
    def Update(self, initializers: IEnumerable_1[ElementInit]) -> MemberListBinding: ...


class MemberMemberBinding(MemberBinding):
    @property
    def Bindings(self) -> ReadOnlyCollection_1[MemberBinding]: ...
    @property
    def BindingType(self) -> MemberBindingType: ...
    @property
    def Member(self) -> MemberInfo: ...
    def Update(self, bindings: IEnumerable_1[MemberBinding]) -> MemberMemberBinding: ...


class MethodCallExpression(Expression_0, IArgumentProvider):
    @property
    def ArgumentCount(self) -> int: ...
    @property
    def Arguments(self) -> ReadOnlyCollection_1[Expression]: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Object(self) -> Expression: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def GetArgument(self, index: int) -> Expression: ...
    def Update(self, object: Expression, arguments: IEnumerable_1[Expression]) -> MethodCallExpression: ...


class NewArrayExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Expressions(self) -> ReadOnlyCollection_1[Expression]: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def Update(self, expressions: IEnumerable_1[Expression]) -> NewArrayExpression: ...


class NewExpression(Expression_0, IArgumentProvider):
    @property
    def ArgumentCount(self) -> int: ...
    @property
    def Arguments(self) -> ReadOnlyCollection_1[Expression]: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Constructor(self) -> ConstructorInfo: ...
    @property
    def Members(self) -> ReadOnlyCollection_1[MemberInfo]: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def GetArgument(self, index: int) -> Expression: ...
    def Update(self, arguments: IEnumerable_1[Expression]) -> NewExpression: ...


class ParameterExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def IsByRef(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...


class RuntimeVariablesExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    @property
    def Variables(self) -> ReadOnlyCollection_1[ParameterExpression]: ...
    def Update(self, variables: IEnumerable_1[ParameterExpression]) -> RuntimeVariablesExpression: ...


class SwitchCase:
    @property
    def Body(self) -> Expression: ...
    @property
    def TestValues(self) -> ReadOnlyCollection_1[Expression]: ...
    def ToString(self) -> str: ...
    def Update(self, testValues: IEnumerable_1[Expression], body: Expression) -> SwitchCase: ...


class SwitchExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Cases(self) -> ReadOnlyCollection_1[SwitchCase]: ...
    @property
    def Comparison(self) -> MethodInfo: ...
    @property
    def DefaultBody(self) -> Expression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def SwitchValue(self) -> Expression: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def Update(self, switchValue: Expression, cases: IEnumerable_1[SwitchCase], defaultBody: Expression) -> SwitchExpression: ...


class SymbolDocumentInfo:
    @property
    def DocumentType(self) -> Guid: ...
    @property
    def FileName(self) -> str: ...
    @property
    def Language(self) -> Guid: ...
    @property
    def LanguageVendor(self) -> Guid: ...


class TryExpression(Expression_0):
    @property
    def Body(self) -> Expression: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Fault(self) -> Expression: ...
    @property
    def Finally(self) -> Expression: ...
    @property
    def Handlers(self) -> ReadOnlyCollection_1[CatchBlock]: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    # FIXME: Document "finally" rename
    def Update(self, body: Expression, handlers: IEnumerable_1[CatchBlock], finally_: Expression, fault: Expression) -> TryExpression: ...


class TypeBinaryExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Expression(self) -> Expression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    @property
    def TypeOperand(self) -> typing.Type[typing.Any]: ...
    def Update(self, expression: Expression) -> TypeBinaryExpression: ...


class UnaryExpression(Expression_0):
    @property
    def CanReduce(self) -> bool: ...
    @property
    def IsLifted(self) -> bool: ...
    @property
    def IsLiftedToNull(self) -> bool: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Operand(self) -> Expression: ...
    @property
    def Type(self) -> typing.Type[typing.Any]: ...
    def Reduce(self) -> Expression: ...
    def Update(self, operand: Expression) -> UnaryExpression: ...

