import typing, abc
from System.Collections import SortedList, Hashtable, IDictionary, ICollection, IDictionaryEnumerator, IComparer, IEnumerator, IEqualityComparer, IHashCodeProvider, IList, IEnumerable
from System import Array, Array_1, EventArgs, MulticastDelegate, IAsyncResult, AsyncCallback
from System.Runtime.Serialization import IDeserializationCallback, ISerializable, SerializationInfo, StreamingContext
from System.Reflection import MethodInfo

class BitVector32:
    @typing.overload
    def __init__(self, data: int) -> None: ...
    @typing.overload
    def __init__(self, value: BitVector32) -> None: ...
    @property
    def Data(self) -> int: ...
    @property
    def Item(self) -> bool: ...
    @Item.setter
    def Item(self, value: bool) -> bool: ...
    @property
    def Item(self) -> int: ...
    @Item.setter
    def Item(self, value: int) -> int: ...
    def Equals(self, o: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    # Skipped CreateMask due to it being static, abstract and generic.

    CreateMask : CreateMask_MethodGroup
    class CreateMask_MethodGroup:
        @typing.overload
        def __call__(self) -> int:...
        @typing.overload
        def __call__(self, previous: int) -> int:...

    # Skipped CreateSection due to it being static, abstract and generic.

    CreateSection : CreateSection_MethodGroup
    class CreateSection_MethodGroup:
        @typing.overload
        def __call__(self, maxValue: int) -> BitVector32.Section:...
        @typing.overload
        def __call__(self, maxValue: int, previous: BitVector32.Section) -> BitVector32.Section:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, value: BitVector32) -> str:...


    class Section:
        @property
        def Mask(self) -> int: ...
        @property
        def Offset(self) -> int: ...
        def GetHashCode(self) -> int: ...
        def __eq__(self, a: BitVector32.Section, b: BitVector32.Section) -> bool: ...
        def __ne__(self, a: BitVector32.Section, b: BitVector32.Section) -> bool: ...
        # Skipped Equals due to it being static, abstract and generic.

        Equals : Equals_MethodGroup
        class Equals_MethodGroup:
            @typing.overload
            def __call__(self, obj: BitVector32.Section) -> bool:...
            @typing.overload
            def __call__(self, o: typing.Any) -> bool:...

        # Skipped ToString due to it being static, abstract and generic.

        ToString : ToString_MethodGroup
        class ToString_MethodGroup:
            @typing.overload
            def __call__(self) -> str:...
            @typing.overload
            def __call__(self, value: BitVector32.Section) -> str:...




class CollectionsUtil:
    def __init__(self) -> None: ...
    @staticmethod
    def CreateCaseInsensitiveSortedList() -> SortedList: ...
    # Skipped CreateCaseInsensitiveHashtable due to it being static, abstract and generic.

    CreateCaseInsensitiveHashtable : CreateCaseInsensitiveHashtable_MethodGroup
    class CreateCaseInsensitiveHashtable_MethodGroup:
        @typing.overload
        def __call__(self) -> Hashtable:...
        @typing.overload
        def __call__(self, capacity: int) -> Hashtable:...
        @typing.overload
        def __call__(self, d: IDictionary) -> Hashtable:...



class HybridDictionary(IDictionary):
    # Constructor .ctor(initialSize : Int32) was skipped since it collides with above method
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, caseInsensitive: bool) -> None: ...
    @typing.overload
    def __init__(self, initialSize: int, caseInsensitive: bool) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsFixedSize(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Keys(self) -> ICollection: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    @property
    def Values(self) -> ICollection: ...
    def Add(self, key: typing.Any, value: typing.Any) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, key: typing.Any) -> bool: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    def GetEnumerator(self) -> IDictionaryEnumerator: ...
    def Remove(self, key: typing.Any) -> None: ...


class INotifyCollectionChanged(typing.Protocol):
    pass


class IOrderedDictionary(IDictionary, typing.Protocol):
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @abc.abstractmethod
    def GetEnumerator(self) -> IDictionaryEnumerator: ...
    @abc.abstractmethod
    def Insert(self, index: int, key: typing.Any, value: typing.Any) -> None: ...
    @abc.abstractmethod
    def RemoveAt(self, index: int) -> None: ...


class ListDictionary(IDictionary):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, comparer: IComparer) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsFixedSize(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Keys(self) -> ICollection: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    @property
    def Values(self) -> ICollection: ...
    def Add(self, key: typing.Any, value: typing.Any) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, key: typing.Any) -> bool: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    def GetEnumerator(self) -> IDictionaryEnumerator: ...
    def Remove(self, key: typing.Any) -> None: ...

    class DictionaryNode:
        def __init__(self) -> None: ...
        key : typing.Any
        next : ListDictionary.DictionaryNode
        value : typing.Any



class NameObjectCollectionBase(ICollection, IDeserializationCallback, ISerializable, abc.ABC):
    @property
    def Count(self) -> int: ...
    @property
    def Keys(self) -> NameObjectCollectionBase.KeysCollection: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def OnDeserialization(self, sender: typing.Any) -> None: ...

    class KeysCollection(ICollection):
        @property
        def Count(self) -> int: ...
        @property
        def Item(self) -> str: ...
        def Get(self, index: int) -> str: ...
        def GetEnumerator(self) -> IEnumerator: ...



class NameValueCollection(NameObjectCollectionBase):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, capacity: int) -> None: ...
    @typing.overload
    def __init__(self, capacity: int, col: NameValueCollection) -> None: ...
    @typing.overload
    def __init__(self, capacity: int, equalityComparer: IEqualityComparer) -> None: ...
    @typing.overload
    def __init__(self, capacity: int, hashProvider: IHashCodeProvider, comparer: IComparer) -> None: ...
    @typing.overload
    def __init__(self, col: NameValueCollection) -> None: ...
    @typing.overload
    def __init__(self, equalityComparer: IEqualityComparer) -> None: ...
    @typing.overload
    def __init__(self, hashProvider: IHashCodeProvider, comparer: IComparer) -> None: ...
    @property
    def AllKeys(self) -> Array_1[str]: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> str: ...
    @Item.setter
    def Item(self, value: str) -> str: ...
    @property
    def Item(self) -> str: ...
    @property
    def Keys(self) -> NameObjectCollectionBase.KeysCollection: ...
    def Clear(self) -> None: ...
    def CopyTo(self, dest: Array, index: int) -> None: ...
    def GetKey(self, index: int) -> str: ...
    def HasKeys(self) -> bool: ...
    def Remove(self, name: str) -> None: ...
    def Set(self, name: str, value: str) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, c: NameValueCollection) -> None:...
        @typing.overload
        def __call__(self, name: str, value: str) -> None:...

    # Skipped Get due to it being static, abstract and generic.

    Get : Get_MethodGroup
    class Get_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> str:...
        @typing.overload
        def __call__(self, name: str) -> str:...

    # Skipped GetValues due to it being static, abstract and generic.

    GetValues : GetValues_MethodGroup
    class GetValues_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> Array_1[str]:...
        @typing.overload
        def __call__(self, name: str) -> Array_1[str]:...



class NotifyCollectionChangedAction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Add : NotifyCollectionChangedAction # 0
    Remove : NotifyCollectionChangedAction # 1
    Replace : NotifyCollectionChangedAction # 2
    Move : NotifyCollectionChangedAction # 3
    Reset : NotifyCollectionChangedAction # 4


class NotifyCollectionChangedEventArgs(EventArgs):
    @typing.overload
    def __init__(self, action: NotifyCollectionChangedAction) -> None: ...
    @typing.overload
    def __init__(self, action: NotifyCollectionChangedAction, changedItem: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, action: NotifyCollectionChangedAction, changedItem: typing.Any, index: int) -> None: ...
    @typing.overload
    def __init__(self, action: NotifyCollectionChangedAction, changedItem: typing.Any, index: int, oldIndex: int) -> None: ...
    @typing.overload
    def __init__(self, action: NotifyCollectionChangedAction, changedItems: IList) -> None: ...
    @typing.overload
    def __init__(self, action: NotifyCollectionChangedAction, changedItems: IList, index: int, oldIndex: int) -> None: ...
    @typing.overload
    def __init__(self, action: NotifyCollectionChangedAction, changedItems: IList, startingIndex: int) -> None: ...
    @typing.overload
    def __init__(self, action: NotifyCollectionChangedAction, newItem: typing.Any, oldItem: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, action: NotifyCollectionChangedAction, newItem: typing.Any, oldItem: typing.Any, index: int) -> None: ...
    @typing.overload
    def __init__(self, action: NotifyCollectionChangedAction, newItems: IList, oldItems: IList) -> None: ...
    @typing.overload
    def __init__(self, action: NotifyCollectionChangedAction, newItems: IList, oldItems: IList, startingIndex: int) -> None: ...
    @property
    def Action(self) -> NotifyCollectionChangedAction: ...
    @property
    def NewItems(self) -> IList: ...
    @property
    def NewStartingIndex(self) -> int: ...
    @property
    def OldItems(self) -> IList: ...
    @property
    def OldStartingIndex(self) -> int: ...


class NotifyCollectionChangedEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: NotifyCollectionChangedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: NotifyCollectionChangedEventArgs) -> None: ...


class OrderedDictionary(IOrderedDictionary, IDeserializationCallback, ISerializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, capacity: int) -> None: ...
    @typing.overload
    def __init__(self, capacity: int, comparer: IEqualityComparer) -> None: ...
    @typing.overload
    def __init__(self, comparer: IEqualityComparer) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Item(self) -> typing.Any: ...
    @Item.setter
    def Item(self, value: typing.Any) -> typing.Any: ...
    @property
    def Keys(self) -> ICollection: ...
    @property
    def Values(self) -> ICollection: ...
    def Add(self, key: typing.Any, value: typing.Any) -> None: ...
    def AsReadOnly(self) -> OrderedDictionary: ...
    def Clear(self) -> None: ...
    def Contains(self, key: typing.Any) -> bool: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    def GetEnumerator(self) -> IDictionaryEnumerator: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def Insert(self, index: int, key: typing.Any, value: typing.Any) -> None: ...
    def Remove(self, key: typing.Any) -> None: ...
    def RemoveAt(self, index: int) -> None: ...


class StringCollection(IList):
    def __init__(self) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> str: ...
    @Item.setter
    def Item(self, value: str) -> str: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    def Add(self, value: str) -> int: ...
    def AddRange(self, value: Array_1[str]) -> None: ...
    def Clear(self) -> None: ...
    def Contains(self, value: str) -> bool: ...
    def CopyTo(self, array: Array_1[str], index: int) -> None: ...
    def GetEnumerator(self) -> StringEnumerator: ...
    def IndexOf(self, value: str) -> int: ...
    def Insert(self, index: int, value: str) -> None: ...
    def Remove(self, value: str) -> None: ...
    def RemoveAt(self, index: int) -> None: ...


class StringDictionary(IEnumerable):
    def __init__(self) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsSynchronized(self) -> bool: ...
    @property
    def Item(self) -> str: ...
    @Item.setter
    def Item(self, value: str) -> str: ...
    @property
    def Keys(self) -> ICollection: ...
    @property
    def SyncRoot(self) -> typing.Any: ...
    @property
    def Values(self) -> ICollection: ...
    def Add(self, key: str, value: str) -> None: ...
    def Clear(self) -> None: ...
    def ContainsKey(self, key: str) -> bool: ...
    def ContainsValue(self, value: str) -> bool: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def Remove(self, key: str) -> None: ...


class StringEnumerator:
    @property
    def Current(self) -> str: ...
    def MoveNext(self) -> bool: ...
    def Reset(self) -> None: ...

