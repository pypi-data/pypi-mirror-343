import typing, abc
from System.IO import Stream, SeekOrigin, IOException
from System import IAsyncResult, Array_1, AsyncCallback, Span_1, Memory_1, ReadOnlySpan_1, ReadOnlyMemory_1, IDisposable, DateTimeOffset, Exception
from System.Threading.Tasks import ValueTask, Task, ValueTask_1, Task_1
from System.Threading import CancellationToken
from System.Text import Encoding
from System.Collections.ObjectModel import ReadOnlyCollection_1
from System.Collections import IDictionary
from System.Reflection import MethodBase

class CompressionLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Optimal : CompressionLevel # 0
    Fastest : CompressionLevel # 1
    NoCompression : CompressionLevel # 2
    SmallestSize : CompressionLevel # 3


class CompressionMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Decompress : CompressionMode # 0
    Compress : CompressionMode # 1


class DeflateStream(Stream):
    @typing.overload
    def __init__(self, stream: Stream, compressionLevel: CompressionLevel) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, compressionLevel: CompressionLevel, leaveOpen: bool) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, mode: CompressionMode) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, mode: CompressionMode, leaveOpen: bool) -> None: ...
    @property
    def BaseStream(self) -> Stream: ...
    @property
    def CanRead(self) -> bool: ...
    @property
    def CanSeek(self) -> bool: ...
    @property
    def CanTimeout(self) -> bool: ...
    @property
    def CanWrite(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    @property
    def Position(self) -> int: ...
    @Position.setter
    def Position(self, value: int) -> int: ...
    @property
    def ReadTimeout(self) -> int: ...
    @ReadTimeout.setter
    def ReadTimeout(self, value: int) -> int: ...
    @property
    def WriteTimeout(self) -> int: ...
    @WriteTimeout.setter
    def WriteTimeout(self, value: int) -> int: ...
    def BeginRead(self, buffer: Array_1[int], offset: int, count: int, asyncCallback: AsyncCallback, asyncState: typing.Any) -> IAsyncResult: ...
    def BeginWrite(self, buffer: Array_1[int], offset: int, count: int, asyncCallback: AsyncCallback, asyncState: typing.Any) -> IAsyncResult: ...
    def DisposeAsync(self) -> ValueTask: ...
    def EndRead(self, asyncResult: IAsyncResult) -> int: ...
    def EndWrite(self, asyncResult: IAsyncResult) -> None: ...
    def Flush(self) -> None: ...
    def ReadByte(self) -> int: ...
    def Seek(self, offset: int, origin: SeekOrigin) -> int: ...
    def SetLength(self, value: int) -> None: ...
    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, destination: Stream) -> None:...
        @typing.overload
        def __call__(self, destination: Stream, bufferSize: int) -> None:...

    # Skipped CopyToAsync due to it being static, abstract and generic.

    CopyToAsync : CopyToAsync_MethodGroup
    class CopyToAsync_MethodGroup:
        @typing.overload
        def __call__(self, destination: Stream) -> Task:...
        @typing.overload
        def __call__(self, destination: Stream, bufferSize: int) -> Task:...
        @typing.overload
        def __call__(self, destination: Stream, cancellationToken: CancellationToken) -> Task:...
        @typing.overload
        def __call__(self, destination: Stream, bufferSize: int, cancellationToken: CancellationToken) -> Task:...

    # Skipped FlushAsync due to it being static, abstract and generic.

    FlushAsync : FlushAsync_MethodGroup
    class FlushAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Task:...

    # Skipped Read due to it being static, abstract and generic.

    Read : Read_MethodGroup
    class Read_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Span_1[int]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> int:...

    # Skipped ReadAsync due to it being static, abstract and generic.

    ReadAsync : ReadAsync_MethodGroup
    class ReadAsync_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Memory_1[int], cancellationToken: CancellationToken = ...) -> ValueTask_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> Task_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, cancellationToken: CancellationToken) -> Task_1[int]:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> None:...

    # Skipped WriteAsync due to it being static, abstract and generic.

    WriteAsync : WriteAsync_MethodGroup
    class WriteAsync_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ReadOnlyMemory_1[int], cancellationToken: CancellationToken) -> ValueTask:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> Task:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, cancellationToken: CancellationToken) -> Task:...



class GZipStream(Stream):
    @typing.overload
    def __init__(self, stream: Stream, compressionLevel: CompressionLevel) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, compressionLevel: CompressionLevel, leaveOpen: bool) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, mode: CompressionMode) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, mode: CompressionMode, leaveOpen: bool) -> None: ...
    @property
    def BaseStream(self) -> Stream: ...
    @property
    def CanRead(self) -> bool: ...
    @property
    def CanSeek(self) -> bool: ...
    @property
    def CanTimeout(self) -> bool: ...
    @property
    def CanWrite(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    @property
    def Position(self) -> int: ...
    @Position.setter
    def Position(self, value: int) -> int: ...
    @property
    def ReadTimeout(self) -> int: ...
    @ReadTimeout.setter
    def ReadTimeout(self, value: int) -> int: ...
    @property
    def WriteTimeout(self) -> int: ...
    @WriteTimeout.setter
    def WriteTimeout(self, value: int) -> int: ...
    def BeginRead(self, buffer: Array_1[int], offset: int, count: int, asyncCallback: AsyncCallback, asyncState: typing.Any) -> IAsyncResult: ...
    def BeginWrite(self, buffer: Array_1[int], offset: int, count: int, asyncCallback: AsyncCallback, asyncState: typing.Any) -> IAsyncResult: ...
    def DisposeAsync(self) -> ValueTask: ...
    def EndRead(self, asyncResult: IAsyncResult) -> int: ...
    def EndWrite(self, asyncResult: IAsyncResult) -> None: ...
    def Flush(self) -> None: ...
    def ReadByte(self) -> int: ...
    def Seek(self, offset: int, origin: SeekOrigin) -> int: ...
    def SetLength(self, value: int) -> None: ...
    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, destination: Stream) -> None:...
        @typing.overload
        def __call__(self, destination: Stream, bufferSize: int) -> None:...

    # Skipped CopyToAsync due to it being static, abstract and generic.

    CopyToAsync : CopyToAsync_MethodGroup
    class CopyToAsync_MethodGroup:
        @typing.overload
        def __call__(self, destination: Stream) -> Task:...
        @typing.overload
        def __call__(self, destination: Stream, bufferSize: int) -> Task:...
        @typing.overload
        def __call__(self, destination: Stream, cancellationToken: CancellationToken) -> Task:...
        @typing.overload
        def __call__(self, destination: Stream, bufferSize: int, cancellationToken: CancellationToken) -> Task:...

    # Skipped FlushAsync due to it being static, abstract and generic.

    FlushAsync : FlushAsync_MethodGroup
    class FlushAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Task:...

    # Skipped Read due to it being static, abstract and generic.

    Read : Read_MethodGroup
    class Read_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Span_1[int]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> int:...

    # Skipped ReadAsync due to it being static, abstract and generic.

    ReadAsync : ReadAsync_MethodGroup
    class ReadAsync_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Memory_1[int], cancellationToken: CancellationToken = ...) -> ValueTask_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> Task_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, cancellationToken: CancellationToken) -> Task_1[int]:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> None:...

    # Skipped WriteAsync due to it being static, abstract and generic.

    WriteAsync : WriteAsync_MethodGroup
    class WriteAsync_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ReadOnlyMemory_1[int], cancellationToken: CancellationToken = ...) -> ValueTask:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> Task:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, cancellationToken: CancellationToken) -> Task:...



class ZipArchive(IDisposable):
    @typing.overload
    def __init__(self, stream: Stream) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, mode: ZipArchiveMode) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, mode: ZipArchiveMode, leaveOpen: bool) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, mode: ZipArchiveMode, leaveOpen: bool, entryNameEncoding: Encoding) -> None: ...
    @property
    def Entries(self) -> ReadOnlyCollection_1[ZipArchiveEntry]: ...
    @property
    def Mode(self) -> ZipArchiveMode: ...
    def Dispose(self) -> None: ...
    def GetEntry(self, entryName: str) -> ZipArchiveEntry: ...
    # Skipped CreateEntry due to it being static, abstract and generic.

    CreateEntry : CreateEntry_MethodGroup
    class CreateEntry_MethodGroup:
        @typing.overload
        def __call__(self, entryName: str) -> ZipArchiveEntry:...
        @typing.overload
        def __call__(self, entryName: str, compressionLevel: CompressionLevel) -> ZipArchiveEntry:...



class ZipArchiveEntry:
    @property
    def Archive(self) -> ZipArchive: ...
    @property
    def CompressedLength(self) -> int: ...
    @property
    def Crc32(self) -> int: ...
    @property
    def ExternalAttributes(self) -> int: ...
    @ExternalAttributes.setter
    def ExternalAttributes(self, value: int) -> int: ...
    @property
    def FullName(self) -> str: ...
    @FullName.setter
    def FullName(self, value: str) -> str: ...
    @property
    def LastWriteTime(self) -> DateTimeOffset: ...
    @LastWriteTime.setter
    def LastWriteTime(self, value: DateTimeOffset) -> DateTimeOffset: ...
    @property
    def Length(self) -> int: ...
    @property
    def Name(self) -> str: ...
    def Delete(self) -> None: ...
    def Open(self) -> Stream: ...
    def ToString(self) -> str: ...


class ZipArchiveMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Read : ZipArchiveMode # 0
    Create : ZipArchiveMode # 1
    Update : ZipArchiveMode # 2


class ZipFile(abc.ABC):
    @staticmethod
    def OpenRead(archiveFileName: str) -> ZipArchive: ...
    # Skipped CreateFromDirectory due to it being static, abstract and generic.

    CreateFromDirectory : CreateFromDirectory_MethodGroup
    class CreateFromDirectory_MethodGroup:
        @typing.overload
        def __call__(self, sourceDirectoryName: str, destinationArchiveFileName: str) -> None:...
        @typing.overload
        def __call__(self, sourceDirectoryName: str, destinationArchiveFileName: str, compressionLevel: CompressionLevel, includeBaseDirectory: bool) -> None:...
        @typing.overload
        def __call__(self, sourceDirectoryName: str, destinationArchiveFileName: str, compressionLevel: CompressionLevel, includeBaseDirectory: bool, entryNameEncoding: Encoding) -> None:...

    # Skipped ExtractToDirectory due to it being static, abstract and generic.

    ExtractToDirectory : ExtractToDirectory_MethodGroup
    class ExtractToDirectory_MethodGroup:
        @typing.overload
        def __call__(self, sourceArchiveFileName: str, destinationDirectoryName: str) -> None:...
        @typing.overload
        def __call__(self, sourceArchiveFileName: str, destinationDirectoryName: str, overwriteFiles: bool) -> None:...
        @typing.overload
        def __call__(self, sourceArchiveFileName: str, destinationDirectoryName: str, entryNameEncoding: Encoding) -> None:...
        @typing.overload
        def __call__(self, sourceArchiveFileName: str, destinationDirectoryName: str, entryNameEncoding: Encoding, overwriteFiles: bool) -> None:...

    # Skipped Open due to it being static, abstract and generic.

    Open : Open_MethodGroup
    class Open_MethodGroup:
        @typing.overload
        def __call__(self, archiveFileName: str, mode: ZipArchiveMode) -> ZipArchive:...
        @typing.overload
        def __call__(self, archiveFileName: str, mode: ZipArchiveMode, entryNameEncoding: Encoding) -> ZipArchive:...



class ZipFileExtensions(abc.ABC):
    # Skipped CreateEntryFromFile due to it being static, abstract and generic.

    CreateEntryFromFile : CreateEntryFromFile_MethodGroup
    class CreateEntryFromFile_MethodGroup:
        @typing.overload
        def __call__(self, destination: ZipArchive, sourceFileName: str, entryName: str) -> ZipArchiveEntry:...
        @typing.overload
        def __call__(self, destination: ZipArchive, sourceFileName: str, entryName: str, compressionLevel: CompressionLevel) -> ZipArchiveEntry:...

    # Skipped ExtractToDirectory due to it being static, abstract and generic.

    ExtractToDirectory : ExtractToDirectory_MethodGroup
    class ExtractToDirectory_MethodGroup:
        @typing.overload
        def __call__(self, source: ZipArchive, destinationDirectoryName: str) -> None:...
        @typing.overload
        def __call__(self, source: ZipArchive, destinationDirectoryName: str, overwriteFiles: bool) -> None:...

    # Skipped ExtractToFile due to it being static, abstract and generic.

    ExtractToFile : ExtractToFile_MethodGroup
    class ExtractToFile_MethodGroup:
        @typing.overload
        def __call__(self, source: ZipArchiveEntry, destinationFileName: str) -> None:...
        @typing.overload
        def __call__(self, source: ZipArchiveEntry, destinationFileName: str, overwrite: bool) -> None:...



class ZLibException(IOException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @typing.overload
    def __init__(self, message: str, zlibErrorContext: str, zlibErrorCode: int, zlibErrorMessage: str) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class ZLibStream(Stream):
    @typing.overload
    def __init__(self, stream: Stream, compressionLevel: CompressionLevel) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, compressionLevel: CompressionLevel, leaveOpen: bool) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, mode: CompressionMode) -> None: ...
    @typing.overload
    def __init__(self, stream: Stream, mode: CompressionMode, leaveOpen: bool) -> None: ...
    @property
    def BaseStream(self) -> Stream: ...
    @property
    def CanRead(self) -> bool: ...
    @property
    def CanSeek(self) -> bool: ...
    @property
    def CanTimeout(self) -> bool: ...
    @property
    def CanWrite(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    @property
    def Position(self) -> int: ...
    @Position.setter
    def Position(self, value: int) -> int: ...
    @property
    def ReadTimeout(self) -> int: ...
    @ReadTimeout.setter
    def ReadTimeout(self, value: int) -> int: ...
    @property
    def WriteTimeout(self) -> int: ...
    @WriteTimeout.setter
    def WriteTimeout(self, value: int) -> int: ...
    def BeginRead(self, buffer: Array_1[int], offset: int, count: int, asyncCallback: AsyncCallback, asyncState: typing.Any) -> IAsyncResult: ...
    def BeginWrite(self, buffer: Array_1[int], offset: int, count: int, asyncCallback: AsyncCallback, asyncState: typing.Any) -> IAsyncResult: ...
    def DisposeAsync(self) -> ValueTask: ...
    def EndRead(self, asyncResult: IAsyncResult) -> int: ...
    def EndWrite(self, asyncResult: IAsyncResult) -> None: ...
    def Flush(self) -> None: ...
    def ReadByte(self) -> int: ...
    def Seek(self, offset: int, origin: SeekOrigin) -> int: ...
    def SetLength(self, value: int) -> None: ...
    def WriteByte(self, value: int) -> None: ...
    # Skipped CopyTo due to it being static, abstract and generic.

    CopyTo : CopyTo_MethodGroup
    class CopyTo_MethodGroup:
        @typing.overload
        def __call__(self, destination: Stream) -> None:...
        @typing.overload
        def __call__(self, destination: Stream, bufferSize: int) -> None:...

    # Skipped CopyToAsync due to it being static, abstract and generic.

    CopyToAsync : CopyToAsync_MethodGroup
    class CopyToAsync_MethodGroup:
        @typing.overload
        def __call__(self, destination: Stream) -> Task:...
        @typing.overload
        def __call__(self, destination: Stream, bufferSize: int) -> Task:...
        @typing.overload
        def __call__(self, destination: Stream, cancellationToken: CancellationToken) -> Task:...
        @typing.overload
        def __call__(self, destination: Stream, bufferSize: int, cancellationToken: CancellationToken) -> Task:...

    # Skipped FlushAsync due to it being static, abstract and generic.

    FlushAsync : FlushAsync_MethodGroup
    class FlushAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> Task:...
        @typing.overload
        def __call__(self, cancellationToken: CancellationToken) -> Task:...

    # Skipped Read due to it being static, abstract and generic.

    Read : Read_MethodGroup
    class Read_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Span_1[int]) -> int:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> int:...

    # Skipped ReadAsync due to it being static, abstract and generic.

    ReadAsync : ReadAsync_MethodGroup
    class ReadAsync_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Memory_1[int], cancellationToken: CancellationToken = ...) -> ValueTask_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> Task_1[int]:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, cancellationToken: CancellationToken) -> Task_1[int]:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ReadOnlySpan_1[int]) -> None:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> None:...

    # Skipped WriteAsync due to it being static, abstract and generic.

    WriteAsync : WriteAsync_MethodGroup
    class WriteAsync_MethodGroup:
        @typing.overload
        def __call__(self, buffer: ReadOnlyMemory_1[int], cancellationToken: CancellationToken = ...) -> ValueTask:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int) -> Task:...
        @typing.overload
        def __call__(self, buffer: Array_1[int], offset: int, count: int, cancellationToken: CancellationToken) -> Task:...


