import typing, clr, abc
from System import EventArgs, MulticastDelegate, IAsyncResult, AsyncCallback, Attribute, Array, Array_1, Exception, MarshalByRefObject, Delegate, IDisposable, ArgumentException, IServiceProvider, SystemException, ICloneable, EventHandler
from System.Reflection import MethodInfo, MethodBase, Assembly, Module
from System.Globalization import CultureInfo
from System.Threading import SynchronizationContext, SendOrPostCallback
from System.Collections import ICollection, IEnumerator, ReadOnlyCollectionBase, IList, IComparer, IEnumerable, IDictionary, Hashtable
from System.Collections.ObjectModel import Collection_1
from System.Collections.Generic import IList_1
from System.Resources import ResourceManager
from System.Runtime.Serialization import SerializationInfo, StreamingContext
from System.ComponentModel.Design import IDesigner
from System.Runtime.InteropServices import ExternalException

class AddingNewEventArgs(EventArgs):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, newObject: typing.Any) -> None: ...
    @property
    def NewObject(self) -> typing.Any: ...
    @NewObject.setter
    def NewObject(self, value: typing.Any) -> typing.Any: ...


class AddingNewEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: AddingNewEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: AddingNewEventArgs) -> None: ...


class AmbientValueAttribute(Attribute):
    # Constructor .ctor(value : Int16) was skipped since it collides with above method
    # Constructor .ctor(value : Int32) was skipped since it collides with above method
    # Constructor .ctor(value : Int64) was skipped since it collides with above method
    # Constructor .ctor(value : Single) was skipped since it collides with above method
    # Constructor .ctor(value : Double) was skipped since it collides with above method
    # Constructor .ctor(value : Boolean) was skipped since it collides with above method
    # Constructor .ctor(value : String) was skipped since it collides with above method
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any], value: str) -> None: ...
    @typing.overload
    def __init__(self, value: str) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Any) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def Value(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class ArrayConverter(CollectionConverter):
    def __init__(self) -> None: ...
    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties : GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...

    # Skipped GetPropertiesSupported due to it being static, abstract and generic.

    GetPropertiesSupported : GetPropertiesSupported_MethodGroup
    class GetPropertiesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...



class AsyncCompletedEventArgs(EventArgs):
    def __init__(self, error: Exception, cancelled: bool, userState: typing.Any) -> None: ...
    @property
    def Cancelled(self) -> bool: ...
    @property
    def Error(self) -> Exception: ...
    @property
    def UserState(self) -> typing.Any: ...


class AsyncCompletedEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: AsyncCompletedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: AsyncCompletedEventArgs) -> None: ...


class AsyncOperation:
    @property
    def SynchronizationContext(self) -> SynchronizationContext: ...
    @property
    def UserSuppliedState(self) -> typing.Any: ...
    def OperationCompleted(self) -> None: ...
    def Post(self, d: SendOrPostCallback, arg: typing.Any) -> None: ...
    def PostOperationCompleted(self, d: SendOrPostCallback, arg: typing.Any) -> None: ...


class AsyncOperationManager(abc.ABC):
    @classmethod
    @property
    def SynchronizationContext(cls) -> SynchronizationContext: ...
    @classmethod
    @SynchronizationContext.setter
    def SynchronizationContext(cls, value: SynchronizationContext) -> SynchronizationContext: ...
    @staticmethod
    def CreateOperation(userSuppliedState: typing.Any) -> AsyncOperation: ...


class AttributeCollection(ICollection):
    def __init__(self, attributes: Array_1[Attribute]) -> None: ...
    Empty : AttributeCollection
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> Attribute: ...
    @property
    def Item(self) -> Attribute: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    @staticmethod
    def FromExisting(existing: AttributeCollection, newAttributes: Array_1[Attribute]) -> AttributeCollection: ...
    def GetEnumerator(self) -> IEnumerator: ...
    # Skipped Contains due to it being static, abstract and generic.

    Contains : Contains_MethodGroup
    class Contains_MethodGroup:
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> bool:...
        @typing.overload
        def __call__(self, attribute: Attribute) -> bool:...

    # Skipped Matches due to it being static, abstract and generic.

    Matches : Matches_MethodGroup
    class Matches_MethodGroup:
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> bool:...
        @typing.overload
        def __call__(self, attribute: Attribute) -> bool:...



class AttributeProviderAttribute(Attribute):
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, typeName: str) -> None: ...
    @typing.overload
    def __init__(self, typeName: str, propertyName: str) -> None: ...
    @property
    def PropertyName(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def TypeName(self) -> str: ...


class BackgroundWorker(Component):
    def __init__(self) -> None: ...
    @property
    def CancellationPending(self) -> bool: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def IsBusy(self) -> bool: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    @property
    def WorkerReportsProgress(self) -> bool: ...
    @WorkerReportsProgress.setter
    def WorkerReportsProgress(self, value: bool) -> bool: ...
    @property
    def WorkerSupportsCancellation(self) -> bool: ...
    @WorkerSupportsCancellation.setter
    def WorkerSupportsCancellation(self, value: bool) -> bool: ...
    def CancelAsync(self) -> None: ...
    # Skipped ReportProgress due to it being static, abstract and generic.

    ReportProgress : ReportProgress_MethodGroup
    class ReportProgress_MethodGroup:
        @typing.overload
        def __call__(self, percentProgress: int) -> None:...
        @typing.overload
        def __call__(self, percentProgress: int, userState: typing.Any) -> None:...

    # Skipped RunWorkerAsync due to it being static, abstract and generic.

    RunWorkerAsync : RunWorkerAsync_MethodGroup
    class RunWorkerAsync_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, argument: typing.Any) -> None:...



class BaseNumberConverter(TypeConverter, abc.ABC):
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...



class BindableAttribute(Attribute):
    @typing.overload
    def __init__(self, bindable: bool) -> None: ...
    @typing.overload
    def __init__(self, bindable: bool, direction: BindingDirection) -> None: ...
    @typing.overload
    def __init__(self, flags: BindableSupport) -> None: ...
    @typing.overload
    def __init__(self, flags: BindableSupport, direction: BindingDirection) -> None: ...
    Default : BindableAttribute
    No : BindableAttribute
    Yes : BindableAttribute
    @property
    def Bindable(self) -> bool: ...
    @property
    def Direction(self) -> BindingDirection: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class BindableSupport(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    No : BindableSupport # 0
    Yes : BindableSupport # 1
    Default : BindableSupport # 2


class BindingDirection(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    OneWay : BindingDirection # 0
    TwoWay : BindingDirection # 1


class BindingList_GenericClasses(abc.ABCMeta):
    Generic_BindingList_GenericClasses_BindingList_1_T = typing.TypeVar('Generic_BindingList_GenericClasses_BindingList_1_T')
    def __getitem__(self, types : typing.Type[Generic_BindingList_GenericClasses_BindingList_1_T]) -> typing.Type[BindingList_1[Generic_BindingList_GenericClasses_BindingList_1_T]]: ...

BindingList : BindingList_GenericClasses

BindingList_1_T = typing.TypeVar('BindingList_1_T')
class BindingList_1(typing.Generic[BindingList_1_T], Collection_1[BindingList_1_T], IBindingList, IRaiseItemChangedEvents, ICancelAddNew):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, list: IList_1[BindingList_1_T]) -> None: ...
    @property
    def AllowEdit(self) -> bool: ...
    @AllowEdit.setter
    def AllowEdit(self, value: bool) -> bool: ...
    @property
    def AllowNew(self) -> bool: ...
    @AllowNew.setter
    def AllowNew(self, value: bool) -> bool: ...
    @property
    def AllowRemove(self) -> bool: ...
    @AllowRemove.setter
    def AllowRemove(self, value: bool) -> bool: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> BindingList_1_T: ...
    @Item.setter
    def Item(self, value: BindingList_1_T) -> BindingList_1_T: ...
    @property
    def RaiseListChangedEvents(self) -> bool: ...
    @RaiseListChangedEvents.setter
    def RaiseListChangedEvents(self, value: bool) -> bool: ...
    def AddNew(self) -> BindingList_1_T: ...
    def CancelNew(self, itemIndex: int) -> None: ...
    def EndNew(self, itemIndex: int) -> None: ...
    def ResetBindings(self) -> None: ...
    def ResetItem(self, position: int) -> None: ...


class BooleanConverter(TypeConverter):
    def __init__(self) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped GetStandardValues due to it being static, abstract and generic.

    GetStandardValues : GetStandardValues_MethodGroup
    class GetStandardValues_MethodGroup:
        @typing.overload
        def __call__(self) -> ICollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> TypeConverter.StandardValuesCollection:...

    # Skipped GetStandardValuesExclusive due to it being static, abstract and generic.

    GetStandardValuesExclusive : GetStandardValuesExclusive_MethodGroup
    class GetStandardValuesExclusive_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetStandardValuesSupported due to it being static, abstract and generic.

    GetStandardValuesSupported : GetStandardValuesSupported_MethodGroup
    class GetStandardValuesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...



class BrowsableAttribute(Attribute):
    def __init__(self, browsable: bool) -> None: ...
    Default : BrowsableAttribute
    No : BrowsableAttribute
    Yes : BrowsableAttribute
    @property
    def Browsable(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class ByteConverter(BaseNumberConverter):
    def __init__(self) -> None: ...


class CancelEventArgs(EventArgs):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, cancel: bool) -> None: ...
    @property
    def Cancel(self) -> bool: ...
    @Cancel.setter
    def Cancel(self, value: bool) -> bool: ...


class CancelEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: CancelEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: CancelEventArgs) -> None: ...


class CategoryAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, category: str) -> None: ...
    @classmethod
    @property
    def Action(cls) -> CategoryAttribute: ...
    @classmethod
    @property
    def Appearance(cls) -> CategoryAttribute: ...
    @classmethod
    @property
    def Asynchronous(cls) -> CategoryAttribute: ...
    @classmethod
    @property
    def Behavior(cls) -> CategoryAttribute: ...
    @property
    def Category(self) -> str: ...
    @classmethod
    @property
    def Data(cls) -> CategoryAttribute: ...
    @classmethod
    @property
    def Default(cls) -> CategoryAttribute: ...
    @classmethod
    @property
    def Design(cls) -> CategoryAttribute: ...
    @classmethod
    @property
    def DragDrop(cls) -> CategoryAttribute: ...
    @classmethod
    @property
    def Focus(cls) -> CategoryAttribute: ...
    @classmethod
    @property
    def Format(cls) -> CategoryAttribute: ...
    @classmethod
    @property
    def Key(cls) -> CategoryAttribute: ...
    @classmethod
    @property
    def Layout(cls) -> CategoryAttribute: ...
    @classmethod
    @property
    def Mouse(cls) -> CategoryAttribute: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @classmethod
    @property
    def WindowStyle(cls) -> CategoryAttribute: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class CharConverter(TypeConverter):
    def __init__(self) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...



class CollectionChangeAction(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Add : CollectionChangeAction # 1
    Remove : CollectionChangeAction # 2
    Refresh : CollectionChangeAction # 3


class CollectionChangeEventArgs(EventArgs):
    def __init__(self, action: CollectionChangeAction, element: typing.Any) -> None: ...
    @property
    def Action(self) -> CollectionChangeAction: ...
    @property
    def Element(self) -> typing.Any: ...


class CollectionChangeEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: CollectionChangeEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: CollectionChangeEventArgs) -> None: ...


class CollectionConverter(TypeConverter):
    def __init__(self) -> None: ...
    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties : GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...



class ComplexBindingPropertiesAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, dataSource: str) -> None: ...
    @typing.overload
    def __init__(self, dataSource: str, dataMember: str) -> None: ...
    Default : ComplexBindingPropertiesAttribute
    @property
    def DataMember(self) -> str: ...
    @property
    def DataSource(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class Component(MarshalByRefObject, IComponent):
    def __init__(self) -> None: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    def Dispose(self) -> None: ...
    def ToString(self) -> str: ...


class ComponentCollection(ReadOnlyCollectionBase):
    def __init__(self, components: Array_1[IComponent]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> IComponent: ...
    @property
    def Item(self) -> IComponent: ...
    def CopyTo(self, array: Array_1[IComponent], index: int) -> None: ...


class ComponentConverter(ReferenceConverter):
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties : GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...

    # Skipped GetPropertiesSupported due to it being static, abstract and generic.

    GetPropertiesSupported : GetPropertiesSupported_MethodGroup
    class GetPropertiesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...



class ComponentEditor(abc.ABC):
    # Skipped EditComponent due to it being static, abstract and generic.

    EditComponent : EditComponent_MethodGroup
    class EditComponent_MethodGroup:
        @typing.overload
        def __call__(self, component: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, component: typing.Any) -> bool:...



class ComponentResourceManager(ResourceManager):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, t: typing.Type[typing.Any]) -> None: ...
    @property
    def BaseName(self) -> str: ...
    @property
    def IgnoreCase(self) -> bool: ...
    @IgnoreCase.setter
    def IgnoreCase(self, value: bool) -> bool: ...
    @property
    def ResourceSetType(self) -> typing.Type[typing.Any]: ...
    # Skipped ApplyResources due to it being static, abstract and generic.

    ApplyResources : ApplyResources_MethodGroup
    class ApplyResources_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, objectName: str) -> None:...
        @typing.overload
        def __call__(self, value: typing.Any, objectName: str, culture: CultureInfo) -> None:...



class Container(IContainer):
    def __init__(self) -> None: ...
    @property
    def Components(self) -> ComponentCollection: ...
    def Dispose(self) -> None: ...
    def Remove(self, component: IComponent) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, component: IComponent) -> None:...
        @typing.overload
        def __call__(self, component: IComponent, name: str) -> None:...



class ContainerFilterService(abc.ABC):
    def FilterComponents(self, components: ComponentCollection) -> ComponentCollection: ...


class CultureInfoConverter(TypeConverter):
    def __init__(self) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped GetStandardValues due to it being static, abstract and generic.

    GetStandardValues : GetStandardValues_MethodGroup
    class GetStandardValues_MethodGroup:
        @typing.overload
        def __call__(self) -> ICollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> TypeConverter.StandardValuesCollection:...

    # Skipped GetStandardValuesExclusive due to it being static, abstract and generic.

    GetStandardValuesExclusive : GetStandardValuesExclusive_MethodGroup
    class GetStandardValuesExclusive_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetStandardValuesSupported due to it being static, abstract and generic.

    GetStandardValuesSupported : GetStandardValuesSupported_MethodGroup
    class GetStandardValuesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...



class CustomTypeDescriptor(ICustomTypeDescriptor, abc.ABC):
    def GetAttributes(self) -> AttributeCollection: ...
    def GetClassName(self) -> str: ...
    def GetComponentName(self) -> str: ...
    def GetConverter(self) -> TypeConverter: ...
    def GetDefaultEvent(self) -> EventDescriptor: ...
    def GetDefaultProperty(self) -> PropertyDescriptor: ...
    def GetEditor(self, editorBaseType: typing.Type[typing.Any]) -> typing.Any: ...
    def GetPropertyOwner(self, pd: PropertyDescriptor) -> typing.Any: ...
    # Skipped GetEvents due to it being static, abstract and generic.

    GetEvents : GetEvents_MethodGroup
    class GetEvents_MethodGroup:
        @typing.overload
        def __call__(self) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> EventDescriptorCollection:...

    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties : GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...



class DataErrorsChangedEventArgs(EventArgs):
    def __init__(self, propertyName: str) -> None: ...
    @property
    def PropertyName(self) -> str: ...


class DataObjectAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, isDataObject: bool) -> None: ...
    DataObject : DataObjectAttribute
    Default : DataObjectAttribute
    NonDataObject : DataObjectAttribute
    @property
    def IsDataObject(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class DataObjectFieldAttribute(Attribute):
    @typing.overload
    def __init__(self, primaryKey: bool) -> None: ...
    @typing.overload
    def __init__(self, primaryKey: bool, isIdentity: bool) -> None: ...
    @typing.overload
    def __init__(self, primaryKey: bool, isIdentity: bool, isNullable: bool) -> None: ...
    @typing.overload
    def __init__(self, primaryKey: bool, isIdentity: bool, isNullable: bool, length: int) -> None: ...
    @property
    def IsIdentity(self) -> bool: ...
    @property
    def IsNullable(self) -> bool: ...
    @property
    def Length(self) -> int: ...
    @property
    def PrimaryKey(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class DataObjectMethodAttribute(Attribute):
    @typing.overload
    def __init__(self, methodType: DataObjectMethodType) -> None: ...
    @typing.overload
    def __init__(self, methodType: DataObjectMethodType, isDefault: bool) -> None: ...
    @property
    def IsDefault(self) -> bool: ...
    @property
    def MethodType(self) -> DataObjectMethodType: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def Match(self, obj: typing.Any) -> bool: ...


class DataObjectMethodType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Fill : DataObjectMethodType # 0
    Select : DataObjectMethodType # 1
    Update : DataObjectMethodType # 2
    Insert : DataObjectMethodType # 3
    Delete : DataObjectMethodType # 4


class DateTimeConverter(TypeConverter):
    def __init__(self) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...



class DateTimeOffsetConverter(TypeConverter):
    def __init__(self) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...



class DecimalConverter(BaseNumberConverter):
    def __init__(self) -> None: ...
    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...



class DefaultBindingPropertyAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    Default : DefaultBindingPropertyAttribute
    @property
    def Name(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class DefaultEventAttribute(Attribute):
    def __init__(self, name: str) -> None: ...
    Default : DefaultEventAttribute
    @property
    def Name(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class DefaultPropertyAttribute(Attribute):
    def __init__(self, name: str) -> None: ...
    Default : DefaultPropertyAttribute
    @property
    def Name(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class DefaultValueAttribute(Attribute):
    # Constructor .ctor(value : Int16) was skipped since it collides with above method
    # Constructor .ctor(value : Int32) was skipped since it collides with above method
    # Constructor .ctor(value : Int64) was skipped since it collides with above method
    # Constructor .ctor(value : Single) was skipped since it collides with above method
    # Constructor .ctor(value : Double) was skipped since it collides with above method
    # Constructor .ctor(value : Boolean) was skipped since it collides with above method
    # Constructor .ctor(value : String) was skipped since it collides with above method
    # Constructor .ctor(value : SByte) was skipped since it collides with above method
    # Constructor .ctor(value : UInt16) was skipped since it collides with above method
    # Constructor .ctor(value : UInt32) was skipped since it collides with above method
    # Constructor .ctor(value : UInt64) was skipped since it collides with above method
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any], value: str) -> None: ...
    @typing.overload
    def __init__(self, value: str) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @typing.overload
    def __init__(self, value: typing.Any) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def Value(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class DescriptionAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, description: str) -> None: ...
    Default : DescriptionAttribute
    @property
    def Description(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class DesignerAttribute(Attribute):
    @typing.overload
    def __init__(self, designerType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, designerType: typing.Type[typing.Any], designerBaseType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, designerTypeName: str) -> None: ...
    @typing.overload
    def __init__(self, designerTypeName: str, designerBaseType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, designerTypeName: str, designerBaseTypeName: str) -> None: ...
    @property
    def DesignerBaseTypeName(self) -> str: ...
    @property
    def DesignerTypeName(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class DesignerCategoryAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, category: str) -> None: ...
    Component : DesignerCategoryAttribute
    Default : DesignerCategoryAttribute
    Form : DesignerCategoryAttribute
    Generic : DesignerCategoryAttribute
    @property
    def Category(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class DesignerSerializationVisibility(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Hidden : DesignerSerializationVisibility # 0
    Visible : DesignerSerializationVisibility # 1
    Content : DesignerSerializationVisibility # 2


class DesignerSerializationVisibilityAttribute(Attribute):
    def __init__(self, visibility: DesignerSerializationVisibility) -> None: ...
    Content : DesignerSerializationVisibilityAttribute
    Default : DesignerSerializationVisibilityAttribute
    Hidden : DesignerSerializationVisibilityAttribute
    Visible : DesignerSerializationVisibilityAttribute
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def Visibility(self) -> DesignerSerializationVisibility: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class DesignOnlyAttribute(Attribute):
    def __init__(self, isDesignOnly: bool) -> None: ...
    Default : DesignOnlyAttribute
    No : DesignOnlyAttribute
    Yes : DesignOnlyAttribute
    @property
    def IsDesignOnly(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class DesignTimeVisibleAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, visible: bool) -> None: ...
    Default : DesignTimeVisibleAttribute
    No : DesignTimeVisibleAttribute
    Yes : DesignTimeVisibleAttribute
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def Visible(self) -> bool: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class DisplayNameAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, displayName: str) -> None: ...
    Default : DisplayNameAttribute
    @property
    def DisplayName(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class DoubleConverter(BaseNumberConverter):
    def __init__(self) -> None: ...


class DoWorkEventArgs(CancelEventArgs):
    def __init__(self, argument: typing.Any) -> None: ...
    @property
    def Argument(self) -> typing.Any: ...
    @property
    def Cancel(self) -> bool: ...
    @Cancel.setter
    def Cancel(self, value: bool) -> bool: ...
    @property
    def Result(self) -> typing.Any: ...
    @Result.setter
    def Result(self, value: typing.Any) -> typing.Any: ...


class DoWorkEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: DoWorkEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: DoWorkEventArgs) -> None: ...


class EditorAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any], baseType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, typeName: str, baseType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, typeName: str, baseTypeName: str) -> None: ...
    @property
    def EditorBaseTypeName(self) -> str: ...
    @property
    def EditorTypeName(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class EditorBrowsableAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, state: EditorBrowsableState) -> None: ...
    @property
    def State(self) -> EditorBrowsableState: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class EditorBrowsableState(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Always : EditorBrowsableState # 0
    Never : EditorBrowsableState # 1
    Advanced : EditorBrowsableState # 2


class EnumConverter(TypeConverter):
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped GetStandardValues due to it being static, abstract and generic.

    GetStandardValues : GetStandardValues_MethodGroup
    class GetStandardValues_MethodGroup:
        @typing.overload
        def __call__(self) -> ICollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> TypeConverter.StandardValuesCollection:...

    # Skipped GetStandardValuesExclusive due to it being static, abstract and generic.

    GetStandardValuesExclusive : GetStandardValuesExclusive_MethodGroup
    class GetStandardValuesExclusive_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetStandardValuesSupported due to it being static, abstract and generic.

    GetStandardValuesSupported : GetStandardValuesSupported_MethodGroup
    class GetStandardValuesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped IsValid due to it being static, abstract and generic.

    IsValid : IsValid_MethodGroup
    class IsValid_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> bool:...



class EventDescriptor(MemberDescriptor):
    @property
    def Attributes(self) -> AttributeCollection: ...
    @property
    def Category(self) -> str: ...
    @property
    def ComponentType(self) -> typing.Type[typing.Any]: ...
    @property
    def Description(self) -> str: ...
    @property
    def DesignTimeOnly(self) -> bool: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def EventType(self) -> typing.Type[typing.Any]: ...
    @property
    def IsBrowsable(self) -> bool: ...
    @property
    def IsMulticast(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @abc.abstractmethod
    def AddEventHandler(self, component: typing.Any, value: Delegate) -> None: ...
    @abc.abstractmethod
    def RemoveEventHandler(self, component: typing.Any, value: Delegate) -> None: ...


class EventDescriptorCollection(IList):
    @typing.overload
    def __init__(self, events: Array_1[EventDescriptor]) -> None: ...
    @typing.overload
    def __init__(self, events: Array_1[EventDescriptor], readOnly: bool) -> None: ...
    Empty : EventDescriptorCollection
    @property
    def Count(self) -> int: ...
    @Count.setter
    def Count(self, value: int) -> int: ...
    @property
    def Item(self) -> EventDescriptor: ...
    @property
    def Item(self) -> EventDescriptor: ...
    def Add(self, value: EventDescriptor) -> int: ...
    def Clear(self) -> None: ...
    def Contains(self, value: EventDescriptor) -> bool: ...
    def Find(self, name: str, ignoreCase: bool) -> EventDescriptor: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def IndexOf(self, value: EventDescriptor) -> int: ...
    def Insert(self, index: int, value: EventDescriptor) -> None: ...
    def Remove(self, value: EventDescriptor) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Sort due to it being static, abstract and generic.

    Sort : Sort_MethodGroup
    class Sort_MethodGroup:
        @typing.overload
        def __call__(self) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, names: Array_1[str]) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, comparer: IComparer) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, names: Array_1[str], comparer: IComparer) -> EventDescriptorCollection:...



class EventHandlerList(IDisposable):
    def __init__(self) -> None: ...
    @property
    def Item(self) -> Delegate: ...
    @Item.setter
    def Item(self, value: Delegate) -> Delegate: ...
    def AddHandler(self, key: typing.Any, value: Delegate) -> None: ...
    def AddHandlers(self, listToAddFrom: EventHandlerList) -> None: ...
    def Dispose(self) -> None: ...
    def RemoveHandler(self, key: typing.Any, value: Delegate) -> None: ...


class ExpandableObjectConverter(TypeConverter):
    def __init__(self) -> None: ...
    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties : GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...

    # Skipped GetPropertiesSupported due to it being static, abstract and generic.

    GetPropertiesSupported : GetPropertiesSupported_MethodGroup
    class GetPropertiesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...



class ExtenderProvidedPropertyAttribute(Attribute):
    def __init__(self) -> None: ...
    @property
    def ExtenderProperty(self) -> PropertyDescriptor: ...
    @ExtenderProperty.setter
    def ExtenderProperty(self, value: PropertyDescriptor) -> PropertyDescriptor: ...
    @property
    def Provider(self) -> IExtenderProvider: ...
    @Provider.setter
    def Provider(self, value: IExtenderProvider) -> IExtenderProvider: ...
    @property
    def ReceiverType(self) -> typing.Type[typing.Any]: ...
    @ReceiverType.setter
    def ReceiverType(self, value: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class GuidConverter(TypeConverter):
    def __init__(self) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...



class HandledEventArgs(EventArgs):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, defaultHandledValue: bool) -> None: ...
    @property
    def Handled(self) -> bool: ...
    @Handled.setter
    def Handled(self, value: bool) -> bool: ...


class HandledEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: HandledEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: HandledEventArgs) -> None: ...


class IBindingList(IList, typing.Protocol):
    @property
    def AllowEdit(self) -> bool: ...
    @property
    def AllowNew(self) -> bool: ...
    @property
    def AllowRemove(self) -> bool: ...
    @property
    def IsSorted(self) -> bool: ...
    @property
    def SortDirection(self) -> ListSortDirection: ...
    @property
    def SortProperty(self) -> PropertyDescriptor: ...
    @property
    def SupportsChangeNotification(self) -> bool: ...
    @property
    def SupportsSearching(self) -> bool: ...
    @property
    def SupportsSorting(self) -> bool: ...
    @abc.abstractmethod
    def AddIndex(self, property: PropertyDescriptor) -> None: ...
    @abc.abstractmethod
    def AddNew(self) -> typing.Any: ...
    @abc.abstractmethod
    def ApplySort(self, property: PropertyDescriptor, direction: ListSortDirection) -> None: ...
    @abc.abstractmethod
    def Find(self, property: PropertyDescriptor, key: typing.Any) -> int: ...
    @abc.abstractmethod
    def RemoveIndex(self, property: PropertyDescriptor) -> None: ...
    @abc.abstractmethod
    def RemoveSort(self) -> None: ...


class IBindingListView(IBindingList, typing.Protocol):
    @property
    def Filter(self) -> str: ...
    @Filter.setter
    def Filter(self, value: str) -> str: ...
    @property
    def SortDescriptions(self) -> ListSortDescriptionCollection: ...
    @property
    def SupportsAdvancedSorting(self) -> bool: ...
    @property
    def SupportsFiltering(self) -> bool: ...
    @abc.abstractmethod
    def ApplySort(self, sorts: ListSortDescriptionCollection) -> None: ...
    @abc.abstractmethod
    def RemoveFilter(self) -> None: ...


class ICancelAddNew(typing.Protocol):
    @abc.abstractmethod
    def CancelNew(self, itemIndex: int) -> None: ...
    @abc.abstractmethod
    def EndNew(self, itemIndex: int) -> None: ...


class IChangeTracking(typing.Protocol):
    @property
    def IsChanged(self) -> bool: ...
    @abc.abstractmethod
    def AcceptChanges(self) -> None: ...


class IComNativeDescriptorHandler(typing.Protocol):
    @abc.abstractmethod
    def GetAttributes(self, component: typing.Any) -> AttributeCollection: ...
    @abc.abstractmethod
    def GetClassName(self, component: typing.Any) -> str: ...
    @abc.abstractmethod
    def GetConverter(self, component: typing.Any) -> TypeConverter: ...
    @abc.abstractmethod
    def GetDefaultEvent(self, component: typing.Any) -> EventDescriptor: ...
    @abc.abstractmethod
    def GetDefaultProperty(self, component: typing.Any) -> PropertyDescriptor: ...
    @abc.abstractmethod
    def GetEditor(self, component: typing.Any, baseEditorType: typing.Type[typing.Any]) -> typing.Any: ...
    @abc.abstractmethod
    def GetName(self, component: typing.Any) -> str: ...
    @abc.abstractmethod
    def GetProperties(self, component: typing.Any, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection: ...
    # Skipped GetEvents due to it being static, abstract and generic.

    GetEvents : GetEvents_MethodGroup
    class GetEvents_MethodGroup:
        @typing.overload
        def __call__(self, component: typing.Any) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, component: typing.Any, attributes: Array_1[Attribute]) -> EventDescriptorCollection:...

    # Skipped GetPropertyValue due to it being static, abstract and generic.

    GetPropertyValue : GetPropertyValue_MethodGroup
    class GetPropertyValue_MethodGroup:
        @typing.overload
        def __call__(self, component: typing.Any, dispid: int, success: clr.Reference[bool]) -> typing.Any:...
        @typing.overload
        def __call__(self, component: typing.Any, propertyName: str, success: clr.Reference[bool]) -> typing.Any:...



class IComponent(IDisposable, typing.Protocol):
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...


class IContainer(IDisposable, typing.Protocol):
    @property
    def Components(self) -> ComponentCollection: ...
    @abc.abstractmethod
    def Remove(self, component: IComponent) -> None: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, component: IComponent) -> None:...
        @typing.overload
        def __call__(self, component: IComponent, name: str) -> None:...



class ICustomTypeDescriptor(typing.Protocol):
    @abc.abstractmethod
    def GetAttributes(self) -> AttributeCollection: ...
    @abc.abstractmethod
    def GetClassName(self) -> str: ...
    @abc.abstractmethod
    def GetComponentName(self) -> str: ...
    @abc.abstractmethod
    def GetConverter(self) -> TypeConverter: ...
    @abc.abstractmethod
    def GetDefaultEvent(self) -> EventDescriptor: ...
    @abc.abstractmethod
    def GetDefaultProperty(self) -> PropertyDescriptor: ...
    @abc.abstractmethod
    def GetEditor(self, editorBaseType: typing.Type[typing.Any]) -> typing.Any: ...
    @abc.abstractmethod
    def GetPropertyOwner(self, pd: PropertyDescriptor) -> typing.Any: ...
    # Skipped GetEvents due to it being static, abstract and generic.

    GetEvents : GetEvents_MethodGroup
    class GetEvents_MethodGroup:
        @typing.overload
        def __call__(self) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> EventDescriptorCollection:...

    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties : GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...



class IDataErrorInfo(typing.Protocol):
    @property
    def Error(self) -> str: ...
    @property
    def Item(self) -> str: ...


class IEditableObject(typing.Protocol):
    @abc.abstractmethod
    def BeginEdit(self) -> None: ...
    @abc.abstractmethod
    def CancelEdit(self) -> None: ...
    @abc.abstractmethod
    def EndEdit(self) -> None: ...


class IExtenderProvider(typing.Protocol):
    @abc.abstractmethod
    def CanExtend(self, extendee: typing.Any) -> bool: ...


class IIntellisenseBuilder(typing.Protocol):
    @property
    def Name(self) -> str: ...
    @abc.abstractmethod
    def Show(self, language: str, value: str, newValue: clr.Reference[str]) -> bool: ...


class IListSource(typing.Protocol):
    @property
    def ContainsListCollection(self) -> bool: ...
    @abc.abstractmethod
    def GetList(self) -> IList: ...


class ImmutableObjectAttribute(Attribute):
    def __init__(self, immutable: bool) -> None: ...
    Default : ImmutableObjectAttribute
    No : ImmutableObjectAttribute
    Yes : ImmutableObjectAttribute
    @property
    def Immutable(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class INestedContainer(IContainer, typing.Protocol):
    @property
    def Owner(self) -> IComponent: ...


class INestedSite(ISite, typing.Protocol):
    @property
    def FullName(self) -> str: ...


class InheritanceAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, inheritanceLevel: InheritanceLevel) -> None: ...
    Default : InheritanceAttribute
    Inherited : InheritanceAttribute
    InheritedReadOnly : InheritanceAttribute
    NotInherited : InheritanceAttribute
    @property
    def InheritanceLevel(self) -> InheritanceLevel: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, value: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...
    def ToString(self) -> str: ...


class InheritanceLevel(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Inherited : InheritanceLevel # 1
    InheritedReadOnly : InheritanceLevel # 2
    NotInherited : InheritanceLevel # 3


class InitializationEventAttribute(Attribute):
    def __init__(self, eventName: str) -> None: ...
    @property
    def EventName(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...


class INotifyDataErrorInfo(typing.Protocol):
    @property
    def HasErrors(self) -> bool: ...
    @abc.abstractmethod
    def GetErrors(self, propertyName: str) -> IEnumerable: ...


class INotifyPropertyChanged(typing.Protocol):
    pass


class INotifyPropertyChanging(typing.Protocol):
    pass


class InstallerTypeAttribute(Attribute):
    @typing.overload
    def __init__(self, installerType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, typeName: str) -> None: ...
    @property
    def InstallerType(self) -> typing.Type[typing.Any]: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class InstanceCreationEditor(abc.ABC):
    @property
    def Text(self) -> str: ...
    @abc.abstractmethod
    def CreateInstance(self, context: ITypeDescriptorContext, instanceType: typing.Type[typing.Any]) -> typing.Any: ...


class Int16Converter(BaseNumberConverter):
    def __init__(self) -> None: ...


class Int32Converter(BaseNumberConverter):
    def __init__(self) -> None: ...


class Int64Converter(BaseNumberConverter):
    def __init__(self) -> None: ...


class InvalidAsynchronousStateException(ArgumentException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def ParamName(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class InvalidEnumArgumentException(ArgumentException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, argumentName: str, invalidValue: int, enumClass: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def ParamName(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class IRaiseItemChangedEvents(typing.Protocol):
    @property
    def RaisesItemChangedEvents(self) -> bool: ...


class IRevertibleChangeTracking(IChangeTracking, typing.Protocol):
    @abc.abstractmethod
    def RejectChanges(self) -> None: ...


class ISite(IServiceProvider, typing.Protocol):
    @property
    def Component(self) -> IComponent: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @Name.setter
    def Name(self, value: str) -> str: ...


class ISupportInitialize(typing.Protocol):
    @abc.abstractmethod
    def BeginInit(self) -> None: ...
    @abc.abstractmethod
    def EndInit(self) -> None: ...


class ISupportInitializeNotification(ISupportInitialize, typing.Protocol):
    @property
    def IsInitialized(self) -> bool: ...


class ISynchronizeInvoke(typing.Protocol):
    @property
    def InvokeRequired(self) -> bool: ...
    @abc.abstractmethod
    def BeginInvoke(self, method: Delegate, args: Array_1[typing.Any]) -> IAsyncResult: ...
    @abc.abstractmethod
    def EndInvoke(self, result: IAsyncResult) -> typing.Any: ...
    @abc.abstractmethod
    def Invoke(self, method: Delegate, args: Array_1[typing.Any]) -> typing.Any: ...


class ITypeDescriptorContext(IServiceProvider, typing.Protocol):
    @property
    def Container(self) -> IContainer: ...
    @property
    def Instance(self) -> typing.Any: ...
    @property
    def PropertyDescriptor(self) -> PropertyDescriptor: ...
    @abc.abstractmethod
    def OnComponentChanged(self) -> None: ...
    @abc.abstractmethod
    def OnComponentChanging(self) -> bool: ...


class ITypedList(typing.Protocol):
    @abc.abstractmethod
    def GetItemProperties(self, listAccessors: Array_1[PropertyDescriptor]) -> PropertyDescriptorCollection: ...
    @abc.abstractmethod
    def GetListName(self, listAccessors: Array_1[PropertyDescriptor]) -> str: ...


class License(IDisposable, abc.ABC):
    @property
    def LicenseKey(self) -> str: ...
    @abc.abstractmethod
    def Dispose(self) -> None: ...


class LicenseContext(IServiceProvider):
    def __init__(self) -> None: ...
    @property
    def UsageMode(self) -> LicenseUsageMode: ...
    def GetSavedLicenseKey(self, type: typing.Type[typing.Any], resourceAssembly: Assembly) -> str: ...
    def GetService(self, type: typing.Type[typing.Any]) -> typing.Any: ...
    def SetSavedLicenseKey(self, type: typing.Type[typing.Any], key: str) -> None: ...


class LicenseException(SystemException):
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any], instance: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any], instance: typing.Any, message: str) -> None: ...
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any], instance: typing.Any, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def LicensedType(self) -> typing.Type[typing.Any]: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...


class LicenseManager:
    @classmethod
    @property
    def CurrentContext(cls) -> LicenseContext: ...
    @classmethod
    @CurrentContext.setter
    def CurrentContext(cls, value: LicenseContext) -> LicenseContext: ...
    @classmethod
    @property
    def UsageMode(cls) -> LicenseUsageMode: ...
    @staticmethod
    def IsLicensed(type: typing.Type[typing.Any]) -> bool: ...
    @staticmethod
    def LockContext(contextUser: typing.Any) -> None: ...
    @staticmethod
    def UnlockContext(contextUser: typing.Any) -> None: ...
    # Skipped CreateWithContext due to it being static, abstract and generic.

    CreateWithContext : CreateWithContext_MethodGroup
    class CreateWithContext_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], creationContext: LicenseContext) -> typing.Any:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], creationContext: LicenseContext, args: Array_1[typing.Any]) -> typing.Any:...

    # Skipped IsValid due to it being static, abstract and generic.

    IsValid : IsValid_MethodGroup
    class IsValid_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], instance: typing.Any, license: clr.Reference[License]) -> bool:...

    # Skipped Validate due to it being static, abstract and generic.

    Validate : Validate_MethodGroup
    class Validate_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], instance: typing.Any) -> License:...



class LicenseProvider(abc.ABC):
    @abc.abstractmethod
    def GetLicense(self, context: LicenseContext, type: typing.Type[typing.Any], instance: typing.Any, allowExceptions: bool) -> License: ...


class LicenseProviderAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, typeName: str) -> None: ...
    Default : LicenseProviderAttribute
    @property
    def LicenseProvider(self) -> typing.Type[typing.Any]: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, value: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class LicenseUsageMode(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Runtime : LicenseUsageMode # 0
    Designtime : LicenseUsageMode # 1


class LicFileLicenseProvider(LicenseProvider):
    def __init__(self) -> None: ...
    def GetLicense(self, context: LicenseContext, type: typing.Type[typing.Any], instance: typing.Any, allowExceptions: bool) -> License: ...


class ListBindableAttribute(Attribute):
    @typing.overload
    def __init__(self, flags: BindableSupport) -> None: ...
    @typing.overload
    def __init__(self, listBindable: bool) -> None: ...
    Default : ListBindableAttribute
    No : ListBindableAttribute
    Yes : ListBindableAttribute
    @property
    def ListBindable(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class ListChangedEventArgs(EventArgs):
    @typing.overload
    def __init__(self, listChangedType: ListChangedType, newIndex: int) -> None: ...
    @typing.overload
    def __init__(self, listChangedType: ListChangedType, newIndex: int, oldIndex: int) -> None: ...
    @typing.overload
    def __init__(self, listChangedType: ListChangedType, newIndex: int, propDesc: PropertyDescriptor) -> None: ...
    @typing.overload
    def __init__(self, listChangedType: ListChangedType, propDesc: PropertyDescriptor) -> None: ...
    @property
    def ListChangedType(self) -> ListChangedType: ...
    @property
    def NewIndex(self) -> int: ...
    @property
    def OldIndex(self) -> int: ...
    @property
    def PropertyDescriptor(self) -> PropertyDescriptor: ...


class ListChangedEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: ListChangedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: ListChangedEventArgs) -> None: ...


class ListChangedType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Reset : ListChangedType # 0
    ItemAdded : ListChangedType # 1
    ItemDeleted : ListChangedType # 2
    ItemMoved : ListChangedType # 3
    ItemChanged : ListChangedType # 4
    PropertyDescriptorAdded : ListChangedType # 5
    PropertyDescriptorDeleted : ListChangedType # 6
    PropertyDescriptorChanged : ListChangedType # 7


class ListSortDescription:
    def __init__(self, property: PropertyDescriptor, direction: ListSortDirection) -> None: ...
    @property
    def PropertyDescriptor(self) -> PropertyDescriptor: ...
    @PropertyDescriptor.setter
    def PropertyDescriptor(self, value: PropertyDescriptor) -> PropertyDescriptor: ...
    @property
    def SortDirection(self) -> ListSortDirection: ...
    @SortDirection.setter
    def SortDirection(self, value: ListSortDirection) -> ListSortDirection: ...


class ListSortDescriptionCollection(IList):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, sorts: Array_1[ListSortDescription]) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> ListSortDescription: ...
    @Item.setter
    def Item(self, value: ListSortDescription) -> ListSortDescription: ...
    def Contains(self, value: typing.Any) -> bool: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    def IndexOf(self, value: typing.Any) -> int: ...


class ListSortDirection(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Ascending : ListSortDirection # 0
    Descending : ListSortDirection # 1


class LocalizableAttribute(Attribute):
    def __init__(self, isLocalizable: bool) -> None: ...
    Default : LocalizableAttribute
    No : LocalizableAttribute
    Yes : LocalizableAttribute
    @property
    def IsLocalizable(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class LookupBindingPropertiesAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, dataSource: str, displayMember: str, valueMember: str, lookupMember: str) -> None: ...
    Default : LookupBindingPropertiesAttribute
    @property
    def DataSource(self) -> str: ...
    @property
    def DisplayMember(self) -> str: ...
    @property
    def LookupMember(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def ValueMember(self) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class MarshalByValueComponent(IComponent, IServiceProvider):
    def __init__(self) -> None: ...
    @property
    def Container(self) -> IContainer: ...
    @property
    def DesignMode(self) -> bool: ...
    @property
    def Site(self) -> ISite: ...
    @Site.setter
    def Site(self, value: ISite) -> ISite: ...
    def Dispose(self) -> None: ...
    def GetService(self, service: typing.Type[typing.Any]) -> typing.Any: ...
    def ToString(self) -> str: ...


class MaskedTextProvider(ICloneable):
    @typing.overload
    def __init__(self, mask: str) -> None: ...
    @typing.overload
    def __init__(self, mask: str, culture: CultureInfo) -> None: ...
    @typing.overload
    def __init__(self, mask: str, culture: CultureInfo, allowPromptAsInput: bool, promptChar: str, passwordChar: str, restrictToAscii: bool) -> None: ...
    @typing.overload
    def __init__(self, mask: str, culture: CultureInfo, passwordChar: str, allowPromptAsInput: bool) -> None: ...
    @typing.overload
    def __init__(self, mask: str, culture: CultureInfo, restrictToAscii: bool) -> None: ...
    @typing.overload
    def __init__(self, mask: str, passwordChar: str, allowPromptAsInput: bool) -> None: ...
    @typing.overload
    def __init__(self, mask: str, restrictToAscii: bool) -> None: ...
    @property
    def AllowPromptAsInput(self) -> bool: ...
    @property
    def AsciiOnly(self) -> bool: ...
    @property
    def AssignedEditPositionCount(self) -> int: ...
    @AssignedEditPositionCount.setter
    def AssignedEditPositionCount(self, value: int) -> int: ...
    @property
    def AvailableEditPositionCount(self) -> int: ...
    @property
    def Culture(self) -> CultureInfo: ...
    @classmethod
    @property
    def DefaultPasswordChar(cls) -> str: ...
    @property
    def EditPositionCount(self) -> int: ...
    @property
    def EditPositions(self) -> IEnumerator: ...
    @property
    def IncludeLiterals(self) -> bool: ...
    @IncludeLiterals.setter
    def IncludeLiterals(self, value: bool) -> bool: ...
    @property
    def IncludePrompt(self) -> bool: ...
    @IncludePrompt.setter
    def IncludePrompt(self, value: bool) -> bool: ...
    @classmethod
    @property
    def InvalidIndex(cls) -> int: ...
    @property
    def IsPassword(self) -> bool: ...
    @IsPassword.setter
    def IsPassword(self, value: bool) -> bool: ...
    @property
    def Item(self) -> str: ...
    @property
    def LastAssignedPosition(self) -> int: ...
    @property
    def Length(self) -> int: ...
    @property
    def Mask(self) -> str: ...
    @property
    def MaskCompleted(self) -> bool: ...
    @property
    def MaskFull(self) -> bool: ...
    @property
    def PasswordChar(self) -> str: ...
    @PasswordChar.setter
    def PasswordChar(self, value: str) -> str: ...
    @property
    def PromptChar(self) -> str: ...
    @PromptChar.setter
    def PromptChar(self, value: str) -> str: ...
    @property
    def ResetOnPrompt(self) -> bool: ...
    @ResetOnPrompt.setter
    def ResetOnPrompt(self, value: bool) -> bool: ...
    @property
    def ResetOnSpace(self) -> bool: ...
    @ResetOnSpace.setter
    def ResetOnSpace(self, value: bool) -> bool: ...
    @property
    def SkipLiterals(self) -> bool: ...
    @SkipLiterals.setter
    def SkipLiterals(self, value: bool) -> bool: ...
    def Clone(self) -> typing.Any: ...
    def FindAssignedEditPositionFrom(self, position: int, direction: bool) -> int: ...
    def FindAssignedEditPositionInRange(self, startPosition: int, endPosition: int, direction: bool) -> int: ...
    def FindEditPositionFrom(self, position: int, direction: bool) -> int: ...
    def FindEditPositionInRange(self, startPosition: int, endPosition: int, direction: bool) -> int: ...
    def FindNonEditPositionFrom(self, position: int, direction: bool) -> int: ...
    def FindNonEditPositionInRange(self, startPosition: int, endPosition: int, direction: bool) -> int: ...
    def FindUnassignedEditPositionFrom(self, position: int, direction: bool) -> int: ...
    def FindUnassignedEditPositionInRange(self, startPosition: int, endPosition: int, direction: bool) -> int: ...
    @staticmethod
    def GetOperationResultFromHint(hint: MaskedTextResultHint) -> bool: ...
    def IsAvailablePosition(self, position: int) -> bool: ...
    def IsEditPosition(self, position: int) -> bool: ...
    @staticmethod
    def IsValidInputChar(c: str) -> bool: ...
    @staticmethod
    def IsValidMaskChar(c: str) -> bool: ...
    @staticmethod
    def IsValidPasswordChar(c: str) -> bool: ...
    def ToDisplayString(self) -> str: ...
    def VerifyChar(self, input: str, position: int, hint: clr.Reference[MaskedTextResultHint]) -> bool: ...
    def VerifyEscapeChar(self, input: str, position: int) -> bool: ...
    # Skipped Add due to it being static, abstract and generic.

    Add : Add_MethodGroup
    class Add_MethodGroup:
        @typing.overload
        def __call__(self, input: str) -> bool:...
        # Method Add(input : String) was skipped since it collides with above method
        @typing.overload
        def __call__(self, input: str, testPosition: clr.Reference[int], resultHint: clr.Reference[MaskedTextResultHint]) -> bool:...
        # Method Add(input : String, testPosition : Int32&, resultHint : MaskedTextResultHint&) was skipped since it collides with above method

    # Skipped Clear due to it being static, abstract and generic.

    Clear : Clear_MethodGroup
    class Clear_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, resultHint: clr.Reference[MaskedTextResultHint]) -> None:...

    # Skipped InsertAt due to it being static, abstract and generic.

    InsertAt : InsertAt_MethodGroup
    class InsertAt_MethodGroup:
        @typing.overload
        def __call__(self, input: str, position: int) -> bool:...
        # Method InsertAt(input : String, position : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, input: str, position: int, testPosition: clr.Reference[int], resultHint: clr.Reference[MaskedTextResultHint]) -> bool:...
        # Method InsertAt(input : String, position : Int32, testPosition : Int32&, resultHint : MaskedTextResultHint&) was skipped since it collides with above method

    # Skipped Remove due to it being static, abstract and generic.

    Remove : Remove_MethodGroup
    class Remove_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, testPosition: clr.Reference[int], resultHint: clr.Reference[MaskedTextResultHint]) -> bool:...

    # Skipped RemoveAt due to it being static, abstract and generic.

    RemoveAt : RemoveAt_MethodGroup
    class RemoveAt_MethodGroup:
        @typing.overload
        def __call__(self, position: int) -> bool:...
        @typing.overload
        def __call__(self, startPosition: int, endPosition: int) -> bool:...
        @typing.overload
        def __call__(self, startPosition: int, endPosition: int, testPosition: clr.Reference[int], resultHint: clr.Reference[MaskedTextResultHint]) -> bool:...

    # Skipped Replace due to it being static, abstract and generic.

    Replace : Replace_MethodGroup
    class Replace_MethodGroup:
        @typing.overload
        def __call__(self, input: str, position: int) -> bool:...
        # Method Replace(input : String, position : Int32) was skipped since it collides with above method
        @typing.overload
        def __call__(self, input: str, position: int, testPosition: clr.Reference[int], resultHint: clr.Reference[MaskedTextResultHint]) -> bool:...
        # Method Replace(input : Char, position : Int32, testPosition : Int32&, resultHint : MaskedTextResultHint&) was skipped since it collides with above method
        @typing.overload
        def __call__(self, input: str, startPosition: int, endPosition: int, testPosition: clr.Reference[int], resultHint: clr.Reference[MaskedTextResultHint]) -> bool:...
        # Method Replace(input : Char, startPosition : Int32, endPosition : Int32, testPosition : Int32&, resultHint : MaskedTextResultHint&) was skipped since it collides with above method

    # Skipped Set due to it being static, abstract and generic.

    Set : Set_MethodGroup
    class Set_MethodGroup:
        @typing.overload
        def __call__(self, input: str) -> bool:...
        @typing.overload
        def __call__(self, input: str, testPosition: clr.Reference[int], resultHint: clr.Reference[MaskedTextResultHint]) -> bool:...

    # Skipped ToString due to it being static, abstract and generic.

    ToString : ToString_MethodGroup
    class ToString_MethodGroup:
        @typing.overload
        def __call__(self) -> str:...
        @typing.overload
        def __call__(self, ignorePasswordChar: bool) -> str:...
        @typing.overload
        def __call__(self, startPosition: int, length: int) -> str:...
        # Method ToString(includePrompt : Boolean, includeLiterals : Boolean) was skipped since it collides with above method
        @typing.overload
        def __call__(self, ignorePasswordChar: bool, startPosition: int, length: int) -> str:...
        @typing.overload
        def __call__(self, includePrompt: bool, includeLiterals: bool, startPosition: int, length: int) -> str:...
        @typing.overload
        def __call__(self, ignorePasswordChar: bool, includePrompt: bool, includeLiterals: bool, startPosition: int, length: int) -> str:...

    # Skipped VerifyString due to it being static, abstract and generic.

    VerifyString : VerifyString_MethodGroup
    class VerifyString_MethodGroup:
        @typing.overload
        def __call__(self, input: str) -> bool:...
        @typing.overload
        def __call__(self, input: str, testPosition: clr.Reference[int], resultHint: clr.Reference[MaskedTextResultHint]) -> bool:...



class MaskedTextResultHint(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Unknown : MaskedTextResultHint # 0
    CharacterEscaped : MaskedTextResultHint # 1
    NoEffect : MaskedTextResultHint # 2
    SideEffect : MaskedTextResultHint # 3
    Success : MaskedTextResultHint # 4
    PositionOutOfRange : MaskedTextResultHint # -55
    NonEditPosition : MaskedTextResultHint # -54
    UnavailableEditPosition : MaskedTextResultHint # -53
    PromptCharNotAllowed : MaskedTextResultHint # -52
    InvalidInput : MaskedTextResultHint # -51
    SignedDigitExpected : MaskedTextResultHint # -5
    LetterExpected : MaskedTextResultHint # -4
    DigitExpected : MaskedTextResultHint # -3
    AlphanumericCharacterExpected : MaskedTextResultHint # -2
    AsciiCharacterExpected : MaskedTextResultHint # -1


class MemberDescriptor(abc.ABC):
    @property
    def Attributes(self) -> AttributeCollection: ...
    @property
    def Category(self) -> str: ...
    @property
    def Description(self) -> str: ...
    @property
    def DesignTimeOnly(self) -> bool: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def IsBrowsable(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class MergablePropertyAttribute(Attribute):
    def __init__(self, allowMerge: bool) -> None: ...
    Default : MergablePropertyAttribute
    No : MergablePropertyAttribute
    Yes : MergablePropertyAttribute
    @property
    def AllowMerge(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class MultilineStringConverter(TypeConverter):
    def __init__(self) -> None: ...
    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties : GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...

    # Skipped GetPropertiesSupported due to it being static, abstract and generic.

    GetPropertiesSupported : GetPropertiesSupported_MethodGroup
    class GetPropertiesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...



class NestedContainer(Container, INestedContainer):
    def __init__(self, owner: IComponent) -> None: ...
    @property
    def Components(self) -> ComponentCollection: ...
    @property
    def Owner(self) -> IComponent: ...


class NotifyParentPropertyAttribute(Attribute):
    def __init__(self, notifyParent: bool) -> None: ...
    Default : NotifyParentPropertyAttribute
    No : NotifyParentPropertyAttribute
    Yes : NotifyParentPropertyAttribute
    @property
    def NotifyParent(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class NullableConverter(TypeConverter):
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    @property
    def NullableType(self) -> typing.Type[typing.Any]: ...
    @property
    def UnderlyingType(self) -> typing.Type[typing.Any]: ...
    @property
    def UnderlyingTypeConverter(self) -> TypeConverter: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped CreateInstance due to it being static, abstract and generic.

    CreateInstance : CreateInstance_MethodGroup
    class CreateInstance_MethodGroup:
        @typing.overload
        def __call__(self, propertyValues: IDictionary) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, propertyValues: IDictionary) -> typing.Any:...

    # Skipped GetCreateInstanceSupported due to it being static, abstract and generic.

    GetCreateInstanceSupported : GetCreateInstanceSupported_MethodGroup
    class GetCreateInstanceSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties : GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...

    # Skipped GetPropertiesSupported due to it being static, abstract and generic.

    GetPropertiesSupported : GetPropertiesSupported_MethodGroup
    class GetPropertiesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetStandardValues due to it being static, abstract and generic.

    GetStandardValues : GetStandardValues_MethodGroup
    class GetStandardValues_MethodGroup:
        @typing.overload
        def __call__(self) -> ICollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> TypeConverter.StandardValuesCollection:...

    # Skipped GetStandardValuesExclusive due to it being static, abstract and generic.

    GetStandardValuesExclusive : GetStandardValuesExclusive_MethodGroup
    class GetStandardValuesExclusive_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetStandardValuesSupported due to it being static, abstract and generic.

    GetStandardValuesSupported : GetStandardValuesSupported_MethodGroup
    class GetStandardValuesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped IsValid due to it being static, abstract and generic.

    IsValid : IsValid_MethodGroup
    class IsValid_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> bool:...



class ParenthesizePropertyNameAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, needParenthesis: bool) -> None: ...
    Default : ParenthesizePropertyNameAttribute
    @property
    def NeedParenthesis(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class PasswordPropertyTextAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, password: bool) -> None: ...
    Default : PasswordPropertyTextAttribute
    No : PasswordPropertyTextAttribute
    Yes : PasswordPropertyTextAttribute
    @property
    def Password(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, o: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class ProgressChangedEventArgs(EventArgs):
    def __init__(self, progressPercentage: int, userState: typing.Any) -> None: ...
    @property
    def ProgressPercentage(self) -> int: ...
    @property
    def UserState(self) -> typing.Any: ...


class ProgressChangedEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: ProgressChangedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: ProgressChangedEventArgs) -> None: ...


class PropertyChangedEventArgs(EventArgs):
    def __init__(self, propertyName: str) -> None: ...
    @property
    def PropertyName(self) -> str: ...


class PropertyChangedEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: PropertyChangedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: PropertyChangedEventArgs) -> None: ...


class PropertyChangingEventArgs(EventArgs):
    def __init__(self, propertyName: str) -> None: ...
    @property
    def PropertyName(self) -> str: ...


class PropertyChangingEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: PropertyChangingEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: PropertyChangingEventArgs) -> None: ...


class PropertyDescriptor(MemberDescriptor):
    @property
    def Attributes(self) -> AttributeCollection: ...
    @property
    def Category(self) -> str: ...
    @property
    def ComponentType(self) -> typing.Type[typing.Any]: ...
    @property
    def Converter(self) -> TypeConverter: ...
    @property
    def Description(self) -> str: ...
    @property
    def DesignTimeOnly(self) -> bool: ...
    @property
    def DisplayName(self) -> str: ...
    @property
    def IsBrowsable(self) -> bool: ...
    @property
    def IsLocalizable(self) -> bool: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def PropertyType(self) -> typing.Type[typing.Any]: ...
    @property
    def SerializationVisibility(self) -> DesignerSerializationVisibility: ...
    @property
    def SupportsChangeEvents(self) -> bool: ...
    def AddValueChanged(self, component: typing.Any, handler: EventHandler) -> None: ...
    @abc.abstractmethod
    def CanResetValue(self, component: typing.Any) -> bool: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetEditor(self, editorBaseType: typing.Type[typing.Any]) -> typing.Any: ...
    def GetHashCode(self) -> int: ...
    @abc.abstractmethod
    def GetValue(self, component: typing.Any) -> typing.Any: ...
    def RemoveValueChanged(self, component: typing.Any, handler: EventHandler) -> None: ...
    @abc.abstractmethod
    def ResetValue(self, component: typing.Any) -> None: ...
    @abc.abstractmethod
    def SetValue(self, component: typing.Any, value: typing.Any) -> None: ...
    @abc.abstractmethod
    def ShouldSerializeValue(self, component: typing.Any) -> bool: ...
    # Skipped GetChildProperties due to it being static, abstract and generic.

    GetChildProperties : GetChildProperties_MethodGroup
    class GetChildProperties_MethodGroup:
        @typing.overload
        def __call__(self) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, filter: Array_1[Attribute]) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, instance: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, instance: typing.Any, filter: Array_1[Attribute]) -> PropertyDescriptorCollection:...



class PropertyDescriptorCollection(IDictionary, IList):
    @typing.overload
    def __init__(self, properties: Array_1[PropertyDescriptor]) -> None: ...
    @typing.overload
    def __init__(self, properties: Array_1[PropertyDescriptor], readOnly: bool) -> None: ...
    Empty : PropertyDescriptorCollection
    @property
    def Count(self) -> int: ...
    @Count.setter
    def Count(self, value: int) -> int: ...
    @property
    def Item(self) -> PropertyDescriptor: ...
    @property
    def Item(self) -> PropertyDescriptor: ...
    def Add(self, value: PropertyDescriptor) -> int: ...
    def Clear(self) -> None: ...
    def Contains(self, value: PropertyDescriptor) -> bool: ...
    def CopyTo(self, array: Array, index: int) -> None: ...
    def Find(self, name: str, ignoreCase: bool) -> PropertyDescriptor: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def IndexOf(self, value: PropertyDescriptor) -> int: ...
    def Insert(self, index: int, value: PropertyDescriptor) -> None: ...
    def Remove(self, value: PropertyDescriptor) -> None: ...
    def RemoveAt(self, index: int) -> None: ...
    # Skipped Sort due to it being static, abstract and generic.

    Sort : Sort_MethodGroup
    class Sort_MethodGroup:
        @typing.overload
        def __call__(self) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, names: Array_1[str]) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, comparer: IComparer) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, names: Array_1[str], comparer: IComparer) -> PropertyDescriptorCollection:...



class PropertyTabAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, tabClass: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, tabClass: typing.Type[typing.Any], tabScope: PropertyTabScope) -> None: ...
    @typing.overload
    def __init__(self, tabClassName: str) -> None: ...
    @typing.overload
    def __init__(self, tabClassName: str, tabScope: PropertyTabScope) -> None: ...
    @property
    def TabClasses(self) -> Array_1[typing.Type[typing.Any]]: ...
    @property
    def TabScopes(self) -> Array_1[PropertyTabScope]: ...
    @TabScopes.setter
    def TabScopes(self, value: Array_1[PropertyTabScope]) -> Array_1[PropertyTabScope]: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def GetHashCode(self) -> int: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: PropertyTabAttribute) -> bool:...
        @typing.overload
        def __call__(self, other: typing.Any) -> bool:...



class PropertyTabScope(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Static : PropertyTabScope # 0
    Global : PropertyTabScope # 1
    Document : PropertyTabScope # 2
    Component : PropertyTabScope # 3


class ProvidePropertyAttribute(Attribute):
    @typing.overload
    def __init__(self, propertyName: str, receiverType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, propertyName: str, receiverTypeName: str) -> None: ...
    @property
    def PropertyName(self) -> str: ...
    @property
    def ReceiverTypeName(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class ReadOnlyAttribute(Attribute):
    def __init__(self, isReadOnly: bool) -> None: ...
    Default : ReadOnlyAttribute
    No : ReadOnlyAttribute
    Yes : ReadOnlyAttribute
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, value: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class RecommendedAsConfigurableAttribute(Attribute):
    def __init__(self, recommendedAsConfigurable: bool) -> None: ...
    Default : RecommendedAsConfigurableAttribute
    No : RecommendedAsConfigurableAttribute
    Yes : RecommendedAsConfigurableAttribute
    @property
    def RecommendedAsConfigurable(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class ReferenceConverter(TypeConverter):
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped GetStandardValues due to it being static, abstract and generic.

    GetStandardValues : GetStandardValues_MethodGroup
    class GetStandardValues_MethodGroup:
        @typing.overload
        def __call__(self) -> ICollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> TypeConverter.StandardValuesCollection:...

    # Skipped GetStandardValuesExclusive due to it being static, abstract and generic.

    GetStandardValuesExclusive : GetStandardValuesExclusive_MethodGroup
    class GetStandardValuesExclusive_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetStandardValuesSupported due to it being static, abstract and generic.

    GetStandardValuesSupported : GetStandardValuesSupported_MethodGroup
    class GetStandardValuesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...



class RefreshEventArgs(EventArgs):
    @typing.overload
    def __init__(self, componentChanged: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, typeChanged: typing.Type[typing.Any]) -> None: ...
    @property
    def ComponentChanged(self) -> typing.Any: ...
    @property
    def TypeChanged(self) -> typing.Type[typing.Any]: ...


class RefreshEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, e: RefreshEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, e: RefreshEventArgs) -> None: ...


class RefreshProperties(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : RefreshProperties # 0
    All : RefreshProperties # 1
    Repaint : RefreshProperties # 2


class RefreshPropertiesAttribute(Attribute):
    def __init__(self, refresh: RefreshProperties) -> None: ...
    All : RefreshPropertiesAttribute
    Default : RefreshPropertiesAttribute
    Repaint : RefreshPropertiesAttribute
    @property
    def RefreshProperties(self) -> RefreshProperties: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class RunInstallerAttribute(Attribute):
    def __init__(self, runInstaller: bool) -> None: ...
    Default : RunInstallerAttribute
    No : RunInstallerAttribute
    Yes : RunInstallerAttribute
    @property
    def RunInstaller(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class RunWorkerCompletedEventArgs(AsyncCompletedEventArgs):
    def __init__(self, result: typing.Any, error: Exception, cancelled: bool) -> None: ...
    @property
    def Cancelled(self) -> bool: ...
    @property
    def Error(self) -> Exception: ...
    @property
    def Result(self) -> typing.Any: ...
    @property
    def UserState(self) -> typing.Any: ...


class RunWorkerCompletedEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: RunWorkerCompletedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: RunWorkerCompletedEventArgs) -> None: ...


class SByteConverter(BaseNumberConverter):
    def __init__(self) -> None: ...


class SettingsBindableAttribute(Attribute):
    def __init__(self, bindable: bool) -> None: ...
    No : SettingsBindableAttribute
    Yes : SettingsBindableAttribute
    @property
    def Bindable(self) -> bool: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class SingleConverter(BaseNumberConverter):
    def __init__(self) -> None: ...


class StringConverter(TypeConverter):
    def __init__(self) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...



class SyntaxCheck(abc.ABC):
    @staticmethod
    def CheckMachineName(value: str) -> bool: ...
    @staticmethod
    def CheckPath(value: str) -> bool: ...
    @staticmethod
    def CheckRootedPath(value: str) -> bool: ...


class TimeSpanConverter(TypeConverter):
    def __init__(self) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...



class ToolboxItemAttribute(Attribute):
    @typing.overload
    def __init__(self, defaultType: bool) -> None: ...
    @typing.overload
    def __init__(self, toolboxItemType: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, toolboxItemTypeName: str) -> None: ...
    Default : ToolboxItemAttribute
    # FIXME: "None" is a reserved keyword
    # None : ToolboxItemAttribute
    @property
    def ToolboxItemType(self) -> typing.Type[typing.Any]: ...
    @property
    def ToolboxItemTypeName(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class ToolboxItemFilterAttribute(Attribute):
    @typing.overload
    def __init__(self, filterString: str) -> None: ...
    @typing.overload
    def __init__(self, filterString: str, filterType: ToolboxItemFilterType) -> None: ...
    @property
    def FilterString(self) -> str: ...
    @property
    def FilterType(self) -> ToolboxItemFilterType: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def Match(self, obj: typing.Any) -> bool: ...
    def ToString(self) -> str: ...


class ToolboxItemFilterType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Allow : ToolboxItemFilterType # 0
    Custom : ToolboxItemFilterType # 1
    Prevent : ToolboxItemFilterType # 2
    Require : ToolboxItemFilterType # 3


class TypeConverter:
    def __init__(self) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertFromInvariantString due to it being static, abstract and generic.

    ConvertFromInvariantString : ConvertFromInvariantString_MethodGroup
    class ConvertFromInvariantString_MethodGroup:
        @typing.overload
        def __call__(self, text: str) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, text: str) -> typing.Any:...

    # Skipped ConvertFromString due to it being static, abstract and generic.

    ConvertFromString : ConvertFromString_MethodGroup
    class ConvertFromString_MethodGroup:
        @typing.overload
        def __call__(self, text: str) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, text: str) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, text: str) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped ConvertToInvariantString due to it being static, abstract and generic.

    ConvertToInvariantString : ConvertToInvariantString_MethodGroup
    class ConvertToInvariantString_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> str:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> str:...

    # Skipped ConvertToString due to it being static, abstract and generic.

    ConvertToString : ConvertToString_MethodGroup
    class ConvertToString_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> str:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> str:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> str:...

    # Skipped CreateInstance due to it being static, abstract and generic.

    CreateInstance : CreateInstance_MethodGroup
    class CreateInstance_MethodGroup:
        @typing.overload
        def __call__(self, propertyValues: IDictionary) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, propertyValues: IDictionary) -> typing.Any:...

    # Skipped GetCreateInstanceSupported due to it being static, abstract and generic.

    GetCreateInstanceSupported : GetCreateInstanceSupported_MethodGroup
    class GetCreateInstanceSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties : GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...

    # Skipped GetPropertiesSupported due to it being static, abstract and generic.

    GetPropertiesSupported : GetPropertiesSupported_MethodGroup
    class GetPropertiesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetStandardValues due to it being static, abstract and generic.

    GetStandardValues : GetStandardValues_MethodGroup
    class GetStandardValues_MethodGroup:
        @typing.overload
        def __call__(self) -> ICollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> TypeConverter.StandardValuesCollection:...

    # Skipped GetStandardValuesExclusive due to it being static, abstract and generic.

    GetStandardValuesExclusive : GetStandardValuesExclusive_MethodGroup
    class GetStandardValuesExclusive_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetStandardValuesSupported due to it being static, abstract and generic.

    GetStandardValuesSupported : GetStandardValuesSupported_MethodGroup
    class GetStandardValuesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped IsValid due to it being static, abstract and generic.

    IsValid : IsValid_MethodGroup
    class IsValid_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> bool:...


    class StandardValuesCollection(ICollection):
        def __init__(self, values: ICollection) -> None: ...
        @property
        def Count(self) -> int: ...
        @property
        def Item(self) -> typing.Any: ...
        def CopyTo(self, array: Array, index: int) -> None: ...
        def GetEnumerator(self) -> IEnumerator: ...



class TypeConverterAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, typeName: str) -> None: ...
    Default : TypeConverterAttribute
    @property
    def ConverterTypeName(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...


class TypeDescriptionProvider(abc.ABC):
    def CreateInstance(self, provider: IServiceProvider, objectType: typing.Type[typing.Any], argTypes: Array_1[typing.Type[typing.Any]], args: Array_1[typing.Any]) -> typing.Any: ...
    def GetCache(self, instance: typing.Any) -> IDictionary: ...
    def GetExtendedTypeDescriptor(self, instance: typing.Any) -> ICustomTypeDescriptor: ...
    def GetFullComponentName(self, component: typing.Any) -> str: ...
    def GetRuntimeType(self, reflectionType: typing.Type[typing.Any]) -> typing.Type[typing.Any]: ...
    def IsSupportedType(self, type: typing.Type[typing.Any]) -> bool: ...
    # Skipped GetReflectionType due to it being static, abstract and generic.

    GetReflectionType : GetReflectionType_MethodGroup
    class GetReflectionType_MethodGroup:
        @typing.overload
        def __call__(self, objectType: typing.Type[typing.Any]) -> typing.Type[typing.Any]:...
        @typing.overload
        def __call__(self, instance: typing.Any) -> typing.Type[typing.Any]:...
        @typing.overload
        def __call__(self, objectType: typing.Type[typing.Any], instance: typing.Any) -> typing.Type[typing.Any]:...

    # Skipped GetTypeDescriptor due to it being static, abstract and generic.

    GetTypeDescriptor : GetTypeDescriptor_MethodGroup
    class GetTypeDescriptor_MethodGroup:
        @typing.overload
        def __call__(self, objectType: typing.Type[typing.Any]) -> ICustomTypeDescriptor:...
        @typing.overload
        def __call__(self, instance: typing.Any) -> ICustomTypeDescriptor:...
        @typing.overload
        def __call__(self, objectType: typing.Type[typing.Any], instance: typing.Any) -> ICustomTypeDescriptor:...



class TypeDescriptionProviderAttribute(Attribute):
    @typing.overload
    def __init__(self, type: typing.Type[typing.Any]) -> None: ...
    @typing.overload
    def __init__(self, typeName: str) -> None: ...
    @property
    def TypeId(self) -> typing.Any: ...
    @property
    def TypeName(self) -> str: ...


class TypeDescriptor:
    @classmethod
    @property
    def ComNativeDescriptorHandler(cls) -> IComNativeDescriptorHandler: ...
    @classmethod
    @ComNativeDescriptorHandler.setter
    def ComNativeDescriptorHandler(cls, value: IComNativeDescriptorHandler) -> IComNativeDescriptorHandler: ...
    @classmethod
    @property
    def ComObjectType(cls) -> typing.Type[typing.Any]: ...
    @classmethod
    @property
    def InterfaceType(cls) -> typing.Type[typing.Any]: ...
    @staticmethod
    def AddEditorTable(editorBaseType: typing.Type[typing.Any], table: Hashtable) -> None: ...
    @staticmethod
    def CreateAssociation(primary: typing.Any, secondary: typing.Any) -> None: ...
    @staticmethod
    def CreateDesigner(component: IComponent, designerBaseType: typing.Type[typing.Any]) -> IDesigner: ...
    @staticmethod
    def CreateInstance(provider: IServiceProvider, objectType: typing.Type[typing.Any], argTypes: Array_1[typing.Type[typing.Any]], args: Array_1[typing.Any]) -> typing.Any: ...
    @staticmethod
    def GetAssociation(type: typing.Type[typing.Any], primary: typing.Any) -> typing.Any: ...
    @staticmethod
    def GetFullComponentName(component: typing.Any) -> str: ...
    @staticmethod
    def RemoveAssociation(primary: typing.Any, secondary: typing.Any) -> None: ...
    @staticmethod
    def RemoveAssociations(primary: typing.Any) -> None: ...
    @staticmethod
    def SortDescriptorArray(infos: IList) -> None: ...
    # Skipped AddAttributes due to it being static, abstract and generic.

    AddAttributes : AddAttributes_MethodGroup
    class AddAttributes_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], attributes: Array_1[Attribute]) -> TypeDescriptionProvider:...
        @typing.overload
        def __call__(self, instance: typing.Any, attributes: Array_1[Attribute]) -> TypeDescriptionProvider:...

    # Skipped AddProvider due to it being static, abstract and generic.

    AddProvider : AddProvider_MethodGroup
    class AddProvider_MethodGroup:
        @typing.overload
        def __call__(self, provider: TypeDescriptionProvider, type: typing.Type[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, provider: TypeDescriptionProvider, instance: typing.Any) -> None:...

    # Skipped AddProviderTransparent due to it being static, abstract and generic.

    AddProviderTransparent : AddProviderTransparent_MethodGroup
    class AddProviderTransparent_MethodGroup:
        @typing.overload
        def __call__(self, provider: TypeDescriptionProvider, type: typing.Type[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, provider: TypeDescriptionProvider, instance: typing.Any) -> None:...

    # Skipped CreateEvent due to it being static, abstract and generic.

    CreateEvent : CreateEvent_MethodGroup
    class CreateEvent_MethodGroup:
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any], oldEventDescriptor: EventDescriptor, attributes: Array_1[Attribute]) -> EventDescriptor:...
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any], name: str, type: typing.Type[typing.Any], attributes: Array_1[Attribute]) -> EventDescriptor:...

    # Skipped CreateProperty due to it being static, abstract and generic.

    CreateProperty : CreateProperty_MethodGroup
    class CreateProperty_MethodGroup:
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any], oldPropertyDescriptor: PropertyDescriptor, attributes: Array_1[Attribute]) -> PropertyDescriptor:...
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any], name: str, type: typing.Type[typing.Any], attributes: Array_1[Attribute]) -> PropertyDescriptor:...

    # Skipped GetAttributes due to it being static, abstract and generic.

    GetAttributes : GetAttributes_MethodGroup
    class GetAttributes_MethodGroup:
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any]) -> AttributeCollection:...
        @typing.overload
        def __call__(self, component: typing.Any) -> AttributeCollection:...
        @typing.overload
        def __call__(self, component: typing.Any, noCustomTypeDesc: bool) -> AttributeCollection:...

    # Skipped GetClassName due to it being static, abstract and generic.

    GetClassName : GetClassName_MethodGroup
    class GetClassName_MethodGroup:
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any]) -> str:...
        @typing.overload
        def __call__(self, component: typing.Any) -> str:...
        @typing.overload
        def __call__(self, component: typing.Any, noCustomTypeDesc: bool) -> str:...

    # Skipped GetComponentName due to it being static, abstract and generic.

    GetComponentName : GetComponentName_MethodGroup
    class GetComponentName_MethodGroup:
        @typing.overload
        def __call__(self, component: typing.Any) -> str:...
        @typing.overload
        def __call__(self, component: typing.Any, noCustomTypeDesc: bool) -> str:...

    # Skipped GetConverter due to it being static, abstract and generic.

    GetConverter : GetConverter_MethodGroup
    class GetConverter_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> TypeConverter:...
        @typing.overload
        def __call__(self, component: typing.Any) -> TypeConverter:...
        @typing.overload
        def __call__(self, component: typing.Any, noCustomTypeDesc: bool) -> TypeConverter:...

    # Skipped GetDefaultEvent due to it being static, abstract and generic.

    GetDefaultEvent : GetDefaultEvent_MethodGroup
    class GetDefaultEvent_MethodGroup:
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any]) -> EventDescriptor:...
        @typing.overload
        def __call__(self, component: typing.Any) -> EventDescriptor:...
        @typing.overload
        def __call__(self, component: typing.Any, noCustomTypeDesc: bool) -> EventDescriptor:...

    # Skipped GetDefaultProperty due to it being static, abstract and generic.

    GetDefaultProperty : GetDefaultProperty_MethodGroup
    class GetDefaultProperty_MethodGroup:
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any]) -> PropertyDescriptor:...
        @typing.overload
        def __call__(self, component: typing.Any) -> PropertyDescriptor:...
        @typing.overload
        def __call__(self, component: typing.Any, noCustomTypeDesc: bool) -> PropertyDescriptor:...

    # Skipped GetEditor due to it being static, abstract and generic.

    GetEditor : GetEditor_MethodGroup
    class GetEditor_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any], editorBaseType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, component: typing.Any, editorBaseType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, component: typing.Any, editorBaseType: typing.Type[typing.Any], noCustomTypeDesc: bool) -> typing.Any:...

    # Skipped GetEvents due to it being static, abstract and generic.

    GetEvents : GetEvents_MethodGroup
    class GetEvents_MethodGroup:
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any]) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, component: typing.Any) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any], attributes: Array_1[Attribute]) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, component: typing.Any, attributes: Array_1[Attribute]) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, component: typing.Any, noCustomTypeDesc: bool) -> EventDescriptorCollection:...
        @typing.overload
        def __call__(self, component: typing.Any, attributes: Array_1[Attribute], noCustomTypeDesc: bool) -> EventDescriptorCollection:...

    # Skipped GetProperties due to it being static, abstract and generic.

    GetProperties : GetProperties_MethodGroup
    class GetProperties_MethodGroup:
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any]) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, component: typing.Any) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, componentType: typing.Type[typing.Any], attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, component: typing.Any, attributes: Array_1[Attribute]) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, component: typing.Any, noCustomTypeDesc: bool) -> PropertyDescriptorCollection:...
        @typing.overload
        def __call__(self, component: typing.Any, attributes: Array_1[Attribute], noCustomTypeDesc: bool) -> PropertyDescriptorCollection:...

    # Skipped GetProvider due to it being static, abstract and generic.

    GetProvider : GetProvider_MethodGroup
    class GetProvider_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> TypeDescriptionProvider:...
        @typing.overload
        def __call__(self, instance: typing.Any) -> TypeDescriptionProvider:...

    # Skipped GetReflectionType due to it being static, abstract and generic.

    GetReflectionType : GetReflectionType_MethodGroup
    class GetReflectionType_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> typing.Type[typing.Any]:...
        @typing.overload
        def __call__(self, instance: typing.Any) -> typing.Type[typing.Any]:...

    # Skipped Refresh due to it being static, abstract and generic.

    Refresh : Refresh_MethodGroup
    class Refresh_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, assembly: Assembly) -> None:...
        @typing.overload
        def __call__(self, module: Module) -> None:...
        @typing.overload
        def __call__(self, component: typing.Any) -> None:...

    # Skipped RemoveProvider due to it being static, abstract and generic.

    RemoveProvider : RemoveProvider_MethodGroup
    class RemoveProvider_MethodGroup:
        @typing.overload
        def __call__(self, provider: TypeDescriptionProvider, type: typing.Type[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, provider: TypeDescriptionProvider, instance: typing.Any) -> None:...

    # Skipped RemoveProviderTransparent due to it being static, abstract and generic.

    RemoveProviderTransparent : RemoveProviderTransparent_MethodGroup
    class RemoveProviderTransparent_MethodGroup:
        @typing.overload
        def __call__(self, provider: TypeDescriptionProvider, type: typing.Type[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, provider: TypeDescriptionProvider, instance: typing.Any) -> None:...



class TypeListConverter(TypeConverter, abc.ABC):
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped GetStandardValues due to it being static, abstract and generic.

    GetStandardValues : GetStandardValues_MethodGroup
    class GetStandardValues_MethodGroup:
        @typing.overload
        def __call__(self) -> ICollection:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> TypeConverter.StandardValuesCollection:...

    # Skipped GetStandardValuesExclusive due to it being static, abstract and generic.

    GetStandardValuesExclusive : GetStandardValuesExclusive_MethodGroup
    class GetStandardValuesExclusive_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...

    # Skipped GetStandardValuesSupported due to it being static, abstract and generic.

    GetStandardValuesSupported : GetStandardValuesSupported_MethodGroup
    class GetStandardValuesSupported_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext) -> bool:...



class UInt16Converter(BaseNumberConverter):
    def __init__(self) -> None: ...


class UInt32Converter(BaseNumberConverter):
    def __init__(self) -> None: ...


class UInt64Converter(BaseNumberConverter):
    def __init__(self) -> None: ...


class VersionConverter(TypeConverter):
    def __init__(self) -> None: ...
    # Skipped CanConvertFrom due to it being static, abstract and generic.

    CanConvertFrom : CanConvertFrom_MethodGroup
    class CanConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, sourceType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, sourceType: typing.Type[typing.Any]) -> bool:...

    # Skipped CanConvertTo due to it being static, abstract and generic.

    CanConvertTo : CanConvertTo_MethodGroup
    class CanConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, destinationType: typing.Type[typing.Any]) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, destinationType: typing.Type[typing.Any]) -> bool:...

    # Skipped ConvertFrom due to it being static, abstract and generic.

    ConvertFrom : ConvertFrom_MethodGroup
    class ConvertFrom_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any) -> typing.Any:...

    # Skipped ConvertTo due to it being static, abstract and generic.

    ConvertTo : ConvertTo_MethodGroup
    class ConvertTo_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, culture: CultureInfo, value: typing.Any, destinationType: typing.Type[typing.Any]) -> typing.Any:...

    # Skipped IsValid due to it being static, abstract and generic.

    IsValid : IsValid_MethodGroup
    class IsValid_MethodGroup:
        @typing.overload
        def __call__(self, value: typing.Any) -> bool:...
        @typing.overload
        def __call__(self, context: ITypeDescriptorContext, value: typing.Any) -> bool:...



class WarningException(SystemException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, helpUrl: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, helpUrl: str, helpTopic: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HelpTopic(self) -> str: ...
    @property
    def HelpUrl(self) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...


class Win32Exception(ExternalException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, error: int) -> None: ...
    @typing.overload
    def __init__(self, error: int, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    @property
    def Data(self) -> IDictionary: ...
    @property
    def ErrorCode(self) -> int: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def NativeErrorCode(self) -> int: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...
    def GetObjectData(self, info: SerializationInfo, context: StreamingContext) -> None: ...
    def ToString(self) -> str: ...

