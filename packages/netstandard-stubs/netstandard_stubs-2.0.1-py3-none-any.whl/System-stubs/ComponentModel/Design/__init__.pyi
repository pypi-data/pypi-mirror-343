import typing, abc
from System import EventArgs, MulticastDelegate, IAsyncResult, AsyncCallback, Exception, Guid, Array, Array_1, IDisposable, EventHandler, Attribute, IServiceProvider
from System.Reflection import MethodInfo, MethodBase, Assembly, AssemblyName
from System.Runtime.InteropServices import ExternalException
from System.Collections import IDictionary, ICollection, IList, IEnumerator, CollectionBase
from System.ComponentModel import MemberDescriptor, IComponent, PropertyDescriptorCollection, LicenseContext, LicenseUsageMode, IContainer, EventDescriptor, PropertyDescriptor, EventDescriptorCollection, IExtenderProvider, InheritanceAttribute, TypeDescriptionProvider
from System.IO import Stream
from System.Resources import IResourceReader, IResourceWriter
from System.Globalization import CultureInfo

class ActiveDesignerEventArgs(EventArgs):
    def __init__(self, oldDesigner: IDesignerHost, newDesigner: IDesignerHost) -> None: ...
    @property
    def NewDesigner(self) -> IDesignerHost: ...
    @property
    def OldDesigner(self) -> IDesignerHost: ...


class ActiveDesignerEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: ActiveDesignerEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: ActiveDesignerEventArgs) -> None: ...


class CheckoutException(ExternalException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str) -> None: ...
    @typing.overload
    def __init__(self, message: str, errorCode: int) -> None: ...
    @typing.overload
    def __init__(self, message: str, innerException: Exception) -> None: ...
    Canceled : CheckoutException
    @property
    def Data(self) -> IDictionary: ...
    @property
    def ErrorCode(self) -> int: ...
    @property
    def HelpLink(self) -> str: ...
    @HelpLink.setter
    def HelpLink(self, value: str) -> str: ...
    @property
    def HResult(self) -> int: ...
    @HResult.setter
    def HResult(self, value: int) -> int: ...
    @property
    def InnerException(self) -> Exception: ...
    @property
    def Message(self) -> str: ...
    @property
    def Source(self) -> str: ...
    @Source.setter
    def Source(self, value: str) -> str: ...
    @property
    def StackTrace(self) -> str: ...
    @property
    def TargetSite(self) -> MethodBase: ...


class CommandID:
    def __init__(self, menuGroup: Guid, commandID: int) -> None: ...
    @property
    def Guid(self) -> Guid: ...
    @property
    def ID(self) -> int: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def ToString(self) -> str: ...


class ComponentChangedEventArgs(EventArgs):
    def __init__(self, component: typing.Any, member: MemberDescriptor, oldValue: typing.Any, newValue: typing.Any) -> None: ...
    @property
    def Component(self) -> typing.Any: ...
    @property
    def Member(self) -> MemberDescriptor: ...
    @property
    def NewValue(self) -> typing.Any: ...
    @property
    def OldValue(self) -> typing.Any: ...


class ComponentChangedEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: ComponentChangedEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: ComponentChangedEventArgs) -> None: ...


class ComponentChangingEventArgs(EventArgs):
    def __init__(self, component: typing.Any, member: MemberDescriptor) -> None: ...
    @property
    def Component(self) -> typing.Any: ...
    @property
    def Member(self) -> MemberDescriptor: ...


class ComponentChangingEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: ComponentChangingEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: ComponentChangingEventArgs) -> None: ...


class ComponentEventArgs(EventArgs):
    def __init__(self, component: IComponent) -> None: ...
    @property
    def Component(self) -> IComponent: ...


class ComponentEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: ComponentEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: ComponentEventArgs) -> None: ...


class ComponentRenameEventArgs(EventArgs):
    def __init__(self, component: typing.Any, oldName: str, newName: str) -> None: ...
    @property
    def Component(self) -> typing.Any: ...
    @property
    def NewName(self) -> str: ...
    @property
    def OldName(self) -> str: ...


class ComponentRenameEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: ComponentRenameEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: ComponentRenameEventArgs) -> None: ...


class DesignerCollection(ICollection):
    @typing.overload
    def __init__(self, designers: Array_1[IDesignerHost]) -> None: ...
    @typing.overload
    def __init__(self, designers: IList) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> IDesignerHost: ...
    def GetEnumerator(self) -> IEnumerator: ...


class DesignerEventArgs(EventArgs):
    def __init__(self, host: IDesignerHost) -> None: ...
    @property
    def Designer(self) -> IDesignerHost: ...


class DesignerEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: DesignerEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: DesignerEventArgs) -> None: ...


class DesignerOptionService(IDesignerOptionService, abc.ABC):
    @property
    def Options(self) -> DesignerOptionService.DesignerOptionCollection: ...

    class DesignerOptionCollection(IList):
        @property
        def Count(self) -> int: ...
        @property
        def Item(self) -> DesignerOptionService.DesignerOptionCollection: ...
        @property
        def Item(self) -> DesignerOptionService.DesignerOptionCollection: ...
        @property
        def Name(self) -> str: ...
        @property
        def Parent(self) -> DesignerOptionService.DesignerOptionCollection: ...
        @property
        def Properties(self) -> PropertyDescriptorCollection: ...
        def CopyTo(self, array: Array, index: int) -> None: ...
        def GetEnumerator(self) -> IEnumerator: ...
        def IndexOf(self, value: DesignerOptionService.DesignerOptionCollection) -> int: ...
        def ShowDialog(self) -> bool: ...



class DesignerTransaction(IDisposable, abc.ABC):
    @property
    def Canceled(self) -> bool: ...
    @Canceled.setter
    def Canceled(self, value: bool) -> bool: ...
    @property
    def Committed(self) -> bool: ...
    @Committed.setter
    def Committed(self, value: bool) -> bool: ...
    @property
    def Description(self) -> str: ...
    def Cancel(self) -> None: ...
    def Commit(self) -> None: ...


class DesignerTransactionCloseEventArgs(EventArgs):
    @typing.overload
    def __init__(self, commit: bool) -> None: ...
    @typing.overload
    def __init__(self, commit: bool, lastTransaction: bool) -> None: ...
    @property
    def LastTransaction(self) -> bool: ...
    @property
    def TransactionCommitted(self) -> bool: ...


class DesignerTransactionCloseEventHandler(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, sender: typing.Any, e: DesignerTransactionCloseEventArgs, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, sender: typing.Any, e: DesignerTransactionCloseEventArgs) -> None: ...


class DesignerVerb(MenuCommand):
    @typing.overload
    def __init__(self, text: str, handler: EventHandler) -> None: ...
    @typing.overload
    def __init__(self, text: str, handler: EventHandler, startCommandID: CommandID) -> None: ...
    @property
    def Checked(self) -> bool: ...
    @Checked.setter
    def Checked(self, value: bool) -> bool: ...
    @property
    def CommandID(self) -> CommandID: ...
    @property
    def Description(self) -> str: ...
    @Description.setter
    def Description(self, value: str) -> str: ...
    @property
    def Enabled(self) -> bool: ...
    @Enabled.setter
    def Enabled(self, value: bool) -> bool: ...
    @property
    def OleStatus(self) -> int: ...
    @property
    def Properties(self) -> IDictionary: ...
    @property
    def Supported(self) -> bool: ...
    @Supported.setter
    def Supported(self, value: bool) -> bool: ...
    @property
    def Text(self) -> str: ...
    @property
    def Visible(self) -> bool: ...
    @Visible.setter
    def Visible(self, value: bool) -> bool: ...
    def ToString(self) -> str: ...


class DesignerVerbCollection(CollectionBase):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, value: Array_1[DesignerVerb]) -> None: ...
    @property
    def Capacity(self) -> int: ...
    @Capacity.setter
    def Capacity(self, value: int) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def Item(self) -> DesignerVerb: ...
    @Item.setter
    def Item(self, value: DesignerVerb) -> DesignerVerb: ...
    def Add(self, value: DesignerVerb) -> int: ...
    def Contains(self, value: DesignerVerb) -> bool: ...
    def CopyTo(self, array: Array_1[DesignerVerb], index: int) -> None: ...
    def IndexOf(self, value: DesignerVerb) -> int: ...
    def Insert(self, index: int, value: DesignerVerb) -> None: ...
    def Remove(self, value: DesignerVerb) -> None: ...
    # Skipped AddRange due to it being static, abstract and generic.

    AddRange : AddRange_MethodGroup
    class AddRange_MethodGroup:
        @typing.overload
        def __call__(self, value: Array_1[DesignerVerb]) -> None:...
        @typing.overload
        def __call__(self, value: DesignerVerbCollection) -> None:...



class DesigntimeLicenseContext(LicenseContext):
    def __init__(self) -> None: ...
    @property
    def UsageMode(self) -> LicenseUsageMode: ...
    def GetSavedLicenseKey(self, type: typing.Type[typing.Any], resourceAssembly: Assembly) -> str: ...
    def SetSavedLicenseKey(self, type: typing.Type[typing.Any], key: str) -> None: ...


class DesigntimeLicenseContextSerializer:
    @staticmethod
    def Serialize(o: Stream, cryptoKey: str, context: DesigntimeLicenseContext) -> None: ...


class HelpContextType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Ambient : HelpContextType # 0
    Window : HelpContextType # 1
    Selection : HelpContextType # 2
    ToolWindowSelection : HelpContextType # 3


class HelpKeywordAttribute(Attribute):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, keyword: str) -> None: ...
    @typing.overload
    def __init__(self, t: typing.Type[typing.Any]) -> None: ...
    Default : HelpKeywordAttribute
    @property
    def HelpKeyword(self) -> str: ...
    @property
    def TypeId(self) -> typing.Any: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsDefaultAttribute(self) -> bool: ...


class HelpKeywordType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    F1Keyword : HelpKeywordType # 0
    GeneralKeyword : HelpKeywordType # 1
    FilterKeyword : HelpKeywordType # 2


class IComponentChangeService(typing.Protocol):
    @abc.abstractmethod
    def OnComponentChanged(self, component: typing.Any, member: MemberDescriptor, oldValue: typing.Any, newValue: typing.Any) -> None: ...
    @abc.abstractmethod
    def OnComponentChanging(self, component: typing.Any, member: MemberDescriptor) -> None: ...


class IComponentDiscoveryService(typing.Protocol):
    @abc.abstractmethod
    def GetComponentTypes(self, designerHost: IDesignerHost, baseType: typing.Type[typing.Any]) -> ICollection: ...


class IComponentInitializer(typing.Protocol):
    @abc.abstractmethod
    def InitializeExistingComponent(self, defaultValues: IDictionary) -> None: ...
    @abc.abstractmethod
    def InitializeNewComponent(self, defaultValues: IDictionary) -> None: ...


class IDesigner(IDisposable, typing.Protocol):
    @property
    def Component(self) -> IComponent: ...
    @property
    def Verbs(self) -> DesignerVerbCollection: ...
    @abc.abstractmethod
    def DoDefaultAction(self) -> None: ...
    @abc.abstractmethod
    def Initialize(self, component: IComponent) -> None: ...


class IDesignerEventService(typing.Protocol):
    @property
    def ActiveDesigner(self) -> IDesignerHost: ...
    @property
    def Designers(self) -> DesignerCollection: ...


class IDesignerFilter(typing.Protocol):
    @abc.abstractmethod
    def PostFilterAttributes(self, attributes: IDictionary) -> None: ...
    @abc.abstractmethod
    def PostFilterEvents(self, events: IDictionary) -> None: ...
    @abc.abstractmethod
    def PostFilterProperties(self, properties: IDictionary) -> None: ...
    @abc.abstractmethod
    def PreFilterAttributes(self, attributes: IDictionary) -> None: ...
    @abc.abstractmethod
    def PreFilterEvents(self, events: IDictionary) -> None: ...
    @abc.abstractmethod
    def PreFilterProperties(self, properties: IDictionary) -> None: ...


class IDesignerHost(IServiceContainer, typing.Protocol):
    @property
    def Container(self) -> IContainer: ...
    @property
    def InTransaction(self) -> bool: ...
    @property
    def Loading(self) -> bool: ...
    @property
    def RootComponent(self) -> IComponent: ...
    @property
    def RootComponentClassName(self) -> str: ...
    @property
    def TransactionDescription(self) -> str: ...
    @abc.abstractmethod
    def Activate(self) -> None: ...
    @abc.abstractmethod
    def DestroyComponent(self, component: IComponent) -> None: ...
    @abc.abstractmethod
    def GetDesigner(self, component: IComponent) -> IDesigner: ...
    @abc.abstractmethod
    def GetType(self, typeName: str) -> typing.Type[typing.Any]: ...
    # Skipped CreateComponent due to it being static, abstract and generic.

    CreateComponent : CreateComponent_MethodGroup
    class CreateComponent_MethodGroup:
        @typing.overload
        def __call__(self, componentClass: typing.Type[typing.Any]) -> IComponent:...
        @typing.overload
        def __call__(self, componentClass: typing.Type[typing.Any], name: str) -> IComponent:...

    # Skipped CreateTransaction due to it being static, abstract and generic.

    CreateTransaction : CreateTransaction_MethodGroup
    class CreateTransaction_MethodGroup:
        @typing.overload
        def __call__(self) -> DesignerTransaction:...
        @typing.overload
        def __call__(self, description: str) -> DesignerTransaction:...



class IDesignerHostTransactionState(typing.Protocol):
    @property
    def IsClosingTransaction(self) -> bool: ...


class IDesignerOptionService(typing.Protocol):
    @abc.abstractmethod
    def GetOptionValue(self, pageName: str, valueName: str) -> typing.Any: ...
    @abc.abstractmethod
    def SetOptionValue(self, pageName: str, valueName: str, value: typing.Any) -> None: ...


class IDictionaryService(typing.Protocol):
    @abc.abstractmethod
    def GetKey(self, value: typing.Any) -> typing.Any: ...
    @abc.abstractmethod
    def GetValue(self, key: typing.Any) -> typing.Any: ...
    @abc.abstractmethod
    def SetValue(self, key: typing.Any, value: typing.Any) -> None: ...


class IEventBindingService(typing.Protocol):
    @abc.abstractmethod
    def CreateUniqueMethodName(self, component: IComponent, e: EventDescriptor) -> str: ...
    @abc.abstractmethod
    def GetCompatibleMethods(self, e: EventDescriptor) -> ICollection: ...
    @abc.abstractmethod
    def GetEvent(self, property: PropertyDescriptor) -> EventDescriptor: ...
    @abc.abstractmethod
    def GetEventProperties(self, events: EventDescriptorCollection) -> PropertyDescriptorCollection: ...
    @abc.abstractmethod
    def GetEventProperty(self, e: EventDescriptor) -> PropertyDescriptor: ...
    # Skipped ShowCode due to it being static, abstract and generic.

    ShowCode : ShowCode_MethodGroup
    class ShowCode_MethodGroup:
        @typing.overload
        def __call__(self) -> bool:...
        @typing.overload
        def __call__(self, lineNumber: int) -> bool:...
        @typing.overload
        def __call__(self, component: IComponent, e: EventDescriptor) -> bool:...



class IExtenderListService(typing.Protocol):
    @abc.abstractmethod
    def GetExtenderProviders(self) -> Array_1[IExtenderProvider]: ...


class IExtenderProviderService(typing.Protocol):
    @abc.abstractmethod
    def AddExtenderProvider(self, provider: IExtenderProvider) -> None: ...
    @abc.abstractmethod
    def RemoveExtenderProvider(self, provider: IExtenderProvider) -> None: ...


class IHelpService(typing.Protocol):
    @abc.abstractmethod
    def AddContextAttribute(self, name: str, value: str, keywordType: HelpKeywordType) -> None: ...
    @abc.abstractmethod
    def ClearContextAttributes(self) -> None: ...
    @abc.abstractmethod
    def CreateLocalContext(self, contextType: HelpContextType) -> IHelpService: ...
    @abc.abstractmethod
    def RemoveContextAttribute(self, name: str, value: str) -> None: ...
    @abc.abstractmethod
    def RemoveLocalContext(self, localContext: IHelpService) -> None: ...
    @abc.abstractmethod
    def ShowHelpFromKeyword(self, helpKeyword: str) -> None: ...
    @abc.abstractmethod
    def ShowHelpFromUrl(self, helpUrl: str) -> None: ...


class IInheritanceService(typing.Protocol):
    @abc.abstractmethod
    def AddInheritedComponents(self, component: IComponent, container: IContainer) -> None: ...
    @abc.abstractmethod
    def GetInheritanceAttribute(self, component: IComponent) -> InheritanceAttribute: ...


class IMenuCommandService(typing.Protocol):
    @property
    def Verbs(self) -> DesignerVerbCollection: ...
    @abc.abstractmethod
    def AddCommand(self, command: MenuCommand) -> None: ...
    @abc.abstractmethod
    def AddVerb(self, verb: DesignerVerb) -> None: ...
    @abc.abstractmethod
    def FindCommand(self, commandID: CommandID) -> MenuCommand: ...
    @abc.abstractmethod
    def GlobalInvoke(self, commandID: CommandID) -> bool: ...
    @abc.abstractmethod
    def RemoveCommand(self, command: MenuCommand) -> None: ...
    @abc.abstractmethod
    def RemoveVerb(self, verb: DesignerVerb) -> None: ...
    @abc.abstractmethod
    def ShowContextMenu(self, menuID: CommandID, x: int, y: int) -> None: ...


class IReferenceService(typing.Protocol):
    @abc.abstractmethod
    def GetComponent(self, reference: typing.Any) -> IComponent: ...
    @abc.abstractmethod
    def GetName(self, reference: typing.Any) -> str: ...
    @abc.abstractmethod
    def GetReference(self, name: str) -> typing.Any: ...
    # Skipped GetReferences due to it being static, abstract and generic.

    GetReferences : GetReferences_MethodGroup
    class GetReferences_MethodGroup:
        @typing.overload
        def __call__(self) -> Array_1[typing.Any]:...
        @typing.overload
        def __call__(self, baseType: typing.Type[typing.Any]) -> Array_1[typing.Any]:...



class IResourceService(typing.Protocol):
    @abc.abstractmethod
    def GetResourceReader(self, info: CultureInfo) -> IResourceReader: ...
    @abc.abstractmethod
    def GetResourceWriter(self, info: CultureInfo) -> IResourceWriter: ...


class IRootDesigner(IDesigner, typing.Protocol):
    @property
    def SupportedTechnologies(self) -> Array_1[ViewTechnology]: ...
    @abc.abstractmethod
    def GetView(self, technology: ViewTechnology) -> typing.Any: ...


class ISelectionService(typing.Protocol):
    @property
    def PrimarySelection(self) -> typing.Any: ...
    @property
    def SelectionCount(self) -> int: ...
    @abc.abstractmethod
    def GetComponentSelected(self, component: typing.Any) -> bool: ...
    @abc.abstractmethod
    def GetSelectedComponents(self) -> ICollection: ...
    # Skipped SetSelectedComponents due to it being static, abstract and generic.

    SetSelectedComponents : SetSelectedComponents_MethodGroup
    class SetSelectedComponents_MethodGroup:
        @typing.overload
        def __call__(self, components: ICollection) -> None:...
        @typing.overload
        def __call__(self, components: ICollection, selectionType: SelectionTypes) -> None:...



class IServiceContainer(IServiceProvider, typing.Protocol):
    # Skipped AddService due to it being static, abstract and generic.

    AddService : AddService_MethodGroup
    class AddService_MethodGroup:
        @typing.overload
        def __call__(self, serviceType: typing.Type[typing.Any], callback: ServiceCreatorCallback) -> None:...
        @typing.overload
        def __call__(self, serviceType: typing.Type[typing.Any], serviceInstance: typing.Any) -> None:...
        @typing.overload
        def __call__(self, serviceType: typing.Type[typing.Any], callback: ServiceCreatorCallback, promote: bool) -> None:...
        @typing.overload
        def __call__(self, serviceType: typing.Type[typing.Any], serviceInstance: typing.Any, promote: bool) -> None:...

    # Skipped RemoveService due to it being static, abstract and generic.

    RemoveService : RemoveService_MethodGroup
    class RemoveService_MethodGroup:
        @typing.overload
        def __call__(self, serviceType: typing.Type[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, serviceType: typing.Type[typing.Any], promote: bool) -> None:...



class ITreeDesigner(IDesigner, typing.Protocol):
    @property
    def Children(self) -> ICollection: ...
    @property
    def Parent(self) -> IDesigner: ...


class ITypeDescriptorFilterService(typing.Protocol):
    @abc.abstractmethod
    def FilterAttributes(self, component: IComponent, attributes: IDictionary) -> bool: ...
    @abc.abstractmethod
    def FilterEvents(self, component: IComponent, events: IDictionary) -> bool: ...
    @abc.abstractmethod
    def FilterProperties(self, component: IComponent, properties: IDictionary) -> bool: ...


class ITypeDiscoveryService(typing.Protocol):
    @abc.abstractmethod
    def GetTypes(self, baseType: typing.Type[typing.Any], excludeGlobalTypes: bool) -> ICollection: ...


class ITypeResolutionService(typing.Protocol):
    @abc.abstractmethod
    def GetPathOfAssembly(self, name: AssemblyName) -> str: ...
    @abc.abstractmethod
    def ReferenceAssembly(self, name: AssemblyName) -> None: ...
    # Skipped GetAssembly due to it being static, abstract and generic.

    GetAssembly : GetAssembly_MethodGroup
    class GetAssembly_MethodGroup:
        @typing.overload
        def __call__(self, name: AssemblyName) -> Assembly:...
        @typing.overload
        def __call__(self, name: AssemblyName, throwOnError: bool) -> Assembly:...

    # Skipped GetType due to it being static, abstract and generic.

    GetType : GetType_MethodGroup
    class GetType_MethodGroup:
        @typing.overload
        def __call__(self, name: str) -> typing.Type[typing.Any]:...
        @typing.overload
        def __call__(self, name: str, throwOnError: bool) -> typing.Type[typing.Any]:...
        @typing.overload
        def __call__(self, name: str, throwOnError: bool, ignoreCase: bool) -> typing.Type[typing.Any]:...



class MenuCommand:
    def __init__(self, handler: EventHandler, command: CommandID) -> None: ...
    @property
    def Checked(self) -> bool: ...
    @Checked.setter
    def Checked(self, value: bool) -> bool: ...
    @property
    def CommandID(self) -> CommandID: ...
    @property
    def Enabled(self) -> bool: ...
    @Enabled.setter
    def Enabled(self, value: bool) -> bool: ...
    @property
    def OleStatus(self) -> int: ...
    @property
    def Properties(self) -> IDictionary: ...
    @property
    def Supported(self) -> bool: ...
    @Supported.setter
    def Supported(self, value: bool) -> bool: ...
    @property
    def Visible(self) -> bool: ...
    @Visible.setter
    def Visible(self, value: bool) -> bool: ...
    def ToString(self) -> str: ...
    # Skipped Invoke due to it being static, abstract and generic.

    Invoke : Invoke_MethodGroup
    class Invoke_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, arg: typing.Any) -> None:...



class SelectionTypes(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Auto : SelectionTypes # 1
    Normal : SelectionTypes # 1
    Replace : SelectionTypes # 2
    MouseDown : SelectionTypes # 4
    MouseUp : SelectionTypes # 8
    Click : SelectionTypes # 16
    Primary : SelectionTypes # 16
    Valid : SelectionTypes # 31
    Toggle : SelectionTypes # 32
    Add : SelectionTypes # 64
    Remove : SelectionTypes # 128


class ServiceContainer(IServiceContainer, IDisposable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, parentProvider: IServiceProvider) -> None: ...
    def Dispose(self) -> None: ...
    def GetService(self, serviceType: typing.Type[typing.Any]) -> typing.Any: ...
    # Skipped AddService due to it being static, abstract and generic.

    AddService : AddService_MethodGroup
    class AddService_MethodGroup:
        @typing.overload
        def __call__(self, serviceType: typing.Type[typing.Any], callback: ServiceCreatorCallback) -> None:...
        @typing.overload
        def __call__(self, serviceType: typing.Type[typing.Any], serviceInstance: typing.Any) -> None:...
        @typing.overload
        def __call__(self, serviceType: typing.Type[typing.Any], callback: ServiceCreatorCallback, promote: bool) -> None:...
        @typing.overload
        def __call__(self, serviceType: typing.Type[typing.Any], serviceInstance: typing.Any, promote: bool) -> None:...

    # Skipped RemoveService due to it being static, abstract and generic.

    RemoveService : RemoveService_MethodGroup
    class RemoveService_MethodGroup:
        @typing.overload
        def __call__(self, serviceType: typing.Type[typing.Any]) -> None:...
        @typing.overload
        def __call__(self, serviceType: typing.Type[typing.Any], promote: bool) -> None:...



class ServiceCreatorCallback(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, container: IServiceContainer, serviceType: typing.Type[typing.Any], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> typing.Any: ...
    def Invoke(self, container: IServiceContainer, serviceType: typing.Type[typing.Any]) -> typing.Any: ...


class StandardCommands:
    def __init__(self) -> None: ...
    AlignBottom : CommandID
    AlignHorizontalCenters : CommandID
    AlignLeft : CommandID
    AlignRight : CommandID
    AlignToGrid : CommandID
    AlignTop : CommandID
    AlignVerticalCenters : CommandID
    ArrangeBottom : CommandID
    ArrangeIcons : CommandID
    ArrangeRight : CommandID
    BringForward : CommandID
    BringToFront : CommandID
    CenterHorizontally : CommandID
    CenterVertically : CommandID
    Copy : CommandID
    Cut : CommandID
    Delete : CommandID
    DocumentOutline : CommandID
    F1Help : CommandID
    Group : CommandID
    HorizSpaceConcatenate : CommandID
    HorizSpaceDecrease : CommandID
    HorizSpaceIncrease : CommandID
    HorizSpaceMakeEqual : CommandID
    LineupIcons : CommandID
    LockControls : CommandID
    MultiLevelRedo : CommandID
    MultiLevelUndo : CommandID
    Paste : CommandID
    Properties : CommandID
    PropertiesWindow : CommandID
    Redo : CommandID
    Replace : CommandID
    SelectAll : CommandID
    SendBackward : CommandID
    SendToBack : CommandID
    ShowGrid : CommandID
    ShowLargeIcons : CommandID
    SizeToControl : CommandID
    SizeToControlHeight : CommandID
    SizeToControlWidth : CommandID
    SizeToFit : CommandID
    SizeToGrid : CommandID
    SnapToGrid : CommandID
    TabOrder : CommandID
    Undo : CommandID
    Ungroup : CommandID
    VerbFirst : CommandID
    VerbLast : CommandID
    VertSpaceConcatenate : CommandID
    VertSpaceDecrease : CommandID
    VertSpaceIncrease : CommandID
    VertSpaceMakeEqual : CommandID
    ViewCode : CommandID
    ViewGrid : CommandID


class StandardToolWindows:
    def __init__(self) -> None: ...
    ObjectBrowser : Guid
    OutputWindow : Guid
    ProjectExplorer : Guid
    PropertyBrowser : Guid
    RelatedLinks : Guid
    ServerExplorer : Guid
    TaskList : Guid
    Toolbox : Guid


class TypeDescriptionProviderService(abc.ABC):
    # Skipped GetProvider due to it being static, abstract and generic.

    GetProvider : GetProvider_MethodGroup
    class GetProvider_MethodGroup:
        @typing.overload
        def __call__(self, type: typing.Type[typing.Any]) -> TypeDescriptionProvider:...
        @typing.overload
        def __call__(self, instance: typing.Any) -> TypeDescriptionProvider:...



class ViewTechnology(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Passthrough : ViewTechnology # 0
    WindowsForms : ViewTechnology # 1
    Default : ViewTechnology # 2

