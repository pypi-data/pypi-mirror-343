import numpy as np
from scipy.interpolate import interp1d

def PAR_from_Ed_380_412_443_490_555_v5(Ed, z):
    """
    PAR predictor from multispectral Ed at the bands [380, 412, 443, 490, 555]
    Vectorized code, works with N samples at once, and returns N PAR
    estimates.

    Parameters:
    -----------
    Ed : numpy.ndarray
        Nx5 matrix: downwelling irradiance spectrum (with 5 bands: [380, 412, 443, 490, 555]).
    z : numpy.ndarray
        Nx1 matrix: depth (m).

    Returns:
    --------
    PAR : numpy.ndarray
        Nx1 matrix: Best PAR estimate.
    PAR_b : numpy.ndarray
        Nx1 matrix: PAR with some remaining biases to be corrected with ep50.
    ep50 : numpy.ndarray
        Nx1 matrix: Estimated median percent error of the output value, as a function of depth.
    IQR_ep : numpy.ndarray
        Nx1 matrix: Estimated interquartile range of the percent error of the output value, as a function of depth.

    Notes:
    ------
    - The function is vectorized and works with N samples simultaneously.
    - N is the number of samples in the input arrays Ed and z.

    Example usage:
    ---------------
    my_Ed = np.array([[0.10728, 0.27631, 0.37879, 0.50215, 0.25799],
                      [4.7654e-06, 3.9603e-05, 0.00020864, 0.00067752, 3.2299e-06],
                      [6.0923e-05, 0.00032247, 0.0014818, 0.006675, 0.0016808]])
    z = np.array([18.1, 155.3, 71.1])

    PAR, PAR_b, ep50, IQR_ep = PAR_from_Ed_380_412_443_490_555_v5(my_Ed, z)
    """

    
    # Constantes de la red neuronal
    x1_step1 = {
        'xoffset': np.array([-22.6422533091432, -20.6614926671289, -19.5694508081377, -7.62188447185006, -21.2406406116215]),
        'gain': np.array([0.0862100486323673, 0.0930530950102774, 0.0977451436694377, 0.233748143539256, 0.0903196568208667]),
        'ymin': -1
    }

    y1_step1 = {
        'ymin': -1,
        'gain': 0.250728512194969,
        'xoffset': -3.99369680999518
    }

    b1 = np.array([2.4086293995445520189, 1.6451478823708511889, 0.80894781919170422047,
                  -0.12009672485161763944, 0.6784744080719454784, -0.034963316365103455641,
                  -7.5506003682556013246, -1.1085160972112277911, -0.92133106094005656761,
                  -2.2720743018240625588])
    
    IW1_1 = np.array([
        [-0.40228932010097756544, 1.3844249319344237303, 1.2272494718505437827, 0.04166727355483041545, 1.04200433310472107],
        [-0.61575063960839016008, 1.7020614928792048293, 0.13348615917864906089, -0.15294109567955319062, 1.2852910523079197347],
        [-0.53100248117456183561, -0.27966191027849301998, 0.56035886980278748482, 0.52200255857141886207, -1.6729555506821625066],
        [0.66984303170524983617, 0.55302567831738602688, -1.3200737271756761704, -0.38400960424987845565, 0.46434711135813477867],
        [-0.0013983759160220432527, -1.0349237383425671233, -1.7993399498543742876, 0.72561362160058506809, 0.53352358896729379367],
        [0.23876131778406425865, 1.213320722203189872, 0.5821275602245417069, 0.30812858284240551843, -2.5859377678898236574],
        [1.4644062302039841938, 0.21372462845412715238, -0.64850617823215273017, -3.1698831127879021352, 8.0566983539608845177],
        [-0.93486103657990027305, -0.79640777299629639252, -1.4343719137208232883, -0.30426921754557212374, -1.1404815359079039094],
        [-0.0033655790467217814449, -1.3929928808160143561, -1.0687316942038185275, -0.035074284212627017399, 1.5795589169668717844],
        [-1.1553346682320342342, -0.84677227383754805068, 1.0598215434894273645, 0.7938011067589191283, -1.0498763931614858436]
    ])
    
    b2 = np.array([1.1206188194439596906])
    LW2_1 = np.array([0.99174721536452947745, -0.03481447942426652703, -2.2390536302625796417,
                     -2.1556286055030162707, 1.4421851940291410266, 1.0880951783241665787,
                     2.6833601919696303817, 0.35072234950287251021, -1.7095589581290109304,
                     0.05249237199957798583])
    
    mat = np.array([
        [0.1, -26.554, 2.5365],
        [0.2122, -25.161, 2.9357],
        [0.23809, -24.708, 2.8129],
        [0.26715, -24.2, 2.6752],
        [0.29974, -23.629, 2.5206],
        [0.33632, -23.345, 3.0679],
        [0.37735, -23.026, 3.6819],
        [0.4234, -22.668, 4.3708],
        [0.47506, -21.659, 2.6484],
        [0.53303, -21.129, 2.6629],
        [0.59807, -20.534, 2.6791],
        [0.67104, -20.389, 1.8772],
        [0.75292, -19.809, 2.1138],
        [0.84479, -19.158, 2.3792],
        [0.94787, -18.292, 1.9704],
        [1.0635, -17.945, 2.8367],
        [1.1933, -17.298, 1.6628],
        [1.3389, -15.08, 2.7532],
        [1.5023, -14.858, 2.93],
        [1.6856, -13.749, 1.7314],
        [1.8913, -12.487, 2.5107],
        [2.122, -10.919, 2.3702],
        [2.3809, -9.3017, 2.3051],
        [2.6715, -8.2433, 2.3163],
        [2.9974, -6.6701, 2.0137],
        [3.3632, -5.3999, 1.8026],
        [3.7735, -4.2309, 2.2971],
        [4.234, -2.6665, 2.0645],
        [4.7506, -1.0693, 1.8124],
        [5.3303, 0.02051, 1.7437],
        [5.9807, 1.344, 1.8681],
        [6.7104, 2.3762, 1.684],
        [7.5292, 3.0321, 1.6651],
        [8.4479, 3.7246, 1.7853],
        [9.4787, 4.1512, 1.8386],
        [10.635, 4.268, 1.8487],
        [11.933, 4.1647, 1.7741],
        [13.389, 3.8638, 1.582],
        [15.023, 3.3153, 1.5617],
        [16.856, 2.6439, 1.4108],
        [18.913, 1.931, 1.148],
        [21.22, 1.0384, 1.0015],
        [23.809, 0.41677, 0.84406],
        [26.715, -0.32179, 0.879],
        [29.974, -1.0205, 0.81151],
        [33.632, -1.5818, 0.80976],
        [37.735, -1.9422, 0.90525],
        [42.34, -2.1432, 1.1063],
        [47.506, -2.0363, 1.2777],
        [53.303, -1.7173, 1.3873],
        [59.807, -1.1815, 1.5215],
        [67.104, -0.61885, 1.5216],
        [75.292, -0.15499, 1.3922],
        [84.479, 0.26124, 1.4346],
        [94.787, 0.54836, 1.6633],
        [106.35, 0.46015, 1.8951],
        [119.33, 0.20045, 1.9891],
        [133.89, -0.14995, 2.0765],
        [150.23, -0.26744, 2.0627],
        [168.56, -0.54467, 1.9987],
        [189.13, -0.95253, 2.3743],
        [201, 0, 0],
        [1000, 0, 0]
        ])
        
    # Log10 del espectro de irradiancia
    x1 = np.log10(Ed).T  # Transpuesta para (5, N)
    xp1 = mapminmax_apply(x1, x1_step1)

    # Capa oculta
    a1 = tansig_apply(b1[:, np.newaxis] + IW1_1 @ xp1)

    # Capa de salida
    a2 = b2 + LW2_1 @ a1

    # Salida final
    y1 = mapminmax_reverse(a2, y1_step1)
    PAR_b = 10 ** y1.T  # (N,)

    # Interpolación de ep50 y IQR_ep
    log_z = np.log10(z)
    ep50 = interp1d(np.log10(mat[:, 0]), mat[:, 1], bounds_error=False, fill_value="extrapolate")(log_z)
    IQR_ep = interp1d(np.log10(mat[:, 0]), mat[:, 2], bounds_error=False, fill_value="extrapolate")(log_z)

    # Estimación final
    PAR = PAR_b / (1 + ep50 / 100)

    return PAR, PAR_b, ep50, IQR_ep

def mapminmax_apply(x, settings):
    y = (x - settings['xoffset'][:, np.newaxis]) * settings['gain'][:, np.newaxis] + settings['ymin']
    return y

def tansig_apply(n):
    return 2 / (1 + np.exp(-2 * n)) - 1

def mapminmax_reverse(y, settings):
    x = (y - settings['ymin']) / settings['gain'] + settings['xoffset']
    return x