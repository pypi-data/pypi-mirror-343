import numpy as np
from scipy.interpolate import interp1d

def PAR_from_Ed_380_443_490_555_v5(Ed, z):
    """
    PAR predictor from multispectral Ed at the bands [380, 443, 490, 555]
    Vectorized code, works with N samples at once, and returns N PAR
    estimates.

    Parameters:
    -----------
    Ed : numpy.ndarray
        Nx4 matrix: downwelling irradiance spectrum (with 4 bands: [380, 443, 490, 555]).
    z : numpy.ndarray
        Nx1 matrix: depth (m).

    Returns:
    --------
    PAR : numpy.ndarray
        Nx1 matrix: Best PAR estimate.
    PAR_b : numpy.ndarray
        Nx1 matrix: PAR with some remaining biases to be corrected with ep50.
    ep50 : numpy.ndarray
        Nx1 matrix: Estimated median percent error of the output value, as a function of depth.
    IQR_ep : numpy.ndarray
        Nx1 matrix: Estimated interquartile range of the percent error of the output value, as a function of depth.

    Notes:
    ------
    - The function is vectorized and works with N samples simultaneously.
    - N is the number of samples in the input arrays Ed and z.

    Example usage:
    ---------------
    my_Ed = np.array([[3.1477e-07, 4.401e-05, 0.00031093, 2.6219e-05],
                      [0.0097528, 0.061085, 0.10562, 0.087316],
                      [0.20572, 0.52315, 0.54544, 0.16185]])
    z = np.array([84.8, 14.2, 28.1])

    PAR, PAR_b, ep50, IQR_ep = PAR_from_Ed_380_443_490_555_v5(my_Ed, z)
    """
    
    # Constantes de la red neuronal
    x1_step1 = {
  'xoffset': np.array([-22.6422533091432,-19.5694508081377,-7.62188447185006,-21.2406406116215]),
  'gain': np.array([0.0862100486323673,0.0977451436694377,0.233748143539256,0.0903196568208667]),
  'ymin': -1
    }

    y1_step1 = {
  'ymin': -1,
  'gain': 0.250728512194969,
  'xoffset': -3.99369680999518
    }

    b1 = np.array([1.9999734207594397351,-1.6927877045818850998,-1.5919189540071247979,0.77084223512022242986,3.2507371514645919675,-0.8251077372562986012,0.58305766196260599976,1.8112706736240511418,2.1467018502692800652,-2.5379282491232872943])
    
    IW1_1 = np.array([
  [-1.8199769781946091296,-0.94400874081320684805,-0.052374294569623960904,1.5809476784843543573],
  [0.056951288431130536738,1.6423409062809199987,-0.62195397755439030263,0.5643543075814567711],
  [0.72404795300219160215,-0.4375480986875049938,-0.93674190196188777957,2.4987649071804396428],
  [-1.2146256272085447225,-0.90915351816213807457,1.5370713401317150915,-1.43468340618492185],
  [-0.45221919315026853914,1.6689500323933479375,0.67449349160353577748,-4.1085625234587874743],
  [0.9423289918230917106,-1.7864531580316835857,-0.045688770163778411049,2.7340261911068428624],
  [1.0576706495702499211,0.72720040597984869635,0.59799445164407505349,1.1589649578689671383],
  [1.3777799222831617065,0.50317810827634557036,2.7189827109907436231,1.0273482186260671778],
  [0.2068521074937265114,1.5490998555968336081,0.79006721530447576729,1.5975284880066564774],
  [-0.83388462708274690982,-0.84152375288066061376,1.5982424654774112227,-1.5242426243515774242]
    ])
    
    b2 = np.array([0.39470408235767201477])
    LW2_1 = np.array([-0.41598255025912123095,1.641544458195727918,-1.5605845756858713891,0.4912210532277936359,-2.6010193848740237321,0.97550696309075168866,1.042840617993222363,-0.45142797186454142189,0.70203279318522826546,-1.7139393267908404894])
    
    mat = np.array([
[0.1,-28.044,3.3016],
[0.2122,-27.539,3.2366],
[0.23809,-26.862,3.1561],
[0.26715,-26.101,3.0657],
[0.29974,-25.247,2.9643],
[0.33632,-25.117,3.5459],
[0.37735,-24.971,4.1984],
[0.4234,-24.808,4.9305],
[0.47506,-24.039,2.3823],
[0.53303,-23.344,2.5273],
[0.59807,-22.565,2.69],
[0.67104,-22.748,2.0647],
[0.75292,-21.789,2.3925],
[0.84479,-20.712,2.7603],
[0.94787,-20.243,2.3714],
[1.0635,-19.499,1.9977],
[1.1933,-19.434, 2.407],
[1.3389,-16.582,2.4207],
[1.5023,-16.422,2.4328],
[1.6856,-15.804,1.4701],
[1.8913,-14.417,2.0467],
[2.122,-12.558,2.3909],
[2.3809,-10.774,1.9671],
[2.6715,-9.6617,2.0619],
[2.9974,-8.434,1.8019],
[3.3632,-6.9121,1.8913],
[3.7735,-5.3481,1.8698],
[4.234,-3.6119,2.1792],
[4.7506,-2.1318,2.2633],
[5.3303,-0.96811,2.2906],
[5.9807,0.71423,2.358],
[6.7104,1.9079,2.0484],
[7.5292,2.7701,2.0286],
[8.4479,3.625,2.0842],
[9.4787,4.2107,2.1105],
[10.635,4.5906,2.1296],
[11.933,4.7321,2.073],
[13.389,4.5513,1.7558],
[15.023,4.2007,1.6246],
[16.856,3.6374,1.303],
[18.913,2.9922,0.94564],
[21.22,2.3404,0.92539],
[23.809,1.6894,0.97038],
[26.715,0.85746,1.1391],
[29.974,0.14528,1.4443],
[33.632,-0.68366,1.52],
[37.735,-1.313,1.7102],
[42.34,-1.6954,1.6599],
[47.506,-1.7649,1.6524],
[53.303,-1.6641,1.473],
[59.807,-1.2533,1.286],
[67.104,-0.5964,1.3987],
[75.292,0.06364,1.5348],
[84.479,0.64164,1.5231],
[94.787,1.0962,1.743],
[106.35,1.1153,2.0395],
[119.33,0.95929,1.7282],
[133.89,0.62081,1.5752],
[150.23,0.045255,1.8427],
[168.56,-0.49023,2.7481],
[189.13,-0.86369,3.8264],
[201,0,0],
[1000,0,0]
])
  
    # Log10 del espectro de irradiancia
    x1 = np.log10(Ed).T  # Transpuesta para (5, N)
    xp1 = mapminmax_apply(x1, x1_step1)

    # Capa oculta
    a1 = tansig_apply(b1[:, np.newaxis] + IW1_1 @ xp1)

    # Capa de salida
    a2 = b2 + LW2_1 @ a1

    # Salida final
    y1 = mapminmax_reverse(a2, y1_step1)
    PAR_b = 10 ** y1.T  # (N,)

    # Interpolación de ep50 y IQR_ep
    log_z = np.log10(z)
    ep50 = interp1d(np.log10(mat[:, 0]), mat[:, 1], bounds_error=False, fill_value="extrapolate")(log_z)
    IQR_ep = interp1d(np.log10(mat[:, 0]), mat[:, 2], bounds_error=False, fill_value="extrapolate")(log_z)

    # Estimación final
    PAR = PAR_b / (1 + ep50 / 100)

    return PAR, PAR_b, ep50, IQR_ep

def mapminmax_apply(x, settings):
    y = (x - settings['xoffset'][:, np.newaxis]) * settings['gain'][:, np.newaxis] + settings['ymin']
    return y

def tansig_apply(n):
    return 2 / (1 + np.exp(-2 * n)) - 1

def mapminmax_reverse(y, settings):
    x = (y - settings['ymin']) / settings['gain'] + settings['xoffset']
    return x