import numpy as np
from scipy.interpolate import interp1d

def PAR_from_Ed_380_490_555_665_v5(Ed, z):
    """
    PAR predictor from multispectral Ed at the bands [380, 490, 555, 665].
    Vectorized code, works with N samples at once, and returns N PAR
    estimates.

    Parameters:
    -----------
    Ed : numpy.ndarray
        Nx4 matrix: downwelling irradiance spectrum (with 4 bands: [380, 490, 555, 665]).
    z : numpy.ndarray
        Nx1 matrix: depth (m).

    Returns:
    --------
    PAR : numpy.ndarray
        Nx1 matrix: Best PAR estimate.
    PAR_b : numpy.ndarray
        Nx1 matrix: PAR with some remaining biases to be corrected with ep50.
    ep50 : numpy.ndarray
        Nx1 matrix: Estimated median percent error of the output value, as a function of depth.
    IQR_ep : numpy.ndarray
        Nx1 matrix: Estimated interquartile range of the percent error of the output value, as a function of depth.

    Notes:
    ------
    - This function works with N samples simultaneously, where N is the number of samples in the input arrays `Ed` and `z`.
    - The function is self-contained and does not rely on any external data.

    Example usage:
    ---------------
    my_Ed = np.array([[0.72199, 1.6553, 1.6139, 1.0218],
                      [0.0021873, 0.062225, 0.0052865, 1.7514e-05],
                      [0.079935, 0.45121, 0.32895, 0.0012265]])
    z = np.array([0.7, 74.4, 16.4])

    PAR, PAR_b, ep50, IQR_ep = PAR_from_Ed_380_490_555_665_v5(my_Ed, z)
    """

    # Constantes de la red neuronal
    x1_step1 = {
  'xoffset': np.array([-22.6422533091432,-7.62188447185006,-21.2406406116215,-22.1732499446457]),
  'gain': np.array([0.0862100486323673,0.233748143539256,0.0903196568208667,0.0872091412720763]),
  'ymin': -1
    }

    y1_step1 = {
  'ymin': -1,
  'gain': 0.250728512194969,
  'xoffset': -3.99369680999518
    }

    b1 = np.array([1.3773464153038603719,3.934717931881863251,0.52675095292634865896,-0.10299073255373906999,-1.098891162818485645,1.0545142766089230513,-0.64538664072691687146,0.39854275393886368084,-2.0068504080442410853,3.4287637416258429646])
    
    IW1_1 = np.array([
  [-0.29134625456595830695,-2.352247775075971159,-0.23988589933927972897,1.6349723708078853779],
[0.31283190732449889238,1.5218017803267791521,-4.9466115392924852046,0.073019394319042599251],
[-1.0110443127012016529,-1.7831903035187097739,1.4100745497236202297,1.2333845810950849753],
[0.34453970755045482122,1.7859966959649229423,-0.084401439196087613137,-0.59812661340320993908],
[1.742021793990166989,-2.0002374236844526756,-1.4020409467087877609,0.6586906022553369322],
[-6.3820912642481779642,0.5353260563131788663,6.6667201829568156768,-1.0338245525385805212],
[1.523843466565415472,-0.43732011898881772982,0.20947299211361555815,3.5081512898236546505],
[1.5884843318685439861,-2.1761792882986847886,-2.4378150914911125291,-0.65702103674302758662],
[-0.74841850626434702765,1.1773296250078351122,3.0402833485572289263,-1.6241807390924207777],
[1.1358252828179440375,0.39215750910377827898,1.6790144905005168763,-4.9802969177871201367]
    ])
    
    b2 = np.array([1.5399787796826152064])
    LW2_1 = np.array([-1.3142932341237907323,-0.95142756846376530522,0.91657977379205202162,0.69990615325192007123,-0.50040495690264430451,-0.1370257908912806688,0.19501202293220704087,0.14954303973742777423,-0.69502750373713040322,-1.2677926646034007874])
    
    mat = np.array([
  [0.1,-3.7386,0.81093],
[0.2122,-3.3655,0.83813],
[0.23809,-3.0734,1.1184],
[0.26715,-2.7456,1.4328],
[0.29974,-2.3778,1.7855],
[0.33632,-2.5827,1.6887],
[0.37735,-2.8126,1.5801],
[0.4234,-3.0706,1.4582],
[0.47506,-2.6888,1.493],
[0.53303,-2.4966,1.4733],
[0.59807,-2.281,1.4511],
[0.67104,-2.2564,1.3994],
[0.75292,-1.9559,1.4315],
[0.84479,-1.6186,1.4675],
[0.94787,-1.49,0.85171],
[1.0635,-1.0293,0.76307],
[1.1933,-1.1257,0.75985],
[1.3389,-0.47736, 1.1322],
[1.5023,-0.077835,1.94],
[1.6856,-0.49583,1.6567],
[1.8913,0.08395,1.1179],
[2.122,0.45883,0.92605],
[2.3809,0.73549,1.2375],
[2.6715,1.0404,1.0683],
[2.9974,1.0627,0.88337],
[3.3632,1.0408,0.92075],
[3.7735,1.2251,0.94419],
[4.234,1.2941,0.94618],
[4.7506,1.2296,1.0103],
[5.3303,1.0726,1.0602],
[5.9807,0.771,0.94917],
[6.7104,0.52638,0.99797],
[7.5292,0.18161,0.98175],
[8.4479,-0.16693,0.86562],
[9.4787,-0.41726,0.82827],
[10.635,-0.57626,0.84045],
[11.933,-0.61061,0.79922],
[13.389,-0.62086,0.856],
[15.023,-0.55187,1.0413],
[16.856,-0.35671,1.2344],
[18.913,-0.22218,1.2702],
[21.22,-0.085756,1.4414],
[23.809,-0.0039399,1.4868],
[26.715,-0.058402,1.4959],
[29.974,-0.085731,1.6772],
[33.632,-0.048984,1.8299],
[37.735,-0.12471,2.1584],
[42.34,-0.18625,2.1244],
[47.506,-0.26989,2.5215],
[53.303,-0.23538,2.8674],
[59.807,-0.12665,3.0497],
[67.104,0.036652,3.2778],
[75.292,0.25315,3.3009],
[84.479,0.29168,3.2199],
[94.787,0.050012,2.9597],
[106.35,0.085327,3.2845],
[119.33,0.52048,4.0777],
[133.89,0.87175,4.8183],
[150.23,0.73795,5.1978],
[168.56,0.48548,7.1637],
[189.13,-1.1529,8.9553],
[201,0,0],
[1000,0,0]
])
  
    # Log10 del espectro de irradiancia
    x1 = np.log10(Ed).T  # Transpuesta para (5, N)
    xp1 = mapminmax_apply(x1, x1_step1)

    # Capa oculta
    a1 = tansig_apply(b1[:, np.newaxis] + IW1_1 @ xp1)

    # Capa de salida
    a2 = b2 + LW2_1 @ a1

    # Salida final
    y1 = mapminmax_reverse(a2, y1_step1)
    PAR_b = 10 ** y1.T  # (N,)

    # Interpolación de ep50 y IQR_ep
    log_z = np.log10(z)
    ep50 = interp1d(np.log10(mat[:, 0]), mat[:, 1], bounds_error=False, fill_value="extrapolate")(log_z)
    IQR_ep = interp1d(np.log10(mat[:, 0]), mat[:, 2], bounds_error=False, fill_value="extrapolate")(log_z)

    # Estimación final
    PAR = PAR_b / (1 + ep50 / 100)

    return PAR, PAR_b, ep50, IQR_ep

def mapminmax_apply(x, settings):
    y = (x - settings['xoffset'][:, np.newaxis]) * settings['gain'][:, np.newaxis] + settings['ymin']
    return y

def tansig_apply(n):
    return 2 / (1 + np.exp(-2 * n)) - 1

def mapminmax_reverse(y, settings):
    x = (y - settings['ymin']) / settings['gain'] + settings['xoffset']
    return x