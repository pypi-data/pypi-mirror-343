import numpy as np
from scipy.interpolate import interp1d

def PAR_from_Ed_380_443_490_560_v5(Ed, z):
    """
    PAR predictor from multispectral Ed at the bands [380, 443, 490, 560]
    Vectorized code, works with N samples at once, and returns N PAR
    estimates.

    Parameters:
    -----------
    Ed : numpy.ndarray
        Nx4 matrix: downwelling irradiance spectrum (with 4 bands: [380, 443, 490, 560]).
    z : numpy.ndarray
        Nx1 matrix: depth (m).

    Returns:
    --------
    PAR : numpy.ndarray
        Nx1 matrix: Best PAR estimate.
    PAR_b : numpy.ndarray
        Nx1 matrix: PAR with some remaining biases to be corrected with ep50.
    ep50 : numpy.ndarray
        Nx1 matrix: Estimated median percent error of the output value, as a function of depth.
    IQR_ep : numpy.ndarray
        Nx1 matrix: Estimated interquartile range of the percent error of the output value, as a function of depth.

    Notes:
    ------
    - The function is vectorized and works with N samples simultaneously.
    - N is the number of samples in the input arrays Ed and z.

    Example usage:
    ---------------
    my_Ed = np.array([[3.1477e-07, 4.401e-05, 0.00031093, 2.6219e-05],
                      [0.0097528, 0.061085, 0.10562, 0.087316],
                      [0.20572, 0.52315, 0.54544, 0.16185]])
    z = np.array([84.8, 14.2, 28.1])

    PAR, PAR_b, ep50, IQR_ep = PAR_from_Ed_380_443_490_555_v5(my_Ed, z)
    """
    
    # Constantes de la red neuronal
    x1_step1 = {
  'xoffset': np.array([-22.6422533091432,-19.5694508081377,-7.62188447185006,-22.463455710035]),
  'gain': np.array([0.0862100486323673,0.0977451436694377,0.233748143539256,0.0856004733764567]),
  'ymin': -1
    }

    y1_step1 = {
  'ymin': -1,
  'gain': 0.250728512194969,
  'xoffset': -3.99369680999518
    }

    b1 = np.array([15.730647333191342341,-0.49534156966572195913,0.97039137012893650347,-0.49171979839193752371,0.56264651486382422085,-3.0411491226910096763,-0.22429894553145560132,-2.6707220720367437217,0.67953896280893855142,-2.8438002814946115038])
    
    IW1_1 = np.array([
  [-1.8914038560741825989,-4.6202437271523564277,7.1277982402258652783,-14.698572793496168742],
  [0.2674572598092799236,1.3965220021786377558,-1.1738749761661486648,-2.2247807558806695916],
  [-0.15556463580010077008,1.3211396666341432837,0.28527318824435110578,-2.4312397134304464252],
  [0.7388290043686613906,3.3445917458413094714,-0.83904671265044583617,-2.2207059782083025112],
  [-0.96552007111379878346,-1.2996091513202774337,2.6734623034880686809,-0.64326600469676253891],
  [0.97247735089758025051,-1.0945654158130249112,-1.037234918043992371,5.3831860197187273442],
  [1.1038320702621962077,1.0023177900372604032,-0.78440926624369422537,0.64670680848829120713],
  [0.77459667593935299656,-0.74991984648234621957,-0.93308902814315941576,4.4558340566813283701],
  [2.2517159390256504814,-1.409035219230303948,-0.0999517984062262832,1.3554797208309452561],
  [0.61181001521085665029,-1.5970195329113765492,-5.0286505928624043449,-1.3945510147810746826]
    ])
    
    b2 = np.array([1.7894788442237250514])
    LW2_1 = np.array([-3.570472663825885018,-0.53651281954554341791,3.9814825188204947537,-1.4789492177671916817,0.20046607043831010664,-1.5379867326700220609,2.6805448746310056585,3.2684742226310432578,-0.79425733660514752366,0.082818785655453558414])
    
    mat = np.array([
[0.1,-15.175,7.921],
[0.2122,-15.472,6.7888],
[0.23809,-15.311,5.822],
[0.26715,-15.13,4.7373],
[0.29974,-14.928,3.5202],
[0.33632,-15.01,4.9463],
[0.37735,-15.102,6.5466],
[0.4234,-15.206,8.342],
[0.47506,-12.194,4.5598],
[0.53303,-11.6,4.8607],
[0.59807,-10.934,5.1984],
[0.67104,-11.606,3.4838],
[0.75292,-11.177,3.2473],
[0.84479,-10.697,2.982],
[0.94787,-9.9255,3.1747],
[1.0635,-9.3424,2.7291],
[1.1933,-8.6378,2.9057],
[1.3389,-6.9457,2.5844],
[1.5023,-7.5955,3.5953],
[1.6856,-6.2508,3.618],
[1.8913,-5.9706,3.265],
[2.122,-3.6584,3.5806],
[2.3809,-2.883,3.7172],
[2.6715,-1.5395,3.3463],
[2.9974,-1.2254,3.7032],
[3.3632,-0.43397,3.3444],
[3.7735,0.2191,2.8257],
[4.234,0.99176,3.2119],
[4.7506,2.1467,3.0988],
[5.3303,2.3311,2.6431],
[5.9807,2.6085,2.8889],
[6.7104,2.9363,2.5897],
[7.5292,2.6349,2.7991],
[8.4479,2.5279,2.6024],
[9.4787,2.3178,2.3078],
[10.635,1.7633,1.944],
[11.933,1.2258,1.745],
[13.389,0.61719,1.6872],
[15.023,0.10997,1.5912],
[16.856,-0.49782,1.7335],
[18.913,-1.0101,1.7457],
[21.22,-1.362,1.875],
[23.809,-1.4939,1.7661],
[26.715,-1.5622,1.647],
[29.974,-1.2306,1.5158],
[33.632,-1.0545,1.3203],
[37.735,-0.73813,1.0835],
[42.34,-0.38927,1.0106],
[47.506,0.060673,1.1068],
[53.303,0.23859,1.5087],
[59.807,0.22202,1.6215],
[67.104,0.055418,1.704],
[75.292,-0.15609,1.3196],
[84.479,-0.35789,1.1319],
[94.787,-0.5941,1.2445],
[106.35,-0.75959,1.4773],
[119.33,-0.77206,1.5534],
[133.89,-0.56203,1.6347],
[150.23,-0.17703,1.6786],
[168.56,0.11636,1.7007],
[189.13,-0.044101,1.7838],
[201,0,0],
[1000,0,0],
])
  
    # Log10 del espectro de irradiancia
    x1 = np.log10(Ed).T  # Transpuesta para (5, N)
    xp1 = mapminmax_apply(x1, x1_step1)

    # Capa oculta
    a1 = tansig_apply(b1[:, np.newaxis] + IW1_1 @ xp1)

    # Capa de salida
    a2 = b2 + LW2_1 @ a1

    # Salida final
    y1 = mapminmax_reverse(a2, y1_step1)
    PAR_b = 10 ** y1.T  # (N,)

    # Interpolación de ep50 y IQR_ep
    log_z = np.log10(z)
    ep50 = interp1d(np.log10(mat[:, 0]), mat[:, 1], bounds_error=False, fill_value="extrapolate")(log_z)
    IQR_ep = interp1d(np.log10(mat[:, 0]), mat[:, 2], bounds_error=False, fill_value="extrapolate")(log_z)

    # Estimación final
    PAR = PAR_b / (1 + ep50 / 100)

    return PAR, PAR_b, ep50, IQR_ep

def mapminmax_apply(x, settings):
    y = (x - settings['xoffset'][:, np.newaxis]) * settings['gain'][:, np.newaxis] + settings['ymin']
    return y

def tansig_apply(n):
    return 2 / (1 + np.exp(-2 * n)) - 1

def mapminmax_reverse(y, settings):
    x = (y - settings['ymin']) / settings['gain'] + settings['xoffset']
    return x