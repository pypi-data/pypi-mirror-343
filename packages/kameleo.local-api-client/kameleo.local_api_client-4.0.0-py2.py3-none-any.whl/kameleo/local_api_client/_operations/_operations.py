# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.6, generator: @autorest/python@6.5.1)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._serialization import Serializer
from .._vendor import KameleoLocalApiClientMixinABC, _format_url_section

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_kameleo_local_api_get_fingerprint_search_parameters_request(
    *,
    device_type: Optional[str] = None,
    os_family: Optional[str] = None,
    browser_product: Optional[str] = None,
    language: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/base-profile-search-parameters"

    # Construct parameters
    if device_type is not None:
        _params["deviceType"] = _SERIALIZER.query("device_type", device_type, "str")
    if os_family is not None:
        _params["osFamily"] = _SERIALIZER.query("os_family", os_family, "str")
    if browser_product is not None:
        _params["browserProduct"] = _SERIALIZER.query("browser_product", browser_product, "str")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_kameleo_local_api_search_fingerprints_request(
    *,
    device_type: Optional[str] = None,
    os_family: Optional[str] = None,
    browser_product: Optional[str] = None,
    language: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/base-profiles"

    # Construct parameters
    if device_type is not None:
        _params["deviceType"] = _SERIALIZER.query("device_type", device_type, "str")
    if os_family is not None:
        _params["osFamily"] = _SERIALIZER.query("os_family", os_family, "str")
    if browser_product is not None:
        _params["browserProduct"] = _SERIALIZER.query("browser_product", browser_product, "str")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_kameleo_local_api_list_cookies_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/cookies"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_add_cookies_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/cookies"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_delete_cookies_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/cookies"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_list_folders_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/folders"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_read_folder_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/folders/{guid}"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_update_folder_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/folders/{guid}"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_delete_folder_request(
    guid: str, *, include_profiles: bool = False, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/folders/{guid}"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if include_profiles is not None:
        _params["includeProfiles"] = _SERIALIZER.query("include_profiles", include_profiles, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_kameleo_local_api_create_folder_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/folders/new"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_add_profile_to_folder_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/folders/{guid}/add"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_remove_profile_from_folder_request(
    guid: str, profile_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/folders/{guid}/{profileId}"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
        "profileId": _SERIALIZER.url("profile_id", profile_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_read_sharing_options_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/folders/share"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_share_group_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/folders/{guid}/share"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_healthcheck_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/general/healthcheck"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_get_user_info_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/general/user-info"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_terminate_application_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/general/terminate"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_list_profiles_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_create_profile_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/new"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_update_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_read_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_delete_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_get_profile_status_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/status"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_start_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/start"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_start_profile_with_options_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/start"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_stop_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/stop"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_export_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/export"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_duplicate_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/duplicate"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_import_profile_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/import"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_kameleo_local_api_upgrade_profile_request(guid: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/profiles/{guid}/upgrade"
    path_format_arguments = {
        "guid": _SERIALIZER.url("guid", guid, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


class KameleoLocalApiClientOperationsMixin(KameleoLocalApiClientMixinABC):  # pylint: disable=too-many-public-methods
    @distributed_trace
    def get_fingerprint_search_parameters(
        self,
        *,
        device_type: Optional[str] = None,
        os_family: Optional[str] = None,
        browser_product: Optional[str] = None,
        language: Optional[str] = None,
        **kwargs: Any
    ) -> _models.BaseProfileSearchParameters:
        """Retrieves the available filtering options for base profiles, including device types, operating
        system families, browser products, and languages. This enables you to refine the selection, for
        example, to see which languages are available for profiles using Windows with Chrome.

        Retrieves the available filtering options for base profiles, including device types, operating
        system families, browser products, and languages. This enables you to refine the selection, for
        example, to see which languages are available for profiles using Windows with Chrome.

        :keyword device_type: Filter option for the Device Type. Possible values are 'desktop',
         'mobile'. For example set it to mobile if you only want to see what os families we have for
         mobile profiles. Default value is None.
        :paramtype device_type: str
        :keyword os_family: Filter option for os family. Possible values are 'windows', 'macos',
         'linux', 'android', 'ios'. For example set it to windows if you only want to see what languages
         we have for windows profiles. Default value is None.
        :paramtype os_family: str
        :keyword browser_product: Filter option for browser product. Possible values are 'chrome',
         'firefox', 'edge', 'safari'. For example set it to safari if you only want to see what os
         families we have for chrome profiles. Default value is None.
        :paramtype browser_product: str
        :keyword language: Filter option for os language. Use ISO 639-1 language code format. For
         example set it to en-gb if you only want to see what browser products we have for English
         profiles. Default value is None.
        :paramtype language: str
        :return: BaseProfileSearchParameters
        :rtype: ~kameleo.local_api_client.models.BaseProfileSearchParameters
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.BaseProfileSearchParameters] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_get_fingerprint_search_parameters_request(
            device_type=device_type,
            os_family=os_family,
            browser_product=browser_product,
            language=language,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("BaseProfileSearchParameters", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def search_fingerprints(
        self,
        *,
        device_type: Optional[str] = None,
        os_family: Optional[str] = None,
        browser_product: Optional[str] = None,
        language: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.BaseProfilePreview]:
        """Retrieves a set of 25 base profiles based on specified criteria, with the most recent browser
        versions at the beginning of the list. Note that calling this method multiple times will return
        different sets of base profiles.

        Retrieves a set of 25 base profiles based on specified criteria, with the most recent browser
        versions at the beginning of the list. Note that calling this method multiple times will return
        different sets of base profiles.

        :keyword device_type: Filter option for the Device Type. Possible values are 'desktop',
         'mobile'.
         You can also use a comma-separated list to provide more than one value. Default value is None.
        :paramtype device_type: str
        :keyword os_family: Filter option for os family. Possible values are 'windows', 'macos',
         'linux', 'android', 'ios'.
         You can also use a comma-separated list to provide more than one value. Default value is None.
        :paramtype os_family: str
        :keyword browser_product: Filter option for browser product. Possible values are 'chrome',
         'firefox', 'edge', 'safari'.
         You can also use a comma-separated list to provide more than one value. Default value is None.
        :paramtype browser_product: str
        :keyword language: Filter option for os language. Use ISO 639-1 language code format.
         For example, set it to en-gb if you want to get only English profiles from Great-Britain.
         You can also use a comma-separated list to provide more than one value.
         This field also supports wildcard for the sublanguage part: to retrieve both en-us, en-gb, and
         en-ca profiles, use 'en-*' as value. Default value is None.
        :paramtype language: str
        :return: list of BaseProfilePreview
        :rtype: list[~kameleo.local_api_client.models.BaseProfilePreview]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BaseProfilePreview]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_search_fingerprints_request(
            device_type=device_type,
            os_family=os_family,
            browser_product=browser_product,
            language=language,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[BaseProfilePreview]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list_cookies(self, guid: str, **kwargs: Any) -> List[_models.BrowserCookie]:
        """Retrieves the list of cookies stored in the profile's browser. Note that this list does not
        include session cookies, which are not persisted between browser launches.

        Retrieves the list of cookies stored in the profile's browser. Note that this list does not
        include session cookies, which are not persisted between browser launches.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.BrowserCookie]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_list_cookies_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[BrowserCookie]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def add_cookies(
        self,
        guid: str,
        body: Optional[List[_models.CookieRequest]] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.BrowserCookie]:
        """Adds a list of cookies to the profile, allowing you to inject cookies before starting the
        profile. If cookies already exist for a domain, they will be replaced with the new ones.

        Adds a list of cookies to the profile, allowing you to inject cookies before starting the
        profile. If cookies already exist for a domain, they will be replaced with the new ones.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: list[~kameleo.local_api_client.models.CookieRequest]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_cookies(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.BrowserCookie]:
        """Adds a list of cookies to the profile, allowing you to inject cookies before starting the
        profile. If cookies already exist for a domain, they will be replaced with the new ones.

        Adds a list of cookies to the profile, allowing you to inject cookies before starting the
        profile. If cookies already exist for a domain, they will be replaced with the new ones.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add_cookies(
        self, guid: str, body: Optional[Union[List[_models.CookieRequest], IO]] = None, **kwargs: Any
    ) -> List[_models.BrowserCookie]:
        """Adds a list of cookies to the profile, allowing you to inject cookies before starting the
        profile. If cookies already exist for a domain, they will be replaced with the new ones.

        Adds a list of cookies to the profile, allowing you to inject cookies before starting the
        profile. If cookies already exist for a domain, they will be replaced with the new ones.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a [CookieRequest] type or a IO type. Default value is None.
        :type body: list[~kameleo.local_api_client.models.CookieRequest] or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: list of BrowserCookie
        :rtype: list[~kameleo.local_api_client.models.BrowserCookie]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.BrowserCookie]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "[CookieRequest]")
            else:
                _json = None

        request = build_kameleo_local_api_add_cookies_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[BrowserCookie]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def delete_cookies(self, guid: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes all the cookies stored in the profile, which will likely log the profile out of all
        websites.

        Deletes all the cookies stored in the profile, which will likely log the profile out of all
        websites.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_delete_cookies_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list_folders(self, **kwargs: Any) -> _models.ListFoldersResponse:
        """Gets the list of folders including subfolders and profiles that are loaded in the current
        workspace.

        Gets the list of folders including subfolders and profiles that are loaded in the current
        workspace.

        :return: ListFoldersResponse
        :rtype: ~kameleo.local_api_client.models.ListFoldersResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListFoldersResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_list_folders_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ListFoldersResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def read_folder(self, guid: str, **kwargs: Any) -> _models.FolderResponse:
        """Gets the folder with the sepcified Id from the current workspace.

        Gets the folder with the sepcified Id from the current workspace.

        :param guid: The unique identifier of the folder. Required.
        :type guid: str
        :return: FolderResponse
        :rtype: ~kameleo.local_api_client.models.FolderResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FolderResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_read_folder_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("FolderResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def update_folder(
        self,
        guid: str,
        body: Optional[_models.UpdateFolderRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.FolderResponse:
        """Updates the details of an existing folder, not including its content.

        Updates the details of an existing folder, not including its content.

        :param guid: The unique identifier of the folder. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.UpdateFolderRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FolderResponse
        :rtype: ~kameleo.local_api_client.models.FolderResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_folder(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FolderResponse:
        """Updates the details of an existing folder, not including its content.

        Updates the details of an existing folder, not including its content.

        :param guid: The unique identifier of the folder. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FolderResponse
        :rtype: ~kameleo.local_api_client.models.FolderResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_folder(
        self, guid: str, body: Optional[Union[_models.UpdateFolderRequest, IO]] = None, **kwargs: Any
    ) -> _models.FolderResponse:
        """Updates the details of an existing folder, not including its content.

        Updates the details of an existing folder, not including its content.

        :param guid: The unique identifier of the folder. Required.
        :type guid: str
        :param body: Is either a UpdateFolderRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.UpdateFolderRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: FolderResponse
        :rtype: ~kameleo.local_api_client.models.FolderResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FolderResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateFolderRequest")
            else:
                _json = None

        request = build_kameleo_local_api_update_folder_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("FolderResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def delete_folder(
        self, guid: str, *, include_profiles: bool = False, **kwargs: Any
    ) -> _models.DeleteFolderResponse:
        """Deletes a folder along with all its subfolders. Profiles within the folder will either be
        deleted or moved to the top-level based on the query parameters.

        Deletes a folder along with all its subfolders. Profiles within the folder will either be
        deleted or moved to the top-level based on the query parameters.

        :param guid: The unique identifier of the folder. Required.
        :type guid: str
        :keyword include_profiles: Flag to indicate if the contained profiles should be deleted (true)
         or moved to the top-level (false). Default value is False.
        :paramtype include_profiles: bool
        :return: DeleteFolderResponse
        :rtype: ~kameleo.local_api_client.models.DeleteFolderResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DeleteFolderResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_delete_folder_request(
            guid=guid,
            include_profiles=include_profiles,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("DeleteFolderResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def create_folder(
        self,
        body: Optional[_models.CreateFolderRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.FolderResponse:
        """Creates a new folder.

        Creates a new folder.

        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.CreateFolderRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FolderResponse
        :rtype: ~kameleo.local_api_client.models.FolderResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_folder(
        self, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FolderResponse:
        """Creates a new folder.

        Creates a new folder.

        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FolderResponse
        :rtype: ~kameleo.local_api_client.models.FolderResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_folder(
        self, body: Optional[Union[_models.CreateFolderRequest, IO]] = None, **kwargs: Any
    ) -> _models.FolderResponse:
        """Creates a new folder.

        Creates a new folder.

        :param body: Is either a CreateFolderRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.CreateFolderRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: FolderResponse
        :rtype: ~kameleo.local_api_client.models.FolderResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FolderResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateFolderRequest")
            else:
                _json = None

        request = build_kameleo_local_api_create_folder_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("FolderResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def add_profile_to_folder(
        self,
        guid: str,
        body: Optional[_models.AddProfileToFolderRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Adds the given profile to the specified folder.

        Adds the given profile to the specified folder.

        :param guid: The unique identifier of the folder. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.AddProfileToFolderRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_profile_to_folder(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Adds the given profile to the specified folder.

        Adds the given profile to the specified folder.

        :param guid: The unique identifier of the folder. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add_profile_to_folder(
        self, guid: str, body: Optional[Union[_models.AddProfileToFolderRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Adds the given profile to the specified folder.

        Adds the given profile to the specified folder.

        :param guid: The unique identifier of the folder. Required.
        :type guid: str
        :param body: Is either a AddProfileToFolderRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.AddProfileToFolderRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "AddProfileToFolderRequest")
            else:
                _json = None

        request = build_kameleo_local_api_add_profile_to_folder_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def remove_profile_from_folder(self, guid: str, profile_id: str, **kwargs: Any) -> _models.ProfileResponse:
        """Removes the given profile from the specified folder.

        Removes the given profile from the specified folder.

        :param guid: The unique identifier of the folder. Required.
        :type guid: str
        :param profile_id: The unique identifier of the profile. Required.
        :type profile_id: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_remove_profile_from_folder_request(
            guid=guid,
            profile_id=profile_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def read_sharing_options(self, **kwargs: Any) -> _models.SharingOptionsResponse:
        """Reads the sharing options (list of users and roles).

        Reads the sharing options (list of users and roles).

        :return: SharingOptionsResponse
        :rtype: ~kameleo.local_api_client.models.SharingOptionsResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SharingOptionsResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_read_sharing_options_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("SharingOptionsResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def share_group(
        self,
        guid: str,
        body: Optional[_models.ShareGroupRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.FolderResponse:
        """Updates the share access of the specified folder.

        Updates the share access of the specified folder.

        :param guid: Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.ShareGroupRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FolderResponse
        :rtype: ~kameleo.local_api_client.models.FolderResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def share_group(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FolderResponse:
        """Updates the share access of the specified folder.

        Updates the share access of the specified folder.

        :param guid: Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FolderResponse
        :rtype: ~kameleo.local_api_client.models.FolderResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def share_group(
        self, guid: str, body: Optional[Union[_models.ShareGroupRequest, IO]] = None, **kwargs: Any
    ) -> _models.FolderResponse:
        """Updates the share access of the specified folder.

        Updates the share access of the specified folder.

        :param guid: Required.
        :type guid: str
        :param body: Is either a ShareGroupRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.ShareGroupRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: FolderResponse
        :rtype: ~kameleo.local_api_client.models.FolderResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FolderResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ShareGroupRequest")
            else:
                _json = None

        request = build_kameleo_local_api_share_group_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("FolderResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def healthcheck(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Health check request to test if Kameleo has been started and accepting connections.

        Health check request to test if Kameleo has been started and accepting connections.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_healthcheck_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_user_info(self, **kwargs: Any) -> _models.UserInfoResponse:
        """Provides information about the user.

        Provides information about the user.

        :return: UserInfoResponse
        :rtype: ~kameleo.local_api_client.models.UserInfoResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UserInfoResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_get_user_info_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("UserInfoResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def terminate_application(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Terminates the Kameleo session by deauthenticating and exiting the CLI. It is important to call
        it after operating with Kameleo, so other users of the team account won't be logged out.

        Terminates the Kameleo session by deauthenticating and exiting the CLI. It is important to call
        it after operating with Kameleo, so other users of the team account won't be logged out.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_terminate_application_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list_profiles(self, **kwargs: Any) -> List[_models.ProfilePreview]:
        """Gets a list of the profiles that are loaded in the current workspace.

        Gets a list of the profiles that are loaded in the current workspace.

        :return: list of ProfilePreview
        :rtype: list[~kameleo.local_api_client.models.ProfilePreview]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.ProfilePreview]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_list_profiles_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("[ProfilePreview]", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def create_profile(
        self,
        body: Optional[_models.CreateProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Creates a new profile based on a selected Fingerprint and inputs.

        Creates a new profile based on a selected Fingerprint and inputs.

        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.CreateProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_profile(
        self, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Creates a new profile based on a selected Fingerprint and inputs.

        Creates a new profile based on a selected Fingerprint and inputs.

        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_profile(
        self, body: Optional[Union[_models.CreateProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Creates a new profile based on a selected Fingerprint and inputs.

        Creates a new profile based on a selected Fingerprint and inputs.

        :param body: Is either a CreateProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.CreateProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "CreateProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_create_profile_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def update_profile(
        self,
        guid: str,
        body: Optional[_models.UpdateProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Updates profile settings.

        Updates profile settings.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.UpdateProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_profile(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Updates profile settings.

        Updates profile settings.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_profile(
        self, guid: str, body: Optional[Union[_models.UpdateProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Updates profile settings.

        Updates profile settings.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a UpdateProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.UpdateProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "UpdateProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_update_profile_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def read_profile(self, guid: str, **kwargs: Any) -> _models.ProfileResponse:
        """Gets the profile with the specified ID from the current workspace. On startup, Kameleo will
        automatically scan and load profiles stored in your workspace folder.

        Gets the profile with the specified ID from the current workspace. On startup, Kameleo will
        automatically scan and load profiles stored in your workspace folder.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_read_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def delete_profile(self, guid: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Irreversibly deletes a profile from the current workspace, freeing up disk space and removing
        all associated data. It is recommended to create a backup using the export function before
        deleting a profile, as this operation is permanent and can result in data loss.

        Irreversibly deletes a profile from the current workspace, freeing up disk space and removing
        all associated data. It is recommended to create a backup using the export function before
        deleting a profile, as this operation is permanent and can result in data loss.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_delete_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_profile_status(self, guid: str, **kwargs: Any) -> _models.StatusResponse:
        """Returns the current status information about a profile, including its save state, lifetime
        state, and the connection port for profiles using an external spoofing engine.

        Returns the current status information about a profile, including its save state, lifetime
        state, and the connection port for profiles using an external spoofing engine.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_get_profile_status_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def start_profile(self, guid: str, **kwargs: Any) -> _models.StatusResponse:
        """Starts the selected profile by transitioning its status to 'starting', launching the browser
        engine associated with the profile, and then changing its status to 'running'. If there is an
        error during start up, it will be 'terminated'. You can use the launcher property to override
        the browser engine before the first start.

        Starts the selected profile by transitioning its status to 'starting', launching the browser
        engine associated with the profile, and then changing its status to 'running'. If there is an
        error during start up, it will be 'terminated'. You can use the launcher property to override
        the browser engine before the first start.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_start_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def start_profile_with_options(
        self,
        guid: str,
        body: Optional[_models.WebDriverSettings] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.StatusResponse:
        """Starts the selected profile with additional command line arguments or browser profile options.
        The browser engine associated with the profile is launched, and then the profile's status is
        changed to 'running'. If there is an error during start-up, it will be 'terminated'. You can
        use the launcher property to override the browser engine before the first start.

        Starts the selected profile with additional command line arguments or browser profile options.
        The browser engine associated with the profile is launched, and then the profile's status is
        changed to 'running'. If there is an error during start-up, it will be 'terminated'. You can
        use the launcher property to override the browser engine before the first start.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.WebDriverSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def start_profile_with_options(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.StatusResponse:
        """Starts the selected profile with additional command line arguments or browser profile options.
        The browser engine associated with the profile is launched, and then the profile's status is
        changed to 'running'. If there is an error during start-up, it will be 'terminated'. You can
        use the launcher property to override the browser engine before the first start.

        Starts the selected profile with additional command line arguments or browser profile options.
        The browser engine associated with the profile is launched, and then the profile's status is
        changed to 'running'. If there is an error during start-up, it will be 'terminated'. You can
        use the launcher property to override the browser engine before the first start.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def start_profile_with_options(
        self, guid: str, body: Optional[Union[_models.WebDriverSettings, IO]] = None, **kwargs: Any
    ) -> _models.StatusResponse:
        """Starts the selected profile with additional command line arguments or browser profile options.
        The browser engine associated with the profile is launched, and then the profile's status is
        changed to 'running'. If there is an error during start-up, it will be 'terminated'. You can
        use the launcher property to override the browser engine before the first start.

        Starts the selected profile with additional command line arguments or browser profile options.
        The browser engine associated with the profile is launched, and then the profile's status is
        changed to 'running'. If there is an error during start-up, it will be 'terminated'. You can
        use the launcher property to override the browser engine before the first start.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a WebDriverSettings type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.WebDriverSettings or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "WebDriverSettings")
            else:
                _json = None

        request = build_kameleo_local_api_start_profile_with_options_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def stop_profile(self, guid: str, **kwargs: Any) -> _models.StatusResponse:
        """Stops the selected profile and optionally releases resources. The browser engine (desktop
        browsers or external spoofing engine) associated with the profile is closed, and the profile's
        status is changed to 'terminated'.

        Stops the selected profile and optionally releases resources. The browser engine (desktop
        browsers or external spoofing engine) associated with the profile is closed, and the profile's
        status is changed to 'terminated'.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: StatusResponse
        :rtype: ~kameleo.local_api_client.models.StatusResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatusResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_stop_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("StatusResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def export_profile(
        self,
        guid: str,
        body: Optional[_models.ExportProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Exports a profile to a file, creating a .kameleo file at the specified location. This file
        encapsulates everything about the profile including settings, browsing data, cookies, history,
        bookmarks, and any installed extensions/addons. This allows for the profile to be loaded again
        at a later time, and it can also be loaded into a different Kameleo instance.

        Exports a profile to a file, creating a .kameleo file at the specified location. This file
        encapsulates everything about the profile including settings, browsing data, cookies, history,
        bookmarks, and any installed extensions/addons. This allows for the profile to be loaded again
        at a later time, and it can also be loaded into a different Kameleo instance.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.ExportProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def export_profile(
        self, guid: str, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Exports a profile to a file, creating a .kameleo file at the specified location. This file
        encapsulates everything about the profile including settings, browsing data, cookies, history,
        bookmarks, and any installed extensions/addons. This allows for the profile to be loaded again
        at a later time, and it can also be loaded into a different Kameleo instance.

        Exports a profile to a file, creating a .kameleo file at the specified location. This file
        encapsulates everything about the profile including settings, browsing data, cookies, history,
        bookmarks, and any installed extensions/addons. This allows for the profile to be loaded again
        at a later time, and it can also be loaded into a different Kameleo instance.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def export_profile(
        self, guid: str, body: Optional[Union[_models.ExportProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Exports a profile to a file, creating a .kameleo file at the specified location. This file
        encapsulates everything about the profile including settings, browsing data, cookies, history,
        bookmarks, and any installed extensions/addons. This allows for the profile to be loaded again
        at a later time, and it can also be loaded into a different Kameleo instance.

        Exports a profile to a file, creating a .kameleo file at the specified location. This file
        encapsulates everything about the profile including settings, browsing data, cookies, history,
        bookmarks, and any installed extensions/addons. This allows for the profile to be loaded again
        at a later time, and it can also be loaded into a different Kameleo instance.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :param body: Is either a ExportProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.ExportProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ExportProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_export_profile_request(
            guid=guid,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def duplicate_profile(self, guid: str, **kwargs: Any) -> _models.ProfileResponse:
        """Creates a copy of the loaded profile, which is saved to the workspace on the filesystem. The
        duplicated profile will have a new ID, but will retain all the settings, browsing data,
        cookies, history, bookmarks, and installed extensions of the original profile.

        Creates a copy of the loaded profile, which is saved to the workspace on the filesystem. The
        duplicated profile will have a new ID, but will retain all the settings, browsing data,
        cookies, history, bookmarks, and installed extensions of the original profile.

        :param guid: The unique identifier of the profile. Required.
        :type guid: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_duplicate_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def import_profile(
        self,
        body: Optional[_models.ImportProfileRequest] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ProfileResponse:
        """Imports a profile from a .kameleo file, effectively recreating the profile with all its
        attributes, including settings, browsing data, cookies, history, bookmarks, and any installed
        extensions/addons. If the profile is already loaded, the import process will fail.

        Imports a profile from a .kameleo file, effectively recreating the profile with all its
        attributes, including settings, browsing data, cookies, history, bookmarks, and any installed
        extensions/addons. If the profile is already loaded, the import process will fail.

        :param body: Default value is None.
        :type body: ~kameleo.local_api_client.models.ImportProfileRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def import_profile(
        self, body: Optional[IO] = None, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ProfileResponse:
        """Imports a profile from a .kameleo file, effectively recreating the profile with all its
        attributes, including settings, browsing data, cookies, history, bookmarks, and any installed
        extensions/addons. If the profile is already loaded, the import process will fail.

        Imports a profile from a .kameleo file, effectively recreating the profile with all its
        attributes, including settings, browsing data, cookies, history, bookmarks, and any installed
        extensions/addons. If the profile is already loaded, the import process will fail.

        :param body: Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def import_profile(
        self, body: Optional[Union[_models.ImportProfileRequest, IO]] = None, **kwargs: Any
    ) -> _models.ProfileResponse:
        """Imports a profile from a .kameleo file, effectively recreating the profile with all its
        attributes, including settings, browsing data, cookies, history, bookmarks, and any installed
        extensions/addons. If the profile is already loaded, the import process will fail.

        Imports a profile from a .kameleo file, effectively recreating the profile with all its
        attributes, including settings, browsing data, cookies, history, bookmarks, and any installed
        extensions/addons. If the profile is already loaded, the import process will fail.

        :param body: Is either a ImportProfileRequest type or a IO type. Default value is None.
        :type body: ~kameleo.local_api_client.models.ImportProfileRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ProfileResponse
        :rtype: ~kameleo.local_api_client.models.ProfileResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ProfileResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "ImportProfileRequest")
            else:
                _json = None

        request = build_kameleo_local_api_import_profile_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def upgrade_profile(self, guid: str, **kwargs: Any) -> Optional[_models.ProfileResponse]:
        """Upgrades the profile to the most recent browser version available from the server, tailored to
        the profile's current device, browser, operating system, and language settings. Note that
        upgrading a profile will alter its browser fingerprint.

        Upgrades the profile to the most recent browser version available from the server, tailored to
        the profile's current device, browser, operating system, and language settings. Note that
        upgrading a profile will alter its browser fingerprint.

        :param guid: Required.
        :type guid: str
        :return: ProfileResponse or None
        :rtype: ~kameleo.local_api_client.models.ProfileResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ProfileResponse]] = kwargs.pop("cls", None)

        request = build_kameleo_local_api_upgrade_profile_request(
            guid=guid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ProblemResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize("ProfileResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
