/* LCM type definition class file
 * This file was automatically generated by lcm-gen
 * DO NOT MODIFY BY HAND!!!!
{% if lcmtype.struct.source_file %}
 *
 * From Source File: {{ lcmtype.struct.source_file }}
{% endif %}
 */

package {{ lcmtype.full_package_name }};
 
import java.io.*;
import java.util.*;
import lcm.lcm.*;
 
{% if enum_cases %}
public final class {{ lcmtype.name }} implements lcm.lcm.LCMEnum
{% else %}
public final class {{ lcmtype.name }} implements lcm.lcm.LCMEncodable
{% endif %}
{
{% for member in lcmtype.members %}
{{ lcmtype.declare_member(member) }}
{% endfor %}
 
    public {{ lcmtype.name }}()
    {
{% for array_member in lcmtype.fixed_size_array_members() %}
        {{ lcmtype.preallocate_array_member(array_member) }}
{% endfor %}
    }
 
    public static final long LCM_FINGERPRINT;
    public static final long LCM_FINGERPRINT_BASE = {{ lcmtype.hash }};
 
{% if lcmtype.constants %}
{% for type, name, value in lcmtype.define_constants() %}
    public static final {{ type }} {{ name }} = {{ value }};
{% endfor %}

{% endif %}
    static {
        LCM_FINGERPRINT = _hashRecursive(new ArrayList<Class<?>>());
    }
 
    public static long _hashRecursive(ArrayList<Class<?>> classes)
    {
        if (classes.contains({{ lcmtype.full_name }}.class))
            return 0L;
 
        classes.add({{ lcmtype.full_name }}.class);
        long hash = LCM_FINGERPRINT_BASE
{% for type_ref in lcmtype.complex_subtypes() %}
             + {{ type_ref.full_name }}._hashRecursive(classes)
{% endfor %}
            ;
        classes.remove(classes.size() - 1);
        return (hash<<1) + ((hash>>63)&1);
    }
 
    public void encode(DataOutput outs) throws IOException
    {
        outs.writeLong(LCM_FINGERPRINT);
        _encodeRecursive(outs);
    }
 
    public void _encodeRecursive(DataOutput outs) throws IOException
    {
{% if lcmtype.has_string_members() %}
        char[] __strbuf = null;
{% endif %}
{% for member in lcmtype.members %}
{{ lcmtype.encode_member(member) }}
{% endfor %}
    }
 
    public {{ lcmtype.name }}(byte[] data) throws IOException
    {
        this(new LCMDataInputStream(data));
    }
 
    public {{ lcmtype.name }}(DataInput ins) throws IOException
    {
        if (ins.readLong() != LCM_FINGERPRINT)
            throw new IOException("LCM Decode error: bad fingerprint");
 
        _decodeRecursive(ins);
    }
 
    public static {{ lcmtype.full_name }} _decodeRecursiveFactory(DataInput ins) throws IOException
    {
        {{ lcmtype.full_name }} o = new {{ lcmtype.full_name }}();
        o._decodeRecursive(ins);
        return o;
    }
 
    public void _decodeRecursive(DataInput ins) throws IOException
    {
{% if lcmtype.has_string_members() %}
        char[] __strbuf = null;
{% endif %}
{% for member in lcmtype.members %}
{{ lcmtype.decode_member(member) }}
{% endfor %}
    }
 
    public {{ lcmtype.full_name }} copy()
    {
        {{ lcmtype.full_name }} outobj = new {{ lcmtype.full_name }}();
{% for member in lcmtype.members %}
{{ lcmtype.copy_member(member) }}
{% endfor %}
        return outobj;
    }
 
{% if enum_cases %}
    public final String string_value() {
        // NOTE(stevemo): We can't use a switch() because that doesn't work for longs
        // NOTE(stevemo): Explicitly cast to the value type because java lacks unsigned types
        {% for enum_case in enum_cases %}
        if (value == {{ enum_storage_type.replace("#", enum_case.value_str) }}) return "{{ enum_case.name }}";
        {% endfor %}
        return String.valueOf(value);
    }
{% endif %}
}


