# coding: utf-8

"""
    OpenPay API

    super charge your subscription management.

    The version of the OpenAPI document: 1.2.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, conlist
from getopenpay.models.checkout_processors_preferences import CheckoutProcessorsPreferences
from getopenpay.models.fallback_configuration_input import FallbackConfigurationInput
from getopenpay.models.selected_price_quantity import SelectedPriceQuantity

class CheckoutPreferences(BaseModel):
    """
    Preferences for the checkout session. All changes to this object must be backwards-compatible, old objects should still be valid with all new schemas.  Note: this object is stored in both PaymentLinks (in string form) and CheckoutSessions  # noqa: E501
    """
    fallback_cascade_preferences: Optional[conlist(FallbackConfigurationInput)] = Field(default=None, description="This object contains a list of price groups that will be used to fall back to if the selected product price quantity fails to be created. Processor preferences here will override the processor preferences in the processor_preferences field.")
    fallback_cascade_selected_product_price_quantity: Optional[conlist(conlist(SelectedPriceQuantity))] = Field(default=None, description="This object contains a list of price groups that will be used to fall back to if the selected product price quantity fails to be created.")
    processor_preferences: Optional[CheckoutProcessorsPreferences] = None
    __properties = ["fallback_cascade_preferences", "fallback_cascade_selected_product_price_quantity", "processor_preferences"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> CheckoutPreferences:
        """Create an instance of CheckoutPreferences from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in fallback_cascade_preferences (list)
        _items = []
        if self.fallback_cascade_preferences:
            for _item in self.fallback_cascade_preferences:
                if _item:
                    _items.append(_item.to_dict())
            _dict['fallback_cascade_preferences'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in fallback_cascade_selected_product_price_quantity (list of list)
        _items = []
        if self.fallback_cascade_selected_product_price_quantity:
            for _item in self.fallback_cascade_selected_product_price_quantity:
                if _item:
                    _items.append(
                         [_inner_item.to_dict() for _inner_item in _item if _inner_item is not None]
                    )
            _dict['fallback_cascade_selected_product_price_quantity'] = _items
        # override the default output from pydantic by calling `to_dict()` of processor_preferences
        if self.processor_preferences:
            _dict['processor_preferences'] = self.processor_preferences.to_dict()
        # set to None if processor_preferences (nullable) is None
        # and __fields_set__ contains the field
        if self.processor_preferences is None and "processor_preferences" in self.__fields_set__:
            _dict['processor_preferences'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> CheckoutPreferences:
        """Create an instance of CheckoutPreferences from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return CheckoutPreferences.parse_obj(obj)

        _obj = CheckoutPreferences.parse_obj({
            "fallback_cascade_preferences": [FallbackConfigurationInput.from_dict(_item) for _item in obj.get("fallback_cascade_preferences")] if obj.get("fallback_cascade_preferences") is not None else None,
            "fallback_cascade_selected_product_price_quantity": [
                    [SelectedPriceQuantity.from_dict(_inner_item) for _inner_item in _item]
                    for _item in obj.get("fallback_cascade_selected_product_price_quantity")
                ] if obj.get("fallback_cascade_selected_product_price_quantity") is not None else None,
            "processor_preferences": CheckoutProcessorsPreferences.from_dict(obj.get("processor_preferences")) if obj.get("processor_preferences") is not None else None
        })
        return _obj


