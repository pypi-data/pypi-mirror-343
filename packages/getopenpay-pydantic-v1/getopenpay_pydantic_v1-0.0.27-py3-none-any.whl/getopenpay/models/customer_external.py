# coding: utf-8

"""
    OpenPay API

    super charge your subscription management.

    The version of the OpenAPI document: 1.2.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Any, Dict, List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
from getopenpay.models.complete_address import CompleteAddress
from getopenpay.models.customer_balance_external import CustomerBalanceExternal
from getopenpay.models.customer_invoice_settings import CustomerInvoiceSettings
from getopenpay.models.customer_language import CustomerLanguage
from getopenpay.models.customer_status import CustomerStatus
from getopenpay.models.customer_total_amount import CustomerTotalAmount
from getopenpay.models.discount_external import DiscountExternal
from getopenpay.models.object_name import ObjectName
from getopenpay.models.product_external import ProductExternal
from getopenpay.models.subscription_external import SubscriptionExternal

class CustomerExternal(BaseModel):
    """
    CustomerExternal
    """
    account_id: StrictStr = Field(default=..., description="Unique identifier for the account.")
    address: Optional[CompleteAddress] = Field(...)
    balance_atoms: Optional[conlist(CustomerBalanceExternal)] = Field(default=None, description="List of the customer's balance in the smallest unit of currency (e.g., cents for USD). Positive values indicate the amount owed by the customer, to be applied to the next invoice. Negative values represent credit to apply to future invoices.")
    billing_email: Optional[StrictStr] = None
    business_name: Optional[StrictStr] = Field(...)
    created_at: datetime = Field(default=..., description="DateTime at which the object was created, in 'ISO 8601' format.")
    custom_fields: Optional[Dict[str, Any]] = None
    customer_billing_address: Optional[CompleteAddress] = None
    discount: Optional[DiscountExternal] = None
    email: StrictStr = Field(default=..., description="Customer's email address.")
    first_name: Optional[StrictStr] = Field(...)
    id: StrictStr = Field(default=..., description="Unique identifier of the customer.")
    invoice_settings: Optional[CustomerInvoiceSettings] = None
    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
    language: Optional[CustomerLanguage] = Field(default=None, description="Language of the customer.")
    last_name: Optional[StrictStr] = Field(...)
    last_successful_payment_intent: Optional[PaymentIntentExternal] = None
    metadata: Optional[Dict[str, Any]] = None
    mrr: Optional[conlist(CustomerTotalAmount)] = Field(default=None, description="The monthly recurring revenue of the customer broken down by currency.")
    notes: Optional[StrictStr] = Field(...)
    object: Optional[ObjectName] = None
    phone_number: Optional[StrictStr] = None
    shipping_addresses: Optional[conlist(CompleteAddress)] = Field(default=None, description="List of customer's shipping addresses.")
    should_send_payment_receipt: StrictBool = Field(default=..., description="Whether email should be sent or not on payment.")
    status: Optional[CustomerStatus] = None
    subscribed_to_products: Optional[conlist(ProductExternal)] = Field(default=None, description="List of products that the customer is subscribed to.")
    subscriptions: Optional[conlist(SubscriptionExternal)] = Field(default=None, description="List of customer's subscriptions.")
    total_refunds: Optional[conlist(CustomerTotalAmount)] = Field(default=None, description="The total amount refunded to the customer.")
    total_spent: Optional[conlist(CustomerTotalAmount)] = Field(default=None, description="The total amount spent by the customer.")
    updated_at: datetime = Field(default=..., description="DateTime at which the object was updated, in 'ISO 8601' format.")
    __properties = ["account_id", "address", "balance_atoms", "billing_email", "business_name", "created_at", "custom_fields", "customer_billing_address", "discount", "email", "first_name", "id", "invoice_settings", "is_deleted", "language", "last_name", "last_successful_payment_intent", "metadata", "mrr", "notes", "object", "phone_number", "shipping_addresses", "should_send_payment_receipt", "status", "subscribed_to_products", "subscriptions", "total_refunds", "total_spent", "updated_at"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> CustomerExternal:
        """Create an instance of CustomerExternal from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of address
        if self.address:
            _dict['address'] = self.address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in balance_atoms (list)
        _items = []
        if self.balance_atoms:
            for _item in self.balance_atoms:
                if _item:
                    _items.append(_item.to_dict())
            _dict['balance_atoms'] = _items
        # override the default output from pydantic by calling `to_dict()` of customer_billing_address
        if self.customer_billing_address:
            _dict['customer_billing_address'] = self.customer_billing_address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of discount
        if self.discount:
            _dict['discount'] = self.discount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of invoice_settings
        if self.invoice_settings:
            _dict['invoice_settings'] = self.invoice_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of last_successful_payment_intent
        if self.last_successful_payment_intent:
            _dict['last_successful_payment_intent'] = self.last_successful_payment_intent.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in mrr (list)
        _items = []
        if self.mrr:
            for _item in self.mrr:
                if _item:
                    _items.append(_item.to_dict())
            _dict['mrr'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in shipping_addresses (list)
        _items = []
        if self.shipping_addresses:
            for _item in self.shipping_addresses:
                if _item:
                    _items.append(_item.to_dict())
            _dict['shipping_addresses'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in subscribed_to_products (list)
        _items = []
        if self.subscribed_to_products:
            for _item in self.subscribed_to_products:
                if _item:
                    _items.append(_item.to_dict())
            _dict['subscribed_to_products'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in subscriptions (list)
        _items = []
        if self.subscriptions:
            for _item in self.subscriptions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['subscriptions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in total_refunds (list)
        _items = []
        if self.total_refunds:
            for _item in self.total_refunds:
                if _item:
                    _items.append(_item.to_dict())
            _dict['total_refunds'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in total_spent (list)
        _items = []
        if self.total_spent:
            for _item in self.total_spent:
                if _item:
                    _items.append(_item.to_dict())
            _dict['total_spent'] = _items
        # set to None if address (nullable) is None
        # and __fields_set__ contains the field
        if self.address is None and "address" in self.__fields_set__:
            _dict['address'] = None

        # set to None if billing_email (nullable) is None
        # and __fields_set__ contains the field
        if self.billing_email is None and "billing_email" in self.__fields_set__:
            _dict['billing_email'] = None

        # set to None if business_name (nullable) is None
        # and __fields_set__ contains the field
        if self.business_name is None and "business_name" in self.__fields_set__:
            _dict['business_name'] = None

        # set to None if custom_fields (nullable) is None
        # and __fields_set__ contains the field
        if self.custom_fields is None and "custom_fields" in self.__fields_set__:
            _dict['custom_fields'] = None

        # set to None if customer_billing_address (nullable) is None
        # and __fields_set__ contains the field
        if self.customer_billing_address is None and "customer_billing_address" in self.__fields_set__:
            _dict['customer_billing_address'] = None

        # set to None if discount (nullable) is None
        # and __fields_set__ contains the field
        if self.discount is None and "discount" in self.__fields_set__:
            _dict['discount'] = None

        # set to None if first_name (nullable) is None
        # and __fields_set__ contains the field
        if self.first_name is None and "first_name" in self.__fields_set__:
            _dict['first_name'] = None

        # set to None if invoice_settings (nullable) is None
        # and __fields_set__ contains the field
        if self.invoice_settings is None and "invoice_settings" in self.__fields_set__:
            _dict['invoice_settings'] = None

        # set to None if last_name (nullable) is None
        # and __fields_set__ contains the field
        if self.last_name is None and "last_name" in self.__fields_set__:
            _dict['last_name'] = None

        # set to None if last_successful_payment_intent (nullable) is None
        # and __fields_set__ contains the field
        if self.last_successful_payment_intent is None and "last_successful_payment_intent" in self.__fields_set__:
            _dict['last_successful_payment_intent'] = None

        # set to None if metadata (nullable) is None
        # and __fields_set__ contains the field
        if self.metadata is None and "metadata" in self.__fields_set__:
            _dict['metadata'] = None

        # set to None if notes (nullable) is None
        # and __fields_set__ contains the field
        if self.notes is None and "notes" in self.__fields_set__:
            _dict['notes'] = None

        # set to None if phone_number (nullable) is None
        # and __fields_set__ contains the field
        if self.phone_number is None and "phone_number" in self.__fields_set__:
            _dict['phone_number'] = None

        # set to None if status (nullable) is None
        # and __fields_set__ contains the field
        if self.status is None and "status" in self.__fields_set__:
            _dict['status'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> CustomerExternal:
        """Create an instance of CustomerExternal from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return CustomerExternal.parse_obj(obj)

        _obj = CustomerExternal.parse_obj({
            "account_id": obj.get("account_id"),
            "address": CompleteAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
            "balance_atoms": [CustomerBalanceExternal.from_dict(_item) for _item in obj.get("balance_atoms")] if obj.get("balance_atoms") is not None else None,
            "billing_email": obj.get("billing_email"),
            "business_name": obj.get("business_name"),
            "created_at": obj.get("created_at"),
            "custom_fields": obj.get("custom_fields"),
            "customer_billing_address": CompleteAddress.from_dict(obj.get("customer_billing_address")) if obj.get("customer_billing_address") is not None else None,
            "discount": DiscountExternal.from_dict(obj.get("discount")) if obj.get("discount") is not None else None,
            "email": obj.get("email"),
            "first_name": obj.get("first_name"),
            "id": obj.get("id"),
            "invoice_settings": CustomerInvoiceSettings.from_dict(obj.get("invoice_settings")) if obj.get("invoice_settings") is not None else None,
            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
            "language": obj.get("language"),
            "last_name": obj.get("last_name"),
            "last_successful_payment_intent": PaymentIntentExternal.from_dict(obj.get("last_successful_payment_intent")) if obj.get("last_successful_payment_intent") is not None else None,
            "metadata": obj.get("metadata"),
            "mrr": [CustomerTotalAmount.from_dict(_item) for _item in obj.get("mrr")] if obj.get("mrr") is not None else None,
            "notes": obj.get("notes"),
            "object": obj.get("object"),
            "phone_number": obj.get("phone_number"),
            "shipping_addresses": [CompleteAddress.from_dict(_item) for _item in obj.get("shipping_addresses")] if obj.get("shipping_addresses") is not None else None,
            "should_send_payment_receipt": obj.get("should_send_payment_receipt"),
            "status": obj.get("status"),
            "subscribed_to_products": [ProductExternal.from_dict(_item) for _item in obj.get("subscribed_to_products")] if obj.get("subscribed_to_products") is not None else None,
            "subscriptions": [SubscriptionExternal.from_dict(_item) for _item in obj.get("subscriptions")] if obj.get("subscriptions") is not None else None,
            "total_refunds": [CustomerTotalAmount.from_dict(_item) for _item in obj.get("total_refunds")] if obj.get("total_refunds") is not None else None,
            "total_spent": [CustomerTotalAmount.from_dict(_item) for _item in obj.get("total_spent")] if obj.get("total_spent") is not None else None,
            "updated_at": obj.get("updated_at")
        })
        return _obj

from getopenpay.models.payment_intent_external import PaymentIntentExternal
CustomerExternal.update_forward_refs()

