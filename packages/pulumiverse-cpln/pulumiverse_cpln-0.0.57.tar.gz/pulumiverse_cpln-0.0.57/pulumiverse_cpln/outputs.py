# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'CloudAccountAws',
    'CloudAccountAzure',
    'CloudAccountGcp',
    'CloudAccountNgs',
    'DomainRouteHeaders',
    'DomainRouteHeadersRequest',
    'DomainSpec',
    'DomainSpecPort',
    'DomainSpecPortCors',
    'DomainSpecPortCorsAllowOrigin',
    'DomainSpecPortTls',
    'DomainSpecPortTlsClientCertificate',
    'DomainSpecPortTlsServerCertificate',
    'DomainStatus',
    'DomainStatusDnsConfig',
    'DomainStatusEndpoint',
    'DomainStatusLocation',
    'GroupIdentityMatcher',
    'GroupMemberQuery',
    'GroupMemberQuerySpec',
    'GroupMemberQuerySpecTerm',
    'GvcControlplaneTracing',
    'GvcLightstepTracing',
    'GvcLoadBalancer',
    'GvcLoadBalancerRedirect',
    'GvcLoadBalancerRedirectClass',
    'GvcOtelTracing',
    'GvcSidecar',
    'IdentityAwsAccessPolicy',
    'IdentityAzureAccessPolicy',
    'IdentityAzureAccessPolicyRoleAssignment',
    'IdentityGcpAccessPolicy',
    'IdentityGcpAccessPolicyBinding',
    'IdentityNativeNetworkResource',
    'IdentityNativeNetworkResourceAwsPrivateLink',
    'IdentityNativeNetworkResourceGcpServiceConnect',
    'IdentityNetworkResource',
    'IdentityNgsAccessPolicy',
    'IdentityNgsAccessPolicyPub',
    'IdentityNgsAccessPolicyResp',
    'IdentityNgsAccessPolicySub',
    'IpSetLocation',
    'IpSetStatus',
    'IpSetStatusIpAddress',
    'LocationGeo',
    'Mk8sAddOns',
    'Mk8sAddOnsAwsEcr',
    'Mk8sAddOnsAwsEfs',
    'Mk8sAddOnsAwsElb',
    'Mk8sAddOnsAzureAcr',
    'Mk8sAddOnsAzureWorkloadIdentity',
    'Mk8sAddOnsLogs',
    'Mk8sAddOnsMetrics',
    'Mk8sAddOnsMetricsScrapeAnnotated',
    'Mk8sAddOnsNvidia',
    'Mk8sAwsProvider',
    'Mk8sAwsProviderAutoscaler',
    'Mk8sAwsProviderDeployRoleChain',
    'Mk8sAwsProviderImage',
    'Mk8sAwsProviderNetworking',
    'Mk8sAwsProviderNodePool',
    'Mk8sAwsProviderNodePoolOverrideImage',
    'Mk8sAwsProviderNodePoolTaint',
    'Mk8sDigitalOceanProvider',
    'Mk8sDigitalOceanProviderAutoscaler',
    'Mk8sDigitalOceanProviderNetworking',
    'Mk8sDigitalOceanProviderNodePool',
    'Mk8sDigitalOceanProviderNodePoolTaint',
    'Mk8sEphemeralProvider',
    'Mk8sEphemeralProviderNodePool',
    'Mk8sEphemeralProviderNodePoolTaint',
    'Mk8sFirewall',
    'Mk8sGenericProvider',
    'Mk8sGenericProviderNetworking',
    'Mk8sGenericProviderNodePool',
    'Mk8sGenericProviderNodePoolTaint',
    'Mk8sHetznerProvider',
    'Mk8sHetznerProviderAutoscaler',
    'Mk8sHetznerProviderDedicatedServerNodePool',
    'Mk8sHetznerProviderDedicatedServerNodePoolTaint',
    'Mk8sHetznerProviderNetworking',
    'Mk8sHetznerProviderNodePool',
    'Mk8sHetznerProviderNodePoolTaint',
    'Mk8sLambdalabsProvider',
    'Mk8sLambdalabsProviderAutoscaler',
    'Mk8sLambdalabsProviderNodePool',
    'Mk8sLambdalabsProviderNodePoolTaint',
    'Mk8sLambdalabsProviderUnmanagedNodePool',
    'Mk8sLambdalabsProviderUnmanagedNodePoolTaint',
    'Mk8sLinodeProvider',
    'Mk8sLinodeProviderAutoscaler',
    'Mk8sLinodeProviderNetworking',
    'Mk8sLinodeProviderNodePool',
    'Mk8sLinodeProviderNodePoolTaint',
    'Mk8sOblivusProvider',
    'Mk8sOblivusProviderAutoscaler',
    'Mk8sOblivusProviderNodePool',
    'Mk8sOblivusProviderNodePoolTaint',
    'Mk8sOblivusProviderUnmanagedNodePool',
    'Mk8sOblivusProviderUnmanagedNodePoolTaint',
    'Mk8sPaperspaceProvider',
    'Mk8sPaperspaceProviderAutoscaler',
    'Mk8sPaperspaceProviderNodePool',
    'Mk8sPaperspaceProviderNodePoolTaint',
    'Mk8sPaperspaceProviderUnmanagedNodePool',
    'Mk8sPaperspaceProviderUnmanagedNodePoolTaint',
    'Mk8sStatus',
    'Mk8sStatusAddOn',
    'Mk8sStatusAddOnAwsEcr',
    'Mk8sStatusAddOnAwsEf',
    'Mk8sStatusAddOnAwsElb',
    'Mk8sStatusAddOnAwsWorkloadIdentity',
    'Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig',
    'Mk8sStatusAddOnDashboard',
    'Mk8sStatusAddOnLog',
    'Mk8sStatusAddOnMetric',
    'Mk8sTritonProvider',
    'Mk8sTritonProviderAutoscaler',
    'Mk8sTritonProviderConnection',
    'Mk8sTritonProviderLoadBalancer',
    'Mk8sTritonProviderLoadBalancerGateway',
    'Mk8sTritonProviderLoadBalancerManual',
    'Mk8sTritonProviderNetworking',
    'Mk8sTritonProviderNodePool',
    'Mk8sTritonProviderNodePoolTaint',
    'OrgAuthConfig',
    'OrgLoggingCloudWatchLogging',
    'OrgLoggingCoralogixLogging',
    'OrgLoggingDatadogLogging',
    'OrgLoggingElasticLogging',
    'OrgLoggingElasticLoggingAws',
    'OrgLoggingElasticLoggingElasticCloud',
    'OrgLoggingElasticLoggingGeneric',
    'OrgLoggingFluentdLogging',
    'OrgLoggingLogzioLogging',
    'OrgLoggingS3Logging',
    'OrgLoggingStackdriverLogging',
    'OrgLoggingSyslogLogging',
    'OrgObservability',
    'OrgSecurity',
    'OrgSecurityThreatDetection',
    'OrgSecurityThreatDetectionSyslog',
    'OrgStatus',
    'OrgTracingControlplaneTracing',
    'OrgTracingLightstepTracing',
    'OrgTracingOtelTracing',
    'PolicyBinding',
    'PolicyTargetQuery',
    'PolicyTargetQuerySpec',
    'PolicyTargetQuerySpecTerm',
    'SecretAws',
    'SecretAzureConnector',
    'SecretEcr',
    'SecretKeypair',
    'SecretNatsAccount',
    'SecretOpaque',
    'SecretTls',
    'SecretUserpass',
    'VolumeSetAutoscaling',
    'VolumeSetSnapshots',
    'VolumeSetStatus',
    'WorkloadContainer',
    'WorkloadContainerGpuNvidia',
    'WorkloadContainerLifecycle',
    'WorkloadContainerLifecyclePostStart',
    'WorkloadContainerLifecyclePostStartExec',
    'WorkloadContainerLifecyclePreStop',
    'WorkloadContainerLifecyclePreStopExec',
    'WorkloadContainerLivenessProbe',
    'WorkloadContainerLivenessProbeExec',
    'WorkloadContainerLivenessProbeGrpc',
    'WorkloadContainerLivenessProbeHttpGet',
    'WorkloadContainerLivenessProbeTcpSocket',
    'WorkloadContainerMetrics',
    'WorkloadContainerPort',
    'WorkloadContainerReadinessProbe',
    'WorkloadContainerReadinessProbeExec',
    'WorkloadContainerReadinessProbeGrpc',
    'WorkloadContainerReadinessProbeHttpGet',
    'WorkloadContainerReadinessProbeTcpSocket',
    'WorkloadContainerVolume',
    'WorkloadFirewallSpec',
    'WorkloadFirewallSpecExternal',
    'WorkloadFirewallSpecExternalOutboundAllowPort',
    'WorkloadFirewallSpecInternal',
    'WorkloadJob',
    'WorkloadLoadBalancer',
    'WorkloadLoadBalancerDirect',
    'WorkloadLoadBalancerDirectPort',
    'WorkloadLoadBalancerGeoLocation',
    'WorkloadLoadBalancerGeoLocationHeaders',
    'WorkloadLocalOption',
    'WorkloadLocalOptionAutoscaling',
    'WorkloadLocalOptionAutoscalingMulti',
    'WorkloadOptions',
    'WorkloadOptionsAutoscaling',
    'WorkloadOptionsAutoscalingMulti',
    'WorkloadRolloutOptions',
    'WorkloadSecurityOptions',
    'WorkloadSidecar',
    'WorkloadStatus',
    'WorkloadStatusHealthCheck',
    'WorkloadStatusLoadBalancer',
    'WorkloadStatusResolvedImage',
    'WorkloadStatusResolvedImageImage',
    'WorkloadStatusResolvedImageImageManifest',
    'GetGvcControlplaneTracingResult',
    'GetGvcLightstepTracingResult',
    'GetGvcLoadBalancerResult',
    'GetGvcLoadBalancerRedirectResult',
    'GetGvcLoadBalancerRedirectClassResult',
    'GetGvcOtelTracingResult',
    'GetGvcSidecarResult',
    'GetImageManifestResult',
    'GetImageManifestConfigResult',
    'GetImageManifestLayerResult',
    'GetImagesImageResult',
    'GetImagesImageManifestResult',
    'GetImagesImageManifestConfigResult',
    'GetImagesImageManifestLayerResult',
    'GetImagesQueryResult',
    'GetImagesQuerySpecResult',
    'GetImagesQuerySpecTermResult',
    'GetLocationGeoResult',
    'GetLocationsLocationResult',
    'GetLocationsLocationGeoResult',
    'GetSecretAwsResult',
    'GetSecretAzureConnectorResult',
    'GetSecretEcrResult',
    'GetSecretKeypairResult',
    'GetSecretNatsAccountResult',
    'GetSecretOpaqueResult',
    'GetSecretTlsResult',
    'GetSecretUserpassResult',
]

@pulumi.output_type
class CloudAccountAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccountAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccountAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccountAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str):
        """
        :param str role_arn: Amazon Resource Name (ARN) Role.
        """
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        Amazon Resource Name (ARN) Role.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class CloudAccountAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretLink":
            suggest = "secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccountAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccountAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccountAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_link: str):
        """
        :param str secret_link: Full link to an Azure secret. (e.g., /org/ORG_NAME/secret/AZURE_SECRET).
        """
        pulumi.set(__self__, "secret_link", secret_link)

    @property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> str:
        """
        Full link to an Azure secret. (e.g., /org/ORG_NAME/secret/AZURE_SECRET).
        """
        return pulumi.get(self, "secret_link")


@pulumi.output_type
class CloudAccountGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccountGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccountGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccountGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str):
        """
        :param str project_id: GCP project ID. Obtained from the GCP cloud console.
        """
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        GCP project ID. Obtained from the GCP cloud console.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class CloudAccountNgs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretLink":
            suggest = "secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccountNgs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccountNgs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccountNgs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_link: str):
        """
        :param str secret_link: Full link to a NATS Account Secret secret. (e.g., /org/ORG_NAME/secret/NATS_ACCOUNT_SECRET).
        """
        pulumi.set(__self__, "secret_link", secret_link)

    @property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> str:
        """
        Full link to a NATS Account Secret secret. (e.g., /org/ORG_NAME/secret/NATS_ACCOUNT_SECRET).
        """
        return pulumi.get(self, "secret_link")


@pulumi.output_type
class DomainRouteHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRouteHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRouteHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRouteHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 request: Optional['outputs.DomainRouteHeadersRequest'] = None):
        """
        :param 'DomainRouteHeadersRequestArgs' request: Manipulates HTTP headers.
        """
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if request is not None:
            pulumi.set(__self__, "request", request)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DomainRouteHeadersRequest']:
        """
        Manipulates HTTP headers.
        """
        return pulumi.get(self, "request")


@pulumi.output_type
class DomainRouteHeadersRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRouteHeadersRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRouteHeadersRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRouteHeadersRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 set: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] set: Sets or overrides headers to all http requests for this route.
        """
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter
    def set(self) -> Optional[Mapping[str, str]]:
        """
        Sets or overrides headers to all http requests for this route.
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class DomainSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAllHosts":
            suggest = "accept_all_hosts"
        elif key == "dnsMode":
            suggest = "dns_mode"
        elif key == "gvcLink":
            suggest = "gvc_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ports: Sequence['outputs.DomainSpecPort'],
                 accept_all_hosts: Optional[bool] = None,
                 dns_mode: Optional[str] = None,
                 gvc_link: Optional[str] = None):
        """
        :param Sequence['DomainSpecPortArgs'] ports: Domain port specifications.
        :param bool accept_all_hosts: Allows domain to accept wildcards. The associated GVC must have dedicated load balancing enabled.
        :param str dns_mode: In `cname` dnsMode, Control Plane will configure workloads to accept traffic for the domain but will not manage DNS records for the domain. End users must configure CNAME records in their own DNS pointed to the canonical workload endpoint. Currently `cname` dnsMode requires that a TLS server certificate be configured when subdomain based routing is used. In `ns` dnsMode, Control Plane will manage the subdomains and create all necessary DNS records. End users configure NS records to forward DNS requests to the Control Plane managed DNS servers. Valid values: `cname`, `ns`. Default: `cname`.
        :param str gvc_link: This value is set to a target GVC (using a full link) for use by subdomain based routing. Each workload in the GVC will receive a subdomain in the form ${workload.name}.${domain.name}. **Do not include if path based routing is used.**
        """
        pulumi.set(__self__, "ports", ports)
        if accept_all_hosts is not None:
            pulumi.set(__self__, "accept_all_hosts", accept_all_hosts)
        if dns_mode is not None:
            pulumi.set(__self__, "dns_mode", dns_mode)
        if gvc_link is not None:
            pulumi.set(__self__, "gvc_link", gvc_link)

    @property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.DomainSpecPort']:
        """
        Domain port specifications.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="acceptAllHosts")
    def accept_all_hosts(self) -> Optional[bool]:
        """
        Allows domain to accept wildcards. The associated GVC must have dedicated load balancing enabled.
        """
        return pulumi.get(self, "accept_all_hosts")

    @property
    @pulumi.getter(name="dnsMode")
    def dns_mode(self) -> Optional[str]:
        """
        In `cname` dnsMode, Control Plane will configure workloads to accept traffic for the domain but will not manage DNS records for the domain. End users must configure CNAME records in their own DNS pointed to the canonical workload endpoint. Currently `cname` dnsMode requires that a TLS server certificate be configured when subdomain based routing is used. In `ns` dnsMode, Control Plane will manage the subdomains and create all necessary DNS records. End users configure NS records to forward DNS requests to the Control Plane managed DNS servers. Valid values: `cname`, `ns`. Default: `cname`.
        """
        return pulumi.get(self, "dns_mode")

    @property
    @pulumi.getter(name="gvcLink")
    def gvc_link(self) -> Optional[str]:
        """
        This value is set to a target GVC (using a full link) for use by subdomain based routing. Each workload in the GVC will receive a subdomain in the form ${workload.name}.${domain.name}. **Do not include if path based routing is used.**
        """
        return pulumi.get(self, "gvc_link")


@pulumi.output_type
class DomainSpecPort(dict):
    def __init__(__self__, *,
                 tls: 'outputs.DomainSpecPortTls',
                 cors: Optional['outputs.DomainSpecPortCors'] = None,
                 number: Optional[int] = None,
                 protocol: Optional[str] = None):
        """
        :param 'DomainSpecPortCorsArgs' cors: A security feature implemented by web browsers to allow resources on a web page to be requested from another domain outside the domain from which the resource originated.
        :param int number: Port to expose externally. Values: `80`, `443`. Default: `443`.
        :param str protocol: Allowed protocol. Valid values: `http`, `http2`, `tcp`. Default: `http2`.
        """
        pulumi.set(__self__, "tls", tls)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def tls(self) -> 'outputs.DomainSpecPortTls':
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.DomainSpecPortCors']:
        """
        A security feature implemented by web browsers to allow resources on a web page to be requested from another domain outside the domain from which the resource originated.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        """
        Port to expose externally. Values: `80`, `443`. Default: `443`.
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Allowed protocol. Valid values: `http`, `http2`, `tcp`. Default: `http2`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class DomainSpecPortCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpecPortCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpecPortCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpecPortCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[bool] = None,
                 allow_headers: Optional[Sequence[str]] = None,
                 allow_methods: Optional[Sequence[str]] = None,
                 allow_origins: Optional[Sequence['outputs.DomainSpecPortCorsAllowOrigin']] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age: Optional[str] = None):
        """
        :param bool allow_credentials: Determines whether the client-side code (typically running in a web browser) is allowed to include credentials (such as cookies, HTTP authentication, or client-side SSL certificates) in cross-origin requests.
        :param Sequence[str] allow_headers: Specifies the custom HTTP headers that are allowed in a cross-origin request to a specific resource.
        :param Sequence[str] allow_methods: Specifies the HTTP methods (such as `GET`, `POST`, `PUT`, `DELETE`, etc.) that are allowed for a cross-origin request to a specific resource.
        :param Sequence['DomainSpecPortCorsAllowOriginArgs'] allow_origins: Determines which origins are allowed to access a particular resource on a server from a web browser.
        :param Sequence[str] expose_headers: The HTTP headers that a server allows to be exposed to the client in response to a cross-origin request. These headers provide additional information about the server's capabilities or requirements, aiding in proper handling of the request by the client's browser or application.
        :param str max_age: Maximum amount of time that a preflight request result can be cached by the client browser. Input is expected as a duration string (i.e, 24h, 20m, etc.).
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        """
        Determines whether the client-side code (typically running in a web browser) is allowed to include credentials (such as cookies, HTTP authentication, or client-side SSL certificates) in cross-origin requests.
        """
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies the custom HTTP headers that are allowed in a cross-origin request to a specific resource.
        """
        return pulumi.get(self, "allow_headers")

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[str]]:
        """
        Specifies the HTTP methods (such as `GET`, `POST`, `PUT`, `DELETE`, etc.) that are allowed for a cross-origin request to a specific resource.
        """
        return pulumi.get(self, "allow_methods")

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence['outputs.DomainSpecPortCorsAllowOrigin']]:
        """
        Determines which origins are allowed to access a particular resource on a server from a web browser.
        """
        return pulumi.get(self, "allow_origins")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        """
        The HTTP headers that a server allows to be exposed to the client in response to a cross-origin request. These headers provide additional information about the server's capabilities or requirements, aiding in proper handling of the request by the client's browser or application.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[str]:
        """
        Maximum amount of time that a preflight request result can be cached by the client browser. Input is expected as a duration string (i.e, 24h, 20m, etc.).
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class DomainSpecPortCorsAllowOrigin(dict):
    def __init__(__self__, *,
                 exact: str):
        """
        :param str exact: Value of allowed origin.
        """
        pulumi.set(__self__, "exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> str:
        """
        Value of allowed origin.
        """
        return pulumi.get(self, "exact")


@pulumi.output_type
class DomainSpecPortTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cipherSuites":
            suggest = "cipher_suites"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "minProtocolVersion":
            suggest = "min_protocol_version"
        elif key == "serverCertificate":
            suggest = "server_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpecPortTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpecPortTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpecPortTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cipher_suites: Optional[Sequence[str]] = None,
                 client_certificate: Optional['outputs.DomainSpecPortTlsClientCertificate'] = None,
                 min_protocol_version: Optional[str] = None,
                 server_certificate: Optional['outputs.DomainSpecPortTlsServerCertificate'] = None):
        """
        :param Sequence[str] cipher_suites: Allowed cipher suites. Refer to the [Domain Reference](https://docs.controlplane.com/reference/domain#cipher-suites) for details.
        :param 'DomainSpecPortTlsClientCertificateArgs' client_certificate: The certificate authority PEM, stored as a TLS Secret, used to verify the authority of the client certificate. The only verification performed checks that the CN of the PEM matches the Domain (i.e., CN=*.DOMAIN).
        :param str min_protocol_version: Minimum TLS version to accept. Minimum is `1.0`. Default: `1.2`.
        :param 'DomainSpecPortTlsServerCertificateArgs' server_certificate: Custom Server Certificate.
        """
        if cipher_suites is not None:
            pulumi.set(__self__, "cipher_suites", cipher_suites)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if min_protocol_version is not None:
            pulumi.set(__self__, "min_protocol_version", min_protocol_version)
        if server_certificate is not None:
            pulumi.set(__self__, "server_certificate", server_certificate)

    @property
    @pulumi.getter(name="cipherSuites")
    def cipher_suites(self) -> Optional[Sequence[str]]:
        """
        Allowed cipher suites. Refer to the [Domain Reference](https://docs.controlplane.com/reference/domain#cipher-suites) for details.
        """
        return pulumi.get(self, "cipher_suites")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional['outputs.DomainSpecPortTlsClientCertificate']:
        """
        The certificate authority PEM, stored as a TLS Secret, used to verify the authority of the client certificate. The only verification performed checks that the CN of the PEM matches the Domain (i.e., CN=*.DOMAIN).
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="minProtocolVersion")
    def min_protocol_version(self) -> Optional[str]:
        """
        Minimum TLS version to accept. Minimum is `1.0`. Default: `1.2`.
        """
        return pulumi.get(self, "min_protocol_version")

    @property
    @pulumi.getter(name="serverCertificate")
    def server_certificate(self) -> Optional['outputs.DomainSpecPortTlsServerCertificate']:
        """
        Custom Server Certificate.
        """
        return pulumi.get(self, "server_certificate")


@pulumi.output_type
class DomainSpecPortTlsClientCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretLink":
            suggest = "secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpecPortTlsClientCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpecPortTlsClientCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpecPortTlsClientCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_link: Optional[str] = None):
        """
        :param str secret_link: Full link to a TLS secret.
        """
        if secret_link is not None:
            pulumi.set(__self__, "secret_link", secret_link)

    @property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> Optional[str]:
        """
        Full link to a TLS secret.
        """
        return pulumi.get(self, "secret_link")


@pulumi.output_type
class DomainSpecPortTlsServerCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretLink":
            suggest = "secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpecPortTlsServerCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpecPortTlsServerCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpecPortTlsServerCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_link: Optional[str] = None):
        """
        :param str secret_link: Full link to a TLS secret.
        """
        if secret_link is not None:
            pulumi.set(__self__, "secret_link", secret_link)

    @property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> Optional[str]:
        """
        Full link to a TLS secret.
        """
        return pulumi.get(self, "secret_link")


@pulumi.output_type
class DomainStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsConfigs":
            suggest = "dns_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_configs: Optional[Sequence['outputs.DomainStatusDnsConfig']] = None,
                 endpoints: Optional[Sequence['outputs.DomainStatusEndpoint']] = None,
                 fingerprint: Optional[str] = None,
                 locations: Optional[Sequence['outputs.DomainStatusLocation']] = None,
                 status: Optional[str] = None,
                 warning: Optional[str] = None):
        """
        :param Sequence['DomainStatusDnsConfigArgs'] dns_configs: List of required DNS record entries.
        :param Sequence['DomainStatusEndpointArgs'] endpoints: List of configured domain endpoints.
        :param Sequence['DomainStatusLocationArgs'] locations: Contains the cloud provider name, region, and certificate status.
        :param str status: Status of Domain. Possible values: `initializing`, `ready`, `pendingDnsConfig`, `pendingCertificate`, `usedByGvc`.
        :param str warning: Warning message.
        """
        if dns_configs is not None:
            pulumi.set(__self__, "dns_configs", dns_configs)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter(name="dnsConfigs")
    def dns_configs(self) -> Optional[Sequence['outputs.DomainStatusDnsConfig']]:
        """
        List of required DNS record entries.
        """
        return pulumi.get(self, "dns_configs")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.DomainStatusEndpoint']]:
        """
        List of configured domain endpoints.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[str]:
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.DomainStatusLocation']]:
        """
        Contains the cloud provider name, region, and certificate status.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of Domain. Possible values: `initializing`, `ready`, `pendingDnsConfig`, `pendingCertificate`, `usedByGvc`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def warning(self) -> Optional[str]:
        """
        Warning message.
        """
        return pulumi.get(self, "warning")


@pulumi.output_type
class DomainStatusDnsConfig(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 ttl: Optional[int] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str host: The host in DNS terminology refers to the domain or subdomain that the DNS record is associated with. It's essentially the name that is being queried or managed. For example, in a DNS record for `www.example.com`, `www` is a host in the domain `example.com`.
        :param int ttl: Time to live (TTL) is a value that signifies how long (in seconds) a DNS record should be cached by a resolver or a browser before a new request should be sent to refresh the data. Lower TTL values mean records are updated more frequently, which is beneficial for dynamic DNS configurations or during DNS migrations. Higher TTL values reduce the load on DNS servers and improve the speed of name resolution for end users by relying on cached data.
        :param str type: The DNS record type specifies the type of data the DNS record contains. Valid values: `CNAME`, `NS`, `TXT`.
        :param str value: The value of a DNS record contains the data the record is meant to convey, based on the type of the record.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The host in DNS terminology refers to the domain or subdomain that the DNS record is associated with. It's essentially the name that is being queried or managed. For example, in a DNS record for `www.example.com`, `www` is a host in the domain `example.com`.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        Time to live (TTL) is a value that signifies how long (in seconds) a DNS record should be cached by a resolver or a browser before a new request should be sent to refresh the data. Lower TTL values mean records are updated more frequently, which is beneficial for dynamic DNS configurations or during DNS migrations. Higher TTL values reduce the load on DNS servers and improve the speed of name resolution for end users by relying on cached data.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The DNS record type specifies the type of data the DNS record contains. Valid values: `CNAME`, `NS`, `TXT`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of a DNS record contains the data the record is meant to convey, based on the type of the record.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainStatusEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workloadLink":
            suggest = "workload_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainStatusEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainStatusEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainStatusEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: Optional[str] = None,
                 workload_link: Optional[str] = None):
        """
        :param str url: URL of endpoint.
        :param str workload_link: Full link to associated workload.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)
        if workload_link is not None:
            pulumi.set(__self__, "workload_link", workload_link)

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        URL of endpoint.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="workloadLink")
    def workload_link(self) -> Optional[str]:
        """
        Full link to associated workload.
        """
        return pulumi.get(self, "workload_link")


@pulumi.output_type
class DomainStatusLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateStatus":
            suggest = "certificate_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainStatusLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainStatusLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainStatusLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_status: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str certificate_status: The current validity or status of the SSL/TLS certificate.
        :param str name: The name of the location.
        """
        if certificate_status is not None:
            pulumi.set(__self__, "certificate_status", certificate_status)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="certificateStatus")
    def certificate_status(self) -> Optional[str]:
        """
        The current validity or status of the SSL/TLS certificate.
        """
        return pulumi.get(self, "certificate_status")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the location.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GroupIdentityMatcher(dict):
    def __init__(__self__, *,
                 expression: str,
                 language: Optional[str] = None):
        """
        :param str expression: Executes the expression against the users' claims to decide whether a user belongs to this group. This method is useful for managing the grouping of users logged in with SAML providers.
        :param str language: Language of the expression. Either `jmespath` or `javascript`. Default: `jmespath`.
        """
        pulumi.set(__self__, "expression", expression)
        if language is not None:
            pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Executes the expression against the users' claims to decide whether a user belongs to this group. This method is useful for managing the grouping of users logged in with SAML providers.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def language(self) -> Optional[str]:
        """
        Language of the expression. Either `jmespath` or `javascript`. Default: `jmespath`.
        """
        return pulumi.get(self, "language")


@pulumi.output_type
class GroupMemberQuery(dict):
    def __init__(__self__, *,
                 fetch: Optional[str] = None,
                 spec: Optional['outputs.GroupMemberQuerySpec'] = None):
        """
        :param str fetch: Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        if fetch is not None:
            pulumi.set(__self__, "fetch", fetch)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def fetch(self) -> Optional[str]:
        """
        Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        return pulumi.get(self, "fetch")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.GroupMemberQuerySpec']:
        return pulumi.get(self, "spec")


@pulumi.output_type
class GroupMemberQuerySpec(dict):
    def __init__(__self__, *,
                 match: Optional[str] = None,
                 terms: Optional[Sequence['outputs.GroupMemberQuerySpecTerm']] = None):
        """
        :param str match: Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        :param Sequence['GroupMemberQuerySpecTermArgs'] terms: Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if terms is not None:
            pulumi.set(__self__, "terms", terms)

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def terms(self) -> Optional[Sequence['outputs.GroupMemberQuerySpecTerm']]:
        """
        Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
        return pulumi.get(self, "terms")


@pulumi.output_type
class GroupMemberQuerySpecTerm(dict):
    def __init__(__self__, *,
                 op: Optional[str] = None,
                 property: Optional[str] = None,
                 rel: Optional[str] = None,
                 tag: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str op: Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        :param str property: Property to use for query evaluation.
        :param str tag: Tag key to use for query evaluation.
        :param str value: Testing value for query evaluation.
        """
        if op is not None:
            pulumi.set(__self__, "op", op)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        """
        Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def rel(self) -> Optional[str]:
        return pulumi.get(self, "rel")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Tag key to use for query evaluation.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Testing value for query evaluation.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        Property to use for query evaluation.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class GvcControlplaneTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcControlplaneTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcControlplaneTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcControlplaneTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling: float,
                 custom_tags: Optional[Mapping[str, str]] = None):
        """
        :param float sampling: Determines what percentage of requests should be traced.
        :param Mapping[str, str] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "sampling", sampling)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter
    def sampling(self) -> float:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GvcLightstepTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcLightstepTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcLightstepTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcLightstepTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 sampling: float,
                 credentials: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None):
        """
        :param str endpoint: Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        :param float sampling: Determines what percentage of requests should be traced.
        :param str credentials: Full link to referenced Opaque Secret.
        :param Mapping[str, str] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "sampling", sampling)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> float:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def credentials(self) -> Optional[str]:
        """
        Full link to referenced Opaque Secret.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GvcLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedProxies":
            suggest = "trusted_proxies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dedicated: Optional[bool] = None,
                 redirect: Optional['outputs.GvcLoadBalancerRedirect'] = None,
                 trusted_proxies: Optional[int] = None):
        """
        :param bool dedicated: Creates a dedicated load balancer in each location and enables additional Domain features: custom ports, protocols and wildcard hostnames. Charges apply for each location.
        :param 'GvcLoadBalancerRedirectArgs' redirect: Specify the url to be redirected to for different http status codes.
        :param int trusted_proxies: Controls the address used for request logging and for setting the X-Envoy-External-Address header. If set to 1, then the last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If set to 2, then the second to last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If the XFF header does not have at least two addresses or does not exist then the source client IP address will be used instead.
        """
        if dedicated is not None:
            pulumi.set(__self__, "dedicated", dedicated)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if trusted_proxies is not None:
            pulumi.set(__self__, "trusted_proxies", trusted_proxies)

    @property
    @pulumi.getter
    def dedicated(self) -> Optional[bool]:
        """
        Creates a dedicated load balancer in each location and enables additional Domain features: custom ports, protocols and wildcard hostnames. Charges apply for each location.
        """
        return pulumi.get(self, "dedicated")

    @property
    @pulumi.getter
    def redirect(self) -> Optional['outputs.GvcLoadBalancerRedirect']:
        """
        Specify the url to be redirected to for different http status codes.
        """
        return pulumi.get(self, "redirect")

    @property
    @pulumi.getter(name="trustedProxies")
    def trusted_proxies(self) -> Optional[int]:
        """
        Controls the address used for request logging and for setting the X-Envoy-External-Address header. If set to 1, then the last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If set to 2, then the second to last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If the XFF header does not have at least two addresses or does not exist then the source client IP address will be used instead.
        """
        return pulumi.get(self, "trusted_proxies")


@pulumi.output_type
class GvcLoadBalancerRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "class":
            suggest = "class_"
        elif key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcLoadBalancerRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcLoadBalancerRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcLoadBalancerRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 class_: Optional['outputs.GvcLoadBalancerRedirectClass'] = None,
                 placeholder_attribute: Optional[bool] = None):
        """
        :param 'GvcLoadBalancerRedirectClassArgs' class_: Specify the redirect url for all status codes in a class.
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional['outputs.GvcLoadBalancerRedirectClass']:
        """
        Specify the redirect url for all status codes in a class.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")


@pulumi.output_type
class GvcLoadBalancerRedirectClass(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcLoadBalancerRedirectClass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcLoadBalancerRedirectClass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcLoadBalancerRedirectClass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 status5xx: Optional[str] = None):
        """
        :param str status5xx: Specify the redirect url for any 500 level status code.
        """
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if status5xx is not None:
            pulumi.set(__self__, "status5xx", status5xx)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter
    def status5xx(self) -> Optional[str]:
        """
        Specify the redirect url for any 500 level status code.
        """
        return pulumi.get(self, "status5xx")


@pulumi.output_type
class GvcOtelTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcOtelTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcOtelTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcOtelTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 sampling: float,
                 custom_tags: Optional[Mapping[str, str]] = None):
        """
        :param str endpoint: Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        :param float sampling: Determines what percentage of requests should be traced.
        :param Mapping[str, str] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "sampling", sampling)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> float:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GvcSidecar(dict):
    def __init__(__self__, *,
                 envoy: str):
        pulumi.set(__self__, "envoy", envoy)

    @property
    @pulumi.getter
    def envoy(self) -> str:
        return pulumi.get(self, "envoy")


@pulumi.output_type
class IdentityAwsAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountLink":
            suggest = "cloud_account_link"
        elif key == "policyRefs":
            suggest = "policy_refs"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityAwsAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityAwsAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityAwsAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_account_link: str,
                 policy_refs: Optional[Sequence[str]] = None,
                 role_name: Optional[str] = None):
        """
        :param str cloud_account_link: Full link to referenced cloud account.
        :param Sequence[str] policy_refs: List of policies.
        :param str role_name: Role name.
        """
        pulumi.set(__self__, "cloud_account_link", cloud_account_link)
        if policy_refs is not None:
            pulumi.set(__self__, "policy_refs", policy_refs)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> str:
        """
        Full link to referenced cloud account.
        """
        return pulumi.get(self, "cloud_account_link")

    @property
    @pulumi.getter(name="policyRefs")
    def policy_refs(self) -> Optional[Sequence[str]]:
        """
        List of policies.
        """
        return pulumi.get(self, "policy_refs")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[str]:
        """
        Role name.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class IdentityAzureAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountLink":
            suggest = "cloud_account_link"
        elif key == "roleAssignments":
            suggest = "role_assignments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityAzureAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityAzureAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityAzureAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_account_link: str,
                 role_assignments: Optional[Sequence['outputs.IdentityAzureAccessPolicyRoleAssignment']] = None):
        """
        :param str cloud_account_link: Full link to referenced cloud account.
        :param Sequence['IdentityAzureAccessPolicyRoleAssignmentArgs'] role_assignments: The process of assigning specific roles or permissions to an entity, such as a user or a service principal, within the system.
        """
        pulumi.set(__self__, "cloud_account_link", cloud_account_link)
        if role_assignments is not None:
            pulumi.set(__self__, "role_assignments", role_assignments)

    @property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> str:
        """
        Full link to referenced cloud account.
        """
        return pulumi.get(self, "cloud_account_link")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Optional[Sequence['outputs.IdentityAzureAccessPolicyRoleAssignment']]:
        """
        The process of assigning specific roles or permissions to an entity, such as a user or a service principal, within the system.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class IdentityAzureAccessPolicyRoleAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityAzureAccessPolicyRoleAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityAzureAccessPolicyRoleAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityAzureAccessPolicyRoleAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 roles: Optional[Sequence[str]] = None,
                 scope: Optional[str] = None):
        """
        :param Sequence[str] roles: List of assigned roles.
        :param str scope: Scope of roles.
        """
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        List of assigned roles.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        Scope of roles.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class IdentityGcpAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountLink":
            suggest = "cloud_account_link"
        elif key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityGcpAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityGcpAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityGcpAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_account_link: str,
                 bindings: Optional[Sequence['outputs.IdentityGcpAccessPolicyBinding']] = None,
                 scopes: Optional[str] = None,
                 service_account: Optional[str] = None):
        """
        :param str cloud_account_link: Full link to referenced cloud account.
        :param Sequence['IdentityGcpAccessPolicyBindingArgs'] bindings: The association or connection between a particular identity, such as a user or a group, and a set of permissions or roles within the system.
        :param str scopes: Comma delimited list of GCP scope URLs.
        :param str service_account: Name of existing GCP service account.
        """
        pulumi.set(__self__, "cloud_account_link", cloud_account_link)
        if bindings is not None:
            pulumi.set(__self__, "bindings", bindings)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> str:
        """
        Full link to referenced cloud account.
        """
        return pulumi.get(self, "cloud_account_link")

    @property
    @pulumi.getter
    def bindings(self) -> Optional[Sequence['outputs.IdentityGcpAccessPolicyBinding']]:
        """
        The association or connection between a particular identity, such as a user or a group, and a set of permissions or roles within the system.
        """
        return pulumi.get(self, "bindings")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[str]:
        """
        Comma delimited list of GCP scope URLs.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[str]:
        """
        Name of existing GCP service account.
        """
        return pulumi.get(self, "service_account")


@pulumi.output_type
class IdentityGcpAccessPolicyBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityGcpAccessPolicyBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityGcpAccessPolicyBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityGcpAccessPolicyBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 resource: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str resource: Name of resource for binding.
        :param Sequence[str] roles: List of allowed roles.
        """
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        Name of resource for binding.
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        List of allowed roles.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class IdentityNativeNetworkResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsPrivateLink":
            suggest = "aws_private_link"
        elif key == "gcpServiceConnect":
            suggest = "gcp_service_connect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNativeNetworkResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNativeNetworkResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNativeNetworkResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: str,
                 name: str,
                 ports: Sequence[int],
                 aws_private_link: Optional['outputs.IdentityNativeNetworkResourceAwsPrivateLink'] = None,
                 gcp_service_connect: Optional['outputs.IdentityNativeNetworkResourceGcpServiceConnect'] = None):
        """
        :param str fqdn: Fully qualified domain name.
        :param str name: Name of the Native Network Resource.
        :param Sequence[int] ports: Ports to expose. At least one port is required.
        :param 'IdentityNativeNetworkResourceAwsPrivateLinkArgs' aws_private_link: A feature provided by AWS that enables private connectivity between private VPCs and compute running at Control Plane without traversing the public internet.
        :param 'IdentityNativeNetworkResourceGcpServiceConnectArgs' gcp_service_connect: Capability provided by GCP that allows private communication between private VPC networks and compute running at Control Plane.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ports", ports)
        if aws_private_link is not None:
            pulumi.set(__self__, "aws_private_link", aws_private_link)
        if gcp_service_connect is not None:
            pulumi.set(__self__, "gcp_service_connect", gcp_service_connect)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        Fully qualified domain name.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Native Network Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        Ports to expose. At least one port is required.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Optional['outputs.IdentityNativeNetworkResourceAwsPrivateLink']:
        """
        A feature provided by AWS that enables private connectivity between private VPCs and compute running at Control Plane without traversing the public internet.
        """
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="gcpServiceConnect")
    def gcp_service_connect(self) -> Optional['outputs.IdentityNativeNetworkResourceGcpServiceConnect']:
        """
        Capability provided by GCP that allows private communication between private VPC networks and compute running at Control Plane.
        """
        return pulumi.get(self, "gcp_service_connect")


@pulumi.output_type
class IdentityNativeNetworkResourceAwsPrivateLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointServiceName":
            suggest = "endpoint_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNativeNetworkResourceAwsPrivateLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNativeNetworkResourceAwsPrivateLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNativeNetworkResourceAwsPrivateLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_service_name: str):
        """
        :param str endpoint_service_name: Endpoint service name.
        """
        pulumi.set(__self__, "endpoint_service_name", endpoint_service_name)

    @property
    @pulumi.getter(name="endpointServiceName")
    def endpoint_service_name(self) -> str:
        """
        Endpoint service name.
        """
        return pulumi.get(self, "endpoint_service_name")


@pulumi.output_type
class IdentityNativeNetworkResourceGcpServiceConnect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetService":
            suggest = "target_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNativeNetworkResourceGcpServiceConnect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNativeNetworkResourceGcpServiceConnect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNativeNetworkResourceGcpServiceConnect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_service: str):
        """
        :param str target_service: Target service name.
        """
        pulumi.set(__self__, "target_service", target_service)

    @property
    @pulumi.getter(name="targetService")
    def target_service(self) -> str:
        """
        Target service name.
        """
        return pulumi.get(self, "target_service")


@pulumi.output_type
class IdentityNetworkResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentLink":
            suggest = "agent_link"
        elif key == "resolverIp":
            suggest = "resolver_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNetworkResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNetworkResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNetworkResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 ports: Sequence[int],
                 agent_link: Optional[str] = None,
                 fqdn: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 resolver_ip: Optional[str] = None):
        """
        :param str name: Name of the Network Resource.
        :param Sequence[int] ports: Ports to expose.
        :param str agent_link: Full link to referenced Agent.
        :param str fqdn: Fully qualified domain name.
        :param Sequence[str] ips: List of IP addresses.
        :param str resolver_ip: Resolver IP.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ports", ports)
        if agent_link is not None:
            pulumi.set(__self__, "agent_link", agent_link)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if resolver_ip is not None:
            pulumi.set(__self__, "resolver_ip", resolver_ip)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Network Resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        Ports to expose.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="agentLink")
    def agent_link(self) -> Optional[str]:
        """
        Full link to referenced Agent.
        """
        return pulumi.get(self, "agent_link")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        Fully qualified domain name.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        """
        List of IP addresses.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="resolverIp")
    def resolver_ip(self) -> Optional[str]:
        """
        Resolver IP.
        """
        return pulumi.get(self, "resolver_ip")


@pulumi.output_type
class IdentityNgsAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountLink":
            suggest = "cloud_account_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNgsAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNgsAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNgsAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_account_link: str,
                 data: Optional[int] = None,
                 payload: Optional[int] = None,
                 pub: Optional['outputs.IdentityNgsAccessPolicyPub'] = None,
                 resp: Optional['outputs.IdentityNgsAccessPolicyResp'] = None,
                 sub: Optional['outputs.IdentityNgsAccessPolicySub'] = None,
                 subs: Optional[int] = None):
        """
        :param str cloud_account_link: Full link to referenced cloud account.
        :param int data: Max number of bytes a connection can send. Default: -1
        :param int payload: Max message payload. Default: -1
        :param 'IdentityNgsAccessPolicyPubArgs' pub: Pub Permission.
        :param 'IdentityNgsAccessPolicyRespArgs' resp: Reponses.
        :param 'IdentityNgsAccessPolicySubArgs' sub: Sub Permission.
        :param int subs: Max number of subscriptions per connection. Default: -1
        """
        pulumi.set(__self__, "cloud_account_link", cloud_account_link)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if pub is not None:
            pulumi.set(__self__, "pub", pub)
        if resp is not None:
            pulumi.set(__self__, "resp", resp)
        if sub is not None:
            pulumi.set(__self__, "sub", sub)
        if subs is not None:
            pulumi.set(__self__, "subs", subs)

    @property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> str:
        """
        Full link to referenced cloud account.
        """
        return pulumi.get(self, "cloud_account_link")

    @property
    @pulumi.getter
    def data(self) -> Optional[int]:
        """
        Max number of bytes a connection can send. Default: -1
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def payload(self) -> Optional[int]:
        """
        Max message payload. Default: -1
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def pub(self) -> Optional['outputs.IdentityNgsAccessPolicyPub']:
        """
        Pub Permission.
        """
        return pulumi.get(self, "pub")

    @property
    @pulumi.getter
    def resp(self) -> Optional['outputs.IdentityNgsAccessPolicyResp']:
        """
        Reponses.
        """
        return pulumi.get(self, "resp")

    @property
    @pulumi.getter
    def sub(self) -> Optional['outputs.IdentityNgsAccessPolicySub']:
        """
        Sub Permission.
        """
        return pulumi.get(self, "sub")

    @property
    @pulumi.getter
    def subs(self) -> Optional[int]:
        """
        Max number of subscriptions per connection. Default: -1
        """
        return pulumi.get(self, "subs")


@pulumi.output_type
class IdentityNgsAccessPolicyPub(dict):
    def __init__(__self__, *,
                 allows: Optional[Sequence[str]] = None,
                 denies: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] allows: List of allow subjects.
        :param Sequence[str] denies: List of deny subjects.
        """
        if allows is not None:
            pulumi.set(__self__, "allows", allows)
        if denies is not None:
            pulumi.set(__self__, "denies", denies)

    @property
    @pulumi.getter
    def allows(self) -> Optional[Sequence[str]]:
        """
        List of allow subjects.
        """
        return pulumi.get(self, "allows")

    @property
    @pulumi.getter
    def denies(self) -> Optional[Sequence[str]]:
        """
        List of deny subjects.
        """
        return pulumi.get(self, "denies")


@pulumi.output_type
class IdentityNgsAccessPolicyResp(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 ttl: Optional[str] = None):
        """
        :param int max: Number of responses allowed on the replyTo subject, -1 means no limit. Default: -1
        :param str ttl: Deadline to send replies on the replyTo subject [#ms(millis) | #s(econds) | m(inutes) | h(ours)]. -1 means no restriction.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Number of responses allowed on the replyTo subject, -1 means no limit. Default: -1
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[str]:
        """
        Deadline to send replies on the replyTo subject [#ms(millis) | #s(econds) | m(inutes) | h(ours)]. -1 means no restriction.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class IdentityNgsAccessPolicySub(dict):
    def __init__(__self__, *,
                 allows: Optional[Sequence[str]] = None,
                 denies: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] allows: List of allow subjects.
        :param Sequence[str] denies: List of deny subjects.
        """
        if allows is not None:
            pulumi.set(__self__, "allows", allows)
        if denies is not None:
            pulumi.set(__self__, "denies", denies)

    @property
    @pulumi.getter
    def allows(self) -> Optional[Sequence[str]]:
        """
        List of allow subjects.
        """
        return pulumi.get(self, "allows")

    @property
    @pulumi.getter
    def denies(self) -> Optional[Sequence[str]]:
        """
        List of deny subjects.
        """
        return pulumi.get(self, "denies")


@pulumi.output_type
class IpSetLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionPolicy":
            suggest = "retention_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpSetLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpSetLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpSetLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 retention_policy: str):
        """
        :param str name: The self link of a location.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "retention_policy", retention_policy)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The self link of a location.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> str:
        return pulumi.get(self, "retention_policy")


@pulumi.output_type
class IpSetStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpSetStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpSetStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpSetStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: Optional[str] = None,
                 ip_addresses: Optional[Sequence['outputs.IpSetStatusIpAddress']] = None):
        if error is not None:
            pulumi.set(__self__, "error", error)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def error(self) -> Optional[str]:
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence['outputs.IpSetStatusIpAddress']]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class IpSetStatusIpAddress(dict):
    def __init__(__self__, *,
                 created: Optional[str] = None,
                 id: Optional[str] = None,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 state: Optional[str] = None):
        if created is not None:
            pulumi.set(__self__, "created", created)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def created(self) -> Optional[str]:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class LocationGeo(dict):
    def __init__(__self__, *,
                 city: Optional[str] = None,
                 continent: Optional[str] = None,
                 country: Optional[str] = None,
                 lat: Optional[float] = None,
                 lon: Optional[float] = None,
                 state: Optional[str] = None):
        """
        :param str city: City.
        :param str continent: Continent.
        :param str country: Country.
        :param float lat: Latitude.
        :param float lon: Longitude.
        :param str state: State.
        """
        if city is not None:
            pulumi.set(__self__, "city", city)
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lon is not None:
            pulumi.set(__self__, "lon", lon)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        """
        City.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def continent(self) -> Optional[str]:
        """
        Continent.
        """
        return pulumi.get(self, "continent")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        """
        Country.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def lat(self) -> Optional[float]:
        """
        Latitude.
        """
        return pulumi.get(self, "lat")

    @property
    @pulumi.getter
    def lon(self) -> Optional[float]:
        """
        Longitude.
        """
        return pulumi.get(self, "lon")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class Mk8sAddOns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsEcr":
            suggest = "aws_ecr"
        elif key == "awsEfs":
            suggest = "aws_efs"
        elif key == "awsElb":
            suggest = "aws_elb"
        elif key == "awsWorkloadIdentity":
            suggest = "aws_workload_identity"
        elif key == "azureAcr":
            suggest = "azure_acr"
        elif key == "azureWorkloadIdentity":
            suggest = "azure_workload_identity"
        elif key == "localPathStorage":
            suggest = "local_path_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_ecr: Optional['outputs.Mk8sAddOnsAwsEcr'] = None,
                 aws_efs: Optional['outputs.Mk8sAddOnsAwsEfs'] = None,
                 aws_elb: Optional['outputs.Mk8sAddOnsAwsElb'] = None,
                 aws_workload_identity: Optional[bool] = None,
                 azure_acr: Optional['outputs.Mk8sAddOnsAzureAcr'] = None,
                 azure_workload_identity: Optional['outputs.Mk8sAddOnsAzureWorkloadIdentity'] = None,
                 dashboard: Optional[bool] = None,
                 local_path_storage: Optional[bool] = None,
                 logs: Optional['outputs.Mk8sAddOnsLogs'] = None,
                 metrics: Optional['outputs.Mk8sAddOnsMetrics'] = None,
                 nvidia: Optional['outputs.Mk8sAddOnsNvidia'] = None,
                 sysbox: Optional[bool] = None):
        if aws_ecr is not None:
            pulumi.set(__self__, "aws_ecr", aws_ecr)
        if aws_efs is not None:
            pulumi.set(__self__, "aws_efs", aws_efs)
        if aws_elb is not None:
            pulumi.set(__self__, "aws_elb", aws_elb)
        if aws_workload_identity is not None:
            pulumi.set(__self__, "aws_workload_identity", aws_workload_identity)
        if azure_acr is not None:
            pulumi.set(__self__, "azure_acr", azure_acr)
        if azure_workload_identity is not None:
            pulumi.set(__self__, "azure_workload_identity", azure_workload_identity)
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if local_path_storage is not None:
            pulumi.set(__self__, "local_path_storage", local_path_storage)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if nvidia is not None:
            pulumi.set(__self__, "nvidia", nvidia)
        if sysbox is not None:
            pulumi.set(__self__, "sysbox", sysbox)

    @property
    @pulumi.getter(name="awsEcr")
    def aws_ecr(self) -> Optional['outputs.Mk8sAddOnsAwsEcr']:
        return pulumi.get(self, "aws_ecr")

    @property
    @pulumi.getter(name="awsEfs")
    def aws_efs(self) -> Optional['outputs.Mk8sAddOnsAwsEfs']:
        return pulumi.get(self, "aws_efs")

    @property
    @pulumi.getter(name="awsElb")
    def aws_elb(self) -> Optional['outputs.Mk8sAddOnsAwsElb']:
        return pulumi.get(self, "aws_elb")

    @property
    @pulumi.getter(name="awsWorkloadIdentity")
    def aws_workload_identity(self) -> Optional[bool]:
        return pulumi.get(self, "aws_workload_identity")

    @property
    @pulumi.getter(name="azureAcr")
    def azure_acr(self) -> Optional['outputs.Mk8sAddOnsAzureAcr']:
        return pulumi.get(self, "azure_acr")

    @property
    @pulumi.getter(name="azureWorkloadIdentity")
    def azure_workload_identity(self) -> Optional['outputs.Mk8sAddOnsAzureWorkloadIdentity']:
        return pulumi.get(self, "azure_workload_identity")

    @property
    @pulumi.getter
    def dashboard(self) -> Optional[bool]:
        return pulumi.get(self, "dashboard")

    @property
    @pulumi.getter(name="localPathStorage")
    def local_path_storage(self) -> Optional[bool]:
        return pulumi.get(self, "local_path_storage")

    @property
    @pulumi.getter
    def logs(self) -> Optional['outputs.Mk8sAddOnsLogs']:
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def metrics(self) -> Optional['outputs.Mk8sAddOnsMetrics']:
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def nvidia(self) -> Optional['outputs.Mk8sAddOnsNvidia']:
        return pulumi.get(self, "nvidia")

    @property
    @pulumi.getter
    def sysbox(self) -> Optional[bool]:
        return pulumi.get(self, "sysbox")


@pulumi.output_type
class Mk8sAddOnsAwsEcr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsAwsEcr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsAwsEcr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsAwsEcr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 role_arn: Optional[str] = None):
        """
        :param str role_arn: Role to use when authorizing ECR pulls. Optional on AWS, in which case it will use the instance role to pull.
        """
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Role to use when authorizing ECR pulls. Optional on AWS, in which case it will use the instance role to pull.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class Mk8sAddOnsAwsEfs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsAwsEfs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsAwsEfs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsAwsEfs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 role_arn: Optional[str] = None):
        """
        :param str role_arn: Use this role for EFS interaction.
        """
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Use this role for EFS interaction.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class Mk8sAddOnsAwsElb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsAwsElb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsAwsElb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsAwsElb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 role_arn: Optional[str] = None):
        """
        :param str role_arn: Role to use when authorizing calls to EC2 ELB. Optional on AWS, when not provided it will create the recommended role.
        """
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Role to use when authorizing calls to EC2 ELB. Optional on AWS, when not provided it will create the recommended role.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class Mk8sAddOnsAzureAcr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsAzureAcr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsAzureAcr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsAzureAcr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str):
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        return pulumi.get(self, "client_id")


@pulumi.output_type
class Mk8sAddOnsAzureWorkloadIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsAzureWorkloadIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsAzureWorkloadIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsAzureWorkloadIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str tenant_id: Tenant ID to use for workload identity.
        """
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        Tenant ID to use for workload identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class Mk8sAddOnsLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditEnabled":
            suggest = "audit_enabled"
        elif key == "excludeNamespaces":
            suggest = "exclude_namespaces"
        elif key == "includeNamespaces":
            suggest = "include_namespaces"
        elif key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit_enabled: Optional[bool] = None,
                 exclude_namespaces: Optional[str] = None,
                 include_namespaces: Optional[str] = None,
                 placeholder_attribute: Optional[bool] = None):
        """
        :param bool audit_enabled: Collect k8s audit log as log events.
        """
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if exclude_namespaces is not None:
            pulumi.set(__self__, "exclude_namespaces", exclude_namespaces)
        if include_namespaces is not None:
            pulumi.set(__self__, "include_namespaces", include_namespaces)
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)

    @property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[bool]:
        """
        Collect k8s audit log as log events.
        """
        return pulumi.get(self, "audit_enabled")

    @property
    @pulumi.getter(name="excludeNamespaces")
    def exclude_namespaces(self) -> Optional[str]:
        return pulumi.get(self, "exclude_namespaces")

    @property
    @pulumi.getter(name="includeNamespaces")
    def include_namespaces(self) -> Optional[str]:
        return pulumi.get(self, "include_namespaces")

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")


@pulumi.output_type
class Mk8sAddOnsMetrics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiServer":
            suggest = "api_server"
        elif key == "coreDns":
            suggest = "core_dns"
        elif key == "kubeState":
            suggest = "kube_state"
        elif key == "nodeExporter":
            suggest = "node_exporter"
        elif key == "placeholderAttribute":
            suggest = "placeholder_attribute"
        elif key == "scrapeAnnotated":
            suggest = "scrape_annotated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsMetrics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsMetrics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsMetrics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_server: Optional[bool] = None,
                 cadvisor: Optional[bool] = None,
                 core_dns: Optional[bool] = None,
                 kube_state: Optional[bool] = None,
                 kubelet: Optional[bool] = None,
                 node_exporter: Optional[bool] = None,
                 placeholder_attribute: Optional[bool] = None,
                 scrape_annotated: Optional['outputs.Mk8sAddOnsMetricsScrapeAnnotated'] = None):
        """
        :param bool api_server: Enable scraping apiserver stats.
        :param bool cadvisor: Enable CNI-level container stats.
        :param bool core_dns: Enable scraping of core-dns service.
        :param bool kube_state: Enable kube-state metrics.
        :param bool kubelet: Enable scraping kubelet stats.
        :param bool node_exporter: Enable collecting node-level stats (disk, network, filesystem, etc).
        :param 'Mk8sAddOnsMetricsScrapeAnnotatedArgs' scrape_annotated: Scrape pods annotated with prometheus.io/scrape=true.
        """
        if api_server is not None:
            pulumi.set(__self__, "api_server", api_server)
        if cadvisor is not None:
            pulumi.set(__self__, "cadvisor", cadvisor)
        if core_dns is not None:
            pulumi.set(__self__, "core_dns", core_dns)
        if kube_state is not None:
            pulumi.set(__self__, "kube_state", kube_state)
        if kubelet is not None:
            pulumi.set(__self__, "kubelet", kubelet)
        if node_exporter is not None:
            pulumi.set(__self__, "node_exporter", node_exporter)
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if scrape_annotated is not None:
            pulumi.set(__self__, "scrape_annotated", scrape_annotated)

    @property
    @pulumi.getter(name="apiServer")
    def api_server(self) -> Optional[bool]:
        """
        Enable scraping apiserver stats.
        """
        return pulumi.get(self, "api_server")

    @property
    @pulumi.getter
    def cadvisor(self) -> Optional[bool]:
        """
        Enable CNI-level container stats.
        """
        return pulumi.get(self, "cadvisor")

    @property
    @pulumi.getter(name="coreDns")
    def core_dns(self) -> Optional[bool]:
        """
        Enable scraping of core-dns service.
        """
        return pulumi.get(self, "core_dns")

    @property
    @pulumi.getter(name="kubeState")
    def kube_state(self) -> Optional[bool]:
        """
        Enable kube-state metrics.
        """
        return pulumi.get(self, "kube_state")

    @property
    @pulumi.getter
    def kubelet(self) -> Optional[bool]:
        """
        Enable scraping kubelet stats.
        """
        return pulumi.get(self, "kubelet")

    @property
    @pulumi.getter(name="nodeExporter")
    def node_exporter(self) -> Optional[bool]:
        """
        Enable collecting node-level stats (disk, network, filesystem, etc).
        """
        return pulumi.get(self, "node_exporter")

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter(name="scrapeAnnotated")
    def scrape_annotated(self) -> Optional['outputs.Mk8sAddOnsMetricsScrapeAnnotated']:
        """
        Scrape pods annotated with prometheus.io/scrape=true.
        """
        return pulumi.get(self, "scrape_annotated")


@pulumi.output_type
class Mk8sAddOnsMetricsScrapeAnnotated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeNamespaces":
            suggest = "exclude_namespaces"
        elif key == "includeNamespaces":
            suggest = "include_namespaces"
        elif key == "intervalSeconds":
            suggest = "interval_seconds"
        elif key == "placeholderAttribute":
            suggest = "placeholder_attribute"
        elif key == "retainLabels":
            suggest = "retain_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsMetricsScrapeAnnotated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsMetricsScrapeAnnotated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsMetricsScrapeAnnotated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_namespaces: Optional[str] = None,
                 include_namespaces: Optional[str] = None,
                 interval_seconds: Optional[int] = None,
                 placeholder_attribute: Optional[bool] = None,
                 retain_labels: Optional[str] = None):
        if exclude_namespaces is not None:
            pulumi.set(__self__, "exclude_namespaces", exclude_namespaces)
        if include_namespaces is not None:
            pulumi.set(__self__, "include_namespaces", include_namespaces)
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if retain_labels is not None:
            pulumi.set(__self__, "retain_labels", retain_labels)

    @property
    @pulumi.getter(name="excludeNamespaces")
    def exclude_namespaces(self) -> Optional[str]:
        return pulumi.get(self, "exclude_namespaces")

    @property
    @pulumi.getter(name="includeNamespaces")
    def include_namespaces(self) -> Optional[str]:
        return pulumi.get(self, "include_namespaces")

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[int]:
        return pulumi.get(self, "interval_seconds")

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter(name="retainLabels")
    def retain_labels(self) -> Optional[str]:
        return pulumi.get(self, "retain_labels")


@pulumi.output_type
class Mk8sAddOnsNvidia(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"
        elif key == "taintGpuNodes":
            suggest = "taint_gpu_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsNvidia. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsNvidia.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsNvidia.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 taint_gpu_nodes: Optional[bool] = None):
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if taint_gpu_nodes is not None:
            pulumi.set(__self__, "taint_gpu_nodes", taint_gpu_nodes)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter(name="taintGpuNodes")
    def taint_gpu_nodes(self) -> Optional[bool]:
        return pulumi.get(self, "taint_gpu_nodes")


@pulumi.output_type
class Mk8sAwsProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployRoleArn":
            suggest = "deploy_role_arn"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "deployRoleChains":
            suggest = "deploy_role_chains"
        elif key == "diskEncryptionKeyArn":
            suggest = "disk_encryption_key_arn"
        elif key == "extraNodePolicies":
            suggest = "extra_node_policies"
        elif key == "keyPair":
            suggest = "key_pair"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "skipCreateRoles":
            suggest = "skip_create_roles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAwsProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAwsProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAwsProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deploy_role_arn: str,
                 image: 'outputs.Mk8sAwsProviderImage',
                 networking: 'outputs.Mk8sAwsProviderNetworking',
                 region: str,
                 vpc_id: str,
                 autoscaler: Optional['outputs.Mk8sAwsProviderAutoscaler'] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 deploy_role_chains: Optional[Sequence['outputs.Mk8sAwsProviderDeployRoleChain']] = None,
                 disk_encryption_key_arn: Optional[str] = None,
                 extra_node_policies: Optional[Sequence[str]] = None,
                 key_pair: Optional[str] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sAwsProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 skip_create_roles: Optional[bool] = None):
        """
        :param str deploy_role_arn: Control Plane will set up the cluster by assuming this role.
        :param 'Mk8sAwsProviderImageArgs' image: Default image for all nodes.
        :param str region: Region where the cluster nodes will live.
        :param str vpc_id: The vpc where nodes will be deployed. Supports SSM.
        :param Mapping[str, str] aws_tags: Extra tags to attach to all created objects.
        :param str disk_encryption_key_arn: KMS key used to encrypt volumes. Supports SSM.
        :param str key_pair: Name of keyPair. Supports SSM
        :param Sequence['Mk8sAwsProviderNodePoolArgs'] node_pools: List of node pools.
        :param str pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        :param Sequence[str] security_group_ids: Security groups to deploy nodes to. Security groups control if the cluster is multi-zone or single-zon.
        :param bool skip_create_roles: If true, Control Plane will not create any roles.
        """
        pulumi.set(__self__, "deploy_role_arn", deploy_role_arn)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "networking", networking)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if deploy_role_chains is not None:
            pulumi.set(__self__, "deploy_role_chains", deploy_role_chains)
        if disk_encryption_key_arn is not None:
            pulumi.set(__self__, "disk_encryption_key_arn", disk_encryption_key_arn)
        if extra_node_policies is not None:
            pulumi.set(__self__, "extra_node_policies", extra_node_policies)
        if key_pair is not None:
            pulumi.set(__self__, "key_pair", key_pair)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if skip_create_roles is not None:
            pulumi.set(__self__, "skip_create_roles", skip_create_roles)

    @property
    @pulumi.getter(name="deployRoleArn")
    def deploy_role_arn(self) -> str:
        """
        Control Plane will set up the cluster by assuming this role.
        """
        return pulumi.get(self, "deploy_role_arn")

    @property
    @pulumi.getter
    def image(self) -> 'outputs.Mk8sAwsProviderImage':
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def networking(self) -> 'outputs.Mk8sAwsProviderNetworking':
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region where the cluster nodes will live.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The vpc where nodes will be deployed. Supports SSM.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sAwsProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        """
        Extra tags to attach to all created objects.
        """
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="deployRoleChains")
    def deploy_role_chains(self) -> Optional[Sequence['outputs.Mk8sAwsProviderDeployRoleChain']]:
        return pulumi.get(self, "deploy_role_chains")

    @property
    @pulumi.getter(name="diskEncryptionKeyArn")
    def disk_encryption_key_arn(self) -> Optional[str]:
        """
        KMS key used to encrypt volumes. Supports SSM.
        """
        return pulumi.get(self, "disk_encryption_key_arn")

    @property
    @pulumi.getter(name="extraNodePolicies")
    def extra_node_policies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "extra_node_policies")

    @property
    @pulumi.getter(name="keyPair")
    def key_pair(self) -> Optional[str]:
        """
        Name of keyPair. Supports SSM
        """
        return pulumi.get(self, "key_pair")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sAwsProviderNodePool']]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        Security groups to deploy nodes to. Security groups control if the cluster is multi-zone or single-zon.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="skipCreateRoles")
    def skip_create_roles(self) -> Optional[bool]:
        """
        If true, Control Plane will not create any roles.
        """
        return pulumi.get(self, "skip_create_roles")


@pulumi.output_type
class Mk8sAwsProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAwsProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAwsProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAwsProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sAwsProviderDeployRoleChain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "sessionNamePrefix":
            suggest = "session_name_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAwsProviderDeployRoleChain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAwsProviderDeployRoleChain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAwsProviderDeployRoleChain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 external_id: Optional[str] = None,
                 session_name_prefix: Optional[str] = None):
        """
        :param str session_name_prefix: Control Plane will append random.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if session_name_prefix is not None:
            pulumi.set(__self__, "session_name_prefix", session_name_prefix)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="sessionNamePrefix")
    def session_name_prefix(self) -> Optional[str]:
        """
        Control Plane will append random.
        """
        return pulumi.get(self, "session_name_prefix")


@pulumi.output_type
class Mk8sAwsProviderImage(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 recommended: Optional[str] = None):
        """
        :param str exact: Support SSM.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if recommended is not None:
            pulumi.set(__self__, "recommended", recommended)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Support SSM.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def recommended(self) -> Optional[str]:
        return pulumi.get(self, "recommended")


@pulumi.output_type
class Mk8sAwsProviderNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podNetwork":
            suggest = "pod_network"
        elif key == "serviceNetwork":
            suggest = "service_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAwsProviderNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAwsProviderNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAwsProviderNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_network: Optional[str] = None,
                 service_network: Optional[str] = None):
        """
        :param str pod_network: The CIDR of the pod network.
        :param str service_network: The CIDR of the service network.
        """
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[str]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[str]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")


@pulumi.output_type
class Mk8sAwsProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceTypes":
            suggest = "instance_types"
        elif key == "overrideImage":
            suggest = "override_image"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "extraSecurityGroupIds":
            suggest = "extra_security_group_ids"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "onDemandBaseCapacity":
            suggest = "on_demand_base_capacity"
        elif key == "onDemandPercentageAboveBaseCapacity":
            suggest = "on_demand_percentage_above_base_capacity"
        elif key == "spotAllocationStrategy":
            suggest = "spot_allocation_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAwsProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAwsProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAwsProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_types: Sequence[str],
                 name: str,
                 override_image: 'outputs.Mk8sAwsProviderNodePoolOverrideImage',
                 subnet_ids: Sequence[str],
                 boot_disk_size: Optional[int] = None,
                 extra_security_group_ids: Optional[Sequence[str]] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 on_demand_base_capacity: Optional[int] = None,
                 on_demand_percentage_above_base_capacity: Optional[int] = None,
                 spot_allocation_strategy: Optional[str] = None,
                 taints: Optional[Sequence['outputs.Mk8sAwsProviderNodePoolTaint']] = None):
        """
        :param 'Mk8sAwsProviderNodePoolOverrideImageArgs' override_image: Default image for all nodes.
        :param int boot_disk_size: Size in GB.
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sAwsProviderNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "instance_types", instance_types)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "override_image", override_image)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if extra_security_group_ids is not None:
            pulumi.set(__self__, "extra_security_group_ids", extra_security_group_ids)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if on_demand_base_capacity is not None:
            pulumi.set(__self__, "on_demand_base_capacity", on_demand_base_capacity)
        if on_demand_percentage_above_base_capacity is not None:
            pulumi.set(__self__, "on_demand_percentage_above_base_capacity", on_demand_percentage_above_base_capacity)
        if spot_allocation_strategy is not None:
            pulumi.set(__self__, "spot_allocation_strategy", spot_allocation_strategy)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="instanceTypes")
    def instance_types(self) -> Sequence[str]:
        return pulumi.get(self, "instance_types")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> 'outputs.Mk8sAwsProviderNodePoolOverrideImage':
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "override_image")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        """
        Size in GB.
        """
        return pulumi.get(self, "boot_disk_size")

    @property
    @pulumi.getter(name="extraSecurityGroupIds")
    def extra_security_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "extra_security_group_ids")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="onDemandBaseCapacity")
    def on_demand_base_capacity(self) -> Optional[int]:
        return pulumi.get(self, "on_demand_base_capacity")

    @property
    @pulumi.getter(name="onDemandPercentageAboveBaseCapacity")
    def on_demand_percentage_above_base_capacity(self) -> Optional[int]:
        return pulumi.get(self, "on_demand_percentage_above_base_capacity")

    @property
    @pulumi.getter(name="spotAllocationStrategy")
    def spot_allocation_strategy(self) -> Optional[str]:
        return pulumi.get(self, "spot_allocation_strategy")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sAwsProviderNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sAwsProviderNodePoolOverrideImage(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 recommended: Optional[str] = None):
        """
        :param str exact: Support SSM.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if recommended is not None:
            pulumi.set(__self__, "recommended", recommended)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        """
        Support SSM.
        """
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def recommended(self) -> Optional[str]:
        return pulumi.get(self, "recommended")


@pulumi.output_type
class Mk8sAwsProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sDigitalOceanProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "tokenSecretLink":
            suggest = "token_secret_link"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "digitalOceanTags":
            suggest = "digital_ocean_tags"
        elif key == "extraSshKeys":
            suggest = "extra_ssh_keys"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "reservedIps":
            suggest = "reserved_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sDigitalOceanProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sDigitalOceanProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sDigitalOceanProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: str,
                 networking: 'outputs.Mk8sDigitalOceanProviderNetworking',
                 region: str,
                 ssh_keys: Sequence[str],
                 token_secret_link: str,
                 vpc_id: str,
                 autoscaler: Optional['outputs.Mk8sDigitalOceanProviderAutoscaler'] = None,
                 digital_ocean_tags: Optional[Sequence[str]] = None,
                 extra_ssh_keys: Optional[Sequence[str]] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sDigitalOceanProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 reserved_ips: Optional[Sequence[str]] = None):
        """
        :param str image: Default image for all nodes.
        :param str region: Region to deploy nodes to.
        :param Sequence[str] ssh_keys: SSH key name for accessing deployed nodes.
        :param str token_secret_link: Link to a secret holding personal access token.
        :param str vpc_id: ID of the Hetzner network to deploy nodes to.
        :param Sequence[str] digital_ocean_tags: Extra tags to attach to droplets.
        :param Sequence[str] extra_ssh_keys: Extra SSH keys to provision for user root that are not registered in the DigitalOcean.
        :param Sequence['Mk8sDigitalOceanProviderNodePoolArgs'] node_pools: List of node pools.
        :param str pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        :param Sequence[str] reserved_ips: Optional set of IPs to assign as extra IPs for nodes of the cluster.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "networking", networking)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        pulumi.set(__self__, "token_secret_link", token_secret_link)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if digital_ocean_tags is not None:
            pulumi.set(__self__, "digital_ocean_tags", digital_ocean_tags)
        if extra_ssh_keys is not None:
            pulumi.set(__self__, "extra_ssh_keys", extra_ssh_keys)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if reserved_ips is not None:
            pulumi.set(__self__, "reserved_ips", reserved_ips)

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def networking(self) -> 'outputs.Mk8sDigitalOceanProviderNetworking':
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region to deploy nodes to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence[str]:
        """
        SSH key name for accessing deployed nodes.
        """
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> str:
        """
        Link to a secret holding personal access token.
        """
        return pulumi.get(self, "token_secret_link")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        ID of the Hetzner network to deploy nodes to.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sDigitalOceanProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="digitalOceanTags")
    def digital_ocean_tags(self) -> Optional[Sequence[str]]:
        """
        Extra tags to attach to droplets.
        """
        return pulumi.get(self, "digital_ocean_tags")

    @property
    @pulumi.getter(name="extraSshKeys")
    def extra_ssh_keys(self) -> Optional[Sequence[str]]:
        """
        Extra SSH keys to provision for user root that are not registered in the DigitalOcean.
        """
        return pulumi.get(self, "extra_ssh_keys")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sDigitalOceanProviderNodePool']]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="reservedIps")
    def reserved_ips(self) -> Optional[Sequence[str]]:
        """
        Optional set of IPs to assign as extra IPs for nodes of the cluster.
        """
        return pulumi.get(self, "reserved_ips")


@pulumi.output_type
class Mk8sDigitalOceanProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sDigitalOceanProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sDigitalOceanProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sDigitalOceanProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sDigitalOceanProviderNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podNetwork":
            suggest = "pod_network"
        elif key == "serviceNetwork":
            suggest = "service_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sDigitalOceanProviderNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sDigitalOceanProviderNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sDigitalOceanProviderNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_network: Optional[str] = None,
                 service_network: Optional[str] = None):
        """
        :param str pod_network: The CIDR of the pod network.
        :param str service_network: The CIDR of the service network.
        """
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[str]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[str]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")


@pulumi.output_type
class Mk8sDigitalOceanProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dropletSize":
            suggest = "droplet_size"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "overrideImage":
            suggest = "override_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sDigitalOceanProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sDigitalOceanProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sDigitalOceanProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 droplet_size: str,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 override_image: Optional[str] = None,
                 taints: Optional[Sequence['outputs.Mk8sDigitalOceanProviderNodePoolTaint']] = None):
        """
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sDigitalOceanProviderNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "droplet_size", droplet_size)
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if override_image is not None:
            pulumi.set(__self__, "override_image", override_image)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="dropletSize")
    def droplet_size(self) -> str:
        return pulumi.get(self, "droplet_size")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> Optional[str]:
        return pulumi.get(self, "override_image")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sDigitalOceanProviderNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sDigitalOceanProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sEphemeralProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePools":
            suggest = "node_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sEphemeralProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sEphemeralProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sEphemeralProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 node_pools: Optional[Sequence['outputs.Mk8sEphemeralProviderNodePool']] = None):
        """
        :param str location: Control Plane location that will host the K8s components. Prefer one that is closest to where the nodes are running.
        :param Sequence['Mk8sEphemeralProviderNodePoolArgs'] node_pools: List of node pools.
        """
        pulumi.set(__self__, "location", location)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Control Plane location that will host the K8s components. Prefer one that is closest to where the nodes are running.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sEphemeralProviderNodePool']]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")


@pulumi.output_type
class Mk8sEphemeralProviderNodePool(dict):
    def __init__(__self__, *,
                 arch: str,
                 count: int,
                 cpu: str,
                 flavor: str,
                 memory: str,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.Mk8sEphemeralProviderNodePoolTaint']] = None):
        """
        :param str arch: CPU architecture of the nodes.
        :param int count: Number of nodes to deploy.
        :param str cpu: Allocated CPU.
        :param str flavor: Linux distro to use for ephemeral nodes.
        :param str memory: Allocated memory.
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sEphemeralProviderNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "arch", arch)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def arch(self) -> str:
        """
        CPU architecture of the nodes.
        """
        return pulumi.get(self, "arch")

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        Number of nodes to deploy.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def cpu(self) -> str:
        """
        Allocated CPU.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def flavor(self) -> str:
        """
        Linux distro to use for ephemeral nodes.
        """
        return pulumi.get(self, "flavor")

    @property
    @pulumi.getter
    def memory(self) -> str:
        """
        Allocated memory.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sEphemeralProviderNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sEphemeralProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sFirewall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCidr":
            suggest = "source_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sFirewall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sFirewall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sFirewall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_cidr: str,
                 description: Optional[str] = None):
        pulumi.set(__self__, "source_cidr", source_cidr)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="sourceCidr")
    def source_cidr(self) -> str:
        return pulumi.get(self, "source_cidr")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class Mk8sGenericProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePools":
            suggest = "node_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sGenericProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sGenericProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sGenericProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 networking: 'outputs.Mk8sGenericProviderNetworking',
                 node_pools: Optional[Sequence['outputs.Mk8sGenericProviderNodePool']] = None):
        """
        :param str location: Control Plane location that will host the K8s components. Prefer one that is closest to where the nodes are running.
        :param Sequence['Mk8sGenericProviderNodePoolArgs'] node_pools: List of node pools.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "networking", networking)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Control Plane location that will host the K8s components. Prefer one that is closest to where the nodes are running.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def networking(self) -> 'outputs.Mk8sGenericProviderNetworking':
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sGenericProviderNodePool']]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")


@pulumi.output_type
class Mk8sGenericProviderNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podNetwork":
            suggest = "pod_network"
        elif key == "serviceNetwork":
            suggest = "service_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sGenericProviderNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sGenericProviderNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sGenericProviderNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_network: Optional[str] = None,
                 service_network: Optional[str] = None):
        """
        :param str pod_network: The CIDR of the pod network.
        :param str service_network: The CIDR of the service network.
        """
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[str]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[str]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")


@pulumi.output_type
class Mk8sGenericProviderNodePool(dict):
    def __init__(__self__, *,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.Mk8sGenericProviderNodePoolTaint']] = None):
        """
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sGenericProviderNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sGenericProviderNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sGenericProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sHetznerProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "tokenSecretLink":
            suggest = "token_secret_link"
        elif key == "dedicatedServerNodePools":
            suggest = "dedicated_server_node_pools"
        elif key == "firewallId":
            suggest = "firewall_id"
        elif key == "floatingIpSelector":
            suggest = "floating_ip_selector"
        elif key == "hetznerLabels":
            suggest = "hetzner_labels"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "sshKey":
            suggest = "ssh_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sHetznerProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sHetznerProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sHetznerProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: str,
                 networking: 'outputs.Mk8sHetznerProviderNetworking',
                 region: str,
                 token_secret_link: str,
                 autoscaler: Optional['outputs.Mk8sHetznerProviderAutoscaler'] = None,
                 dedicated_server_node_pools: Optional[Sequence['outputs.Mk8sHetznerProviderDedicatedServerNodePool']] = None,
                 firewall_id: Optional[str] = None,
                 floating_ip_selector: Optional[Mapping[str, str]] = None,
                 hetzner_labels: Optional[Mapping[str, str]] = None,
                 image: Optional[str] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sHetznerProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 ssh_key: Optional[str] = None):
        """
        :param str network_id: ID of the Hetzner network to deploy nodes to.
        :param str region: Hetzner region to deploy nodes to.
        :param str token_secret_link: Link to a secret holding Hetzner access key.
        :param Sequence['Mk8sHetznerProviderDedicatedServerNodePoolArgs'] dedicated_server_node_pools: Node pools that can configure dedicated Hetzner servers.
        :param str firewall_id: Optional firewall rule to attach to all nodes.
        :param Mapping[str, str] floating_ip_selector: If supplied, nodes will get assigned a random floating ip matching the selector.
        :param Mapping[str, str] hetzner_labels: Extra labels to attach to servers.
        :param str image: Default image for all nodes.
        :param Sequence['Mk8sHetznerProviderNodePoolArgs'] node_pools: List of node pools.
        :param str pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        :param str ssh_key: SSH key name for accessing deployed nodes.
        """
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "networking", networking)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "token_secret_link", token_secret_link)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if dedicated_server_node_pools is not None:
            pulumi.set(__self__, "dedicated_server_node_pools", dedicated_server_node_pools)
        if firewall_id is not None:
            pulumi.set(__self__, "firewall_id", firewall_id)
        if floating_ip_selector is not None:
            pulumi.set(__self__, "floating_ip_selector", floating_ip_selector)
        if hetzner_labels is not None:
            pulumi.set(__self__, "hetzner_labels", hetzner_labels)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if ssh_key is not None:
            pulumi.set(__self__, "ssh_key", ssh_key)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        ID of the Hetzner network to deploy nodes to.
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter
    def networking(self) -> 'outputs.Mk8sHetznerProviderNetworking':
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Hetzner region to deploy nodes to.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> str:
        """
        Link to a secret holding Hetzner access key.
        """
        return pulumi.get(self, "token_secret_link")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sHetznerProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="dedicatedServerNodePools")
    def dedicated_server_node_pools(self) -> Optional[Sequence['outputs.Mk8sHetznerProviderDedicatedServerNodePool']]:
        """
        Node pools that can configure dedicated Hetzner servers.
        """
        return pulumi.get(self, "dedicated_server_node_pools")

    @property
    @pulumi.getter(name="firewallId")
    def firewall_id(self) -> Optional[str]:
        """
        Optional firewall rule to attach to all nodes.
        """
        return pulumi.get(self, "firewall_id")

    @property
    @pulumi.getter(name="floatingIpSelector")
    def floating_ip_selector(self) -> Optional[Mapping[str, str]]:
        """
        If supplied, nodes will get assigned a random floating ip matching the selector.
        """
        return pulumi.get(self, "floating_ip_selector")

    @property
    @pulumi.getter(name="hetznerLabels")
    def hetzner_labels(self) -> Optional[Mapping[str, str]]:
        """
        Extra labels to attach to servers.
        """
        return pulumi.get(self, "hetzner_labels")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sHetznerProviderNodePool']]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[str]:
        """
        SSH key name for accessing deployed nodes.
        """
        return pulumi.get(self, "ssh_key")


@pulumi.output_type
class Mk8sHetznerProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sHetznerProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sHetznerProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sHetznerProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sHetznerProviderDedicatedServerNodePool(dict):
    def __init__(__self__, *,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.Mk8sHetznerProviderDedicatedServerNodePoolTaint']] = None):
        """
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sHetznerProviderDedicatedServerNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sHetznerProviderDedicatedServerNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sHetznerProviderDedicatedServerNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sHetznerProviderNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podNetwork":
            suggest = "pod_network"
        elif key == "serviceNetwork":
            suggest = "service_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sHetznerProviderNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sHetznerProviderNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sHetznerProviderNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_network: Optional[str] = None,
                 service_network: Optional[str] = None):
        """
        :param str pod_network: The CIDR of the pod network.
        :param str service_network: The CIDR of the service network.
        """
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[str]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[str]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")


@pulumi.output_type
class Mk8sHetznerProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverType":
            suggest = "server_type"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "overrideImage":
            suggest = "override_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sHetznerProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sHetznerProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sHetznerProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 server_type: str,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 override_image: Optional[str] = None,
                 taints: Optional[Sequence['outputs.Mk8sHetznerProviderNodePoolTaint']] = None):
        """
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sHetznerProviderNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_type", server_type)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if override_image is not None:
            pulumi.set(__self__, "override_image", override_image)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> str:
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> Optional[str]:
        return pulumi.get(self, "override_image")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sHetznerProviderNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sHetznerProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sLambdalabsProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tokenSecretLink":
            suggest = "token_secret_link"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "unmanagedNodePools":
            suggest = "unmanaged_node_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLambdalabsProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLambdalabsProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLambdalabsProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: str,
                 ssh_key: str,
                 token_secret_link: str,
                 autoscaler: Optional['outputs.Mk8sLambdalabsProviderAutoscaler'] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sLambdalabsProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 unmanaged_node_pools: Optional[Sequence['outputs.Mk8sLambdalabsProviderUnmanagedNodePool']] = None):
        """
        :param str region: Region where the cluster nodes will live.
        :param str ssh_key: SSH key name for accessing deployed nodes.
        :param str token_secret_link: Link to a secret holding Lambdalabs access key.
        :param Sequence['Mk8sLambdalabsProviderNodePoolArgs'] node_pools: List of node pools.
        :param str pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "token_secret_link", token_secret_link)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if unmanaged_node_pools is not None:
            pulumi.set(__self__, "unmanaged_node_pools", unmanaged_node_pools)

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region where the cluster nodes will live.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        SSH key name for accessing deployed nodes.
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> str:
        """
        Link to a secret holding Lambdalabs access key.
        """
        return pulumi.get(self, "token_secret_link")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sLambdalabsProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sLambdalabsProviderNodePool']]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="unmanagedNodePools")
    def unmanaged_node_pools(self) -> Optional[Sequence['outputs.Mk8sLambdalabsProviderUnmanagedNodePool']]:
        return pulumi.get(self, "unmanaged_node_pools")


@pulumi.output_type
class Mk8sLambdalabsProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLambdalabsProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLambdalabsProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLambdalabsProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sLambdalabsProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLambdalabsProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLambdalabsProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLambdalabsProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: str,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 taints: Optional[Sequence['outputs.Mk8sLambdalabsProviderNodePoolTaint']] = None):
        """
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sLambdalabsProviderNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sLambdalabsProviderNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sLambdalabsProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sLambdalabsProviderUnmanagedNodePool(dict):
    def __init__(__self__, *,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.Mk8sLambdalabsProviderUnmanagedNodePoolTaint']] = None):
        """
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sLambdalabsProviderUnmanagedNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sLambdalabsProviderUnmanagedNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sLambdalabsProviderUnmanagedNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sLinodeProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenSecretLink":
            suggest = "token_secret_link"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "authorizedKeys":
            suggest = "authorized_keys"
        elif key == "authorizedUsers":
            suggest = "authorized_users"
        elif key == "firewallId":
            suggest = "firewall_id"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLinodeProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLinodeProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLinodeProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: str,
                 networking: 'outputs.Mk8sLinodeProviderNetworking',
                 region: str,
                 token_secret_link: str,
                 vpc_id: str,
                 authorized_keys: Optional[Sequence[str]] = None,
                 authorized_users: Optional[Sequence[str]] = None,
                 autoscaler: Optional['outputs.Mk8sLinodeProviderAutoscaler'] = None,
                 firewall_id: Optional[str] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sLinodeProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None):
        """
        :param str image: Default image for all nodes.
        :param str region: Region where the cluster nodes will live.
        :param str token_secret_link: Link to a secret holding Linode access key.
        :param str vpc_id: The vpc where nodes will be deployed. Supports SSM.
        :param str firewall_id: Optional firewall rule to attach to all nodes.
        :param Sequence['Mk8sLinodeProviderNodePoolArgs'] node_pools: List of node pools.
        :param str pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "networking", networking)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "token_secret_link", token_secret_link)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if authorized_keys is not None:
            pulumi.set(__self__, "authorized_keys", authorized_keys)
        if authorized_users is not None:
            pulumi.set(__self__, "authorized_users", authorized_users)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if firewall_id is not None:
            pulumi.set(__self__, "firewall_id", firewall_id)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def networking(self) -> 'outputs.Mk8sLinodeProviderNetworking':
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region where the cluster nodes will live.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> str:
        """
        Link to a secret holding Linode access key.
        """
        return pulumi.get(self, "token_secret_link")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The vpc where nodes will be deployed. Supports SSM.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="authorizedKeys")
    def authorized_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "authorized_keys")

    @property
    @pulumi.getter(name="authorizedUsers")
    def authorized_users(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "authorized_users")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sLinodeProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="firewallId")
    def firewall_id(self) -> Optional[str]:
        """
        Optional firewall rule to attach to all nodes.
        """
        return pulumi.get(self, "firewall_id")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sLinodeProviderNodePool']]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")


@pulumi.output_type
class Mk8sLinodeProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLinodeProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLinodeProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLinodeProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sLinodeProviderNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podNetwork":
            suggest = "pod_network"
        elif key == "serviceNetwork":
            suggest = "service_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLinodeProviderNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLinodeProviderNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLinodeProviderNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_network: Optional[str] = None,
                 service_network: Optional[str] = None):
        """
        :param str pod_network: The CIDR of the pod network.
        :param str service_network: The CIDR of the service network.
        """
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[str]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[str]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")


@pulumi.output_type
class Mk8sLinodeProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverType":
            suggest = "server_type"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "overrideImage":
            suggest = "override_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLinodeProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLinodeProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLinodeProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 server_type: str,
                 subnet_id: str,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 override_image: Optional[str] = None,
                 taints: Optional[Sequence['outputs.Mk8sLinodeProviderNodePoolTaint']] = None):
        """
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sLinodeProviderNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_type", server_type)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if override_image is not None:
            pulumi.set(__self__, "override_image", override_image)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> str:
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> Optional[str]:
        return pulumi.get(self, "override_image")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sLinodeProviderNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sLinodeProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sOblivusProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenSecretLink":
            suggest = "token_secret_link"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "unmanagedNodePools":
            suggest = "unmanaged_node_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sOblivusProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sOblivusProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sOblivusProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter: str,
                 token_secret_link: str,
                 autoscaler: Optional['outputs.Mk8sOblivusProviderAutoscaler'] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sOblivusProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 unmanaged_node_pools: Optional[Sequence['outputs.Mk8sOblivusProviderUnmanagedNodePool']] = None):
        """
        :param str token_secret_link: Link to a secret holding Oblivus access key.
        :param Sequence['Mk8sOblivusProviderNodePoolArgs'] node_pools: List of node pools.
        :param str pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "token_secret_link", token_secret_link)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)
        if unmanaged_node_pools is not None:
            pulumi.set(__self__, "unmanaged_node_pools", unmanaged_node_pools)

    @property
    @pulumi.getter
    def datacenter(self) -> str:
        return pulumi.get(self, "datacenter")

    @property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> str:
        """
        Link to a secret holding Oblivus access key.
        """
        return pulumi.get(self, "token_secret_link")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sOblivusProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sOblivusProviderNodePool']]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="unmanagedNodePools")
    def unmanaged_node_pools(self) -> Optional[Sequence['outputs.Mk8sOblivusProviderUnmanagedNodePool']]:
        return pulumi.get(self, "unmanaged_node_pools")


@pulumi.output_type
class Mk8sOblivusProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sOblivusProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sOblivusProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sOblivusProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sOblivusProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sOblivusProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sOblivusProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sOblivusProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flavor: str,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 taints: Optional[Sequence['outputs.Mk8sOblivusProviderNodePoolTaint']] = None):
        """
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sOblivusProviderNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def flavor(self) -> str:
        return pulumi.get(self, "flavor")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sOblivusProviderNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sOblivusProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sOblivusProviderUnmanagedNodePool(dict):
    def __init__(__self__, *,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.Mk8sOblivusProviderUnmanagedNodePoolTaint']] = None):
        """
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sOblivusProviderUnmanagedNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sOblivusProviderUnmanagedNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sOblivusProviderUnmanagedNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sPaperspaceProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "tokenSecretLink":
            suggest = "token_secret_link"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "sharedDrives":
            suggest = "shared_drives"
        elif key == "unmanagedNodePools":
            suggest = "unmanaged_node_pools"
        elif key == "userIds":
            suggest = "user_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sPaperspaceProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sPaperspaceProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sPaperspaceProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: str,
                 region: str,
                 token_secret_link: str,
                 autoscaler: Optional['outputs.Mk8sPaperspaceProviderAutoscaler'] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sPaperspaceProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 shared_drives: Optional[Sequence[str]] = None,
                 unmanaged_node_pools: Optional[Sequence['outputs.Mk8sPaperspaceProviderUnmanagedNodePool']] = None,
                 user_ids: Optional[Sequence[str]] = None):
        """
        :param str region: Region where the cluster nodes will live.
        :param str token_secret_link: Link to a secret holding Paperspace access key.
        :param Sequence['Mk8sPaperspaceProviderNodePoolArgs'] node_pools: List of node pools.
        :param str pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "token_secret_link", token_secret_link)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if shared_drives is not None:
            pulumi.set(__self__, "shared_drives", shared_drives)
        if unmanaged_node_pools is not None:
            pulumi.set(__self__, "unmanaged_node_pools", unmanaged_node_pools)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region where the cluster nodes will live.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> str:
        """
        Link to a secret holding Paperspace access key.
        """
        return pulumi.get(self, "token_secret_link")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sPaperspaceProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sPaperspaceProviderNodePool']]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="sharedDrives")
    def shared_drives(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "shared_drives")

    @property
    @pulumi.getter(name="unmanagedNodePools")
    def unmanaged_node_pools(self) -> Optional[Sequence['outputs.Mk8sPaperspaceProviderUnmanagedNodePool']]:
        return pulumi.get(self, "unmanaged_node_pools")

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "user_ids")


@pulumi.output_type
class Mk8sPaperspaceProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sPaperspaceProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sPaperspaceProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sPaperspaceProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sPaperspaceProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineType":
            suggest = "machine_type"
        elif key == "publicIpType":
            suggest = "public_ip_type"
        elif key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sPaperspaceProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sPaperspaceProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sPaperspaceProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_type: str,
                 name: str,
                 public_ip_type: str,
                 boot_disk_size: Optional[int] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 taints: Optional[Sequence['outputs.Mk8sPaperspaceProviderNodePoolTaint']] = None):
        """
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sPaperspaceProviderNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "machine_type", machine_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip_type", public_ip_type)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> str:
        return pulumi.get(self, "machine_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpType")
    def public_ip_type(self) -> str:
        return pulumi.get(self, "public_ip_type")

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sPaperspaceProviderNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sPaperspaceProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sPaperspaceProviderUnmanagedNodePool(dict):
    def __init__(__self__, *,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.Mk8sPaperspaceProviderUnmanagedNodePoolTaint']] = None):
        """
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence['Mk8sPaperspaceProviderUnmanagedNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sPaperspaceProviderUnmanagedNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sPaperspaceProviderUnmanagedNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addOns":
            suggest = "add_ons"
        elif key == "homeLocation":
            suggest = "home_location"
        elif key == "oidcProviderUrl":
            suggest = "oidc_provider_url"
        elif key == "serverUrl":
            suggest = "server_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_ons: Optional[Sequence['outputs.Mk8sStatusAddOn']] = None,
                 home_location: Optional[str] = None,
                 oidc_provider_url: Optional[str] = None,
                 server_url: Optional[str] = None):
        if add_ons is not None:
            pulumi.set(__self__, "add_ons", add_ons)
        if home_location is not None:
            pulumi.set(__self__, "home_location", home_location)
        if oidc_provider_url is not None:
            pulumi.set(__self__, "oidc_provider_url", oidc_provider_url)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)

    @property
    @pulumi.getter(name="addOns")
    def add_ons(self) -> Optional[Sequence['outputs.Mk8sStatusAddOn']]:
        return pulumi.get(self, "add_ons")

    @property
    @pulumi.getter(name="homeLocation")
    def home_location(self) -> Optional[str]:
        return pulumi.get(self, "home_location")

    @property
    @pulumi.getter(name="oidcProviderUrl")
    def oidc_provider_url(self) -> Optional[str]:
        return pulumi.get(self, "oidc_provider_url")

    @property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[str]:
        return pulumi.get(self, "server_url")


@pulumi.output_type
class Mk8sStatusAddOn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsEcrs":
            suggest = "aws_ecrs"
        elif key == "awsEfs":
            suggest = "aws_efs"
        elif key == "awsElbs":
            suggest = "aws_elbs"
        elif key == "awsWorkloadIdentities":
            suggest = "aws_workload_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_ecrs: Optional[Sequence['outputs.Mk8sStatusAddOnAwsEcr']] = None,
                 aws_efs: Optional[Sequence['outputs.Mk8sStatusAddOnAwsEf']] = None,
                 aws_elbs: Optional[Sequence['outputs.Mk8sStatusAddOnAwsElb']] = None,
                 aws_workload_identities: Optional[Sequence['outputs.Mk8sStatusAddOnAwsWorkloadIdentity']] = None,
                 dashboards: Optional[Sequence['outputs.Mk8sStatusAddOnDashboard']] = None,
                 logs: Optional[Sequence['outputs.Mk8sStatusAddOnLog']] = None,
                 metrics: Optional[Sequence['outputs.Mk8sStatusAddOnMetric']] = None):
        if aws_ecrs is not None:
            pulumi.set(__self__, "aws_ecrs", aws_ecrs)
        if aws_efs is not None:
            pulumi.set(__self__, "aws_efs", aws_efs)
        if aws_elbs is not None:
            pulumi.set(__self__, "aws_elbs", aws_elbs)
        if aws_workload_identities is not None:
            pulumi.set(__self__, "aws_workload_identities", aws_workload_identities)
        if dashboards is not None:
            pulumi.set(__self__, "dashboards", dashboards)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @property
    @pulumi.getter(name="awsEcrs")
    def aws_ecrs(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnAwsEcr']]:
        return pulumi.get(self, "aws_ecrs")

    @property
    @pulumi.getter(name="awsEfs")
    def aws_efs(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnAwsEf']]:
        return pulumi.get(self, "aws_efs")

    @property
    @pulumi.getter(name="awsElbs")
    def aws_elbs(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnAwsElb']]:
        return pulumi.get(self, "aws_elbs")

    @property
    @pulumi.getter(name="awsWorkloadIdentities")
    def aws_workload_identities(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnAwsWorkloadIdentity']]:
        return pulumi.get(self, "aws_workload_identities")

    @property
    @pulumi.getter
    def dashboards(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnDashboard']]:
        return pulumi.get(self, "dashboards")

    @property
    @pulumi.getter
    def logs(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnLog']]:
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnMetric']]:
        return pulumi.get(self, "metrics")


@pulumi.output_type
class Mk8sStatusAddOnAwsEcr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustPolicy":
            suggest = "trust_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnAwsEcr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnAwsEcr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnAwsEcr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust_policy: Optional[str] = None):
        if trust_policy is not None:
            pulumi.set(__self__, "trust_policy", trust_policy)

    @property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[str]:
        return pulumi.get(self, "trust_policy")


@pulumi.output_type
class Mk8sStatusAddOnAwsEf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustPolicy":
            suggest = "trust_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnAwsEf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnAwsEf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnAwsEf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust_policy: Optional[str] = None):
        if trust_policy is not None:
            pulumi.set(__self__, "trust_policy", trust_policy)

    @property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[str]:
        return pulumi.get(self, "trust_policy")


@pulumi.output_type
class Mk8sStatusAddOnAwsElb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustPolicy":
            suggest = "trust_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnAwsElb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnAwsElb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnAwsElb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust_policy: Optional[str] = None):
        if trust_policy is not None:
            pulumi.set(__self__, "trust_policy", trust_policy)

    @property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[str]:
        return pulumi.get(self, "trust_policy")


@pulumi.output_type
class Mk8sStatusAddOnAwsWorkloadIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oidcProviderConfigs":
            suggest = "oidc_provider_configs"
        elif key == "trustPolicy":
            suggest = "trust_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnAwsWorkloadIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnAwsWorkloadIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnAwsWorkloadIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oidc_provider_configs: Optional[Sequence['outputs.Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig']] = None,
                 trust_policy: Optional[str] = None):
        if oidc_provider_configs is not None:
            pulumi.set(__self__, "oidc_provider_configs", oidc_provider_configs)
        if trust_policy is not None:
            pulumi.set(__self__, "trust_policy", trust_policy)

    @property
    @pulumi.getter(name="oidcProviderConfigs")
    def oidc_provider_configs(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig']]:
        return pulumi.get(self, "oidc_provider_configs")

    @property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[str]:
        return pulumi.get(self, "trust_policy")


@pulumi.output_type
class Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerUrl":
            suggest = "provider_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audience: Optional[str] = None,
                 provider_url: Optional[str] = None):
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if provider_url is not None:
            pulumi.set(__self__, "provider_url", provider_url)

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="providerUrl")
    def provider_url(self) -> Optional[str]:
        return pulumi.get(self, "provider_url")


@pulumi.output_type
class Mk8sStatusAddOnDashboard(dict):
    def __init__(__self__, *,
                 url: Optional[str] = None):
        """
        :param str url: Access to dashboard.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        Access to dashboard.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class Mk8sStatusAddOnLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lokiAddress":
            suggest = "loki_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loki_address: Optional[str] = None):
        """
        :param str loki_address: Loki endpoint to query logs from.
        """
        if loki_address is not None:
            pulumi.set(__self__, "loki_address", loki_address)

    @property
    @pulumi.getter(name="lokiAddress")
    def loki_address(self) -> Optional[str]:
        """
        Loki endpoint to query logs from.
        """
        return pulumi.get(self, "loki_address")


@pulumi.output_type
class Mk8sStatusAddOnMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prometheusEndpoint":
            suggest = "prometheus_endpoint"
        elif key == "remoteWriteConfig":
            suggest = "remote_write_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prometheus_endpoint: Optional[str] = None,
                 remote_write_config: Optional[str] = None):
        if prometheus_endpoint is not None:
            pulumi.set(__self__, "prometheus_endpoint", prometheus_endpoint)
        if remote_write_config is not None:
            pulumi.set(__self__, "remote_write_config", remote_write_config)

    @property
    @pulumi.getter(name="prometheusEndpoint")
    def prometheus_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "prometheus_endpoint")

    @property
    @pulumi.getter(name="remoteWriteConfig")
    def remote_write_config(self) -> Optional[str]:
        return pulumi.get(self, "remote_write_config")


@pulumi.output_type
class Mk8sTritonProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"
        elif key == "loadBalancer":
            suggest = "load_balancer"
        elif key == "privateNetworkId":
            suggest = "private_network_id"
        elif key == "firewallEnabled":
            suggest = "firewall_enabled"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "sshKeys":
            suggest = "ssh_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sTritonProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sTritonProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sTritonProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection: 'outputs.Mk8sTritonProviderConnection',
                 image_id: str,
                 load_balancer: 'outputs.Mk8sTritonProviderLoadBalancer',
                 location: str,
                 networking: 'outputs.Mk8sTritonProviderNetworking',
                 private_network_id: str,
                 autoscaler: Optional['outputs.Mk8sTritonProviderAutoscaler'] = None,
                 firewall_enabled: Optional[bool] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sTritonProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 ssh_keys: Optional[Sequence[str]] = None):
        """
        :param str image_id: Default image for all nodes.
        :param str location: Control Plane location that will host the K8s components. Prefer one that is closest to the Triton datacenter.
        :param str private_network_id: ID of the private Fabric/Network.
        :param bool firewall_enabled: Enable firewall for the instances deployed.
        :param Sequence['Mk8sTritonProviderNodePoolArgs'] node_pools: List of node pools.
        :param str pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        :param Sequence[str] ssh_keys: Extra SSH keys to provision for user root.
        """
        pulumi.set(__self__, "connection", connection)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "load_balancer", load_balancer)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "networking", networking)
        pulumi.set(__self__, "private_network_id", private_network_id)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if firewall_enabled is not None:
            pulumi.set(__self__, "firewall_enabled", firewall_enabled)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)

    @property
    @pulumi.getter
    def connection(self) -> 'outputs.Mk8sTritonProviderConnection':
        return pulumi.get(self, "connection")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> 'outputs.Mk8sTritonProviderLoadBalancer':
        return pulumi.get(self, "load_balancer")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Control Plane location that will host the K8s components. Prefer one that is closest to the Triton datacenter.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def networking(self) -> 'outputs.Mk8sTritonProviderNetworking':
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> str:
        """
        ID of the private Fabric/Network.
        """
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sTritonProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="firewallEnabled")
    def firewall_enabled(self) -> Optional[bool]:
        """
        Enable firewall for the instances deployed.
        """
        return pulumi.get(self, "firewall_enabled")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sTritonProviderNodePool']]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        """
        Extra SSH keys to provision for user root.
        """
        return pulumi.get(self, "ssh_keys")


@pulumi.output_type
class Mk8sTritonProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sTritonProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sTritonProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sTritonProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sTritonProviderConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKeySecretLink":
            suggest = "private_key_secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sTritonProviderConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sTritonProviderConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sTritonProviderConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account: str,
                 private_key_secret_link: str,
                 url: str,
                 user: Optional[str] = None):
        """
        :param str private_key_secret_link: Link to a SSH or opaque secret.
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "private_key_secret_link", private_key_secret_link)
        pulumi.set(__self__, "url", url)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def account(self) -> str:
        return pulumi.get(self, "account")

    @property
    @pulumi.getter(name="privateKeySecretLink")
    def private_key_secret_link(self) -> str:
        """
        Link to a SSH or opaque secret.
        """
        return pulumi.get(self, "private_key_secret_link")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class Mk8sTritonProviderLoadBalancer(dict):
    def __init__(__self__, *,
                 gateway: Optional['outputs.Mk8sTritonProviderLoadBalancerGateway'] = None,
                 manual: Optional['outputs.Mk8sTritonProviderLoadBalancerManual'] = None):
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @property
    @pulumi.getter
    def gateway(self) -> Optional['outputs.Mk8sTritonProviderLoadBalancerGateway']:
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def manual(self) -> Optional['outputs.Mk8sTritonProviderLoadBalancerManual']:
        return pulumi.get(self, "manual")


@pulumi.output_type
class Mk8sTritonProviderLoadBalancerGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sTritonProviderLoadBalancerGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sTritonProviderLoadBalancerGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sTritonProviderLoadBalancerGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None):
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")


@pulumi.output_type
class Mk8sTritonProviderLoadBalancerManual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cnsInternalDomain":
            suggest = "cns_internal_domain"
        elif key == "cnsPublicDomain":
            suggest = "cns_public_domain"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "packageId":
            suggest = "package_id"
        elif key == "publicNetworkId":
            suggest = "public_network_id"
        elif key == "privateNetworkIds":
            suggest = "private_network_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sTritonProviderLoadBalancerManual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sTritonProviderLoadBalancerManual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sTritonProviderLoadBalancerManual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cns_internal_domain: str,
                 cns_public_domain: str,
                 count: int,
                 image_id: str,
                 package_id: str,
                 public_network_id: str,
                 metadata: Optional[Mapping[str, str]] = None,
                 private_network_ids: Optional[Sequence[str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param str public_network_id: If set, machine will also get a public IP.
        :param Mapping[str, str] metadata: Extra tags to attach to instances from a node pool.
        :param Sequence[str] private_network_ids: More private networks to join.
        :param Mapping[str, str] tags: Extra tags to attach to instances from a node pool.
        """
        pulumi.set(__self__, "cns_internal_domain", cns_internal_domain)
        pulumi.set(__self__, "cns_public_domain", cns_public_domain)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "package_id", package_id)
        pulumi.set(__self__, "public_network_id", public_network_id)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if private_network_ids is not None:
            pulumi.set(__self__, "private_network_ids", private_network_ids)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="cnsInternalDomain")
    def cns_internal_domain(self) -> str:
        return pulumi.get(self, "cns_internal_domain")

    @property
    @pulumi.getter(name="cnsPublicDomain")
    def cns_public_domain(self) -> str:
        return pulumi.get(self, "cns_public_domain")

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="packageId")
    def package_id(self) -> str:
        return pulumi.get(self, "package_id")

    @property
    @pulumi.getter(name="publicNetworkId")
    def public_network_id(self) -> str:
        """
        If set, machine will also get a public IP.
        """
        return pulumi.get(self, "public_network_id")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        """
        Extra tags to attach to instances from a node pool.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> Optional[Sequence[str]]:
        """
        More private networks to join.
        """
        return pulumi.get(self, "private_network_ids")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Extra tags to attach to instances from a node pool.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class Mk8sTritonProviderNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podNetwork":
            suggest = "pod_network"
        elif key == "serviceNetwork":
            suggest = "service_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sTritonProviderNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sTritonProviderNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sTritonProviderNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_network: Optional[str] = None,
                 service_network: Optional[str] = None):
        """
        :param str pod_network: The CIDR of the pod network.
        :param str service_network: The CIDR of the service network.
        """
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[str]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[str]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")


@pulumi.output_type
class Mk8sTritonProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "packageId":
            suggest = "package_id"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "overrideImageId":
            suggest = "override_image_id"
        elif key == "privateNetworkIds":
            suggest = "private_network_ids"
        elif key == "publicNetworkId":
            suggest = "public_network_id"
        elif key == "tritonTags":
            suggest = "triton_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sTritonProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sTritonProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sTritonProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 package_id: str,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 override_image_id: Optional[str] = None,
                 private_network_ids: Optional[Sequence[str]] = None,
                 public_network_id: Optional[str] = None,
                 taints: Optional[Sequence['outputs.Mk8sTritonProviderNodePoolTaint']] = None,
                 triton_tags: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] labels: Labels to attach to nodes of a node pool.
        :param Sequence[str] private_network_ids: More private networks to join.
        :param str public_network_id: If set, machine will also get a public IP.
        :param Sequence['Mk8sTritonProviderNodePoolTaintArgs'] taints: Taint for the nodes of a pool.
        :param Mapping[str, str] triton_tags: Extra tags to attach to instances from a node pool.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "package_id", package_id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if override_image_id is not None:
            pulumi.set(__self__, "override_image_id", override_image_id)
        if private_network_ids is not None:
            pulumi.set(__self__, "private_network_ids", private_network_ids)
        if public_network_id is not None:
            pulumi.set(__self__, "public_network_id", public_network_id)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if triton_tags is not None:
            pulumi.set(__self__, "triton_tags", triton_tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="packageId")
    def package_id(self) -> str:
        return pulumi.get(self, "package_id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="overrideImageId")
    def override_image_id(self) -> Optional[str]:
        return pulumi.get(self, "override_image_id")

    @property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> Optional[Sequence[str]]:
        """
        More private networks to join.
        """
        return pulumi.get(self, "private_network_ids")

    @property
    @pulumi.getter(name="publicNetworkId")
    def public_network_id(self) -> Optional[str]:
        """
        If set, machine will also get a public IP.
        """
        return pulumi.get(self, "public_network_id")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sTritonProviderNodePoolTaint']]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="tritonTags")
    def triton_tags(self) -> Optional[Mapping[str, str]]:
        """
        Extra tags to attach to instances from a node pool.
        """
        return pulumi.get(self, "triton_tags")


@pulumi.output_type
class Mk8sTritonProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class OrgAuthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainAutoMembers":
            suggest = "domain_auto_members"
        elif key == "samlOnly":
            suggest = "saml_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgAuthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgAuthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgAuthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_auto_members: Sequence[str],
                 saml_only: Optional[bool] = None):
        """
        :param Sequence[str] domain_auto_members: List of domains which will auto-provision users when authenticating using SAML.
        :param bool saml_only: Enforce SAML only authentication.
        """
        pulumi.set(__self__, "domain_auto_members", domain_auto_members)
        if saml_only is not None:
            pulumi.set(__self__, "saml_only", saml_only)

    @property
    @pulumi.getter(name="domainAutoMembers")
    def domain_auto_members(self) -> Sequence[str]:
        """
        List of domains which will auto-provision users when authenticating using SAML.
        """
        return pulumi.get(self, "domain_auto_members")

    @property
    @pulumi.getter(name="samlOnly")
    def saml_only(self) -> Optional[bool]:
        """
        Enforce SAML only authentication.
        """
        return pulumi.get(self, "saml_only")


@pulumi.output_type
class OrgLoggingCloudWatchLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "streamName":
            suggest = "stream_name"
        elif key == "extractFields":
            suggest = "extract_fields"
        elif key == "retentionDays":
            suggest = "retention_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLoggingCloudWatchLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLoggingCloudWatchLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLoggingCloudWatchLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: str,
                 group_name: str,
                 region: str,
                 stream_name: str,
                 extract_fields: Optional[Mapping[str, str]] = None,
                 retention_days: Optional[int] = None):
        """
        :param str credentials: Full Link to a secret of type `opaque`.
        :param str group_name: A container for log streams with common settings like retention. Used to categorize logs by application or service type.
        :param str region: Valid AWS region.
        :param str stream_name: A sequence of log events from the same source within a log group. Typically represents individual instances of services or applications.
        :param Mapping[str, str] extract_fields: Enable custom data extraction from log entries for enhanced querying and analysis.
        :param int retention_days: Length, in days, for how log data is kept before it is automatically deleted.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "stream_name", stream_name)
        if extract_fields is not None:
            pulumi.set(__self__, "extract_fields", extract_fields)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        Full Link to a secret of type `opaque`.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> str:
        """
        A container for log streams with common settings like retention. Used to categorize logs by application or service type.
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Valid AWS region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        """
        A sequence of log events from the same source within a log group. Typically represents individual instances of services or applications.
        """
        return pulumi.get(self, "stream_name")

    @property
    @pulumi.getter(name="extractFields")
    def extract_fields(self) -> Optional[Mapping[str, str]]:
        """
        Enable custom data extraction from log entries for enhanced querying and analysis.
        """
        return pulumi.get(self, "extract_fields")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[int]:
        """
        Length, in days, for how log data is kept before it is automatically deleted.
        """
        return pulumi.get(self, "retention_days")


@pulumi.output_type
class OrgLoggingCoralogixLogging(dict):
    def __init__(__self__, *,
                 app: str,
                 cluster: str,
                 credentials: str,
                 subsystem: str):
        """
        :param str app: App name to be displayed in Coralogix dashboard.
        :param str cluster: Coralogix cluster URI.
        :param str credentials: Full link to referenced Opaque Secret.
        :param str subsystem: Subsystem name to be displayed in Coralogix dashboard.
        """
        pulumi.set(__self__, "app", app)
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "subsystem", subsystem)

    @property
    @pulumi.getter
    def app(self) -> str:
        """
        App name to be displayed in Coralogix dashboard.
        """
        return pulumi.get(self, "app")

    @property
    @pulumi.getter
    def cluster(self) -> str:
        """
        Coralogix cluster URI.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        Full link to referenced Opaque Secret.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def subsystem(self) -> str:
        """
        Subsystem name to be displayed in Coralogix dashboard.
        """
        return pulumi.get(self, "subsystem")


@pulumi.output_type
class OrgLoggingDatadogLogging(dict):
    def __init__(__self__, *,
                 credentials: str,
                 host: str):
        """
        :param str credentials: Full link to referenced Opaque Secret.
        :param str host: Datadog host URI.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        Full link to referenced Opaque Secret.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Datadog host URI.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class OrgLoggingElasticLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticCloud":
            suggest = "elastic_cloud"
        elif key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLoggingElasticLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLoggingElasticLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLoggingElasticLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws: Optional['outputs.OrgLoggingElasticLoggingAws'] = None,
                 elastic_cloud: Optional['outputs.OrgLoggingElasticLoggingElasticCloud'] = None,
                 generic: Optional['outputs.OrgLoggingElasticLoggingGeneric'] = None,
                 placeholder_attribute: Optional[bool] = None):
        """
        :param 'OrgLoggingElasticLoggingAwsArgs' aws: For targeting Amazon Web Services (AWS) ElasticSearch.
        :param 'OrgLoggingElasticLoggingElasticCloudArgs' elastic_cloud: For targeting Elastic Cloud.
        :param 'OrgLoggingElasticLoggingGenericArgs' generic: For targeting generic Elastic Search providers.
        """
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if elastic_cloud is not None:
            pulumi.set(__self__, "elastic_cloud", elastic_cloud)
        if generic is not None:
            pulumi.set(__self__, "generic", generic)
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)

    @property
    @pulumi.getter
    def aws(self) -> Optional['outputs.OrgLoggingElasticLoggingAws']:
        """
        For targeting Amazon Web Services (AWS) ElasticSearch.
        """
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter(name="elasticCloud")
    def elastic_cloud(self) -> Optional['outputs.OrgLoggingElasticLoggingElasticCloud']:
        """
        For targeting Elastic Cloud.
        """
        return pulumi.get(self, "elastic_cloud")

    @property
    @pulumi.getter
    def generic(self) -> Optional['outputs.OrgLoggingElasticLoggingGeneric']:
        """
        For targeting generic Elastic Search providers.
        """
        return pulumi.get(self, "generic")

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")


@pulumi.output_type
class OrgLoggingElasticLoggingAws(dict):
    def __init__(__self__, *,
                 credentials: str,
                 host: str,
                 index: str,
                 port: int,
                 region: str,
                 type: str):
        """
        :param str credentials: Full Link to a secret of type `aws`.
        :param str host: A valid AWS ElasticSearch hostname (must end with es.amazonaws.com).
        :param str index: Logging Index.
        :param int port: Port. Default: 443
        :param str region: Valid AWS region.
        :param str type: Logging Type.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        Full Link to a secret of type `aws`.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        A valid AWS ElasticSearch hostname (must end with es.amazonaws.com).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        Logging Index.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port. Default: 443
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Valid AWS region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OrgLoggingElasticLoggingElasticCloud(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudId":
            suggest = "cloud_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLoggingElasticLoggingElasticCloud. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLoggingElasticLoggingElasticCloud.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLoggingElasticLoggingElasticCloud.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_id: str,
                 credentials: str,
                 index: str,
                 type: str):
        """
        :param str cloud_id: [Cloud ID](https://www.elastic.co/guide/en/cloud/current/ec-cloud-id.html)
        :param str credentials: Full Link to a secret of type `userpass`.
        :param str index: Logging Index.
        :param str type: Logging Type.
        """
        pulumi.set(__self__, "cloud_id", cloud_id)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cloudId")
    def cloud_id(self) -> str:
        """
        [Cloud ID](https://www.elastic.co/guide/en/cloud/current/ec-cloud-id.html)
        """
        return pulumi.get(self, "cloud_id")

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        Full Link to a secret of type `userpass`.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        Logging Index.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OrgLoggingElasticLoggingGeneric(dict):
    def __init__(__self__, *,
                 credentials: str,
                 host: str,
                 index: str,
                 path: str,
                 port: int,
                 type: str):
        """
        :param str credentials: Full Link to a secret of type `userpass`.
        :param str host: A valid Elastic Search provider hostname.
        :param str index: Logging Index.
        :param str path: Logging path.
        :param int port: Port. Default: 443
        :param str type: Logging Type.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        Full Link to a secret of type `userpass`.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        A valid Elastic Search provider hostname.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        Logging Index.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Logging path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port. Default: 443
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OrgLoggingFluentdLogging(dict):
    def __init__(__self__, *,
                 host: str,
                 port: Optional[int] = None):
        """
        :param str host: The hostname or IP address of a remote log storage system.
        :param int port: Port. Default: 24224
        """
        pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname or IP address of a remote log storage system.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port. Default: 24224
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class OrgLoggingLogzioLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listenerHost":
            suggest = "listener_host"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLoggingLogzioLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLoggingLogzioLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLoggingLogzioLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: str,
                 listener_host: str):
        """
        :param str credentials: Full link to referenced Opaque Secret.
        :param str listener_host: Logzio listener host URI.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "listener_host", listener_host)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        Full link to referenced Opaque Secret.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="listenerHost")
    def listener_host(self) -> str:
        """
        Logzio listener host URI.
        """
        return pulumi.get(self, "listener_host")


@pulumi.output_type
class OrgLoggingS3Logging(dict):
    def __init__(__self__, *,
                 bucket: str,
                 credentials: str,
                 region: str,
                 prefix: Optional[str] = None):
        """
        :param str bucket: Name of S3 bucket.
        :param str credentials: Full link to referenced AWS Secret.
        :param str region: AWS region where bucket is located.
        :param str prefix: Bucket path prefix. Default: "/".
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "region", region)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of S3 bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        Full link to referenced AWS Secret.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        AWS region where bucket is located.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Bucket path prefix. Default: "/".
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class OrgLoggingStackdriverLogging(dict):
    def __init__(__self__, *,
                 credentials: str,
                 location: str):
        """
        :param str credentials: Full Link to a secret of type `opaque`.
        :param str location: A Google Cloud Provider region.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        Full Link to a secret of type `opaque`.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        A Google Cloud Provider region.
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class OrgLoggingSyslogLogging(dict):
    def __init__(__self__, *,
                 host: str,
                 port: int,
                 format: Optional[str] = None,
                 mode: Optional[str] = None,
                 severity: Optional[int] = None):
        """
        :param str host: Hostname of Syslog Endpoint.
        :param int port: Port of Syslog Endpoint.
        :param str format: Log Format. Valid values: RFC3164 or RFC5424.
        :param str mode: Log Mode. Valid values: TCP, TLS, or UDP.
        :param int severity: Severity Level. See documentation for details. Valid values: 0 to 7.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of Syslog Endpoint.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port of Syslog Endpoint.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        Log Format. Valid values: RFC3164 or RFC5424.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Log Mode. Valid values: TCP, TLS, or UDP.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def severity(self) -> Optional[int]:
        """
        Severity Level. See documentation for details. Valid values: 0 to 7.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class OrgObservability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logsRetentionDays":
            suggest = "logs_retention_days"
        elif key == "metricsRetentionDays":
            suggest = "metrics_retention_days"
        elif key == "tracesRetentionDays":
            suggest = "traces_retention_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgObservability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgObservability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgObservability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs_retention_days: Optional[int] = None,
                 metrics_retention_days: Optional[int] = None,
                 traces_retention_days: Optional[int] = None):
        """
        :param int logs_retention_days: Log retention days. Default: 30
        :param int metrics_retention_days: Metrics retention days. Default: 30
        :param int traces_retention_days: Traces retention days. Default: 30
        """
        if logs_retention_days is not None:
            pulumi.set(__self__, "logs_retention_days", logs_retention_days)
        if metrics_retention_days is not None:
            pulumi.set(__self__, "metrics_retention_days", metrics_retention_days)
        if traces_retention_days is not None:
            pulumi.set(__self__, "traces_retention_days", traces_retention_days)

    @property
    @pulumi.getter(name="logsRetentionDays")
    def logs_retention_days(self) -> Optional[int]:
        """
        Log retention days. Default: 30
        """
        return pulumi.get(self, "logs_retention_days")

    @property
    @pulumi.getter(name="metricsRetentionDays")
    def metrics_retention_days(self) -> Optional[int]:
        """
        Metrics retention days. Default: 30
        """
        return pulumi.get(self, "metrics_retention_days")

    @property
    @pulumi.getter(name="tracesRetentionDays")
    def traces_retention_days(self) -> Optional[int]:
        """
        Traces retention days. Default: 30
        """
        return pulumi.get(self, "traces_retention_days")


@pulumi.output_type
class OrgSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"
        elif key == "threatDetection":
            suggest = "threat_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 threat_detection: Optional['outputs.OrgSecurityThreatDetection'] = None):
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if threat_detection is not None:
            pulumi.set(__self__, "threat_detection", threat_detection)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter(name="threatDetection")
    def threat_detection(self) -> Optional['outputs.OrgSecurityThreatDetection']:
        return pulumi.get(self, "threat_detection")


@pulumi.output_type
class OrgSecurityThreatDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumSeverity":
            suggest = "minimum_severity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgSecurityThreatDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgSecurityThreatDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgSecurityThreatDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 minimum_severity: Optional[str] = None,
                 syslog: Optional['outputs.OrgSecurityThreatDetectionSyslog'] = None):
        """
        :param bool enabled: Indicates whether threat detection should be forwarded or not.
        :param str minimum_severity: Any threats with this severity and more severe will be sent. Others will be ignored. Valid values: `warning`, `error`, or `critical`.
        :param 'OrgSecurityThreatDetectionSyslogArgs' syslog: Configuration for syslog forwarding.
        """
        pulumi.set(__self__, "enabled", enabled)
        if minimum_severity is not None:
            pulumi.set(__self__, "minimum_severity", minimum_severity)
        if syslog is not None:
            pulumi.set(__self__, "syslog", syslog)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Indicates whether threat detection should be forwarded or not.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="minimumSeverity")
    def minimum_severity(self) -> Optional[str]:
        """
        Any threats with this severity and more severe will be sent. Others will be ignored. Valid values: `warning`, `error`, or `critical`.
        """
        return pulumi.get(self, "minimum_severity")

    @property
    @pulumi.getter
    def syslog(self) -> Optional['outputs.OrgSecurityThreatDetectionSyslog']:
        """
        Configuration for syslog forwarding.
        """
        return pulumi.get(self, "syslog")


@pulumi.output_type
class OrgSecurityThreatDetectionSyslog(dict):
    def __init__(__self__, *,
                 host: str,
                 port: int,
                 transport: Optional[str] = None):
        """
        :param str host: The hostname to send syslog messages to.
        :param int port: The port to send syslog messages to.
        :param str transport: The transport-layer protocol to send the syslog messages over. If TCP is chosen, messages will be sent with TLS. Default: `tcp`.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        if transport is not None:
            pulumi.set(__self__, "transport", transport)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname to send syslog messages to.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port to send syslog messages to.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def transport(self) -> Optional[str]:
        """
        The transport-layer protocol to send the syslog messages over. If TCP is chosen, messages will be sent with TLS. Default: `tcp`.
        """
        return pulumi.get(self, "transport")


@pulumi.output_type
class OrgStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountLink":
            suggest = "account_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_link: Optional[str] = None,
                 active: Optional[bool] = None):
        """
        :param str account_link: The link of the account the org belongs to.
        :param bool active: Indicates whether the org is active or not.
        """
        if account_link is not None:
            pulumi.set(__self__, "account_link", account_link)
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter(name="accountLink")
    def account_link(self) -> Optional[str]:
        """
        The link of the account the org belongs to.
        """
        return pulumi.get(self, "account_link")

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        Indicates whether the org is active or not.
        """
        return pulumi.get(self, "active")


@pulumi.output_type
class OrgTracingControlplaneTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgTracingControlplaneTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgTracingControlplaneTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgTracingControlplaneTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling: float,
                 custom_tags: Optional[Mapping[str, str]] = None):
        """
        :param float sampling: Determines what percentage of requests should be traced.
        :param Mapping[str, str] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "sampling", sampling)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter
    def sampling(self) -> float:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class OrgTracingLightstepTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgTracingLightstepTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgTracingLightstepTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgTracingLightstepTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 sampling: float,
                 credentials: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None):
        """
        :param str endpoint: Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        :param float sampling: Determines what percentage of requests should be traced.
        :param str credentials: Full link to referenced Opaque Secret.
        :param Mapping[str, str] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "sampling", sampling)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> float:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def credentials(self) -> Optional[str]:
        """
        Full link to referenced Opaque Secret.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class OrgTracingOtelTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgTracingOtelTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgTracingOtelTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgTracingOtelTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 sampling: float,
                 custom_tags: Optional[Mapping[str, str]] = None):
        """
        :param str endpoint: Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        :param float sampling: Determines what percentage of requests should be traced.
        :param Mapping[str, str] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "sampling", sampling)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> float:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class PolicyBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalLinks":
            suggest = "principal_links"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permissions: Sequence[str],
                 principal_links: Sequence[str]):
        """
        :param Sequence[str] permissions: List of permissions to allow.
        :param Sequence[str] principal_links: List of the principals this binding will be applied to. Principal links format: `group/GROUP_NAME`, `user/USER_EMAIL`, `gvc/GVC_NAME/identity/IDENTITY_NAME`, `serviceaccount/SERVICE_ACCOUNT_NAME`.
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "principal_links", principal_links)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        """
        List of permissions to allow.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter(name="principalLinks")
    def principal_links(self) -> Sequence[str]:
        """
        List of the principals this binding will be applied to. Principal links format: `group/GROUP_NAME`, `user/USER_EMAIL`, `gvc/GVC_NAME/identity/IDENTITY_NAME`, `serviceaccount/SERVICE_ACCOUNT_NAME`.
        """
        return pulumi.get(self, "principal_links")


@pulumi.output_type
class PolicyTargetQuery(dict):
    def __init__(__self__, *,
                 fetch: Optional[str] = None,
                 spec: Optional['outputs.PolicyTargetQuerySpec'] = None):
        """
        :param str fetch: Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        if fetch is not None:
            pulumi.set(__self__, "fetch", fetch)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def fetch(self) -> Optional[str]:
        """
        Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        return pulumi.get(self, "fetch")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.PolicyTargetQuerySpec']:
        return pulumi.get(self, "spec")


@pulumi.output_type
class PolicyTargetQuerySpec(dict):
    def __init__(__self__, *,
                 match: Optional[str] = None,
                 terms: Optional[Sequence['outputs.PolicyTargetQuerySpecTerm']] = None):
        """
        :param str match: Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        :param Sequence['PolicyTargetQuerySpecTermArgs'] terms: Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if terms is not None:
            pulumi.set(__self__, "terms", terms)

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def terms(self) -> Optional[Sequence['outputs.PolicyTargetQuerySpecTerm']]:
        """
        Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
        return pulumi.get(self, "terms")


@pulumi.output_type
class PolicyTargetQuerySpecTerm(dict):
    def __init__(__self__, *,
                 op: Optional[str] = None,
                 property: Optional[str] = None,
                 rel: Optional[str] = None,
                 tag: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str op: Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        :param str property: Property to use for query evaluation.
        :param str tag: Tag key to use for query evaluation.
        :param str value: Testing value for query evaluation.
        """
        if op is not None:
            pulumi.set(__self__, "op", op)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        """
        Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def rel(self) -> Optional[str]:
        return pulumi.get(self, "rel")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Tag key to use for query evaluation.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Testing value for query evaluation.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        Property to use for query evaluation.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class SecretAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 secret_key: str,
                 external_id: Optional[str] = None,
                 role_arn: Optional[str] = None):
        """
        :param str access_key: Access Key provided by AWS.
        :param str secret_key: Secret Key provided by AWS.
        :param str external_id: AWS IAM Role External ID.
        :param str role_arn: Role ARN provided by AWS.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "secret_key", secret_key)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        Access Key provided by AWS.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        Secret Key provided by AWS.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        AWS IAM Role External ID.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Role ARN provided by AWS.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class SecretAzureConnector(dict):
    def __init__(__self__, *,
                 code: str,
                 url: str):
        """
        :param str code: Code/Key to authenticate to deployment URL.
        :param str url: Deployment URL.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Code/Key to authenticate to deployment URL.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Deployment URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SecretEcr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretEcr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretEcr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretEcr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 repos: Sequence[str],
                 secret_key: str,
                 external_id: Optional[str] = None,
                 role_arn: Optional[str] = None):
        """
        :param str access_key: Access Key provided by AWS.
        :param Sequence[str] repos: List of ECR repositories.
        :param str secret_key: Secret Key provided by AWS.
        :param str external_id: AWS IAM Role External ID. Used when setting up cross-account access to your ECR repositories.
        :param str role_arn: Role ARN provided by AWS.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "repos", repos)
        pulumi.set(__self__, "secret_key", secret_key)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        Access Key provided by AWS.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def repos(self) -> Sequence[str]:
        """
        List of ECR repositories.
        """
        return pulumi.get(self, "repos")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        Secret Key provided by AWS.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        AWS IAM Role External ID. Used when setting up cross-account access to your ECR repositories.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Role ARN provided by AWS.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class SecretKeypair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKey":
            suggest = "secret_key"
        elif key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretKeypair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretKeypair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretKeypair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_key: str,
                 passphrase: Optional[str] = None,
                 public_key: Optional[str] = None):
        """
        :param str secret_key: Secret/Private Key.
        :param str passphrase: Passphrase for private key.
        :param str public_key: Public Key.
        """
        pulumi.set(__self__, "secret_key", secret_key)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        Secret/Private Key.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[str]:
        """
        Passphrase for private key.
        """
        return pulumi.get(self, "passphrase")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        """
        Public Key.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class SecretNatsAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretNatsAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretNatsAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretNatsAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 private_key: str):
        """
        :param str account_id: Account ID.
        :param str private_key: Private Key.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Account ID.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Private Key.
        """
        return pulumi.get(self, "private_key")


@pulumi.output_type
class SecretOpaque(dict):
    def __init__(__self__, *,
                 payload: str,
                 encoding: Optional[str] = None):
        """
        :param str payload: Plain text or base64 encoded string. Use `encoding` attribute to specify encoding.
        :param str encoding: Available encodings: `plain`, `base64`. Default: `plain`.
        """
        pulumi.set(__self__, "payload", payload)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        Plain text or base64 encoded string. Use `encoding` attribute to specify encoding.
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        Available encodings: `plain`, `base64`. Default: `plain`.
        """
        return pulumi.get(self, "encoding")


@pulumi.output_type
class SecretTls(dict):
    def __init__(__self__, *,
                 cert: str,
                 key: str,
                 chain: Optional[str] = None):
        """
        :param str cert: Public Certificate.
        :param str key: Private Certificate.
        :param str chain: Chain Certificate.
        """
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)
        if chain is not None:
            pulumi.set(__self__, "chain", chain)

    @property
    @pulumi.getter
    def cert(self) -> str:
        """
        Public Certificate.
        """
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Private Certificate.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def chain(self) -> Optional[str]:
        """
        Chain Certificate.
        """
        return pulumi.get(self, "chain")


@pulumi.output_type
class SecretUserpass(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str,
                 encoding: Optional[str] = None):
        """
        :param str password: Password.
        :param str username: Username.
        :param str encoding: Available encodings: `plain`, `base64`. Default: `plain`.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        Available encodings: `plain`, `base64`. Default: `plain`.
        """
        return pulumi.get(self, "encoding")


@pulumi.output_type
class VolumeSetAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "minFreePercentage":
            suggest = "min_free_percentage"
        elif key == "scalingFactor":
            suggest = "scaling_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSetAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSetAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSetAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_capacity: Optional[int] = None,
                 min_free_percentage: Optional[int] = None,
                 scaling_factor: Optional[float] = None):
        """
        :param int max_capacity: The maximum size in GB for a volume in this set. A volume cannot grow to be bigger than this value. Minimum value: `10`.
        :param int min_free_percentage: The guaranteed free space on the volume as a percentage of the volume's total size. Control Plane will try to maintain at least that many percent free by scaling up the total size. Minimum percentage: `1`. Maximum Percentage: `100`.
        :param float scaling_factor: When scaling is necessary, then `new_capacity = current_capacity * storageScalingFactor`. Minimum value: `1.1`.
        """
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_free_percentage is not None:
            pulumi.set(__self__, "min_free_percentage", min_free_percentage)
        if scaling_factor is not None:
            pulumi.set(__self__, "scaling_factor", scaling_factor)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[int]:
        """
        The maximum size in GB for a volume in this set. A volume cannot grow to be bigger than this value. Minimum value: `10`.
        """
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minFreePercentage")
    def min_free_percentage(self) -> Optional[int]:
        """
        The guaranteed free space on the volume as a percentage of the volume's total size. Control Plane will try to maintain at least that many percent free by scaling up the total size. Minimum percentage: `1`. Maximum Percentage: `100`.
        """
        return pulumi.get(self, "min_free_percentage")

    @property
    @pulumi.getter(name="scalingFactor")
    def scaling_factor(self) -> Optional[float]:
        """
        When scaling is necessary, then `new_capacity = current_capacity * storageScalingFactor`. Minimum value: `1.1`.
        """
        return pulumi.get(self, "scaling_factor")


@pulumi.output_type
class VolumeSetSnapshots(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createFinalSnapshot":
            suggest = "create_final_snapshot"
        elif key == "retentionDuration":
            suggest = "retention_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSetSnapshots. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSetSnapshots.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSetSnapshots.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_final_snapshot: Optional[bool] = None,
                 retention_duration: Optional[str] = None,
                 schedule: Optional[str] = None):
        """
        :param bool create_final_snapshot: If true, a volume snapshot will be created immediately before deletion of any volume in this set. Default: `true`
        :param str retention_duration: The default retention period for volume snapshots. This string should contain a floating point number followed by either d, h, or m. For example, "10d" would retain snapshots for 10 days.
        :param str schedule: A standard cron schedule expression used to determine when a snapshot will be taken. (i.e., `0 * * * *` Every hour). Note: snapshots cannot be scheduled more often than once per hour.
        """
        if create_final_snapshot is not None:
            pulumi.set(__self__, "create_final_snapshot", create_final_snapshot)
        if retention_duration is not None:
            pulumi.set(__self__, "retention_duration", retention_duration)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter(name="createFinalSnapshot")
    def create_final_snapshot(self) -> Optional[bool]:
        """
        If true, a volume snapshot will be created immediately before deletion of any volume in this set. Default: `true`
        """
        return pulumi.get(self, "create_final_snapshot")

    @property
    @pulumi.getter(name="retentionDuration")
    def retention_duration(self) -> Optional[str]:
        """
        The default retention period for volume snapshots. This string should contain a floating point number followed by either d, h, or m. For example, "10d" would retain snapshots for 10 days.
        """
        return pulumi.get(self, "retention_duration")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[str]:
        """
        A standard cron schedule expression used to determine when a snapshot will be taken. (i.e., `0 * * * *` Every hour). Note: snapshots cannot be scheduled more often than once per hour.
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class VolumeSetStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindingId":
            suggest = "binding_id"
        elif key == "parentId":
            suggest = "parent_id"
        elif key == "usedByWorkload":
            suggest = "used_by_workload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSetStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSetStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSetStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 binding_id: Optional[str] = None,
                 locations: Optional[Sequence[str]] = None,
                 parent_id: Optional[str] = None,
                 used_by_workload: Optional[str] = None):
        """
        :param str binding_id: Uniquely identifies the connection between the volume set and its workload. Every time a new connection is made, a new id is generated (e.g., If a workload is updated to remove the volume set, then updated again to reattach it, the volume set will have a new binding id).
        :param Sequence[str] locations: Contains a list of actual volumes grouped by location.
        :param str parent_id: The GVC ID.
        :param str used_by_workload: The url of the workload currently using this volume set (if any).
        """
        if binding_id is not None:
            pulumi.set(__self__, "binding_id", binding_id)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if parent_id is not None:
            pulumi.set(__self__, "parent_id", parent_id)
        if used_by_workload is not None:
            pulumi.set(__self__, "used_by_workload", used_by_workload)

    @property
    @pulumi.getter(name="bindingId")
    def binding_id(self) -> Optional[str]:
        """
        Uniquely identifies the connection between the volume set and its workload. Every time a new connection is made, a new id is generated (e.g., If a workload is updated to remove the volume set, then updated again to reattach it, the volume set will have a new binding id).
        """
        return pulumi.get(self, "binding_id")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        """
        Contains a list of actual volumes grouped by location.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> Optional[str]:
        """
        The GVC ID.
        """
        return pulumi.get(self, "parent_id")

    @property
    @pulumi.getter(name="usedByWorkload")
    def used_by_workload(self) -> Optional[str]:
        """
        The url of the workload currently using this volume set (if any).
        """
        return pulumi.get(self, "used_by_workload")


@pulumi.output_type
class WorkloadContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gpuNvidia":
            suggest = "gpu_nvidia"
        elif key == "inheritEnv":
            suggest = "inherit_env"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "minCpu":
            suggest = "min_cpu"
        elif key == "minMemory":
            suggest = "min_memory"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "workingDirectory":
            suggest = "working_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: str,
                 name: str,
                 args: Optional[Sequence[str]] = None,
                 command: Optional[str] = None,
                 cpu: Optional[str] = None,
                 env: Optional[Mapping[str, str]] = None,
                 gpu_nvidia: Optional['outputs.WorkloadContainerGpuNvidia'] = None,
                 inherit_env: Optional[bool] = None,
                 lifecycle: Optional['outputs.WorkloadContainerLifecycle'] = None,
                 liveness_probe: Optional['outputs.WorkloadContainerLivenessProbe'] = None,
                 memory: Optional[str] = None,
                 metrics: Optional['outputs.WorkloadContainerMetrics'] = None,
                 min_cpu: Optional[str] = None,
                 min_memory: Optional[str] = None,
                 port: Optional[int] = None,
                 ports: Optional[Sequence['outputs.WorkloadContainerPort']] = None,
                 readiness_probe: Optional['outputs.WorkloadContainerReadinessProbe'] = None,
                 volumes: Optional[Sequence['outputs.WorkloadContainerVolume']] = None,
                 working_directory: Optional[str] = None):
        """
        :param str image: The full image and tag path.
        :param str name: Name of the container.
        :param Sequence[str] args: Command line arguments passed to the container at runtime.
        :param str command: Override the entry point.
        :param str cpu: Reserved CPU of the workload when capacityAI is disabled. Maximum CPU when CapacityAI is enabled. Default: "50m".
        :param Mapping[str, str] env: Name-Value list of environment variables.
        :param 'WorkloadContainerGpuNvidiaArgs' gpu_nvidia: GPUs manufactured by NVIDIA, which are specialized hardware accelerators used to offload and accelerate computationally intensive tasks within the workload.
        :param bool inherit_env: Enables inheritance of GVC environment variables. A variable in spec.env will override a GVC variable with the same name.
        :param 'WorkloadContainerLifecycleArgs' lifecycle: Lifecycle [Reference Page](https://docs.controlplane.com/reference/workload#lifecycle).
        :param 'WorkloadContainerLivenessProbeArgs' liveness_probe: Liveness Probe
        :param str memory: Reserved memory of the workload when capacityAI is disabled. Maximum memory when CapacityAI is enabled. Default: "128Mi".
        :param 'WorkloadContainerMetricsArgs' metrics: [Reference Page](https://docs.controlplane.com/reference/workload#metrics).
        :param str min_cpu: Minimum CPU when capacity AI is enabled.
        :param str min_memory: Minimum memory when capacity AI is enabled.
        :param int port: The port the container exposes. Only one container is allowed to specify a port. Min: `80`. Max: `65535`. Used by `serverless` Workload type. **DEPRECATED - Use `ports`.**
        :param Sequence['WorkloadContainerPortArgs'] ports: Communication endpoints used by the workload to send and receive network traffic.
        :param 'WorkloadContainerReadinessProbeArgs' readiness_probe: Readiness Probe
        :param Sequence['WorkloadContainerVolumeArgs'] volumes: [Reference Page](https://docs.controlplane.com/reference/workload#volumes).
        :param str working_directory: Override the working directory. Must be an absolute path.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "name", name)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if gpu_nvidia is not None:
            pulumi.set(__self__, "gpu_nvidia", gpu_nvidia)
        if inherit_env is not None:
            pulumi.set(__self__, "inherit_env", inherit_env)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        The full image and tag path.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the container.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Command line arguments passed to the container at runtime.
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def command(self) -> Optional[str]:
        """
        Override the entry point.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def cpu(self) -> Optional[str]:
        """
        Reserved CPU of the workload when capacityAI is disabled. Maximum CPU when CapacityAI is enabled. Default: "50m".
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def env(self) -> Optional[Mapping[str, str]]:
        """
        Name-Value list of environment variables.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="gpuNvidia")
    def gpu_nvidia(self) -> Optional['outputs.WorkloadContainerGpuNvidia']:
        """
        GPUs manufactured by NVIDIA, which are specialized hardware accelerators used to offload and accelerate computationally intensive tasks within the workload.
        """
        return pulumi.get(self, "gpu_nvidia")

    @property
    @pulumi.getter(name="inheritEnv")
    def inherit_env(self) -> Optional[bool]:
        """
        Enables inheritance of GVC environment variables. A variable in spec.env will override a GVC variable with the same name.
        """
        return pulumi.get(self, "inherit_env")

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional['outputs.WorkloadContainerLifecycle']:
        """
        Lifecycle [Reference Page](https://docs.controlplane.com/reference/workload#lifecycle).
        """
        return pulumi.get(self, "lifecycle")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.WorkloadContainerLivenessProbe']:
        """
        Liveness Probe
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def memory(self) -> Optional[str]:
        """
        Reserved memory of the workload when capacityAI is disabled. Maximum memory when CapacityAI is enabled. Default: "128Mi".
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def metrics(self) -> Optional['outputs.WorkloadContainerMetrics']:
        """
        [Reference Page](https://docs.controlplane.com/reference/workload#metrics).
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[str]:
        """
        Minimum CPU when capacity AI is enabled.
        """
        return pulumi.get(self, "min_cpu")

    @property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[str]:
        """
        Minimum memory when capacity AI is enabled.
        """
        return pulumi.get(self, "min_memory")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The 'port' attribute will be deprecated in the next major version. Use the 'ports' attribute instead.""")
    def port(self) -> Optional[int]:
        """
        The port the container exposes. Only one container is allowed to specify a port. Min: `80`. Max: `65535`. Used by `serverless` Workload type. **DEPRECATED - Use `ports`.**
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.WorkloadContainerPort']]:
        """
        Communication endpoints used by the workload to send and receive network traffic.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.WorkloadContainerReadinessProbe']:
        """
        Readiness Probe
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.WorkloadContainerVolume']]:
        """
        [Reference Page](https://docs.controlplane.com/reference/workload#volumes).
        """
        return pulumi.get(self, "volumes")

    @property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[str]:
        """
        Override the working directory. Must be an absolute path.
        """
        return pulumi.get(self, "working_directory")


@pulumi.output_type
class WorkloadContainerGpuNvidia(dict):
    def __init__(__self__, *,
                 model: str,
                 quantity: int):
        """
        :param str model: GPU Model (i.e.: t4)
        :param int quantity: Number of GPUs.
        """
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "quantity", quantity)

    @property
    @pulumi.getter
    def model(self) -> str:
        """
        GPU Model (i.e.: t4)
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter
    def quantity(self) -> int:
        """
        Number of GPUs.
        """
        return pulumi.get(self, "quantity")


@pulumi.output_type
class WorkloadContainerLifecycle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"
        elif key == "postStart":
            suggest = "post_start"
        elif key == "preStop":
            suggest = "pre_stop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLifecycle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLifecycle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLifecycle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 post_start: Optional['outputs.WorkloadContainerLifecyclePostStart'] = None,
                 pre_stop: Optional['outputs.WorkloadContainerLifecyclePreStop'] = None):
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if post_start is not None:
            pulumi.set(__self__, "post_start", post_start)
        if pre_stop is not None:
            pulumi.set(__self__, "pre_stop", pre_stop)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter(name="postStart")
    def post_start(self) -> Optional['outputs.WorkloadContainerLifecyclePostStart']:
        return pulumi.get(self, "post_start")

    @property
    @pulumi.getter(name="preStop")
    def pre_stop(self) -> Optional['outputs.WorkloadContainerLifecyclePreStop']:
        return pulumi.get(self, "pre_stop")


@pulumi.output_type
class WorkloadContainerLifecyclePostStart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLifecyclePostStart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLifecyclePostStart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLifecyclePostStart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: 'outputs.WorkloadContainerLifecyclePostStartExec'):
        pulumi.set(__self__, "exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> 'outputs.WorkloadContainerLifecyclePostStartExec':
        return pulumi.get(self, "exec_")


@pulumi.output_type
class WorkloadContainerLifecyclePostStartExec(dict):
    def __init__(__self__, *,
                 commands: Sequence[str]):
        pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")


@pulumi.output_type
class WorkloadContainerLifecyclePreStop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLifecyclePreStop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLifecyclePreStop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLifecyclePreStop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: 'outputs.WorkloadContainerLifecyclePreStopExec'):
        pulumi.set(__self__, "exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> 'outputs.WorkloadContainerLifecyclePreStopExec':
        return pulumi.get(self, "exec_")


@pulumi.output_type
class WorkloadContainerLifecyclePreStopExec(dict):
    def __init__(__self__, *,
                 commands: Sequence[str]):
        pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")


@pulumi.output_type
class WorkloadContainerLivenessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLivenessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLivenessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLivenessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.WorkloadContainerLivenessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpc: Optional['outputs.WorkloadContainerLivenessProbeGrpc'] = None,
                 http_get: Optional['outputs.WorkloadContainerLivenessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_socket: Optional['outputs.WorkloadContainerLivenessProbeTcpSocket'] = None,
                 timeout_seconds: Optional[int] = None):
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpc is not None:
            pulumi.set(__self__, "grpc", grpc)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.WorkloadContainerLivenessProbeExec']:
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpc(self) -> Optional['outputs.WorkloadContainerLivenessProbeGrpc']:
        return pulumi.get(self, "grpc")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.WorkloadContainerLivenessProbeHttpGet']:
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.WorkloadContainerLivenessProbeTcpSocket']:
        return pulumi.get(self, "tcp_socket")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadContainerLivenessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Sequence[str]):
        pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")


@pulumi.output_type
class WorkloadContainerLivenessProbeGrpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLivenessProbeGrpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLivenessProbeGrpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLivenessProbeGrpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 port: Optional[int] = None):
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerLivenessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLivenessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLivenessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLivenessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_headers: Optional[Mapping[str, str]] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None):
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        return pulumi.get(self, "scheme")


@pulumi.output_type
class WorkloadContainerLivenessProbeTcpSocket(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLivenessProbeTcpSocket. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLivenessProbeTcpSocket.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLivenessProbeTcpSocket.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 port: Optional[int] = None):
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerMetrics(dict):
    def __init__(__self__, *,
                 path: str,
                 port: int):
        """
        :param str path: Path from container emitting custom metrics
        :param int port: Port from container emitting custom metrics
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path from container emitting custom metrics
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port from container emitting custom metrics
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerPort(dict):
    def __init__(__self__, *,
                 number: int,
                 protocol: Optional[str] = None):
        """
        :param int number: Port to expose.
        :param str protocol: Protocol. Choice of: `http`, `http2`, `tcp`, or `grpc`.
        """
        pulumi.set(__self__, "number", number)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def number(self) -> int:
        """
        Port to expose.
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol. Choice of: `http`, `http2`, `tcp`, or `grpc`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class WorkloadContainerReadinessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerReadinessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerReadinessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerReadinessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.WorkloadContainerReadinessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpc: Optional['outputs.WorkloadContainerReadinessProbeGrpc'] = None,
                 http_get: Optional['outputs.WorkloadContainerReadinessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_socket: Optional['outputs.WorkloadContainerReadinessProbeTcpSocket'] = None,
                 timeout_seconds: Optional[int] = None):
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpc is not None:
            pulumi.set(__self__, "grpc", grpc)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.WorkloadContainerReadinessProbeExec']:
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpc(self) -> Optional['outputs.WorkloadContainerReadinessProbeGrpc']:
        return pulumi.get(self, "grpc")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.WorkloadContainerReadinessProbeHttpGet']:
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.WorkloadContainerReadinessProbeTcpSocket']:
        return pulumi.get(self, "tcp_socket")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadContainerReadinessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Sequence[str]):
        pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")


@pulumi.output_type
class WorkloadContainerReadinessProbeGrpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerReadinessProbeGrpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerReadinessProbeGrpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerReadinessProbeGrpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 port: Optional[int] = None):
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerReadinessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerReadinessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerReadinessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerReadinessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_headers: Optional[Mapping[str, str]] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None):
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        return pulumi.get(self, "scheme")


@pulumi.output_type
class WorkloadContainerReadinessProbeTcpSocket(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerReadinessProbeTcpSocket. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerReadinessProbeTcpSocket.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerReadinessProbeTcpSocket.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 port: Optional[int] = None):
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recoveryPolicy":
            suggest = "recovery_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 uri: str,
                 recovery_policy: Optional[str] = None):
        """
        :param str path: File path added to workload pointing to the volume.
        :param str uri: URI of a volume hosted at Control Plane (Volume Set) or at a cloud provider (AWS, Azure, GCP).
        :param str recovery_policy: Only applicable to persistent volumes, this determines what Control Plane will do when creating a new workload replica if a corresponding volume exists. Available Values: `retain`, `recycle`. Default: `retain`. **DEPRECATED - No longer being used.**
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "uri", uri)
        if recovery_policy is not None:
            pulumi.set(__self__, "recovery_policy", recovery_policy)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        File path added to workload pointing to the volume.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        URI of a volume hosted at Control Plane (Volume Set) or at a cloud provider (AWS, Azure, GCP).
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="recoveryPolicy")
    def recovery_policy(self) -> Optional[str]:
        """
        Only applicable to persistent volumes, this determines what Control Plane will do when creating a new workload replica if a corresponding volume exists. Available Values: `retain`, `recycle`. Default: `retain`. **DEPRECATED - No longer being used.**
        """
        return pulumi.get(self, "recovery_policy")


@pulumi.output_type
class WorkloadFirewallSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadFirewallSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadFirewallSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadFirewallSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external: Optional['outputs.WorkloadFirewallSpecExternal'] = None,
                 internal: Optional['outputs.WorkloadFirewallSpecInternal'] = None,
                 placeholder_attribute: Optional[bool] = None):
        """
        :param 'WorkloadFirewallSpecExternalArgs' external: The external firewall is used to control inbound and outbound access to the workload for public-facing traffic.
        :param 'WorkloadFirewallSpecInternalArgs' internal: The internal firewall is used to control access between workloads.
        """
        if external is not None:
            pulumi.set(__self__, "external", external)
        if internal is not None:
            pulumi.set(__self__, "internal", internal)
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)

    @property
    @pulumi.getter
    def external(self) -> Optional['outputs.WorkloadFirewallSpecExternal']:
        """
        The external firewall is used to control inbound and outbound access to the workload for public-facing traffic.
        """
        return pulumi.get(self, "external")

    @property
    @pulumi.getter
    def internal(self) -> Optional['outputs.WorkloadFirewallSpecInternal']:
        """
        The internal firewall is used to control access between workloads.
        """
        return pulumi.get(self, "internal")

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")


@pulumi.output_type
class WorkloadFirewallSpecExternal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inboundAllowCidrs":
            suggest = "inbound_allow_cidrs"
        elif key == "outboundAllowCidrs":
            suggest = "outbound_allow_cidrs"
        elif key == "outboundAllowHostnames":
            suggest = "outbound_allow_hostnames"
        elif key == "outboundAllowPorts":
            suggest = "outbound_allow_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadFirewallSpecExternal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadFirewallSpecExternal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadFirewallSpecExternal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inbound_allow_cidrs: Optional[Sequence[str]] = None,
                 outbound_allow_cidrs: Optional[Sequence[str]] = None,
                 outbound_allow_hostnames: Optional[Sequence[str]] = None,
                 outbound_allow_ports: Optional[Sequence['outputs.WorkloadFirewallSpecExternalOutboundAllowPort']] = None):
        """
        :param Sequence[str] inbound_allow_cidrs: The list of ipv4/ipv6 addresses or cidr blocks that are allowed to access this workload. No external access is allowed by default. Specify '0.0.0.0/0' to allow access to the public internet.
        :param Sequence[str] outbound_allow_cidrs: The list of ipv4/ipv6 addresses or cidr blocks that this workload is allowed reach. No outbound access is allowed by default. Specify '0.0.0.0/0' to allow outbound access to the public internet.
        :param Sequence[str] outbound_allow_hostnames: The list of public hostnames that this workload is allowed to reach. No outbound access is allowed by default. A wildcard `*` is allowed on the prefix of the hostname only, ex: `*.amazonaws.com`. Use `outboundAllowCIDR` to allow access to all external websites.
        :param Sequence['WorkloadFirewallSpecExternalOutboundAllowPortArgs'] outbound_allow_ports: Allow outbound access to specific ports and protocols. When not specified, communication to address ranges in outboundAllowCIDR is allowed on all ports and communication to names in outboundAllowHostname is allowed on ports 80/443.
        """
        if inbound_allow_cidrs is not None:
            pulumi.set(__self__, "inbound_allow_cidrs", inbound_allow_cidrs)
        if outbound_allow_cidrs is not None:
            pulumi.set(__self__, "outbound_allow_cidrs", outbound_allow_cidrs)
        if outbound_allow_hostnames is not None:
            pulumi.set(__self__, "outbound_allow_hostnames", outbound_allow_hostnames)
        if outbound_allow_ports is not None:
            pulumi.set(__self__, "outbound_allow_ports", outbound_allow_ports)

    @property
    @pulumi.getter(name="inboundAllowCidrs")
    def inbound_allow_cidrs(self) -> Optional[Sequence[str]]:
        """
        The list of ipv4/ipv6 addresses or cidr blocks that are allowed to access this workload. No external access is allowed by default. Specify '0.0.0.0/0' to allow access to the public internet.
        """
        return pulumi.get(self, "inbound_allow_cidrs")

    @property
    @pulumi.getter(name="outboundAllowCidrs")
    def outbound_allow_cidrs(self) -> Optional[Sequence[str]]:
        """
        The list of ipv4/ipv6 addresses or cidr blocks that this workload is allowed reach. No outbound access is allowed by default. Specify '0.0.0.0/0' to allow outbound access to the public internet.
        """
        return pulumi.get(self, "outbound_allow_cidrs")

    @property
    @pulumi.getter(name="outboundAllowHostnames")
    def outbound_allow_hostnames(self) -> Optional[Sequence[str]]:
        """
        The list of public hostnames that this workload is allowed to reach. No outbound access is allowed by default. A wildcard `*` is allowed on the prefix of the hostname only, ex: `*.amazonaws.com`. Use `outboundAllowCIDR` to allow access to all external websites.
        """
        return pulumi.get(self, "outbound_allow_hostnames")

    @property
    @pulumi.getter(name="outboundAllowPorts")
    def outbound_allow_ports(self) -> Optional[Sequence['outputs.WorkloadFirewallSpecExternalOutboundAllowPort']]:
        """
        Allow outbound access to specific ports and protocols. When not specified, communication to address ranges in outboundAllowCIDR is allowed on all ports and communication to names in outboundAllowHostname is allowed on ports 80/443.
        """
        return pulumi.get(self, "outbound_allow_ports")


@pulumi.output_type
class WorkloadFirewallSpecExternalOutboundAllowPort(dict):
    def __init__(__self__, *,
                 number: int,
                 protocol: str):
        """
        :param int number: Port number. Max: 65000
        :param str protocol: Either `http`, `https` or `tcp`. Default: `tcp`.
        """
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def number(self) -> int:
        """
        Port number. Max: 65000
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Either `http`, `https` or `tcp`. Default: `tcp`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class WorkloadFirewallSpecInternal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inboundAllowType":
            suggest = "inbound_allow_type"
        elif key == "inboundAllowWorkloads":
            suggest = "inbound_allow_workloads"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadFirewallSpecInternal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadFirewallSpecInternal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadFirewallSpecInternal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inbound_allow_type: Optional[str] = None,
                 inbound_allow_workloads: Optional[Sequence[str]] = None):
        """
        :param str inbound_allow_type: Used to control the internal firewall configuration and mutual tls. Allowed Values: "none", "same-gvc", "same-org", "workload-list".
        :param Sequence[str] inbound_allow_workloads: A list of specific workloads which are allowed to access this workload internally. This list is only used if the 'inboundAllowType' is set to 'workload-list'.
        """
        if inbound_allow_type is not None:
            pulumi.set(__self__, "inbound_allow_type", inbound_allow_type)
        if inbound_allow_workloads is not None:
            pulumi.set(__self__, "inbound_allow_workloads", inbound_allow_workloads)

    @property
    @pulumi.getter(name="inboundAllowType")
    def inbound_allow_type(self) -> Optional[str]:
        """
        Used to control the internal firewall configuration and mutual tls. Allowed Values: "none", "same-gvc", "same-org", "workload-list".
        """
        return pulumi.get(self, "inbound_allow_type")

    @property
    @pulumi.getter(name="inboundAllowWorkloads")
    def inbound_allow_workloads(self) -> Optional[Sequence[str]]:
        """
        A list of specific workloads which are allowed to access this workload internally. This list is only used if the 'inboundAllowType' is set to 'workload-list'.
        """
        return pulumi.get(self, "inbound_allow_workloads")


@pulumi.output_type
class WorkloadJob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDeadlineSeconds":
            suggest = "active_deadline_seconds"
        elif key == "concurrencyPolicy":
            suggest = "concurrency_policy"
        elif key == "historyLimit":
            suggest = "history_limit"
        elif key == "restartPolicy":
            suggest = "restart_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadJob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadJob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadJob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedule: str,
                 active_deadline_seconds: Optional[int] = None,
                 concurrency_policy: Optional[str] = None,
                 history_limit: Optional[int] = None,
                 restart_policy: Optional[str] = None):
        """
        :param str schedule: A standard cron [schedule expression](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#schedule-syntax) used to determine when your job should execute.
        :param int active_deadline_seconds: The maximum number of seconds Control Plane will wait for the job to complete. If a job does not succeed or fail in the allotted time, Control Plane will stop the job, moving it into the Removed status.
        :param str concurrency_policy: Either 'Forbid' or 'Replace'. This determines what Control Plane will do when the schedule requires a job to start, while a prior instance of the job is still running. Enum: [ Forbid, Replace ] Default: `Forbid`
        :param int history_limit: The maximum number of completed job instances to display. This should be an integer between 1 and 10. Default: `5`
        :param str restart_policy: Either 'OnFailure' or 'Never'. This determines what Control Plane will do when a job instance fails. Enum: [ OnFailure, Never ] Default: `Never`
        """
        pulumi.set(__self__, "schedule", schedule)
        if active_deadline_seconds is not None:
            pulumi.set(__self__, "active_deadline_seconds", active_deadline_seconds)
        if concurrency_policy is not None:
            pulumi.set(__self__, "concurrency_policy", concurrency_policy)
        if history_limit is not None:
            pulumi.set(__self__, "history_limit", history_limit)
        if restart_policy is not None:
            pulumi.set(__self__, "restart_policy", restart_policy)

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        A standard cron [schedule expression](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#schedule-syntax) used to determine when your job should execute.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> Optional[int]:
        """
        The maximum number of seconds Control Plane will wait for the job to complete. If a job does not succeed or fail in the allotted time, Control Plane will stop the job, moving it into the Removed status.
        """
        return pulumi.get(self, "active_deadline_seconds")

    @property
    @pulumi.getter(name="concurrencyPolicy")
    def concurrency_policy(self) -> Optional[str]:
        """
        Either 'Forbid' or 'Replace'. This determines what Control Plane will do when the schedule requires a job to start, while a prior instance of the job is still running. Enum: [ Forbid, Replace ] Default: `Forbid`
        """
        return pulumi.get(self, "concurrency_policy")

    @property
    @pulumi.getter(name="historyLimit")
    def history_limit(self) -> Optional[int]:
        """
        The maximum number of completed job instances to display. This should be an integer between 1 and 10. Default: `5`
        """
        return pulumi.get(self, "history_limit")

    @property
    @pulumi.getter(name="restartPolicy")
    def restart_policy(self) -> Optional[str]:
        """
        Either 'OnFailure' or 'Never'. This determines what Control Plane will do when a job instance fails. Enum: [ OnFailure, Never ] Default: `Never`
        """
        return pulumi.get(self, "restart_policy")


@pulumi.output_type
class WorkloadLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoLocation":
            suggest = "geo_location"
        elif key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direct: Optional['outputs.WorkloadLoadBalancerDirect'] = None,
                 geo_location: Optional['outputs.WorkloadLoadBalancerGeoLocation'] = None,
                 placeholder_attribute: Optional[bool] = None):
        if direct is not None:
            pulumi.set(__self__, "direct", direct)
        if geo_location is not None:
            pulumi.set(__self__, "geo_location", geo_location)
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)

    @property
    @pulumi.getter
    def direct(self) -> Optional['outputs.WorkloadLoadBalancerDirect']:
        return pulumi.get(self, "direct")

    @property
    @pulumi.getter(name="geoLocation")
    def geo_location(self) -> Optional['outputs.WorkloadLoadBalancerGeoLocation']:
        return pulumi.get(self, "geo_location")

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")


@pulumi.output_type
class WorkloadLoadBalancerDirect(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 ports: Optional[Sequence['outputs.WorkloadLoadBalancerDirectPort']] = None):
        pulumi.set(__self__, "enabled", enabled)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.WorkloadLoadBalancerDirectPort']]:
        return pulumi.get(self, "ports")


@pulumi.output_type
class WorkloadLoadBalancerDirectPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalPort":
            suggest = "external_port"
        elif key == "containerPort":
            suggest = "container_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadLoadBalancerDirectPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadLoadBalancerDirectPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadLoadBalancerDirectPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_port: int,
                 protocol: str,
                 container_port: Optional[int] = None,
                 scheme: Optional[str] = None):
        """
        :param str scheme: Override the default `https` url scheme.
        """
        pulumi.set(__self__, "external_port", external_port)
        pulumi.set(__self__, "protocol", protocol)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter(name="externalPort")
    def external_port(self) -> int:
        return pulumi.get(self, "external_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[int]:
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Override the default `https` url scheme.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class WorkloadLoadBalancerGeoLocation(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 headers: Optional['outputs.WorkloadLoadBalancerGeoLocationHeaders'] = None):
        """
        :param bool enabled: When enabled, geo location headers will be included on inbound http requests. Existing headers will be replaced.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When enabled, geo location headers will be included on inbound http requests. Existing headers will be replaced.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WorkloadLoadBalancerGeoLocationHeaders']:
        return pulumi.get(self, "headers")


@pulumi.output_type
class WorkloadLoadBalancerGeoLocationHeaders(dict):
    def __init__(__self__, *,
                 asn: Optional[str] = None,
                 city: Optional[str] = None,
                 country: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str asn: The geo asn header.
        :param str city: The geo city header.
        :param str country: The geo country header.
        :param str region: The geo region header.
        """
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def asn(self) -> Optional[str]:
        """
        The geo asn header.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        """
        The geo city header.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        """
        The geo country header.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The geo region header.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkloadLocalOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityAi":
            suggest = "capacity_ai"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadLocalOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadLocalOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadLocalOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 autoscaling: Optional['outputs.WorkloadLocalOptionAutoscaling'] = None,
                 capacity_ai: Optional[bool] = None,
                 debug: Optional[bool] = None,
                 suspend: Optional[bool] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param str location: Valid only for `local_options`. Override options for a specific location.
        :param 'WorkloadLocalOptionAutoscalingArgs' autoscaling: Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        :param bool capacity_ai: Capacity AI. Default: `true`.
        :param bool debug: Debug mode. Default: `false`
        :param bool suspend: Workload suspend. Default: `false`
        :param int timeout_seconds: Timeout in seconds. Default: `5`.
        """
        pulumi.set(__self__, "location", location)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if capacity_ai is not None:
            pulumi.set(__self__, "capacity_ai", capacity_ai)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Valid only for `local_options`. Override options for a specific location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def autoscaling(self) -> Optional['outputs.WorkloadLocalOptionAutoscaling']:
        """
        Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        """
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter(name="capacityAi")
    def capacity_ai(self) -> Optional[bool]:
        """
        Capacity AI. Default: `true`.
        """
        return pulumi.get(self, "capacity_ai")

    @property
    @pulumi.getter
    def debug(self) -> Optional[bool]:
        """
        Debug mode. Default: `false`
        """
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[bool]:
        """
        Workload suspend. Default: `false`
        """
        return pulumi.get(self, "suspend")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Timeout in seconds. Default: `5`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadLocalOptionAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrency":
            suggest = "max_concurrency"
        elif key == "maxScale":
            suggest = "max_scale"
        elif key == "metricPercentile":
            suggest = "metric_percentile"
        elif key == "minScale":
            suggest = "min_scale"
        elif key == "scaleToZeroDelay":
            suggest = "scale_to_zero_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadLocalOptionAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadLocalOptionAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadLocalOptionAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrency: Optional[int] = None,
                 max_scale: Optional[int] = None,
                 metric: Optional[str] = None,
                 metric_percentile: Optional[str] = None,
                 min_scale: Optional[int] = None,
                 multis: Optional[Sequence['outputs.WorkloadLocalOptionAutoscalingMulti']] = None,
                 scale_to_zero_delay: Optional[int] = None,
                 target: Optional[int] = None):
        """
        :param int max_concurrency: A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        :param int max_scale: The maximum allowed number of replicas. Min: `0`. Default `5`.
        :param str metric: Valid values: `disabled`, `concurrency`, `cpu`, `memory`, `latency`, or `rps`.
        :param str metric_percentile: For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        :param int min_scale: The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        :param int scale_to_zero_delay: The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        :param int target: Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        if max_concurrency is not None:
            pulumi.set(__self__, "max_concurrency", max_concurrency)
        if max_scale is not None:
            pulumi.set(__self__, "max_scale", max_scale)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metric_percentile is not None:
            pulumi.set(__self__, "metric_percentile", metric_percentile)
        if min_scale is not None:
            pulumi.set(__self__, "min_scale", min_scale)
        if multis is not None:
            pulumi.set(__self__, "multis", multis)
        if scale_to_zero_delay is not None:
            pulumi.set(__self__, "scale_to_zero_delay", scale_to_zero_delay)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[int]:
        """
        A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        """
        return pulumi.get(self, "max_concurrency")

    @property
    @pulumi.getter(name="maxScale")
    def max_scale(self) -> Optional[int]:
        """
        The maximum allowed number of replicas. Min: `0`. Default `5`.
        """
        return pulumi.get(self, "max_scale")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        Valid values: `disabled`, `concurrency`, `cpu`, `memory`, `latency`, or `rps`.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="metricPercentile")
    def metric_percentile(self) -> Optional[str]:
        """
        For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        """
        return pulumi.get(self, "metric_percentile")

    @property
    @pulumi.getter(name="minScale")
    def min_scale(self) -> Optional[int]:
        """
        The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        """
        return pulumi.get(self, "min_scale")

    @property
    @pulumi.getter
    def multis(self) -> Optional[Sequence['outputs.WorkloadLocalOptionAutoscalingMulti']]:
        return pulumi.get(self, "multis")

    @property
    @pulumi.getter(name="scaleToZeroDelay")
    def scale_to_zero_delay(self) -> Optional[int]:
        """
        The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        """
        return pulumi.get(self, "scale_to_zero_delay")

    @property
    @pulumi.getter
    def target(self) -> Optional[int]:
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class WorkloadLocalOptionAutoscalingMulti(dict):
    def __init__(__self__, *,
                 metric: Optional[str] = None,
                 target: Optional[int] = None):
        """
        :param str metric: Valid values: `cpu` or `memory`.
        :param int target: Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        Valid values: `cpu` or `memory`.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def target(self) -> Optional[int]:
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class WorkloadOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityAi":
            suggest = "capacity_ai"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling: Optional['outputs.WorkloadOptionsAutoscaling'] = None,
                 capacity_ai: Optional[bool] = None,
                 debug: Optional[bool] = None,
                 suspend: Optional[bool] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'WorkloadOptionsAutoscalingArgs' autoscaling: Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        :param bool capacity_ai: Capacity AI. Default: `true`.
        :param bool debug: Debug mode. Default: `false`
        :param bool suspend: Workload suspend. Default: `false`
        :param int timeout_seconds: Timeout in seconds. Default: `5`.
        """
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if capacity_ai is not None:
            pulumi.set(__self__, "capacity_ai", capacity_ai)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter
    def autoscaling(self) -> Optional['outputs.WorkloadOptionsAutoscaling']:
        """
        Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        """
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter(name="capacityAi")
    def capacity_ai(self) -> Optional[bool]:
        """
        Capacity AI. Default: `true`.
        """
        return pulumi.get(self, "capacity_ai")

    @property
    @pulumi.getter
    def debug(self) -> Optional[bool]:
        """
        Debug mode. Default: `false`
        """
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[bool]:
        """
        Workload suspend. Default: `false`
        """
        return pulumi.get(self, "suspend")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Timeout in seconds. Default: `5`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadOptionsAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrency":
            suggest = "max_concurrency"
        elif key == "maxScale":
            suggest = "max_scale"
        elif key == "metricPercentile":
            suggest = "metric_percentile"
        elif key == "minScale":
            suggest = "min_scale"
        elif key == "scaleToZeroDelay":
            suggest = "scale_to_zero_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadOptionsAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadOptionsAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadOptionsAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrency: Optional[int] = None,
                 max_scale: Optional[int] = None,
                 metric: Optional[str] = None,
                 metric_percentile: Optional[str] = None,
                 min_scale: Optional[int] = None,
                 multis: Optional[Sequence['outputs.WorkloadOptionsAutoscalingMulti']] = None,
                 scale_to_zero_delay: Optional[int] = None,
                 target: Optional[int] = None):
        """
        :param int max_concurrency: A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        :param int max_scale: The maximum allowed number of replicas. Min: `0`. Default `5`.
        :param str metric: Valid values: `disabled`, `concurrency`, `cpu`, `memory`, `latency`, or `rps`.
        :param str metric_percentile: For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        :param int min_scale: The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        :param int scale_to_zero_delay: The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        :param int target: Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        if max_concurrency is not None:
            pulumi.set(__self__, "max_concurrency", max_concurrency)
        if max_scale is not None:
            pulumi.set(__self__, "max_scale", max_scale)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metric_percentile is not None:
            pulumi.set(__self__, "metric_percentile", metric_percentile)
        if min_scale is not None:
            pulumi.set(__self__, "min_scale", min_scale)
        if multis is not None:
            pulumi.set(__self__, "multis", multis)
        if scale_to_zero_delay is not None:
            pulumi.set(__self__, "scale_to_zero_delay", scale_to_zero_delay)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[int]:
        """
        A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        """
        return pulumi.get(self, "max_concurrency")

    @property
    @pulumi.getter(name="maxScale")
    def max_scale(self) -> Optional[int]:
        """
        The maximum allowed number of replicas. Min: `0`. Default `5`.
        """
        return pulumi.get(self, "max_scale")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        Valid values: `disabled`, `concurrency`, `cpu`, `memory`, `latency`, or `rps`.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="metricPercentile")
    def metric_percentile(self) -> Optional[str]:
        """
        For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        """
        return pulumi.get(self, "metric_percentile")

    @property
    @pulumi.getter(name="minScale")
    def min_scale(self) -> Optional[int]:
        """
        The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        """
        return pulumi.get(self, "min_scale")

    @property
    @pulumi.getter
    def multis(self) -> Optional[Sequence['outputs.WorkloadOptionsAutoscalingMulti']]:
        return pulumi.get(self, "multis")

    @property
    @pulumi.getter(name="scaleToZeroDelay")
    def scale_to_zero_delay(self) -> Optional[int]:
        """
        The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        """
        return pulumi.get(self, "scale_to_zero_delay")

    @property
    @pulumi.getter
    def target(self) -> Optional[int]:
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class WorkloadOptionsAutoscalingMulti(dict):
    def __init__(__self__, *,
                 metric: Optional[str] = None,
                 target: Optional[int] = None):
        """
        :param str metric: Valid values: `cpu` or `memory`.
        :param int target: Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        Valid values: `cpu` or `memory`.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def target(self) -> Optional[int]:
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class WorkloadRolloutOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurgeReplicas":
            suggest = "max_surge_replicas"
        elif key == "maxUnavailableReplicas":
            suggest = "max_unavailable_replicas"
        elif key == "minReadySeconds":
            suggest = "min_ready_seconds"
        elif key == "scalingPolicy":
            suggest = "scaling_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadRolloutOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadRolloutOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadRolloutOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge_replicas: Optional[str] = None,
                 max_unavailable_replicas: Optional[str] = None,
                 min_ready_seconds: Optional[int] = None,
                 scaling_policy: Optional[str] = None):
        """
        :param str max_surge_replicas: The number of replicas that can be created above the desired amount of replicas during an update.
        :param str max_unavailable_replicas: The number of replicas that can be unavailable during the update process.
        :param int min_ready_seconds: The minimum number of seconds a container must run without crashing to be considered available
        :param str scaling_policy: The strategies used to update applications and services deployed. Valid values: `OrderedReady` (Updates workloads in a rolling fashion, taking down old ones and bringing up new ones incrementally, ensuring that the service remains available during the update.), `Parallel` (Causes all pods affected by a scaling operation to be created or destroyed simultaneously. This does not affect update operations.). Default: `OrderedReady`.
        """
        if max_surge_replicas is not None:
            pulumi.set(__self__, "max_surge_replicas", max_surge_replicas)
        if max_unavailable_replicas is not None:
            pulumi.set(__self__, "max_unavailable_replicas", max_unavailable_replicas)
        if min_ready_seconds is not None:
            pulumi.set(__self__, "min_ready_seconds", min_ready_seconds)
        if scaling_policy is not None:
            pulumi.set(__self__, "scaling_policy", scaling_policy)

    @property
    @pulumi.getter(name="maxSurgeReplicas")
    def max_surge_replicas(self) -> Optional[str]:
        """
        The number of replicas that can be created above the desired amount of replicas during an update.
        """
        return pulumi.get(self, "max_surge_replicas")

    @property
    @pulumi.getter(name="maxUnavailableReplicas")
    def max_unavailable_replicas(self) -> Optional[str]:
        """
        The number of replicas that can be unavailable during the update process.
        """
        return pulumi.get(self, "max_unavailable_replicas")

    @property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[int]:
        """
        The minimum number of seconds a container must run without crashing to be considered available
        """
        return pulumi.get(self, "min_ready_seconds")

    @property
    @pulumi.getter(name="scalingPolicy")
    def scaling_policy(self) -> Optional[str]:
        """
        The strategies used to update applications and services deployed. Valid values: `OrderedReady` (Updates workloads in a rolling fashion, taking down old ones and bringing up new ones incrementally, ensuring that the service remains available during the update.), `Parallel` (Causes all pods affected by a scaling operation to be created or destroyed simultaneously. This does not affect update operations.). Default: `OrderedReady`.
        """
        return pulumi.get(self, "scaling_policy")


@pulumi.output_type
class WorkloadSecurityOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemGroupId":
            suggest = "file_system_group_id"
        elif key == "placeholderAttribute":
            suggest = "placeholder_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadSecurityOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadSecurityOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadSecurityOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_group_id: Optional[int] = None,
                 placeholder_attribute: Optional[bool] = None):
        """
        :param int file_system_group_id: The group id assigned to any mounted volume.
        """
        if file_system_group_id is not None:
            pulumi.set(__self__, "file_system_group_id", file_system_group_id)
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)

    @property
    @pulumi.getter(name="fileSystemGroupId")
    def file_system_group_id(self) -> Optional[int]:
        """
        The group id assigned to any mounted volume.
        """
        return pulumi.get(self, "file_system_group_id")

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")


@pulumi.output_type
class WorkloadSidecar(dict):
    def __init__(__self__, *,
                 envoy: str):
        pulumi.set(__self__, "envoy", envoy)

    @property
    @pulumi.getter
    def envoy(self) -> str:
        return pulumi.get(self, "envoy")


@pulumi.output_type
class WorkloadStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canonicalEndpoint":
            suggest = "canonical_endpoint"
        elif key == "currentReplicaCount":
            suggest = "current_replica_count"
        elif key == "healthChecks":
            suggest = "health_checks"
        elif key == "internalName":
            suggest = "internal_name"
        elif key == "loadBalancers":
            suggest = "load_balancers"
        elif key == "parentId":
            suggest = "parent_id"
        elif key == "resolvedImages":
            suggest = "resolved_images"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canonical_endpoint: Optional[str] = None,
                 current_replica_count: Optional[int] = None,
                 endpoint: Optional[str] = None,
                 health_checks: Optional[Sequence['outputs.WorkloadStatusHealthCheck']] = None,
                 internal_name: Optional[str] = None,
                 load_balancers: Optional[Sequence['outputs.WorkloadStatusLoadBalancer']] = None,
                 parent_id: Optional[str] = None,
                 resolved_images: Optional[Sequence['outputs.WorkloadStatusResolvedImage']] = None):
        """
        :param str canonical_endpoint: Canonical endpoint for the workload.
        :param int current_replica_count: Current amount of replicas deployed.
        :param str endpoint: Endpoint for the workload.
        :param Sequence['WorkloadStatusHealthCheckArgs'] health_checks: Current health status.
        :param str internal_name: Internal hostname for the workload. Used for service-to-service requests.
        :param str parent_id: ID of the parent object.
        :param Sequence['WorkloadStatusResolvedImageArgs'] resolved_images: Resolved images for workloads with dynamic tags enabled.
        """
        if canonical_endpoint is not None:
            pulumi.set(__self__, "canonical_endpoint", canonical_endpoint)
        if current_replica_count is not None:
            pulumi.set(__self__, "current_replica_count", current_replica_count)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if health_checks is not None:
            pulumi.set(__self__, "health_checks", health_checks)
        if internal_name is not None:
            pulumi.set(__self__, "internal_name", internal_name)
        if load_balancers is not None:
            pulumi.set(__self__, "load_balancers", load_balancers)
        if parent_id is not None:
            pulumi.set(__self__, "parent_id", parent_id)
        if resolved_images is not None:
            pulumi.set(__self__, "resolved_images", resolved_images)

    @property
    @pulumi.getter(name="canonicalEndpoint")
    def canonical_endpoint(self) -> Optional[str]:
        """
        Canonical endpoint for the workload.
        """
        return pulumi.get(self, "canonical_endpoint")

    @property
    @pulumi.getter(name="currentReplicaCount")
    def current_replica_count(self) -> Optional[int]:
        """
        Current amount of replicas deployed.
        """
        return pulumi.get(self, "current_replica_count")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Endpoint for the workload.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="healthChecks")
    def health_checks(self) -> Optional[Sequence['outputs.WorkloadStatusHealthCheck']]:
        """
        Current health status.
        """
        return pulumi.get(self, "health_checks")

    @property
    @pulumi.getter(name="internalName")
    def internal_name(self) -> Optional[str]:
        """
        Internal hostname for the workload. Used for service-to-service requests.
        """
        return pulumi.get(self, "internal_name")

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Optional[Sequence['outputs.WorkloadStatusLoadBalancer']]:
        return pulumi.get(self, "load_balancers")

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> Optional[str]:
        """
        ID of the parent object.
        """
        return pulumi.get(self, "parent_id")

    @property
    @pulumi.getter(name="resolvedImages")
    def resolved_images(self) -> Optional[Sequence['outputs.WorkloadStatusResolvedImage']]:
        """
        Resolved images for workloads with dynamic tags enabled.
        """
        return pulumi.get(self, "resolved_images")


@pulumi.output_type
class WorkloadStatusHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastChecked":
            suggest = "last_checked"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 code: Optional[int] = None,
                 failures: Optional[int] = None,
                 last_checked: Optional[str] = None,
                 message: Optional[str] = None,
                 success: Optional[bool] = None,
                 successes: Optional[int] = None):
        """
        :param bool active: Active boolean for the associated workload.
        :param int code: Current output code for the associated workload.
        :param int failures: Failure integer for the associated workload.
        :param str last_checked: Timestamp in UTC of the last health check.
        :param str message: Current health status for the associated workload.
        :param bool success: Success boolean for the associated workload.
        :param int successes: Success integer for the associated workload.
        """
        pulumi.set(__self__, "active", active)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if failures is not None:
            pulumi.set(__self__, "failures", failures)
        if last_checked is not None:
            pulumi.set(__self__, "last_checked", last_checked)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if success is not None:
            pulumi.set(__self__, "success", success)
        if successes is not None:
            pulumi.set(__self__, "successes", successes)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        Active boolean for the associated workload.
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        Current output code for the associated workload.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def failures(self) -> Optional[int]:
        """
        Failure integer for the associated workload.
        """
        return pulumi.get(self, "failures")

    @property
    @pulumi.getter(name="lastChecked")
    def last_checked(self) -> Optional[str]:
        """
        Timestamp in UTC of the last health check.
        """
        return pulumi.get(self, "last_checked")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Current health status for the associated workload.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def success(self) -> Optional[bool]:
        """
        Success boolean for the associated workload.
        """
        return pulumi.get(self, "success")

    @property
    @pulumi.getter
    def successes(self) -> Optional[int]:
        """
        Success integer for the associated workload.
        """
        return pulumi.get(self, "successes")


@pulumi.output_type
class WorkloadStatusLoadBalancer(dict):
    def __init__(__self__, *,
                 origin: Optional[str] = None,
                 url: Optional[str] = None):
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def origin(self) -> Optional[str]:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class WorkloadStatusResolvedImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resolvedAt":
            suggest = "resolved_at"
        elif key == "resolvedForVersion":
            suggest = "resolved_for_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusResolvedImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusResolvedImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusResolvedImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 images: Optional[Sequence['outputs.WorkloadStatusResolvedImageImage']] = None,
                 resolved_at: Optional[str] = None,
                 resolved_for_version: Optional[int] = None):
        """
        :param Sequence['WorkloadStatusResolvedImageImageArgs'] images: A list of images that were resolved.
        :param str resolved_at: UTC Time when the images were resolved.
        :param int resolved_for_version: Workload version the images were resolved for.
        """
        if images is not None:
            pulumi.set(__self__, "images", images)
        if resolved_at is not None:
            pulumi.set(__self__, "resolved_at", resolved_at)
        if resolved_for_version is not None:
            pulumi.set(__self__, "resolved_for_version", resolved_for_version)

    @property
    @pulumi.getter
    def images(self) -> Optional[Sequence['outputs.WorkloadStatusResolvedImageImage']]:
        """
        A list of images that were resolved.
        """
        return pulumi.get(self, "images")

    @property
    @pulumi.getter(name="resolvedAt")
    def resolved_at(self) -> Optional[str]:
        """
        UTC Time when the images were resolved.
        """
        return pulumi.get(self, "resolved_at")

    @property
    @pulumi.getter(name="resolvedForVersion")
    def resolved_for_version(self) -> Optional[int]:
        """
        Workload version the images were resolved for.
        """
        return pulumi.get(self, "resolved_for_version")


@pulumi.output_type
class WorkloadStatusResolvedImageImage(dict):
    def __init__(__self__, *,
                 digest: Optional[str] = None,
                 manifests: Optional[Sequence['outputs.WorkloadStatusResolvedImageImageManifest']] = None):
        """
        :param str digest: A unique SHA256 hash value that identifies a specific image content. This digest serves as a fingerprint of the image's content, ensuring the image you pull or run is exactly what you expect, without any modifications or corruptions.
        """
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if manifests is not None:
            pulumi.set(__self__, "manifests", manifests)

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        """
        A unique SHA256 hash value that identifies a specific image content. This digest serves as a fingerprint of the image's content, ensuring the image you pull or run is exactly what you expect, without any modifications or corruptions.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def manifests(self) -> Optional[Sequence['outputs.WorkloadStatusResolvedImageImageManifest']]:
        return pulumi.get(self, "manifests")


@pulumi.output_type
class WorkloadStatusResolvedImageImageManifest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaType":
            suggest = "media_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusResolvedImageImageManifest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusResolvedImageImageManifest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusResolvedImageImageManifest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digest: Optional[str] = None,
                 image: Optional[str] = None,
                 media_type: Optional[str] = None,
                 platform: Optional[Mapping[str, str]] = None):
        """
        :param str digest: A SHA256 hash that uniquely identifies the specific image manifest.
        :param str image: The name and tag of the resolved image.
        :param str media_type: The MIME type used in the Docker Registry HTTP API to specify the format of the data being sent or received. Docker uses media types to distinguish between different kinds of JSON objects and binary data formats within the registry protocol, enabling the Docker client and registry to understand and process different components of Docker images correctly.
        :param Mapping[str, str] platform: Key-value map of strings. The combination of the operating system and architecture for which the image is built.
        """
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if media_type is not None:
            pulumi.set(__self__, "media_type", media_type)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        """
        A SHA256 hash that uniquely identifies the specific image manifest.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The name and tag of the resolved image.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> Optional[str]:
        """
        The MIME type used in the Docker Registry HTTP API to specify the format of the data being sent or received. Docker uses media types to distinguish between different kinds of JSON objects and binary data formats within the registry protocol, enabling the Docker client and registry to understand and process different components of Docker images correctly.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def platform(self) -> Optional[Mapping[str, str]]:
        """
        Key-value map of strings. The combination of the operating system and architecture for which the image is built.
        """
        return pulumi.get(self, "platform")


@pulumi.output_type
class GetGvcControlplaneTracingResult(dict):
    def __init__(__self__, *,
                 sampling: float,
                 custom_tags: Optional[Mapping[str, str]] = None):
        """
        :param float sampling: Determines what percentage of requests should be traced.
        :param Mapping[str, str] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "sampling", sampling)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter
    def sampling(self) -> float:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetGvcLightstepTracingResult(dict):
    def __init__(__self__, *,
                 endpoint: str,
                 sampling: float,
                 credentials: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None):
        """
        :param str endpoint: Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        :param float sampling: Determines what percentage of requests should be traced.
        :param str credentials: Full link to referenced Opaque Secret.
        :param Mapping[str, str] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "sampling", sampling)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> float:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def credentials(self) -> Optional[str]:
        """
        Full link to referenced Opaque Secret.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetGvcLoadBalancerResult(dict):
    def __init__(__self__, *,
                 dedicated: Optional[bool] = None,
                 redirect: Optional['outputs.GetGvcLoadBalancerRedirectResult'] = None,
                 trusted_proxies: Optional[int] = None):
        """
        :param bool dedicated: Creates a dedicated load balancer in each location and enables additional Domain features: custom ports, protocols and wildcard hostnames. Charges apply for each location.
        :param 'GetGvcLoadBalancerRedirectArgs' redirect: Specify the url to be redirected to for different http status codes.
        :param int trusted_proxies: Controls the address used for request logging and for setting the X-Envoy-External-Address header. If set to 1, then the last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If set to 2, then the second to last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If the XFF header does not have at least two addresses or does not exist then the source client IP address will be used instead.
        """
        if dedicated is not None:
            pulumi.set(__self__, "dedicated", dedicated)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if trusted_proxies is not None:
            pulumi.set(__self__, "trusted_proxies", trusted_proxies)

    @property
    @pulumi.getter
    def dedicated(self) -> Optional[bool]:
        """
        Creates a dedicated load balancer in each location and enables additional Domain features: custom ports, protocols and wildcard hostnames. Charges apply for each location.
        """
        return pulumi.get(self, "dedicated")

    @property
    @pulumi.getter
    def redirect(self) -> Optional['outputs.GetGvcLoadBalancerRedirectResult']:
        """
        Specify the url to be redirected to for different http status codes.
        """
        return pulumi.get(self, "redirect")

    @property
    @pulumi.getter(name="trustedProxies")
    def trusted_proxies(self) -> Optional[int]:
        """
        Controls the address used for request logging and for setting the X-Envoy-External-Address header. If set to 1, then the last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If set to 2, then the second to last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If the XFF header does not have at least two addresses or does not exist then the source client IP address will be used instead.
        """
        return pulumi.get(self, "trusted_proxies")


@pulumi.output_type
class GetGvcLoadBalancerRedirectResult(dict):
    def __init__(__self__, *,
                 class_: Optional['outputs.GetGvcLoadBalancerRedirectClassResult'] = None,
                 placeholder_attribute: Optional[bool] = None):
        """
        :param 'GetGvcLoadBalancerRedirectClassArgs' class_: Specify the redirect url for all status codes in a class.
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional['outputs.GetGvcLoadBalancerRedirectClassResult']:
        """
        Specify the redirect url for all status codes in a class.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")


@pulumi.output_type
class GetGvcLoadBalancerRedirectClassResult(dict):
    def __init__(__self__, *,
                 placeholder_attribute: Optional[bool] = None,
                 status5xx: Optional[str] = None):
        """
        :param str status5xx: Specify the redirect url for any 500 level status code.
        """
        if placeholder_attribute is not None:
            pulumi.set(__self__, "placeholder_attribute", placeholder_attribute)
        if status5xx is not None:
            pulumi.set(__self__, "status5xx", status5xx)

    @property
    @pulumi.getter(name="placeholderAttribute")
    def placeholder_attribute(self) -> Optional[bool]:
        return pulumi.get(self, "placeholder_attribute")

    @property
    @pulumi.getter
    def status5xx(self) -> Optional[str]:
        """
        Specify the redirect url for any 500 level status code.
        """
        return pulumi.get(self, "status5xx")


@pulumi.output_type
class GetGvcOtelTracingResult(dict):
    def __init__(__self__, *,
                 endpoint: str,
                 sampling: float,
                 custom_tags: Optional[Mapping[str, str]] = None):
        """
        :param str endpoint: Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        :param float sampling: Determines what percentage of requests should be traced.
        :param Mapping[str, str] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "sampling", sampling)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> float:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetGvcSidecarResult(dict):
    def __init__(__self__, *,
                 envoy: str):
        pulumi.set(__self__, "envoy", envoy)

    @property
    @pulumi.getter
    def envoy(self) -> str:
        return pulumi.get(self, "envoy")


@pulumi.output_type
class GetImageManifestResult(dict):
    def __init__(__self__, *,
                 configs: Sequence['outputs.GetImageManifestConfigResult'],
                 layers: Sequence['outputs.GetImageManifestLayerResult'],
                 media_type: str,
                 schema_version: int):
        """
        :param Sequence['GetImageManifestConfigArgs'] configs: The config is a JSON blob that contains the image configuration data which includes environment variables, default command to run, and other settings necessary to run the container based on this image.
        :param Sequence['GetImageManifestLayerArgs'] layers: Layers lists the digests of the image's layers. These layers are filesystem changes or additions made in each step of the Docker image's creation process. The layers are stored separately and pulled as needed, which allows for efficient storage and transfer of images. Each layer is represented by a SHA256 digest, ensuring the integrity and authenticity of the image.
        :param str media_type: Specifies the type of the content represented in the manifest, allowing Docker clients and registries to understand how to handle the document correctly.
        :param int schema_version: The version of the Docker Image Manifest format.
        """
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "layers", layers)
        pulumi.set(__self__, "media_type", media_type)
        pulumi.set(__self__, "schema_version", schema_version)

    @property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GetImageManifestConfigResult']:
        """
        The config is a JSON blob that contains the image configuration data which includes environment variables, default command to run, and other settings necessary to run the container based on this image.
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter
    def layers(self) -> Sequence['outputs.GetImageManifestLayerResult']:
        """
        Layers lists the digests of the image's layers. These layers are filesystem changes or additions made in each step of the Docker image's creation process. The layers are stored separately and pulled as needed, which allows for efficient storage and transfer of images. Each layer is represented by a SHA256 digest, ensuring the integrity and authenticity of the image.
        """
        return pulumi.get(self, "layers")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        """
        Specifies the type of the content represented in the manifest, allowing Docker clients and registries to understand how to handle the document correctly.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter(name="schemaVersion")
    def schema_version(self) -> int:
        """
        The version of the Docker Image Manifest format.
        """
        return pulumi.get(self, "schema_version")


@pulumi.output_type
class GetImageManifestConfigResult(dict):
    def __init__(__self__, *,
                 digest: str,
                 media_type: str,
                 size: int):
        """
        :param str digest: A unique SHA256 hash used to identify a specific image version within the image registry.
        :param str media_type: Specifies the type of the content represented in the manifest, allowing Docker clients and registries to understand how to handle the document correctly.
        :param int size: The size of the image or layer in bytes. This helps in estimating the space required and the download time.
        """
        pulumi.set(__self__, "digest", digest)
        pulumi.set(__self__, "media_type", media_type)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def digest(self) -> str:
        """
        A unique SHA256 hash used to identify a specific image version within the image registry.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        """
        Specifies the type of the content represented in the manifest, allowing Docker clients and registries to understand how to handle the document correctly.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the image or layer in bytes. This helps in estimating the space required and the download time.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetImageManifestLayerResult(dict):
    def __init__(__self__, *,
                 digest: str,
                 media_type: str,
                 size: int):
        """
        :param str digest: A unique SHA256 hash used to identify a specific image version within the image registry.
        :param str media_type: Specifies the type of the content represented in the manifest, allowing Docker clients and registries to understand how to handle the document correctly.
        :param int size: The size of the image or layer in bytes. This helps in estimating the space required and the download time.
        """
        pulumi.set(__self__, "digest", digest)
        pulumi.set(__self__, "media_type", media_type)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def digest(self) -> str:
        """
        A unique SHA256 hash used to identify a specific image version within the image registry.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        """
        Specifies the type of the content represented in the manifest, allowing Docker clients and registries to understand how to handle the document correctly.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the image or layer in bytes. This helps in estimating the space required and the download time.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetImagesImageResult(dict):
    def __init__(__self__, *,
                 cpln_id: str,
                 digest: str,
                 manifests: Sequence['outputs.GetImagesImageManifestResult'],
                 name: str,
                 repository: str,
                 self_link: str,
                 tag: str,
                 tags: Mapping[str, str]):
        """
        :param str cpln_id: The ID, in GUID format, of the Image.
        :param str digest: A unique SHA256 hash used to identify a specific image version within the image registry.
        :param Sequence['GetImagesImageManifestArgs'] manifests: The manifest provides configuration and layers information about the image. It plays a crucial role in the Docker image distribution system, enabling image creation, verification, and replication in a consistent and secure manner.
        :param str name: Name of the Image.
        :param str repository: Respository name of the image.
        :param str self_link: Full link to this resource. Can be referenced by other resources.
        :param str tag: Tag of the image.
        :param Mapping[str, str] tags: Key-value map of resource tags.
        """
        pulumi.set(__self__, "cpln_id", cpln_id)
        pulumi.set(__self__, "digest", digest)
        pulumi.set(__self__, "manifests", manifests)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "self_link", self_link)
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="cplnId")
    def cpln_id(self) -> str:
        """
        The ID, in GUID format, of the Image.
        """
        return pulumi.get(self, "cpln_id")

    @property
    @pulumi.getter
    def digest(self) -> str:
        """
        A unique SHA256 hash used to identify a specific image version within the image registry.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def manifests(self) -> Sequence['outputs.GetImagesImageManifestResult']:
        """
        The manifest provides configuration and layers information about the image. It plays a crucial role in the Docker image distribution system, enabling image creation, verification, and replication in a consistent and secure manner.
        """
        return pulumi.get(self, "manifests")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Image.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def repository(self) -> str:
        """
        Respository name of the image.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> str:
        """
        Full link to this resource. Can be referenced by other resources.
        """
        return pulumi.get(self, "self_link")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Tag of the image.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Key-value map of resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetImagesImageManifestResult(dict):
    def __init__(__self__, *,
                 configs: Sequence['outputs.GetImagesImageManifestConfigResult'],
                 layers: Sequence['outputs.GetImagesImageManifestLayerResult'],
                 media_type: str,
                 schema_version: int):
        """
        :param Sequence['GetImagesImageManifestConfigArgs'] configs: The config is a JSON blob that contains the image configuration data which includes environment variables, default command to run, and other settings necessary to run the container based on this image.
        :param Sequence['GetImagesImageManifestLayerArgs'] layers: Layers lists the digests of the image's layers. These layers are filesystem changes or additions made in each step of the Docker image's creation process. The layers are stored separately and pulled as needed, which allows for efficient storage and transfer of images. Each layer is represented by a SHA256 digest, ensuring the integrity and authenticity of the image.
        :param str media_type: Specifies the type of the content represented in the manifest, allowing Docker clients and registries to understand how to handle the document correctly.
        :param int schema_version: The version of the Docker Image Manifest format.
        """
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "layers", layers)
        pulumi.set(__self__, "media_type", media_type)
        pulumi.set(__self__, "schema_version", schema_version)

    @property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GetImagesImageManifestConfigResult']:
        """
        The config is a JSON blob that contains the image configuration data which includes environment variables, default command to run, and other settings necessary to run the container based on this image.
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter
    def layers(self) -> Sequence['outputs.GetImagesImageManifestLayerResult']:
        """
        Layers lists the digests of the image's layers. These layers are filesystem changes or additions made in each step of the Docker image's creation process. The layers are stored separately and pulled as needed, which allows for efficient storage and transfer of images. Each layer is represented by a SHA256 digest, ensuring the integrity and authenticity of the image.
        """
        return pulumi.get(self, "layers")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        """
        Specifies the type of the content represented in the manifest, allowing Docker clients and registries to understand how to handle the document correctly.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter(name="schemaVersion")
    def schema_version(self) -> int:
        """
        The version of the Docker Image Manifest format.
        """
        return pulumi.get(self, "schema_version")


@pulumi.output_type
class GetImagesImageManifestConfigResult(dict):
    def __init__(__self__, *,
                 digest: str,
                 media_type: str,
                 size: int):
        """
        :param str digest: A unique SHA256 hash used to identify a specific image version within the image registry.
        :param str media_type: Specifies the type of the content represented in the manifest, allowing Docker clients and registries to understand how to handle the document correctly.
        :param int size: The size of the image or layer in bytes. This helps in estimating the space required and the download time.
        """
        pulumi.set(__self__, "digest", digest)
        pulumi.set(__self__, "media_type", media_type)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def digest(self) -> str:
        """
        A unique SHA256 hash used to identify a specific image version within the image registry.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        """
        Specifies the type of the content represented in the manifest, allowing Docker clients and registries to understand how to handle the document correctly.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the image or layer in bytes. This helps in estimating the space required and the download time.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetImagesImageManifestLayerResult(dict):
    def __init__(__self__, *,
                 digest: str,
                 media_type: str,
                 size: int):
        """
        :param str digest: A unique SHA256 hash used to identify a specific image version within the image registry.
        :param str media_type: Specifies the type of the content represented in the manifest, allowing Docker clients and registries to understand how to handle the document correctly.
        :param int size: The size of the image or layer in bytes. This helps in estimating the space required and the download time.
        """
        pulumi.set(__self__, "digest", digest)
        pulumi.set(__self__, "media_type", media_type)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def digest(self) -> str:
        """
        A unique SHA256 hash used to identify a specific image version within the image registry.
        """
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        """
        Specifies the type of the content represented in the manifest, allowing Docker clients and registries to understand how to handle the document correctly.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the image or layer in bytes. This helps in estimating the space required and the download time.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetImagesQueryResult(dict):
    def __init__(__self__, *,
                 fetch: Optional[str] = None,
                 spec: Optional['outputs.GetImagesQuerySpecResult'] = None):
        """
        :param str fetch: Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        if fetch is not None:
            pulumi.set(__self__, "fetch", fetch)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def fetch(self) -> Optional[str]:
        """
        Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        return pulumi.get(self, "fetch")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.GetImagesQuerySpecResult']:
        return pulumi.get(self, "spec")


@pulumi.output_type
class GetImagesQuerySpecResult(dict):
    def __init__(__self__, *,
                 match: Optional[str] = None,
                 terms: Optional[Sequence['outputs.GetImagesQuerySpecTermResult']] = None):
        """
        :param str match: Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        :param Sequence['GetImagesQuerySpecTermArgs'] terms: Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if terms is not None:
            pulumi.set(__self__, "terms", terms)

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        """
        Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def terms(self) -> Optional[Sequence['outputs.GetImagesQuerySpecTermResult']]:
        """
        Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
        return pulumi.get(self, "terms")


@pulumi.output_type
class GetImagesQuerySpecTermResult(dict):
    def __init__(__self__, *,
                 op: Optional[str] = None,
                 property: Optional[str] = None,
                 rel: Optional[str] = None,
                 tag: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str op: Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        :param str property: Property to use for query evaluation.
        :param str tag: Tag key to use for query evaluation.
        :param str value: Testing value for query evaluation.
        """
        if op is not None:
            pulumi.set(__self__, "op", op)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        """
        Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def rel(self) -> Optional[str]:
        return pulumi.get(self, "rel")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Tag key to use for query evaluation.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Testing value for query evaluation.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        Property to use for query evaluation.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class GetLocationGeoResult(dict):
    def __init__(__self__, *,
                 city: Optional[str] = None,
                 continent: Optional[str] = None,
                 country: Optional[str] = None,
                 lat: Optional[float] = None,
                 lon: Optional[float] = None,
                 state: Optional[str] = None):
        """
        :param str city: City.
        :param str continent: Continent.
        :param str country: Country.
        :param float lat: Latitude.
        :param float lon: Longitude.
        :param str state: State.
        """
        if city is not None:
            pulumi.set(__self__, "city", city)
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lon is not None:
            pulumi.set(__self__, "lon", lon)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        """
        City.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def continent(self) -> Optional[str]:
        """
        Continent.
        """
        return pulumi.get(self, "continent")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        """
        Country.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def lat(self) -> Optional[float]:
        """
        Latitude.
        """
        return pulumi.get(self, "lat")

    @property
    @pulumi.getter
    def lon(self) -> Optional[float]:
        """
        Longitude.
        """
        return pulumi.get(self, "lon")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetLocationsLocationResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 cpln_id: str,
                 description: str,
                 enabled: bool,
                 geos: Sequence['outputs.GetLocationsLocationGeoResult'],
                 ip_ranges: Sequence[str],
                 name: str,
                 region: str,
                 self_link: str,
                 tags: Mapping[str, str]):
        """
        :param str cloud_provider: Cloud Provider of the location.
        :param str cpln_id: The ID, in GUID format, of the location.
        :param str description: Description of the location.
        :param bool enabled: Indication if location is enabled.
        :param Sequence[str] ip_ranges: A list of IP ranges of the location.
        :param str name: Name of the location.
        :param str region: Region of the location.
        :param str self_link: Full link to this resource. Can be referenced by other resources.
        :param Mapping[str, str] tags: Key-value map of resource tags.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "cpln_id", cpln_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "geos", geos)
        pulumi.set(__self__, "ip_ranges", ip_ranges)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "self_link", self_link)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Cloud Provider of the location.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="cplnId")
    def cpln_id(self) -> str:
        """
        The ID, in GUID format, of the location.
        """
        return pulumi.get(self, "cpln_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the location.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Indication if location is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def geos(self) -> Sequence['outputs.GetLocationsLocationGeoResult']:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[str]:
        """
        A list of IP ranges of the location.
        """
        return pulumi.get(self, "ip_ranges")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the location.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Region of the location.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> str:
        """
        Full link to this resource. Can be referenced by other resources.
        """
        return pulumi.get(self, "self_link")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Key-value map of resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetLocationsLocationGeoResult(dict):
    def __init__(__self__, *,
                 city: Optional[str] = None,
                 continent: Optional[str] = None,
                 country: Optional[str] = None,
                 lat: Optional[float] = None,
                 lon: Optional[float] = None,
                 state: Optional[str] = None):
        """
        :param str city: City.
        :param str continent: Continent.
        :param str country: Country.
        :param float lat: Latitude.
        :param float lon: Longitude.
        :param str state: State.
        """
        if city is not None:
            pulumi.set(__self__, "city", city)
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lon is not None:
            pulumi.set(__self__, "lon", lon)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        """
        City.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def continent(self) -> Optional[str]:
        """
        Continent.
        """
        return pulumi.get(self, "continent")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        """
        Country.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def lat(self) -> Optional[float]:
        """
        Latitude.
        """
        return pulumi.get(self, "lat")

    @property
    @pulumi.getter
    def lon(self) -> Optional[float]:
        """
        Longitude.
        """
        return pulumi.get(self, "lon")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetSecretAwsResult(dict):
    def __init__(__self__, *,
                 access_key: str,
                 secret_key: str,
                 external_id: Optional[str] = None,
                 role_arn: Optional[str] = None):
        """
        :param str access_key: Access Key provided by AWS.
        :param str secret_key: Secret Key provided by AWS.
        :param str external_id: AWS IAM Role External ID.
        :param str role_arn: Role ARN provided by AWS.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "secret_key", secret_key)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        Access Key provided by AWS.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        Secret Key provided by AWS.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        AWS IAM Role External ID.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Role ARN provided by AWS.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GetSecretAzureConnectorResult(dict):
    def __init__(__self__, *,
                 code: str,
                 url: str):
        """
        :param str code: Code/Key to authenticate to deployment URL.
        :param str url: Deployment URL.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        Code/Key to authenticate to deployment URL.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Deployment URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetSecretEcrResult(dict):
    def __init__(__self__, *,
                 access_key: str,
                 repos: Sequence[str],
                 secret_key: str,
                 external_id: Optional[str] = None,
                 role_arn: Optional[str] = None):
        """
        :param str access_key: Access Key provided by AWS.
        :param Sequence[str] repos: List of ECR repositories.
        :param str secret_key: Secret Key provided by AWS.
        :param str external_id: AWS IAM Role External ID. Used when setting up cross-account access to your ECR repositories.
        :param str role_arn: Role ARN provided by AWS.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "repos", repos)
        pulumi.set(__self__, "secret_key", secret_key)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        Access Key provided by AWS.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def repos(self) -> Sequence[str]:
        """
        List of ECR repositories.
        """
        return pulumi.get(self, "repos")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        Secret Key provided by AWS.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        AWS IAM Role External ID. Used when setting up cross-account access to your ECR repositories.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Role ARN provided by AWS.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GetSecretKeypairResult(dict):
    def __init__(__self__, *,
                 secret_key: str,
                 passphrase: Optional[str] = None,
                 public_key: Optional[str] = None):
        """
        :param str secret_key: Secret/Private Key.
        :param str passphrase: Passphrase for private key.
        :param str public_key: Public Key.
        """
        pulumi.set(__self__, "secret_key", secret_key)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        Secret/Private Key.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[str]:
        """
        Passphrase for private key.
        """
        return pulumi.get(self, "passphrase")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        """
        Public Key.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetSecretNatsAccountResult(dict):
    def __init__(__self__, *,
                 account_id: str,
                 private_key: str):
        """
        :param str account_id: Account ID.
        :param str private_key: Private Key.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Account ID.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Private Key.
        """
        return pulumi.get(self, "private_key")


@pulumi.output_type
class GetSecretOpaqueResult(dict):
    def __init__(__self__, *,
                 payload: str,
                 encoding: Optional[str] = None):
        """
        :param str payload: Plain text or base64 encoded string. Use `encoding` attribute to specify encoding.
        :param str encoding: Available encodings: `plain`, `base64`. Default: `plain`.
        """
        pulumi.set(__self__, "payload", payload)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @property
    @pulumi.getter
    def payload(self) -> str:
        """
        Plain text or base64 encoded string. Use `encoding` attribute to specify encoding.
        """
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        Available encodings: `plain`, `base64`. Default: `plain`.
        """
        return pulumi.get(self, "encoding")


@pulumi.output_type
class GetSecretTlsResult(dict):
    def __init__(__self__, *,
                 cert: str,
                 key: str,
                 chain: Optional[str] = None):
        """
        :param str cert: Public Certificate.
        :param str key: Private Certificate.
        :param str chain: Chain Certificate.
        """
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)
        if chain is not None:
            pulumi.set(__self__, "chain", chain)

    @property
    @pulumi.getter
    def cert(self) -> str:
        """
        Public Certificate.
        """
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Private Certificate.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def chain(self) -> Optional[str]:
        """
        Chain Certificate.
        """
        return pulumi.get(self, "chain")


@pulumi.output_type
class GetSecretUserpassResult(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str,
                 encoding: Optional[str] = None):
        """
        :param str password: Password.
        :param str username: Username.
        :param str encoding: Available encodings: `plain`, `base64`. Default: `plain`.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        Available encodings: `plain`, `base64`. Default: `plain`.
        """
        return pulumi.get(self, "encoding")


