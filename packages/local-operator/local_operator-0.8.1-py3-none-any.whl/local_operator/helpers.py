"""Helper functions for processing and manipulating response content.

This module contains utility functions designed to assist in the handling and
modification of response content generated by the language model. These functions
are crucial for maintaining the integrity and usability of the responses, ensuring
that they conform to the expected format and are free from unnecessary tags or
elements.
"""

import json
import re


def remove_think_tags(response_content: str) -> str:
    """
    Remove the content enclosed within <think> and </think> tags from the response content.

    Args:
        response_content (str): The original response content potentially containing <think> tags.

    Returns:
        str: The response content with <think> and </think> tags and their content removed.
    """
    if "<think>" in response_content:
        start_think_index = response_content.find("<think>")
        end_think_index = response_content.rfind("</think>")
        if start_think_index != -1 and end_think_index != -1:
            response_content = (
                response_content[:start_think_index]
                + response_content[end_think_index + len("</think>") :].strip()
            )
    return response_content


def clean_plain_text_response(response_content: str) -> str:
    """
    Clean plain text responses like reflection and planning by removing code blocks and
    standalone JSON.

    Args:
        response_content (str): The original plain text response potentially containing
                               code blocks or JSON objects.

    Returns:
        str: The cleaned response with code blocks and standalone JSON removed.
    """
    # Check if the entire content is a JSON object
    if response_content.strip().startswith("{") and response_content.strip().endswith("}"):
        try:
            json.loads(response_content.strip())
            # If it parses as valid JSON, remove it completely
            return ""
        except json.JSONDecodeError:
            # Not valid JSON, keep the content
            pass

    # Remove code blocks
    lines = response_content.split("\n")
    cleaned_lines = []
    in_code_block = False
    code_block_start_index = -1

    for i, line in enumerate(lines):
        if line.strip().startswith("```"):
            if not in_code_block:
                in_code_block = True
                code_block_start_index = i
            else:
                in_code_block = False
                # Add an empty line if there's content before and after the code block
                if code_block_start_index > 0 and i < len(lines) - 1:
                    cleaned_lines.append("")
            continue
        if not in_code_block:
            cleaned_lines.append(line.rstrip())

    cleaned_content = "\n".join(cleaned_lines)

    # Remove JSON objects embedded in the text
    pattern = r'\{(?:[^{}]|"[^"]*")*\}'
    cleaned_content = re.sub(pattern, "", cleaned_content)

    # Clean up any double spaces and preserve line breaks
    cleaned_content = re.sub(r" +", " ", cleaned_content)

    # Remove trailing spaces at the end of each line and leading spaces at the beginning
    # of each line
    cleaned_content = "\n".join(line.strip() for line in cleaned_content.split("\n"))

    return cleaned_content.strip()


def clean_json_response(response_content: str) -> str:
    """
    Clean JSON responses by extracting the JSON content from various formats.

    Args:
        response_content (str): The original JSON response potentially containing
                               code blocks, markdown formatting, or other text.

    Returns:
        str: The extracted JSON content as a string.
    """
    response_content = remove_think_tags(response_content)

    # Special case for the format: ```json\n{...}\n```
    start = response_content.strip().startswith("```json")
    end = response_content.strip().endswith("```")
    if start and end:
        start_marker = "```json\n"
        if start_marker in response_content:
            start_idx = response_content.find(start_marker) + len(start_marker)
            end_idx = response_content.rfind("\n```")
            if end_idx != -1 and end_idx > start_idx:
                result = response_content[start_idx:end_idx].strip()
                if result.endswith("}"):
                    return result

    # Check if the entire content is already valid JSON
    try:
        if response_content.strip().startswith("{") and response_content.strip().endswith("}"):
            json.loads(response_content.strip())
            return response_content.strip()
    except json.JSONDecodeError:
        pass

    # Always search for JSON in code blocks regardless of leading text
    json_block_marker = "```json\n"
    if json_block_marker in response_content:
        start_index = response_content.find(json_block_marker) + len(json_block_marker)
        end_marker = "\n```"
        end_index = response_content.find(end_marker, start_index)

        if end_index != -1:
            json_content = response_content[start_index:end_index].strip()

            # Check for a complete JSON object
            if json_content.startswith("{") and json_content.endswith("}"):
                try:
                    json.loads(json_content)
                    return json_content
                except json.JSONDecodeError:
                    pass

            # If full content isn't parseable, try to extract the JSON object
            first_brace = json_content.find("{")
            last_brace = json_content.rfind("}")

            if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
                extracted_json = json_content[first_brace : last_brace + 1]
                try:
                    json.loads(extracted_json)
                    return extracted_json
                except json.JSONDecodeError:
                    pass

    # Check for JSON code block format with triple backticks
    is_json_start = response_content.strip().startswith("```json")
    is_json_end = response_content.strip().endswith("```")
    if is_json_start and is_json_end:
        # Extract content between the first ```json and the last ```
        content = response_content.strip()
        start_index = content.find("```json") + len("```json")
        end_index = content.rfind("```")
        if start_index < end_index:
            extracted_content = content[start_index:end_index].strip()
            # Make sure we don't have trailing backticks in the extracted content
            if extracted_content.endswith("```"):
                extracted_content = extracted_content[:-3].strip()
            try:
                json.loads(extracted_content)
                return extracted_content
            except json.JSONDecodeError:
                pass

    # Check for JSON code block format with triple backticks
    json_block_patterns = ["```json\n", "```\n"]

    for pattern in json_block_patterns:
        if pattern in response_content and not is_marker_inside_json(response_content, pattern):
            start_index = response_content.find(pattern)
            content_after_marker = response_content[start_index + len(pattern) :]

            # Find the closing backticks that are not inside a JSON structure
            end_index = content_after_marker.find("```")  # Initial find

            while end_index != -1 and is_marker_inside_json(
                content_after_marker[: end_index + 3], "```"  # Check based on original slice
            ):
                # Search *after* the found marker in the original slice
                search_start = end_index + 3
                next_end = content_after_marker.find("```", search_start)
                if next_end == -1:
                    end_index = -1  # No more markers found
                    break
                end_index = next_end  # Update end_index to the new position

            if end_index != -1:
                extracted_content = content_after_marker[:end_index].strip()

                # Special handling for nested JSON with code blocks
                if "```json{" in extracted_content:
                    # Find the last complete JSON object
                    first_brace = extracted_content.find("{")
                    last_brace = extracted_content.rfind("}")

                    if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
                        json_content = extracted_content[first_brace : last_brace + 1].strip()
                        # Remove any trailing backticks that aren't part of the JSON string
                        if json_content.endswith("```"):
                            json_content = json_content[:-3].strip()
                        try:
                            json.loads(json_content)
                            return json_content
                        except json.JSONDecodeError:
                            pass

                # If the content has trailing backticks or newlines (followed by
                # backticks), clean them up
                if "\n```" in extracted_content:
                    extracted_content = extracted_content.split("\n```")[0].strip()
                elif extracted_content.endswith("```"):
                    extracted_content = extracted_content[:-3].strip()

                # Try to parse the entire extracted content first
                try:
                    json.loads(extracted_content)
                    return extracted_content
                except json.JSONDecodeError:
                    # If that fails, look for the last complete JSON object
                    first_brace = extracted_content.find("{")
                    last_brace = extracted_content.rfind("}")

                    if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
                        json_content = extracted_content[first_brace : last_brace + 1].strip()
                        # Remove any trailing backticks that aren't part of the JSON string
                        if json_content.endswith("```"):
                            json_content = json_content[:-3].strip()
                        try:
                            json.loads(json_content)
                            return json_content
                        except json.JSONDecodeError:
                            # If still not valid, return the extracted content as-is
                            pass

                # If we couldn't find valid JSON but have a clean content, return it
                return extracted_content

    # If no specific markers found, try to extract JSON object directly
    # Look for the first { and the last }
    first_brace = response_content.find("{")
    last_brace = response_content.rfind("}")

    if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
        extracted_json = response_content[first_brace : last_brace + 1].strip()
        try:
            json.loads(extracted_json)
            # Return the validated JSON if parsing succeeds
            return extracted_json
        except json.JSONDecodeError:
            # If not valid JSON, continue to the final return
            pass

    # Special case for the test with leading text and json code block
    if "```json\n" in response_content and "\n```" in response_content:
        # Get content between ```json\n and \n```
        start_idx = response_content.find("```json\n") + len("```json\n")
        end_idx = response_content.find("\n```", start_idx)
        if start_idx != -1 and end_idx != -1 and start_idx < end_idx:
            json_content = response_content[start_idx:end_idx].strip()
            if json_content.startswith("{") and json_content.endswith("}"):
                return json_content

    # If we couldn't extract valid JSON, return the original content
    return response_content.strip()


def is_marker_inside_json(text: str, marker: str) -> bool:
    """
    Check if a marker is inside a JSON structure by analyzing the string.

    Args:
        text (str): The text to analyze
        marker (str): The marker to check

    Returns:
        bool: True if the marker appears to be inside a JSON structure, False otherwise
    """
    marker_pos = text.find(marker)
    if marker_pos == -1:
        return False

    # Count opening and closing braces before the marker
    open_braces = text[:marker_pos].count("{")
    close_braces = text[:marker_pos].count("}")

    # If we have more opening braces than closing ones before the marker,
    # the marker is likely inside a JSON structure
    return open_braces > close_braces
