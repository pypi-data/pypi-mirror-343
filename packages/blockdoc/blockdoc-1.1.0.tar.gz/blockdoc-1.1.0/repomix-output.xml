This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed, content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.claude/
  commands/
    add-to-changelog.md
.github/
  workflows/
    python-lint.yml
    python-tests.yml
blockdoc/
  api/
    __init__.py
  conversions/
    __init__.py
    markdown.py
  core/
    __init__.py
    block.py
    document.py
  renderers/
    __init__.py
    html.py
    markdown.py
  schema/
    __init__.py
    blockdoc.schema.json
    loader.py
  utils/
    __init__.py
    sanitize.py
  __init__.py
docs/
  api-docs/
    renderers/
      html.md
      markdown.md
    utils/
      sanitize.md
    block.md
    document.md
    README.md
  spec/
    blockdoc-specification.md
  tutorials/
    block-types.md
    getting-started.md
    llm-integration.md
examples/
  llm-integration/
    llm_content_generator.py
    README.md
  output/
    markdown-converted.html
    markdown-converted.json
    markdown-roundtrip.md
  simple-blog/
    blog_generator.py
    README.md
    sample_content.json
  basic_example.py
  markdown_conversion_example.py
  README.md
scripts/
  format.sh
  lint.sh
tests/
  conversions/
    test_markdown.py
  core/
    __init__.py
    test_block.py
    test_document.py
  __init__.py
.gitignore
.pre-commit-config.yaml
.repomixignore
CHANGELOG.md
CLAUDE.md
CONTRIBUTING.md
LICENSE
MANIFEST.in
pyproject.toml
README.md
repomix.config.json
setup.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
</file>

<file path="repomix.config.json">
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": true,
    "removeEmptyLines": true,
    "compress": true,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path=".claude/commands/add-to-changelog.md">
# Update Changelog

This command adds a new entry to the project's CHANGELOG.md file.

## Usage

```
/add-to-changelog <version> <change_type> <message>
```

Where:
- `<version>` is the version number (e.g., "1.1.0")
- `<change_type>` is one of: "added", "changed", "deprecated", "removed", "fixed", "security"
- `<message>` is the description of the change

## Examples

```
/add-to-changelog 1.1.0 added "New markdown to BlockDoc conversion feature"
```

```
/add-to-changelog 1.0.2 fixed "Bug in HTML renderer causing incorrect output"
```

## Description

This command will:

1. Check if a CHANGELOG.md file exists and create one if needed
2. Look for an existing section for the specified version
   - If found, add the new entry under the appropriate change type section
   - If not found, create a new version section with today's date
3. Format the entry according to Keep a Changelog conventions
4. Commit the changes if requested

The CHANGELOG follows the [Keep a Changelog](https://keepachangelog.com/) format and [Semantic Versioning](https://semver.org/).

## Implementation

The command should:

1. Parse the arguments to extract version, change type, and message
2. Read the existing CHANGELOG.md file if it exists
3. If the file doesn't exist, create a new one with standard header
4. Check if the version section already exists
5. Add the new entry in the appropriate section
6. Write the updated content back to the file
7. Suggest committing the changes

Remember to update the package version in `__init__.py` and `setup.py` if this is a new version.
</file>

<file path="blockdoc/conversions/__init__.py">
__all__ = ["markdown_to_blockdoc"]
</file>

<file path="blockdoc/schema/blockdoc.schema.json">
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "BlockDoc Document",
  "description": "A structured text content format optimized for LLMs and targeted content editing",
  "type": "object",
  "required": [
    "article"
  ],
  "properties": {
    "article": {
      "type": "object",
      "required": [
        "title",
        "blocks"
      ],
      "properties": {
        "title": {
          "type": "string",
          "description": "The title of the article"
        },
        "metadata": {
          "type": "object",
          "description": "Optional metadata for the article",
          "properties": {
            "author": {
              "type": "string"
            },
            "publishedDate": {
              "type": "string",
              "format": "date-time"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "blocks": {
          "type": "array",
          "description": "The content blocks that make up the article",
          "items": {
            "type": "object",
            "required": [
              "id",
              "type",
              "content"
            ],
            "properties": {
              "id": {
                "type": "string",
                "description": "A unique, semantic identifier for the block",
                "pattern": "^[a-zA-Z0-9-_]+$"
              },
              "type": {
                "type": "string",
                "description": "The type of content block",
                "enum": [
                  "text",
                  "heading",
                  "image",
                  "code",
                  "list",
                  "quote",
                  "embed",
                  "divider"
                ]
              },
              "content": {
                "type": "string",
                "description": "The content of the block, interpreted based on type (markdown for text)"
              },
              "level": {
                "type": "integer",
                "description": "The level for heading blocks (1-6)",
                "minimum": 1,
                "maximum": 6
              },
              "language": {
                "type": "string",
                "description": "Programming language for code blocks"
              },
              "url": {
                "type": "string",
                "format": "uri",
                "description": "URL for image or embed blocks"
              },
              "alt": {
                "type": "string",
                "description": "Alt text for image blocks"
              },
              "caption": {
                "type": "string",
                "description": "Optional caption for media blocks"
              },
              "items": {
                "type": "array",
                "description": "Items for list blocks",
                "items": {
                  "type": "string"
                }
              },
              "list_type": {
                "type": "string",
                "description": "Type of list (ordered or unordered)",
                "enum": [
                  "ordered",
                  "unordered"
                ]
              },
              "listType": {
                "type": "string",
                "description": "Type of list (ordered or unordered) - legacy format",
                "enum": [
                  "ordered",
                  "unordered"
                ]
              },
              "embed_type": {
                "type": "string",
                "description": "Type of embedded content",
                "enum": [
                  "youtube",
                  "twitter",
                  "generic"
                ]
              },
              "embedType": {
                "type": "string",
                "description": "Type of embedded content - legacy format",
                "enum": [
                  "youtube",
                  "twitter",
                  "generic"
                ]
              },
              "attribution": {
                "type": "string",
                "description": "Attribution for quote blocks"
              }
            },
            "allOf": [
              {
                "if": {
                  "properties": {
                    "type": {
                      "const": "heading"
                    }
                  }
                },
                "then": {
                  "required": [
                    "level"
                  ]
                }
              },
              {
                "if": {
                  "properties": {
                    "type": {
                      "const": "code"
                    }
                  }
                },
                "then": {
                  "required": [
                    "language"
                  ]
                }
              },
              {
                "if": {
                  "properties": {
                    "type": {
                      "const": "image"
                    }
                  }
                },
                "then": {
                  "required": [
                    "url",
                    "alt"
                  ]
                }
              },
              {
                "if": {
                  "properties": {
                    "type": {
                      "const": "list"
                    }
                  }
                },
                "then": {
                  "anyOf": [
                    {
                      "required": [
                        "items",
                        "list_type"
                      ]
                    },
                    {
                      "required": [
                        "items",
                        "listType"
                      ]
                    }
                  ]
                }
              },
              {
                "if": {
                  "properties": {
                    "type": {
                      "const": "embed"
                    }
                  }
                },
                "then": {
                  "anyOf": [
                    {
                      "required": [
                        "url",
                        "embed_type"
                      ]
                    },
                    {
                      "required": [
                        "url",
                        "embedType"
                      ]
                    }
                  ]
                }
              }
            ]
          }
        }
      }
    }
  }
}
</file>

<file path="docs/api-docs/renderers/html.md">
# HTML Renderer API Reference

The HTML renderer converts BlockDoc documents to HTML.

## Import

```python
from blockdoc.renderers.html import render_to_html
```

## Functions

### `render_to_html(article)`

Renders a BlockDoc document to HTML.

**Parameters:**

- `article` (dict): The article object from a BlockDoc document

**Returns:**

- `str`: HTML representation

**Raises:**

- `ValueError`: If the article structure is invalid

**Example:**

```python
from blockdoc import BlockDocDocument
from blockdoc.renderers.html import render_to_html

doc = BlockDocDocument({
    "title": "My Document",
})
doc.add_block({"id": "intro", "type": "text", "content": "Introduction"})

# Method 1: Use the document's render method
html = doc.render_to_html()

# Method 2: Use the renderer directly
html = render_to_html(doc.article)
```

## Block Rendering Functions

The HTML renderer includes specialized functions for rendering each block type. These are typically used internally by the main `render_to_html` function, but can be used directly if needed.

### `render_block(block)`

Renders a single block to HTML.

**Parameters:**

- `block` (dict): Block data

**Returns:**

- `str`: HTML representation of the block

### Block Type-Specific Renderers

Each block type has its own rendering function:

- `render_text_block(block)`: Renders text blocks using the markdown library
- `render_heading_block(block)`: Renders heading blocks with the appropriate h1-h6 tag
- `render_image_block(block)`: Renders image blocks with proper alt text and optional captions
- `render_code_block(block)`: Renders code blocks with syntax highlighting via Pygments
- `render_list_block(block)`: Renders list blocks as ordered or unordered lists
- `render_quote_block(block)`: Renders quote blocks as blockquotes with optional attribution
- `render_embed_block(block)`: Renders embed blocks for YouTube, Twitter, or generic embeds
- `render_divider_block()`: Renders divider blocks as horizontal rules

## HTML Output Structure

The HTML renderer produces semantic, structured HTML with appropriate classes for styling:

- Document wrapper: `<article class="blockdoc-article">`
- Document title: `<h1 class="blockdoc-title">`
- Block wrapper: `<div class="blockdoc-block blockdoc-{type}" data-block-id="{id}" data-block-type="{type}">`

### Example Output

```html
<article class="blockdoc-article">
  <h1 class="blockdoc-title">My Document</h1>
  
  <div class="blockdoc-block blockdoc-text" data-block-id="intro" data-block-type="text">
    <p>This is the <strong>introduction</strong> paragraph with a <a href="https://example.com">link</a>.</p>
  </div>
  
  <div class="blockdoc-block blockdoc-heading" data-block-id="section-1" data-block-type="heading">
    <h2>Section Title</h2>
  </div>
  
  <div class="blockdoc-block blockdoc-list" data-block-id="feature-list" data-block-type="list">
    <ul class="blockdoc-list blockdoc-list-unordered">
      <li>First item</li>
      <li>Second item</li>
      <li>Third item</li>
    </ul>
  </div>
</article>
```

## CSS Styling

The HTML renderer adds CSS classes to facilitate styling but does not include the CSS itself. Here's a sample CSS starter for styling BlockDoc documents:

```css
.blockdoc-article {
  max-width: 800px;
  margin: 0 auto;
  font-family: system-ui, -apple-system, sans-serif;
  line-height: 1.6;
}

.blockdoc-title {
  margin-bottom: 1.5rem;
}

.blockdoc-block {
  margin-bottom: 1.5rem;
}

.blockdoc-image {
  max-width: 100%;
  height: auto;
}

.blockdoc-figure {
  margin: 0 0 1.5rem 0;
}

.blockdoc-caption {
  font-size: 0.9rem;
  color: #666;
  text-align: center;
  margin-top: 0.5rem;
}

.blockdoc-quote {
  border-left: 4px solid #ccc;
  padding-left: 1rem;
  font-style: italic;
  margin: 0;
}

.blockdoc-attribution {
  display: block;
  text-align: right;
  font-style: normal;
  font-size: 0.9rem;
  margin-top: 0.5rem;
}

.blockdoc-pre {
  background-color: #f5f5f5;
  border-radius: 4px;
  padding: 1rem;
  overflow-x: auto;
}

.blockdoc-code {
  font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
  font-size: 0.9rem;
}

.blockdoc-divider {
  border: 0;
  border-top: 1px solid #eee;
  margin: 2rem 0;
}

.blockdoc-embed-container {
  position: relative;
  width: 100%;
  padding-bottom: 56.25%; /* 16:9 aspect ratio */
  height: 0;
}

.blockdoc-embed-container iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
```

## Security Notes

The HTML renderer uses sanitization to prevent XSS attacks:

- Text content is processed through the markdown library, which handles escaping
- URLs are sanitized to prevent javascript: protocol and other unsafe URLs
- HTML content is sanitized to remove unsafe tags and attributes
</file>

<file path="docs/api-docs/renderers/markdown.md">
# Markdown Renderer API Reference

The Markdown renderer converts BlockDoc documents to Markdown.

## Import

```python
from blockdoc.renderers.markdown import render_to_markdown
```

## Functions

### `render_to_markdown(article)`

Renders a BlockDoc document to Markdown.

**Parameters:**

- `article` (dict): The article object from a BlockDoc document

**Returns:**

- `str`: Markdown representation

**Raises:**

- `ValueError`: If the article structure is invalid

**Example:**

```python
from blockdoc import BlockDocDocument
from blockdoc.renderers.markdown import render_to_markdown

doc = BlockDocDocument({
    "title": "My Document",
})
doc.add_block({"id": "intro", "type": "text", "content": "Introduction"})

# Method 1: Use the document's render method
markdown = doc.render_to_markdown()

# Method 2: Use the renderer directly
markdown = render_to_markdown(doc.article)
```

## Block Rendering Functions

The Markdown renderer includes specialized functions for rendering each block type. These are typically used internally by the main `render_to_markdown` function, but can be used directly if needed.

### `render_block_to_markdown(block)`

Renders a single block to Markdown.

**Parameters:**

- `block` (dict): Block data

**Returns:**

- `str`: Markdown representation of the block

### Block Type-Specific Renderers

Each block type has its own rendering function:

- `render_text_block_to_markdown(block)`: Renders text blocks (passes through Markdown content)
- `render_heading_block_to_markdown(block)`: Renders heading blocks with appropriate number of # symbols
- `render_image_block_to_markdown(block)`: Renders image blocks with Markdown image syntax
- `render_code_block_to_markdown(block)`: Renders code blocks with Markdown code fence syntax
- `render_list_block_to_markdown(block)`: Renders list blocks with proper formatting
- `render_quote_block_to_markdown(block)`: Renders quote blocks with > prefix
- `render_embed_block_to_markdown(block)`: Renders embed blocks as links
- `render_divider_block_to_markdown()`: Renders divider blocks as horizontal rules (---)

## Markdown Output Structure

The Markdown renderer produces clean, structured Markdown with the following elements:

- Document title: `# Title`
- Blocks separated by newlines
- Special formatting for each block type
- Block IDs preserved as HTML comments <!-- block-id: id --> for reference

### Example Output

```markdown
# My Document

<!-- block-id: intro -->
This is the **introduction** paragraph with a [link](https://example.com).

<!-- block-id: section-1 -->
## Section Title

<!-- block-id: feature-list -->
- First item
- Second item
- Third item

<!-- block-id: code-example -->
```python
def hello_world():
    print("Hello, World!")
```

<!-- block-id: quote -->
> This is a quote
> 
> — Source

<!-- block-id: divider -->
---
```

## Usage Considerations

### Preserving Block Identity

The Markdown renderer adds HTML comments containing block IDs to make it easier to map Markdown content back to the original BlockDoc structure. This can be useful for round-trip editing workflows.

### Limitations

Some BlockDoc features don't have direct Markdown equivalents:

1. **Embeds**: Rendered as links since Markdown doesn't natively support embeds
2. **Complex Images**: Caption information is included as text under the image
3. **Metadata**: Document metadata is not included in the Markdown output

### Custom Rendering

You can extend the Markdown renderer with custom functions for specific block types:

```python
from blockdoc.renderers.markdown import render_to_markdown

def custom_render_to_markdown(article):
    # Custom pre-processing if needed
    markdown = render_to_markdown(article)
    # Custom post-processing if needed
    return markdown
```

## Complete Example

```python
from blockdoc import BlockDocDocument, Block

# Create a document
doc = BlockDocDocument({
    "title": "BlockDoc Example",
})

# Add various block types
doc.add_block(Block.text("intro", "This is an introduction to **BlockDoc**."))
doc.add_block(Block.heading("section-1", 2, "Section One"))
doc.add_block(Block.text("para-1", "This is a paragraph with [a link](https://example.com)."))
doc.add_block(Block.code("code-1", "python", "print('Hello, BlockDoc!')"))
doc.add_block(Block.list("list-1", ["Item 1", "Item 2", "Item 3"], "unordered"))
doc.add_block(Block.quote("quote-1", "This is a quote", "Author"))
doc.add_block(Block.divider("div-1"))

# Render to Markdown
markdown = doc.render_to_markdown()
print(markdown)
```
</file>

<file path="docs/api-docs/utils/sanitize.md">
# Sanitization Utilities API Reference

The sanitization utilities provide functions for securing content in BlockDoc documents, particularly when rendering to HTML.

## Import

```python
from blockdoc.utils.sanitize import sanitize_html, sanitize_url
```

## Functions

### `sanitize_html(html_str)`

Sanitizes HTML content to remove potentially dangerous elements and attributes.

**Parameters:**

- `html_str` (str): HTML string to sanitize

**Returns:**

- `str`: Sanitized HTML string

**Example:**

```python
from blockdoc.utils.sanitize import sanitize_html

unsafe_html = '<script>alert("XSS")</script><p>Hello <strong>world</strong></p>'
safe_html = sanitize_html(unsafe_html)
# Result: '<p>Hello <strong>world</strong></p>'
```

### `sanitize_url(url_str)`

Sanitizes a URL to prevent javascript: protocol and other unsafe URL schemes.

**Parameters:**

- `url_str` (str): URL string to sanitize

**Returns:**

- `str`: Sanitized URL string

**Example:**

```python
from blockdoc.utils.sanitize import sanitize_url

unsafe_url = 'javascript:alert("XSS")'
safe_url = sanitize_url(unsafe_url)
# Result: ''

normal_url = 'https://example.com'
result = sanitize_url(normal_url)
# Result: 'https://example.com'
```

## Security Measures

### HTML Sanitization

The `sanitize_html` function implements several security measures:

1. **Tag Filtering**: Allows only safe tags such as `<p>`, `<a>`, `<strong>`, etc.
2. **Attribute Filtering**: Removes dangerous attributes like `onclick`, `onerror`, etc.
3. **Protocol Checking**: Ensures links use safe protocols (http, https, mailto, etc.)
4. **CSS Sanitization**: Removes potentially dangerous CSS properties and url() references

### URL Sanitization

The `sanitize_url` function implements these security measures:

1. **Protocol Checking**: Ensures URLs use safe protocols
2. **Format Validation**: Checks for malformed URLs
3. **Encoding Conversion**: Handles URL encoding to prevent bypass attacks

## Implementation Details

The sanitization functions use a whitelist approach, only allowing known-safe content through rather than trying to detect and block malicious content. This is a more secure approach.

### Allowed HTML Tags

The HTML sanitizer allows a subset of HTML tags that are considered safe for rendering:

- Structural: `p`, `div`, `span`, `br`, `hr`
- Headings: `h1`, `h2`, `h3`, `h4`, `h5`, `h6`
- Formatting: `b`, `strong`, `i`, `em`, `u`, `s`, `strike`, `sup`, `sub`
- Lists: `ul`, `ol`, `li`, `dl`, `dt`, `dd`
- Images: `img` (with src and alt attributes)
- Links: `a` (with href and title attributes)
- Tables: `table`, `thead`, `tbody`, `tr`, `th`, `td`
- Semantic: `figure`, `figcaption`, `blockquote`, `cite`, `code`, `pre`

### Allowed URL Protocols

The URL sanitizer allows a limited set of protocols:

- Web: `http`, `https`
- Email: `mailto`
- Phone: `tel`
- Other safe protocols: `ftp`, `data` (with restrictions)

## Usage in BlockDoc

These sanitization functions are used extensively in the HTML renderer to ensure that user-provided content is safe to render. They are called whenever potentially unsafe content is included in the output.

## Best Practices

1. **Always Sanitize User Content**: Use these utilities for any content that comes from external sources
2. **Apply Sanitization as Late as Possible**: Sanitize at render time rather than at storage time
3. **Use Both Functions**: Apply both HTML and URL sanitization when appropriate
4. **Don't Roll Your Own**: Security is challenging - use these tested functions rather than implementing your own

## Complete Example

```python
from blockdoc import BlockDocDocument, Block
from blockdoc.utils.sanitize import sanitize_html, sanitize_url

# Input from untrusted source
user_content = """
<p>This is an example with <script>alert('XSS')</script> unsafe content.</p>
<img src="javascript:alert('XSS')" alt="Image">
"""

user_url = "javascript:alert('XSS')"

# Sanitize the content before using it
safe_content = sanitize_html(user_content)
safe_url = sanitize_url(user_url)

# Create a BlockDoc document with the sanitized content
doc = BlockDocDocument({
    "title": "User Content Example",
})

doc.add_block(Block.text("user-content", safe_content))

# If the URL is not empty after sanitization, add an image block
if safe_url:
    doc.add_block(Block.image("user-image", safe_url, "User provided image"))

# Render to HTML (the renderer also applies sanitization)
html = doc.render_to_html()
```
</file>

<file path="docs/api-docs/block.md">
# Block Class API Reference

The `Block` class represents a single content block within a BlockDoc document.

## Import

```python
from blockdoc import Block
```

## Constructor

### `Block(data)`

Creates a new Block instance.

**Parameters:**

- `data` (dict): Block data containing at least the following required properties:
  - `id` (str): A unique, semantic identifier for the block
  - `type` (str): The block type, one of the allowed types
  - `content` (str, optional): The content of the block, defaults to empty string
  - Additional type-specific properties as required

**Raises:**

- `ValueError`: If the block is missing required properties or has an invalid type

**Example:**

```python
block = Block({
    "id": "introduction",
    "type": "text",
    "content": "This is a **formatted** introduction paragraph."
})
```

## Constants

### `ALLOWED_TYPES`

A list of allowed block types.

```python
ALLOWED_TYPES = [
    'text',
    'heading',
    'image',
    'code',
    'list',
    'quote',
    'embed',
    'divider',
]
```

### `TYPE_REQUIREMENTS`

A dictionary mapping block types to their required properties.

```python
TYPE_REQUIREMENTS = {
    'heading': ['level'],
    'code': ['language'],
    'image': ['url', 'alt'],
    'list': ['items', 'list_type'],
}
```

## Instance Methods

### `update(updates)`

Updates block properties with new values.

**Parameters:**

- `updates` (dict): Properties to update

**Returns:**

- `Block`: The updated block instance

**Notes:**

- Cannot change the block's `id` or `type`
- Any other property can be updated

**Example:**

```python
block.update({
    "content": "This is the updated content.",
    "custom_property": "custom value"
})
```

### `to_dict()`

Converts the block to a dictionary.

**Returns:**

- `dict`: The block as a dictionary

**Example:**

```python
block_dict = block.to_dict()
```

## Factory Methods

### `Block.text(id, content)`

Creates a text block.

**Parameters:**

- `id` (str): Block ID
- `content` (str): Markdown content

**Returns:**

- `Block`: A new text block instance

**Example:**

```python
text_block = Block.text("intro", "This is **formatted** text with [links](https://example.com).")
```

### `Block.heading(id, level, content)`

Creates a heading block.

**Parameters:**

- `id` (str): Block ID
- `level` (int): Heading level (1-6)
- `content` (str): Heading text

**Returns:**

- `Block`: A new heading block instance

**Example:**

```python
heading_block = Block.heading("section-title", 2, "Section Title")
```

### `Block.image(id, url, alt, caption=None)`

Creates an image block.

**Parameters:**

- `id` (str): Block ID
- `url` (str): Image URL
- `alt` (str): Alt text
- `caption` (str, optional): Optional caption

**Returns:**

- `Block`: A new image block instance

**Example:**

```python
image_block = Block.image(
    "hero-image", 
    "https://example.com/image.jpg", 
    "Example image", 
    "This is the caption"
)
```

### `Block.code(id, language, content)`

Creates a code block.

**Parameters:**

- `id` (str): Block ID
- `language` (str): Programming language
- `content` (str): Code content

**Returns:**

- `Block`: A new code block instance

**Example:**

```python
code_block = Block.code(
    "example-code", 
    "python", 
    "def hello_world():\n    print(\"Hello, World!\")"
)
```

### `Block.list(id, items, list_type='unordered')`

Creates a list block.

**Parameters:**

- `id` (str): Block ID
- `items` (list): List items
- `list_type` (str, optional): List type ("ordered" or "unordered"), defaults to "unordered"

**Returns:**

- `Block`: A new list block instance

**Example:**

```python
list_block = Block.list(
    "feature-list",
    [
        "First item",
        "Second item with **formatting**",
        "Third item with [link](https://example.com)"
    ],
    "unordered"
)
```

### `Block.quote(id, content, attribution=None)`

Creates a quote block.

**Parameters:**

- `id` (str): Block ID
- `content` (str): Quote content
- `attribution` (str, optional): Source attribution

**Returns:**

- `Block`: A new quote block instance

**Example:**

```python
quote_block = Block.quote(
    "important-quote",
    "This is a quotation that might span multiple lines.",
    "Source of the quote"
)
```

### `Block.embed(id, url, embed_type, caption=None)`

Creates an embed block.

**Parameters:**

- `id` (str): Block ID
- `url` (str): URL of embedded content
- `embed_type` (str): Type of embed ("youtube", "twitter", "generic")
- `caption` (str, optional): Optional caption

**Returns:**

- `Block`: A new embed block instance

**Example:**

```python
embed_block = Block.embed(
    "video-embed",
    "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
    "youtube",
    "Optional caption"
)
```

### `Block.divider(id)`

Creates a divider block.

**Parameters:**

- `id` (str): Block ID

**Returns:**

- `Block`: A new divider block instance

**Example:**

```python
divider_block = Block.divider("section-divider")
```

## Complete Example

```python
from blockdoc import Block

# Create blocks using factory methods
text_block = Block.text(
    "introduction",
    "Welcome to **BlockDoc**, a simple yet powerful format for structured content."
)

heading_block = Block.heading(
    "section-title",
    2,
    "Section Title"
)

list_block = Block.list(
    "feature-list",
    [
        "First feature",
        "Second feature",
        "Third feature"
    ],
    "unordered"
)

# Create a block directly with the constructor
custom_block = Block({
    "id": "custom-block",
    "type": "text",
    "content": "This is a custom block with extra properties.",
    "custom_property": "custom value"
})

# Update a block
custom_block.update({
    "content": "Updated content"
})

# Convert a block to a dictionary
block_dict = custom_block.to_dict()
```
</file>

<file path="docs/api-docs/document.md">
# BlockDocDocument Class API Reference

The `BlockDocDocument` class is the core class for creating, manipulating, and rendering BlockDoc documents.

## Import

```python
from blockdoc import BlockDocDocument
```

## Constructor

### `BlockDocDocument(options)`

Creates a new BlockDoc document.

**Parameters:**

- `options` (dict): Document initialization options
  - `title` (str): Document title
  - `metadata` (dict, optional): Optional document metadata
  - `blocks` (list, optional): Initial blocks to add

**Raises:**

- `ValueError`: If title is not provided

**Example:**

```python
doc = BlockDocDocument({
    "title": "My First BlockDoc Document",
    "metadata": {
        "author": "Your Name",
        "publishedDate": "2025-03-23T10:00:00Z",
        "tags": ["blockdoc", "example", "tutorial"]
    }
})
```

## Instance Methods

### `validate()`

Validates the document against the BlockDoc schema.

**Returns:**

- `bool`: True if valid

**Raises:**

- `ValueError`: If validation fails

**Example:**

```python
try:
    doc.validate()
    print("Document is valid!")
except ValueError as e:
    print(f"Validation error: {str(e)}")
```

### `add_block(block_data)`

Adds a block to the document.

**Parameters:**

- `block_data` (dict or Block): Block data or Block instance

**Returns:**

- `Block`: The created block

**Raises:**

- `ValueError`: If block with the same ID already exists

**Example:**

```python
from blockdoc import Block

# Add using a Block instance
doc.add_block(Block.text("intro", "Welcome to my first BlockDoc document."))

# Add using a dictionary
doc.add_block({
    "id": "explanation",
    "type": "text",
    "content": "This is a **formatted** paragraph with a [link](https://example.com)."
})
```

### `insert_block(block_data, position)`

Inserts a block at a specific position.

**Parameters:**

- `block_data` (dict or Block): Block data or Block instance
- `position` (int): Position to insert at

**Returns:**

- `Block`: The created block

**Raises:**

- `ValueError`: If block with the same ID already exists

**Example:**

```python
# Insert a block at position 0 (beginning of document)
doc.insert_block(Block.heading("title", 1, "Document Title"), 0)
```

### `get_block(id)`

Gets a block by ID.

**Parameters:**

- `id` (str): Block ID

**Returns:**

- `dict` or `None`: The block dictionary or None if not found

**Example:**

```python
intro_block = doc.get_block("intro")
if intro_block:
    print(f"Found block: {intro_block['content']}")
else:
    print("Block not found")
```

### `update_block(id, updates)`

Updates a block by ID.

**Parameters:**

- `id` (str): Block ID
- `updates` (dict): Properties to update

**Returns:**

- `dict`: The updated block

**Raises:**

- `ValueError`: If block with the ID doesn't exist

**Example:**

```python
doc.update_block("intro", {
    "content": "This is the updated introduction paragraph."
})
```

### `remove_block(id)`

Removes a block by ID.

**Parameters:**

- `id` (str): Block ID

**Returns:**

- `bool`: True if removed, False if not found

**Example:**

```python
if doc.remove_block("unwanted-block"):
    print("Block removed successfully")
else:
    print("Block not found")
```

### `move_block(id, new_position)`

Moves a block to a new position.

**Parameters:**

- `id` (str): Block ID
- `new_position` (int): New position

**Returns:**

- `bool`: True if moved, False if not found

**Raises:**

- `ValueError`: If new_position is invalid

**Example:**

```python
doc.move_block("intro", 2)  # Move the intro block to the third position
```

### `render_to_html()`

Renders the document to HTML.

**Returns:**

- `str`: HTML representation

**Example:**

```python
html = doc.render_to_html()
with open("document.html", "w") as f:
    f.write(html)
```

### `render_to_markdown()`

Renders the document to Markdown.

**Returns:**

- `str`: Markdown representation

**Example:**

```python
markdown = doc.render_to_markdown()
with open("document.md", "w") as f:
    f.write(markdown)
```

### `to_dict()`

Exports the document as a dictionary.

**Returns:**

- `dict`: Document as dictionary

**Example:**

```python
doc_dict = doc.to_dict()
```

### `to_json(indent=2)`

Exports the document as a JSON string.

**Parameters:**

- `indent` (int, optional): JSON indentation level, defaults to 2

**Returns:**

- `str`: Document as JSON string

**Example:**

```python
json_str = doc.to_json()
with open("document.json", "w") as f:
    f.write(json_str)
```

## Static Methods

### `from_dict(data)`

Creates a BlockDoc document from a dictionary.

**Parameters:**

- `data` (dict): Document data

**Returns:**

- `BlockDocDocument`: New document instance

**Raises:**

- `ValueError`: If data is invalid

**Example:**

```python
doc_dict = {
    "article": {
        "title": "My Document",
        "metadata": {"author": "Your Name"},
        "blocks": [
            {"id": "intro", "type": "text", "content": "Introduction paragraph."}
        ]
    }
}

doc = BlockDocDocument.from_dict(doc_dict)
```

### `from_json(json_str)`

Creates a BlockDoc document from a JSON string.

**Parameters:**

- `json_str` (str): JSON string

**Returns:**

- `BlockDocDocument`: New document instance

**Raises:**

- `ValueError`: If JSON is invalid

**Example:**

```python
with open("document.json", "r") as f:
    json_str = f.read()

doc = BlockDocDocument.from_json(json_str)
```

## Complete Example

```python
from blockdoc import BlockDocDocument, Block

# Create a new document
doc = BlockDocDocument({
    "title": "Getting Started with BlockDoc",
    "metadata": {
        "author": "BlockDoc Team",
        "publishedDate": "2025-03-23T10:00:00Z",
        "tags": ["blockdoc", "tutorial", "content"]
    }
})

# Add blocks
doc.add_block(Block.text(
    "intro",
    "Welcome to **BlockDoc**, a simple yet powerful format for structured content."
))

doc.add_block(Block.heading(
    "section-1",
    2,
    "Getting Started"
))

doc.add_block(Block.text(
    "para-1",
    "This is a paragraph with some **bold text** and a [link](https://example.com)."
))

doc.add_block(Block.code(
    "example-code",
    "python",
    "from blockdoc import BlockDocDocument, Block\n\ndoc = BlockDocDocument({\n    \"title\": \"Example\"\n})"
))

# Validate the document
doc.validate()

# Render to different formats
html = doc.render_to_html()
markdown = doc.render_to_markdown()
json_str = doc.to_json()

# Update a block
doc.update_block("para-1", {
    "content": "This paragraph has been updated with new content."
})

# Remove a block
doc.remove_block("example-code")

# Add a new block and move it
doc.add_block(Block.list(
    "feature-list",
    ["Feature 1", "Feature 2", "Feature 3"],
    "unordered"
))
doc.move_block("feature-list", 1)  # Move it to the second position
```
</file>

<file path="docs/api-docs/README.md">
# BlockDoc API Documentation

This directory contains the comprehensive API documentation for the BlockDoc Python package.

## Table of Contents

### Core Components

- [Block](block.md) - The block class that represents individual content blocks
- [BlockDocDocument](document.md) - The main document class for creating and manipulating BlockDoc documents

### Renderers

- [HTML Renderer](renderers/html.md) - Renders BlockDoc documents to HTML
- [Markdown Renderer](renderers/markdown.md) - Renders BlockDoc documents to Markdown

### Utilities

- [Sanitization](utils/sanitize.md) - Utilities for sanitizing HTML and URLs

## Getting Started

For a quick introduction to using BlockDoc, see the [Getting Started](../tutorials/getting-started.md) tutorial.

## Complete Documentation

For more detailed information about BlockDoc, check out:

- [Formal Specification](../spec/blockdoc-specification.md)
- [Tutorials](../tutorials/)
- [Examples](../../examples/)
</file>

<file path="docs/tutorials/block-types.md">
# Understanding BlockDoc Block Types

This tutorial provides a comprehensive guide to all the block types available in BlockDoc, including their properties, use cases, and examples.

## Table of Contents

1. [Text Blocks](#text-blocks)
2. [Heading Blocks](#heading-blocks)
3. [Image Blocks](#image-blocks)
4. [Code Blocks](#code-blocks)
5. [List Blocks](#list-blocks)
6. [Quote Blocks](#quote-blocks)
7. [Embed Blocks](#embed-blocks)
8. [Divider Blocks](#divider-blocks)
9. [Custom Block Properties](#custom-block-properties)

## Text Blocks

Text blocks are the most common blocks in a document, representing paragraphs of text formatted with Markdown.

### Properties

- `id` (required): A unique identifier for the block
- `type`: Always `"text"` 
- `content`: Markdown-formatted text content

### Example

```python
from blockdoc import Block

text_block = Block.text(
    "introduction",
    "This is a paragraph with **bold text**, *italic text*, and [links](https://example.com).\n\nMarkdown allows for multiple paragraphs within a single text block."
)
```

### Rendering

- **HTML**: Renders as `<p>` tags with HTML formatted according to Markdown syntax
- **Markdown**: Preserves the original Markdown content

### Use Cases

- Regular paragraphs
- Rich text content with formatting
- Multi-paragraph sections

### Markdown Features Supported

- **Bold**: `**bold text**` or `__bold text__`
- **Italic**: `*italic text*` or `_italic text_`
- **Links**: `[link text](https://example.com)`
- **Inline Code**: `` `code` ``
- **Multiple Paragraphs**: Separate with blank lines
- **Line Breaks**: End a line with two spaces or `\n`
- **Strikethrough**: `~~strikethrough~~`

## Heading Blocks

Heading blocks represent section titles and subheadings in a document.

### Properties

- `id` (required): A unique identifier for the block
- `type`: Always `"heading"`
- `content`: The heading text
- `level` (required): Heading level, from 1 (highest) to 6 (lowest)

### Example

```python
from blockdoc import Block

# Main heading (h1)
heading1 = Block.heading("page-title", 1, "Document Title")

# Section heading (h2)
heading2 = Block.heading("section-1", 2, "First Section")

# Subsection heading (h3)
heading3 = Block.heading("subsection-1-1", 3, "Subsection")
```

### Rendering

- **HTML**: Renders as `<h1>` through `<h6>` tags, depending on the level
- **Markdown**: Renders with the corresponding number of `#` characters

### Use Cases

- Document titles
- Section headings
- Content organization and hierarchy

### Best Practices

- Use heading levels consistently and hierarchically
- Don't skip heading levels (e.g., don't follow an h2 with an h4)
- Keep heading text concise
- Use semantic IDs that reflect the heading content

## Image Blocks

Image blocks represent visual content with a URL source, alternative text, and an optional caption.

### Properties

- `id` (required): A unique identifier for the block
- `type`: Always `"image"`
- `content`: Usually empty or used for additional information
- `url` (required): The image URL
- `alt` (required): Alternative text for accessibility
- `caption` (optional): Image caption

### Example

```python
from blockdoc import Block

# Basic image
basic_image = Block.image(
    "hero-image",
    "https://example.com/image.jpg",
    "Photo of mountains at sunset"
)

# Image with caption
captioned_image = Block.image(
    "diagram",
    "https://example.com/diagram.png",
    "System architecture diagram",
    "Figure 1: System Architecture Overview"
)
```

### Rendering

- **HTML**: Renders as an `<img>` element, with optional `<figure>` and `<figcaption>` for captioned images
- **Markdown**: Renders as Markdown image syntax `![alt](url)` with caption as text below

### Use Cases

- Photos and illustrations
- Charts and diagrams
- Screenshots
- Logos and icons

### Best Practices

- Always provide meaningful alt text for accessibility
- Use high-quality, optimized images
- Include captions for images that need additional context

## Code Blocks

Code blocks contain programming code with syntax highlighting based on the specified language.

### Properties

- `id` (required): A unique identifier for the block
- `type`: Always `"code"`
- `content`: The code content, preserving whitespace and indentation
- `language` (required): Programming language for syntax highlighting

### Example

```python
from blockdoc import Block

python_code = Block.code(
    "example-code",
    "python",
    """def hello_world():
    print("Hello, World!")
    
# Call the function
hello_world()"""
)

html_code = Block.code(
    "html-example",
    "html",
    """<!DOCTYPE html>
<html>
<head>
    <title>Example</title>
</head>
<body>
    <h1>Hello, World!</h1>
</body>
</html>"""
)
```

### Rendering

- **HTML**: Renders as a `<pre><code>` block with syntax highlighting
- **Markdown**: Renders as a fenced code block with language identifier (```python)

### Supported Languages

The code block supports any language recognized by the Pygments library, including but not limited to:

- Python
- JavaScript
- HTML
- CSS
- Java
- C/C++
- Ruby
- PHP
- Go
- Rust
- Shell/Bash
- SQL
- JSON
- YAML
- Markdown
- And many more...

Use `"plain"` for plain text without syntax highlighting.

### Use Cases

- Example code
- Configuration snippets
- Command-line instructions
- Data examples (JSON, XML, etc.)

### Best Practices

- Specify the correct language for proper syntax highlighting
- Use meaningful indentation and formatting
- Keep code examples concise and focused
- Include comments when necessary for clarity

## List Blocks

List blocks represent ordered (numbered) or unordered (bulleted) lists.

### Properties

- `id` (required): A unique identifier for the block
- `type`: Always `"list"`
- `content`: Usually empty
- `items` (required): Array of strings, each representing a list item
- `list_type` (required): Either `"ordered"` or `"unordered"`

### Example

```python
from blockdoc import Block

# Unordered list
feature_list = Block.list(
    "features",
    [
        "First feature with **bold text**",
        "Second feature with [link](https://example.com)",
        "Third feature with `code`"
    ],
    "unordered"
)

# Ordered list
steps_list = Block.list(
    "steps",
    [
        "First step",
        "Second step",
        "Third step"
    ],
    "ordered"
)
```

### Rendering

- **HTML**: Renders as `<ul>` or `<ol>` with `<li>` elements
- **Markdown**: Renders as Markdown list syntax (`-` or numbers)

### Use Cases

- Feature lists
- Steps in a process
- Pros and cons
- Table of contents
- Requirements

### Markdown in List Items

Each list item supports Markdown formatting:

- Bold, italic, and other text formatting
- Links
- Inline code
- Other inline Markdown elements

### Best Practices

- Use ordered lists for sequential steps
- Use unordered lists for non-sequential items
- Keep list items concise
- Use consistent formatting across list items
- Use nested list items when appropriate for hierarchy

## Quote Blocks

Quote blocks represent quotations or excerpts, optionally with attribution.

### Properties

- `id` (required): A unique identifier for the block
- `type`: Always `"quote"`
- `content`: The quoted text, can contain Markdown
- `attribution` (optional): Source of the quote

### Example

```python
from blockdoc import Block

# Simple quote
simple_quote = Block.quote(
    "einstein-quote",
    "Imagination is more important than knowledge."
)

# Quote with attribution
attributed_quote = Block.quote(
    "design-quote",
    "Design is not just what it looks like and feels like. Design is how it works.",
    "Steve Jobs"
)
```

### Rendering

- **HTML**: Renders as a `<blockquote>` element with optional `<cite>` for attribution
- **Markdown**: Renders with `>` prefix and attribution as text

### Use Cases

- Testimonials
- Important statements
- Literary quotes
- Excerpts from other sources

### Best Practices

- Use quotes for exact wording from sources
- Always include attribution for others' words
- Use Markdown formatting within quotes when needed
- Keep quotes concise and focused

## Embed Blocks

Embed blocks represent embedded content from external sources, such as videos or social media posts.

### Properties

- `id` (required): A unique identifier for the block
- `type`: Always `"embed"`
- `content`: Usually empty or used for additional information
- `url` (required): URL of the embedded content
- `embed_type` (required): Type of embed (`"youtube"`, `"twitter"`, or `"generic"`)
- `caption` (optional): Caption for the embedded content

### Example

```python
from blockdoc import Block

# YouTube video
youtube_embed = Block.embed(
    "tutorial-video",
    "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
    "youtube",
    "Video tutorial on using BlockDoc"
)

# Twitter post
twitter_embed = Block.embed(
    "tweet",
    "https://twitter.com/user/status/123456789",
    "twitter",
    "Announcement tweet"
)

# Generic iframe embed
generic_embed = Block.embed(
    "map",
    "https://www.google.com/maps/embed?pb=!1m18!1m12!...",
    "generic",
    "Office location"
)
```

### Rendering

- **HTML**: Renders as appropriate embed code (iframe for YouTube, Twitter widget, etc.)
- **Markdown**: Renders as a link, since Markdown doesn't support embeds

### Supported Embed Types

1. **YouTube**
   - Automatically extracts video ID from various YouTube URL formats
   - Renders as a responsive iframe

2. **Twitter**
   - Embeds a Twitter post using Twitter's widget
   - Loads Twitter's JavaScript for interactive features

3. **Generic**
   - Creates a standard iframe for embedding any content
   - Use for maps, forms, or other iframe-compatible content

### Use Cases

- Instructional videos
- Social media content
- Interactive maps
- Live demos
- External content integration

### Best Practices

- Choose the appropriate embed type for the content
- Always provide a descriptive caption
- Consider fallback content for Markdown rendering
- Be aware of privacy implications of third-party embeds

## Divider Blocks

Divider blocks represent horizontal separators between content sections.

### Properties

- `id` (required): A unique identifier for the block
- `type`: Always `"divider"`
- `content`: Usually empty

### Example

```python
from blockdoc import Block

divider = Block.divider("section-break")
```

### Rendering

- **HTML**: Renders as an `<hr>` element
- **Markdown**: Renders as `---`

### Use Cases

- Separating content sections
- Indicating thematic breaks
- Creating visual separation

### Best Practices

- Use sparingly to avoid excessive visual breaks
- Place between logical content sections
- Use meaningful IDs that indicate the purpose of the divider

## Custom Block Properties

All block types support additional custom properties for special use cases.

### Adding Custom Properties

```python
from blockdoc import Block

# Add custom properties to a text block
custom_block = Block({
    "id": "special-text",
    "type": "text",
    "content": "This block has custom properties.",
    "customProp1": "value1",
    "customProp2": 42,
    "customProp3": {
        "nested": "object"
    }
})

# Or use update method on an existing block
normal_block = Block.text("intro", "Introduction text")
normal_block.update({
    "customFlag": True,
    "customData": ["array", "of", "values"]
})
```

### Use Cases for Custom Properties

1. **Frontend rendering hints**
   - `background_color`: Specify a background color
   - `theme`: Specify a theme variant

2. **Tracking and analytics**
   - `created_at`: Timestamp for creation
   - `updated_at`: Timestamp for updates
   - `created_by`: Author identifier

3. **Processing instructions**
   - `processing_hints`: Instructions for renderers
   - `translation_status`: Track translation state

4. **Application-specific metadata**
   - Domain-specific properties
   - Integration information

### Best Practices for Custom Properties

- Use custom properties sparingly and with purpose
- Document all custom properties in your application
- Prefer snake_case naming in Python (e.g., `custom_property`)
- Consider performance implications for large nested objects
- Don't use custom properties to work around core structure

## Conclusion

BlockDoc's block types provide a flexible yet structured approach to content representation. By understanding the properties and best practices for each block type, you can create rich, structured documents that are easy to manipulate and render in different formats.

For more advanced topics, check out the [LLM Integration Tutorial](llm-integration.md) to learn how to use BlockDoc with language models.
</file>

<file path="docs/tutorials/getting-started.md">
# Getting Started with BlockDoc

This tutorial will guide you through the basics of using BlockDoc to create, manipulate, and render structured content.

## Installation

Install BlockDoc from PyPI:

```bash
pip install blockdoc
```

## Creating Your First Document

Let's create a simple blog post using BlockDoc:

```python
from blockdoc import BlockDocDocument, Block

# Create a new document with a title and metadata
blog_post = BlockDocDocument({
    "title": "My First BlockDoc Post",
    "metadata": {
        "author": "Your Name",
        "publishedDate": "2025-03-23T10:00:00Z",
        "tags": ["blockdoc", "tutorial", "beginner"]
    }
})

# Add an introduction
blog_post.add_block(Block.text(
    "intro",
    "Welcome to my **first post** using BlockDoc! In this post, I'll explain why BlockDoc is a great choice for structured content."
))

# Add a heading
blog_post.add_block(Block.heading(
    "benefits",  # Semantic ID describing the section's purpose
    2,           # Heading level (h2)
    "Benefits of BlockDoc"
))

# Add a list of benefits
blog_post.add_block(Block.list(
    "benefits-list",
    [
        "**LLM-friendly**: Designed for AI generation and targeted updates",
        "**Simple structure**: Easy to understand and work with",
        "**Semantic IDs**: Blocks have meaningful identifiers",
        "**Flexible rendering**: Output to HTML, Markdown, or custom formats"
    ],
    "unordered"  # List type (unordered or ordered)
))

# Add a code example
blog_post.add_block(Block.code(
    "code-example",
    "python",    # Language for syntax highlighting
    """from blockdoc import BlockDocDocument, Block

doc = BlockDocDocument({
    "title": "Example Document"
})

doc.add_block(Block.text("intro", "This is an introduction."))"""
))

# Add a conclusion
blog_post.add_block(Block.text(
    "conclusion",
    "As you can see, BlockDoc makes it easy to create structured content that's both human and machine-friendly."
))
```

## Validating Your Document

BlockDoc includes schema validation to ensure documents follow the correct structure:

```python
try:
    blog_post.validate()
    print("Document is valid!")
except ValueError as e:
    print(f"Validation error: {str(e)}")
```

## Rendering to Different Formats

One of BlockDoc's strengths is the ability to render content in different formats:

### Rendering to HTML

```python
# Get the HTML representation
html = blog_post.render_to_html()

# Save to a file
with open("blog_post.html", "w", encoding="utf-8") as f:
    f.write(html)
```

### Rendering to Markdown

```python
# Get the Markdown representation
markdown = blog_post.render_to_markdown()

# Save to a file
with open("blog_post.md", "w", encoding="utf-8") as f:
    f.write(markdown)
```

### Exporting to JSON

```python
# Get the JSON representation
json_str = blog_post.to_json(indent=2)

# Save to a file
with open("blog_post.json", "w", encoding="utf-8") as f:
    f.write(json_str)
```

## Working with Existing Documents

You can also load and modify existing BlockDoc documents:

### Loading from JSON

```python
with open("blog_post.json", "r", encoding="utf-8") as f:
    json_str = f.read()

# Create a document from JSON
loaded_doc = BlockDocDocument.from_json(json_str)
```

### Updating Blocks

```python
# Update a specific block by ID
loaded_doc.update_block("intro", {
    "content": "Welcome to my **updated** introduction using BlockDoc!"
})

# Render the updated document
updated_html = loaded_doc.render_to_html()
```

### Moving and Removing Blocks

```python
# Move a block to a different position
loaded_doc.move_block("conclusion", 1)  # Move conclusion to the second position

# Remove a block
loaded_doc.remove_block("code-example")
```

## Adding Different Block Types

BlockDoc supports multiple block types for different content needs:

### Image Block

```python
blog_post.add_block(Block.image(
    "screenshot",
    "https://example.com/blockdoc-screenshot.jpg",
    "Screenshot of BlockDoc in action",
    "Figure 1: BlockDoc document structure"  # Optional caption
))
```

### Quote Block

```python
blog_post.add_block(Block.quote(
    "testimonial",
    "BlockDoc has revolutionized how we structure content for our LLM applications.",
    "Jane Developer, AI Solutions Inc."  # Optional attribution
))
```

### Embed Block

```python
blog_post.add_block(Block.embed(
    "tutorial-video",
    "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
    "youtube",  # Embed type
    "Video tutorial on using BlockDoc"  # Optional caption
))
```

### Divider Block

```python
blog_post.add_block(Block.divider("section-divider"))
```

## Best Practices

1. **Use Semantic IDs**: Choose IDs that describe the content purpose, not just sequential numbers
2. **Organize Content in Logical Blocks**: Keep blocks focused on discrete units of content
3. **Validate Documents**: Always validate before rendering or storage
4. **Handle Errors Gracefully**: Implement proper error handling for validation and operations
5. **Sanitize External Content**: Use sanitization utilities for user-provided content

## Next Steps

Now that you've learned the basics of using BlockDoc, check out these resources to deepen your knowledge:

- [Block Types Tutorial](block-types.md) - Explore all the available block types
- [LLM Integration Tutorial](llm-integration.md) - Learn how to use BlockDoc with language models
- [API Reference](../api-docs/) - Complete reference documentation
- [Examples](../../examples/) - Real-world examples of BlockDoc in action
</file>

<file path="docs/tutorials/llm-integration.md">
# Integrating BlockDoc with Language Models

This tutorial demonstrates how to effectively integrate BlockDoc with Language Model (LLM) APIs to create, update, and enhance structured content.

## Table of Contents

1. [Why BlockDoc is Ideal for LLMs](#why-blockdoc-is-ideal-for-llms)
2. [Setting Up LLM Integration](#setting-up-llm-integration)
3. [Creating Content with LLMs](#creating-content-with-llms)
4. [Updating Specific Blocks](#updating-specific-blocks)
5. [Enhancing Existing Content](#enhancing-existing-content)
6. [Translating Documents](#translating-documents)
7. [Designing Effective Prompts](#designing-effective-prompts)
8. [Advanced Integration Patterns](#advanced-integration-patterns)
9. [Performance and Cost Optimization](#performance-and-cost-optimization)

## Why BlockDoc is Ideal for LLMs

BlockDoc's structure offers significant advantages when working with LLMs:

1. **Targeted Updates**: Make precise requests to update specific blocks by ID
2. **Structured Output**: Get predictable, structured content rather than free-form text
3. **Semantic Context**: Blocks contain meaningful IDs that provide context for the LLM
4. **Granular Control**: Modularize content for more efficient token usage and more focused generation

## Setting Up LLM Integration

First, let's set up a basic integration with an LLM service. This example uses OpenAI's API, but the principles apply to any LLM API:

```python
import os
import json
from openai import OpenAI
from blockdoc import BlockDocDocument, Block

# Initialize OpenAI client
client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

# Helper function for LLM interaction
def generate_text_with_llm(prompt, model="gpt-4", max_tokens=1000):
    """Generate text using an LLM model"""
    response = client.chat.completions.create(
        model=model,
        messages=[
            {"role": "system", "content": "You are a helpful content creation assistant."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=max_tokens,
        temperature=0.7
    )
    return response.choices[0].message.content
```

## Creating Content with LLMs

Let's use an LLM to generate a complete BlockDoc document:

```python
def create_document_with_llm(title, topic, num_sections=3):
    """Create a complete BlockDoc document using an LLM"""
    # 1. Generate the document structure with the LLM
    prompt = f"""
    Create a structured document about "{topic}" with {num_sections} main sections.
    For each section, provide:
    - A section heading title
    - One paragraph of introductory text
    - A list of 3-4 key points
    
    Format your response as JSON with the following structure:
    {{
        "sections": [
            {{
                "heading": "Section Title",
                "intro": "Introduction text...",
                "points": ["Point 1", "Point 2", "Point 3"]
            }}
        ]
    }}
    """
    
    response = generate_text_with_llm(prompt)
    
    # Parse the JSON response
    try:
        content_structure = json.loads(response)
    except json.JSONDecodeError:
        # Fallback: Try to extract JSON from the response using regex or other means
        import re
        json_match = re.search(r'```json\n(.*?)\n```', response, re.DOTALL)
        if json_match:
            content_structure = json.loads(json_match.group(1))
        else:
            raise ValueError("Could not parse LLM response as JSON")
    
    # 2. Create the BlockDoc document
    doc = BlockDocDocument({
        "title": title,
        "metadata": {
            "author": "AI Assistant",
            "topic": topic,
            "generated": True
        }
    })
    
    # 3. Add an introduction block
    intro_prompt = f"Write a 2-3 sentence introduction for an article titled '{title}' about {topic}."
    intro_content = generate_text_with_llm(intro_prompt, max_tokens=200)
    doc.add_block(Block.text("introduction", intro_content))
    
    # 4. Add the sections from the structure
    for i, section in enumerate(content_structure["sections"]):
        section_id = f"section-{i+1}"
        heading_id = f"{section_id}-heading"
        intro_id = f"{section_id}-intro"
        list_id = f"{section_id}-points"
        
        # Add heading
        doc.add_block(Block.heading(heading_id, 2, section["heading"]))
        
        # Add intro paragraph
        doc.add_block(Block.text(intro_id, section["intro"]))
        
        # Add bullet points
        doc.add_block(Block.list(list_id, section["points"], "unordered"))
    
    # 5. Add a conclusion
    conclusion_prompt = f"Write a brief conclusion for an article about {topic}."
    conclusion_content = generate_text_with_llm(conclusion_prompt, max_tokens=200)
    doc.add_block(Block.text("conclusion", conclusion_content))
    
    return doc

# Usage example
document = create_document_with_llm(
    "BlockDoc: Structured Content for the AI Age",
    "how structured content formats enhance AI content generation"
)

# Save the document
with open("generated_article.json", "w") as f:
    f.write(document.to_json(indent=2))

# Render to HTML
with open("generated_article.html", "w") as f:
    f.write(document.render_to_html())
```

## Updating Specific Blocks

One of BlockDoc's strengths is the ability to target specific blocks for updates:

```python
async def update_block_with_llm(document, block_id, instruction):
    """Update a specific block in a document using an LLM"""
    # 1. Get the existing block
    block = document.get_block(block_id)
    if not block:
        raise ValueError(f"Block with ID '{block_id}' not found")
    
    # 2. Create a prompt based on the block type
    block_type = block["type"]
    content = block.get("content", "")
    
    if block_type == "text":
        prompt = f"""
        Here is an existing text block:
        
        {content}
        
        Please update this text according to this instruction: {instruction}
        
        Preserve any markdown formatting as appropriate. Return only the updated text.
        """
    elif block_type == "heading":
        prompt = f"""
        Here is an existing heading:
        
        {content}
        
        Please update this heading according to this instruction: {instruction}
        
        Keep it concise and clear. Return only the updated heading text.
        """
    elif block_type == "list":
        items = block.get("items", [])
        items_text = "\n".join([f"- {item}" for item in items])
        
        prompt = f"""
        Here is an existing list:
        
        {items_text}
        
        Please update this list according to this instruction: {instruction}
        
        Format your response as a JSON array of strings, like this:
        ["Item 1", "Item 2", "Item 3"]
        """
    else:
        prompt = f"""
        Here is existing content of type {block_type}:
        
        {content}
        
        Please update this content according to this instruction: {instruction}
        
        Return only the updated content.
        """
    
    # 3. Generate the updated content
    updated_content = generate_text_with_llm(prompt)
    
    # 4. Process the response based on block type
    updates = {}
    
    if block_type == "list":
        try:
            # Try to parse JSON array
            updated_items = json.loads(updated_content)
            if isinstance(updated_items, list):
                updates["items"] = updated_items
            else:
                # Fallback: Extract items line by line
                updates["items"] = [line.strip().lstrip('-').strip() 
                                  for line in updated_content.split('\n') 
                                  if line.strip()]
        except json.JSONDecodeError:
            # Fallback: Extract items line by line
            updates["items"] = [line.strip().lstrip('-').strip() 
                              for line in updated_content.split('\n') 
                              if line.strip()]
    else:
        updates["content"] = updated_content
    
    # 5. Update the block
    document.update_block(block_id, updates)
    
    return document

# Usage example
document = BlockDocDocument.from_json(open("blog_post.json").read())

# Update a specific block
document = update_block_with_llm(
    document,
    "introduction",
    "Make the introduction more engaging and add a statistic about content creation."
)

# Update another block
document = update_block_with_llm(
    document,
    "section-2-points",
    "Add two more benefits related to SEO and content reusability."
)
```

## Enhancing Existing Content

You can use LLMs to enhance your BlockDoc content in various ways:

```python
def enhance_document_with_llm(document):
    """Enhance an existing document by adding details, citations, etc."""
    
    # 1. Get all text blocks for enhancement
    text_blocks = [(i, block) for i, block in enumerate(document.article["blocks"]) 
                  if block["type"] == "text"]
    
    for index, block in text_blocks:
        # Only enhance blocks that are short or lack detail
        if len(block["content"]) < 300:
            prompt = f"""
            Here is a text block that needs enhancement:
            
            {block["content"]}
            
            Please enhance this content by:
            1. Adding more specific details
            2. Ensuring it has a clear topic sentence and conclusion
            3. Making the language more engaging
            4. Preserving all existing information
            
            Return only the enhanced text.
            """
            
            enhanced_content = generate_text_with_llm(prompt)
            document.update_block(block["id"], {"content": enhanced_content})
    
    # 2. Add citations to factual claims if needed
    for index, block in enumerate(document.article["blocks"]):
        if block["type"] == "text" and any(keyword in block["content"].lower() 
                                         for keyword in ["according to", "research", "study", "found", "data"]):
            
            prompt = f"""
            This text appears to contain factual claims:
            
            {block["content"]}
            
            For each factual claim, please suggest a suitable citation or source in [Author, Year] format.
            Return a JSON object like this:
            {{
              "factual_claims": [
                {{
                  "claim": "the text of the claim",
                  "citation": "[Author, Year]"
                }}
              ]
            }}
            """
            
            citation_suggestions = generate_text_with_llm(prompt)
            
            # Parse the response (this would need more robust parsing in production)
            try:
                citation_data = json.loads(citation_suggestions)
                # Store the citations as a custom property on the block
                document.update_block(block["id"], {"citation_info": citation_data})
            except:
                # Fallback: Store the raw suggestion
                document.update_block(block["id"], {"citation_suggestions": citation_suggestions})
    
    return document
```

## Translating Documents

BlockDoc's structure makes it easy to translate content while preserving the overall structure:

```python
def translate_document(document, target_language):
    """Translate a BlockDoc document to another language"""
    
    # First, create a new document for the translation
    translated_doc = BlockDocDocument({
        "title": document.article["title"],  # We'll translate this later
        "metadata": document.article["metadata"].copy()
    })
    
    # Update the metadata to indicate this is a translation
    translated_doc.article["metadata"]["original_language"] = "en"
    translated_doc.article["metadata"]["language"] = target_language
    
    # Translate the title
    title_prompt = f"""
    Translate this title to {target_language}:
    
    {document.article["title"]}
    
    Return only the translated title.
    """
    translated_title = generate_text_with_llm(title_prompt, max_tokens=100)
    translated_doc.article["title"] = translated_title
    
    # Translate each block
    for block in document.article["blocks"]:
        block_id = block["id"]
        block_type = block["type"]
        
        # Create a new block with the same ID and type
        new_block = {"id": block_id, "type": block_type}
        
        # Translate based on block type
        if block_type == "text" or block_type == "heading":
            content_prompt = f"""
            Translate this {block_type} to {target_language}:
            
            {block["content"]}
            
            Preserve any markdown formatting. Return only the translated text.
            """
            new_block["content"] = generate_text_with_llm(content_prompt)
            
            # Copy any other properties
            for key, value in block.items():
                if key not in ["id", "type", "content"]:
                    new_block[key] = value
        
        elif block_type == "list":
            items = block.get("items", [])
            items_text = "\n".join([f"- {item}" for item in items])
            
            items_prompt = f"""
            Translate this list to {target_language}:
            
            {items_text}
            
            Format your response as a JSON array of strings, like this:
            ["Translated Item 1", "Translated Item 2", "Translated Item 3"]
            """
            
            response = generate_text_with_llm(items_prompt)
            
            try:
                translated_items = json.loads(response)
                new_block["items"] = translated_items
            except:
                # Fallback: Extract translated items line by line
                new_block["items"] = [line.strip().lstrip('-').strip() 
                                    for line in response.split('\n') 
                                    if line.strip()]
            
            # Copy the list type and other properties
            new_block["list_type"] = block.get("list_type", block.get("listType", "unordered"))
            new_block["content"] = ""  # Lists typically have empty content
        
        elif block_type == "image" or block_type == "embed":
            # For media blocks, only translate captions and alt text
            new_block = block.copy()  # Copy all properties
            
            if "alt" in block:
                alt_prompt = f"""
                Translate this image alternative text to {target_language}:
                
                {block["alt"]}
                
                Return only the translated text.
                """
                new_block["alt"] = generate_text_with_llm(alt_prompt, max_tokens=100)
            
            if "caption" in block:
                caption_prompt = f"""
                Translate this caption to {target_language}:
                
                {block["caption"]}
                
                Return only the translated text.
                """
                new_block["caption"] = generate_text_with_llm(caption_prompt, max_tokens=100)
        
        elif block_type == "divider":
            # Dividers don't need translation
            new_block = block.copy()
        
        # Add the translated block to the document
        translated_doc.add_block(new_block)
    
    return translated_doc
```

## Designing Effective Prompts

When working with LLMs and BlockDoc, effective prompts are crucial for getting the desired output:

### Template for Block Creation

```python
def create_block_prompt(block_type, context, instructions):
    """Generate a prompt for creating a specific block type"""
    
    base_prompt = f"""
    You are generating content for a {block_type} block in a structured document.
    
    Context information:
    {context}
    
    Instructions:
    {instructions}
    """
    
    if block_type == "text":
        return base_prompt + """
        Create a well-formatted paragraph using Markdown for emphasis where appropriate.
        Return only the content text, without any explanations or metadata.
        """
    
    elif block_type == "heading":
        return base_prompt + """
        Create a concise, clear heading.
        Return only the heading text, without any formatting or punctuation at the end.
        """
    
    elif block_type == "list":
        return base_prompt + """
        Create a list of items.
        Format your response as a JSON array of strings, like this:
        ["Item 1", "Item 2", "Item 3"]
        
        Each item should be concise and clear, with Markdown formatting if needed.
        """
    
    # Add more block types as needed
    
    return base_prompt

# Example usage
heading_prompt = create_block_prompt(
    "heading",
    "This is for a section about BlockDoc's advantages for LLM integration",
    "Create a heading that emphasizes the efficiency gains from using BlockDoc with LLMs"
)
heading_content = generate_text_with_llm(heading_prompt, max_tokens=50)
```

### Prompt Engineering Tips

1. **Be specific about the format**: For lists and structured data, request JSON format
2. **Provide context**: Include surrounding blocks for context when updating 
3. **Set clear boundaries**: Ask for only the content, not explanations or metadata
4. **Use examples**: Show examples of desired output format for complex blocks
5. **Control verbosity**: Set appropriate max_tokens values for different block types

## Advanced Integration Patterns

Here are some advanced patterns for integrating BlockDoc with LLMs:

### Content Plans with LLMs

```python
def create_content_plan(topic, target_audience, content_type="blog"):
    """Use an LLM to create a content plan before generating the full document"""
    
    planning_prompt = f"""
    Create a detailed content plan for a {content_type} about "{topic}" targeted at {target_audience}.
    
    Your plan should include:
    1. A compelling title
    2. A brief summary of the content (2-3 sentences)
    3. 4-6 main sections with titles
    4. For each section, list 2-3 key points to cover
    5. Types of media to include (images, code examples, etc.)
    6. A call to action for the conclusion
    
    Format your response as JSON:
    {{
      "title": "The title",
      "summary": "Brief summary...",
      "sections": [
        {{
          "title": "Section title",
          "key_points": ["Point 1", "Point 2"],
          "media": ["Image showing X", "Code example of Y"]
        }}
      ],
      "call_to_action": "What the reader should do next"
    }}
    """
    
    response = generate_text_with_llm(planning_prompt, max_tokens=1500)
    
    try:
        # Parse the content plan
        content_plan = json.loads(response)
        
        # Create a BlockDoc document from the plan
        doc = BlockDocDocument({
            "title": content_plan["title"],
            "metadata": {
                "summary": content_plan["summary"],
                "topic": topic,
                "audience": target_audience,
                "content_type": content_type
            }
        })
        
        # Add introduction
        intro_prompt = f"""
        Write an engaging introduction for an article titled "{content_plan["title"]}" about {topic}.
        The audience is {target_audience}.
        The introduction should be 2-3 paragraphs and should include these key points:
        - What the article is about
        - Why it matters to the reader
        - What they'll learn
        
        Use Markdown for formatting. Return only the introduction text.
        """
        intro_content = generate_text_with_llm(intro_prompt, max_tokens=500)
        doc.add_block(Block.text("introduction", intro_content))
        
        # Process each section
        for i, section in enumerate(content_plan["sections"]):
            section_id = f"section-{i+1}"
            
            # Add section heading
            doc.add_block(Block.heading(
                f"{section_id}-heading",
                2,
                section["title"]
            ))
            
            # Create section content based on key points
            points_text = "\n".join([f"- {point}" for point in section["key_points"]])
            content_prompt = f"""
            Write a detailed section for an article about {topic} targeted at {target_audience}.
            
            Section title: {section["title"]}
            
            Include information about these key points:
            {points_text}
            
            The content should be 2-3 paragraphs with Markdown formatting.
            Return only the section content.
            """
            
            section_content = generate_text_with_llm(content_prompt, max_tokens=800)
            doc.add_block(Block.text(f"{section_id}-content", section_content))
            
            # Add media blocks if specified
            if "media" in section and section["media"]:
                for j, media_desc in enumerate(section["media"]):
                    if "code" in media_desc.lower():
                        # Add a code block
                        code_prompt = f"""
                        Create a code example for the section "{section["title"]}" about {topic}.
                        
                        Description: {media_desc}
                        
                        Return only the code, no explanations. 
                        Include comments to explain key parts of the code.
                        """
                        
                        code_content = generate_text_with_llm(code_prompt, max_tokens=500)
                        
                        # Determine the language from the description
                        language = "python"  # Default
                        for lang in ["python", "javascript", "html", "css", "java", "ruby", "php"]:
                            if lang in media_desc.lower():
                                language = lang
                                break
                        
                        doc.add_block(Block.code(
                            f"{section_id}-code-{j+1}",
                            language,
                            code_content
                        ))
                    
                    elif "image" in media_desc.lower():
                        # For images, we'd need a real source, but here we'll just create a placeholder
                        doc.add_block(Block.image(
                            f"{section_id}-image-{j+1}",
                            "https://placehold.co/600x400?text=Image+placeholder",
                            media_desc,
                            f"Figure: {media_desc}"
                        ))
        
        # Add conclusion with call to action
        conclusion_prompt = f"""
        Write a conclusion for an article titled "{content_plan["title"]}" about {topic}.
        
        Include this call to action: {content_plan["call_to_action"]}
        
        The conclusion should summarize the key points and motivate the reader to take action.
        Use Markdown for formatting. Return only the conclusion text.
        """
        
        conclusion_content = generate_text_with_llm(conclusion_prompt, max_tokens=400)
        doc.add_block(Block.text("conclusion", conclusion_content))
        
        return doc
        
    except json.JSONDecodeError:
        # Handle parsing errors
        raise ValueError("Could not parse LLM response as JSON")
```

### Review and Improve Content

```python
def review_and_improve_document(document):
    """Use an LLM to review and suggest improvements for a document"""
    
    # First, gather statistics about the document
    block_count = len(document.article["blocks"])
    block_types = {}
    word_count = 0
    
    for block in document.article["blocks"]:
        block_type = block["type"]
        block_types[block_type] = block_types.get(block_type, 0) + 1
        
        if block_type == "text":
            # Count words in text blocks
            word_count += len(block["content"].split())
    
    # Create a document summary
    doc_summary = f"""
    Document Title: {document.article["title"]}
    Block Count: {block_count}
    Word Count: {word_count}
    Block Types: {', '.join([f"{k}: {v}" for k, v in block_types.items()])}
    """
    
    # Review prompt
    review_prompt = f"""
    You are a content editor reviewing a structured document. Here's a summary of the document:
    
    {doc_summary}
    
    Please analyze the document's structure and content to identify areas for improvement:
    
    1. Does the document have a logical structure?
    2. Are there any sections that seem underdeveloped?
    3. Is there a good balance of block types?
    4. Are there opportunities to add media or interactive elements?
    5. Is the document's length appropriate for its purpose?
    
    Format your response as JSON:
    {{
      "overall_assessment": "Brief assessment of the document",
      "strengths": ["Strength 1", "Strength 2"],
      "areas_for_improvement": [
        {{
          "issue": "Description of the issue",
          "suggestion": "Specific suggestion for improvement",
          "priority": "high/medium/low"
        }}
      ],
      "recommended_additions": [
        {{
          "block_type": "text/image/list/etc.",
          "location": "Where to add it (after which existing block)",
          "description": "What this block should contain"
        }}
      ]
    }}
    """
    
    response = generate_text_with_llm(review_prompt, max_tokens=1000)
    
    try:
        review_data = json.loads(response)
        
        # Store the review as document metadata
        document.article["metadata"]["review"] = review_data
        
        # Implement high-priority improvements automatically
        for improvement in review_data.get("areas_for_improvement", []):
            if improvement.get("priority") == "high":
                # Find relevant blocks to improve based on issue description
                # This would need more sophisticated matching in a real system
                issue = improvement["issue"].lower()
                
                for block in document.article["blocks"]:
                    if block["type"] == "text" and any(keyword in block["content"].lower() 
                                                    for keyword in issue.split()):
                        
                        improve_prompt = f"""
                        Improve this text block based on this feedback:
                        
                        Issue: {improvement["issue"]}
                        Suggestion: {improvement["suggestion"]}
                        
                        Original content:
                        {block["content"]}
                        
                        Return only the improved content.
                        """
                        
                        improved_content = generate_text_with_llm(improve_prompt)
                        document.update_block(block["id"], {"content": improved_content})
                        
                        # Mark this improvement as applied
                        improvement["applied"] = True
                        break
        
        # Add recommended blocks
        for addition in review_data.get("recommended_additions", []):
            block_type = addition.get("block_type")
            location = addition.get("location")
            description = addition.get("description")
            
            # Find the position to insert the new block
            position = 0
            if location:
                for i, block in enumerate(document.article["blocks"]):
                    if location.lower() in block["id"].lower():
                        position = i + 1
                        break
            
            # Generate content for the new block
            if block_type == "text":
                content_prompt = f"""
                Create a text block with this description:
                {description}
                
                It should flow well with the surrounding content in the document.
                Use Markdown formatting as appropriate. Return only the content.
                """
                
                content = generate_text_with_llm(content_prompt)
                new_block = Block.text(f"added-text-{position}", content)
                
            elif block_type == "list":
                list_prompt = f"""
                Create a list with this description:
                {description}
                
                Format your response as a JSON array of strings.
                Each item should be concise and informative.
                """
                
                response = generate_text_with_llm(list_prompt)
                try:
                    items = json.loads(response)
                    new_block = Block.list(f"added-list-{position}", items, "unordered")
                except:
                    # Fallback
                    items = [line.strip().lstrip('-').strip() 
                            for line in response.split('\n') 
                            if line.strip()]
                    new_block = Block.list(f"added-list-{position}", items, "unordered")
                    
            elif block_type == "heading":
                heading_prompt = f"""
                Create a heading with this description:
                {description}
                
                It should be concise and descriptive.
                Return only the heading text.
                """
                
                content = generate_text_with_llm(heading_prompt, max_tokens=50)
                new_block = Block.heading(f"added-heading-{position}", 2, content)
            
            # Add more block types as needed
            
            # Insert the new block
            document.insert_block(new_block, position)
            
            # Mark this addition as applied
            addition["applied"] = True
        
        return document
        
    except json.JSONDecodeError:
        # Handle parsing errors
        raise ValueError("Could not parse LLM response as JSON")
```

## Performance and Cost Optimization

When working with LLMs and BlockDoc, consider these strategies to optimize performance and costs:

### Batching Related Operations

```python
def batch_generate_sections(document, section_ids, instructions):
    """Generate multiple sections in a single LLM call to reduce API calls"""
    
    sections_prompt = """
    Generate content for multiple sections of a document simultaneously.
    For each section, I'll provide the section ID, its purpose, and specific instructions.
    
    Format your response as JSON with this structure:
    {
      "sections": [
        {
          "id": "section-1",
          "content": "The generated content for section 1..."
        },
        {
          "id": "section-2",
          "content": "The generated content for section 2..."
        }
      ]
    }
    
    Here are the sections to generate:
    """
    
    for i, section_id in enumerate(section_ids):
        sections_prompt += f"""
        SECTION {i+1}:
        ID: {section_id}
        Instructions: {instructions[i]}
        
        """
    
    response = generate_text_with_llm(sections_prompt, max_tokens=2000)
    
    try:
        sections_data = json.loads(response)
        
        # Update each section in the document
        for section in sections_data["sections"]:
            document.update_block(section["id"], {"content": section["content"]})
        
        return document
        
    except json.JSONDecodeError:
        # Handle parsing errors
        raise ValueError("Could not parse LLM response as JSON")
```

### Caching Strategies

```python
import hashlib
import os
import json
import time

class SimpleLLMCache:
    """Simple cache for LLM responses to avoid duplicate API calls"""
    
    def __init__(self, cache_dir="./llm_cache"):
        self.cache_dir = cache_dir
        os.makedirs(cache_dir, exist_ok=True)
    
    def _get_cache_key(self, prompt, model):
        """Generate a unique cache key for a prompt and model"""
        # Create a hash of the prompt and model
        hash_input = f"{prompt}|{model}"
        return hashlib.md5(hash_input.encode()).hexdigest()
    
    def _get_cache_path(self, cache_key):
        """Get the file path for a cache key"""
        return os.path.join(self.cache_dir, f"{cache_key}.json")
    
    def get(self, prompt, model):
        """Get a cached response if available"""
        cache_key = self._get_cache_key(prompt, model)
        cache_path = self._get_cache_path(cache_key)
        
        if os.path.exists(cache_path):
            try:
                with open(cache_path, 'r') as f:
                    cache_data = json.load(f)
                
                # Check if cache is expired (default: 24 hours)
                cache_time = cache_data.get("timestamp", 0)
                if time.time() - cache_time < 86400:  # 24 hours
                    return cache_data.get("response")
            except:
                pass
        
        return None
    
    def set(self, prompt, model, response):
        """Cache a response"""
        cache_key = self._get_cache_key(prompt, model)
        cache_path = self._get_cache_path(cache_key)
        
        cache_data = {
            "timestamp": time.time(),
            "prompt": prompt,
            "model": model,
            "response": response
        }
        
        with open(cache_path, 'w') as f:
            json.dump(cache_data, f)

# Use the cache with the generate function
cache = SimpleLLMCache()

def cached_generate_text_with_llm(prompt, model="gpt-4", max_tokens=1000):
    """Generate text using an LLM with caching"""
    # Check cache first
    cached_response = cache.get(prompt, model)
    if cached_response:
        return cached_response
    
    # Generate new response if not in cache
    response = generate_text_with_llm(prompt, model, max_tokens)
    
    # Cache the response
    cache.set(prompt, model, response)
    
    return response
```

### Using Smaller Models for Simple Tasks

```python
def generate_with_appropriate_model(prompt, task_complexity="medium"):
    """Choose an appropriate model based on task complexity"""
    
    if task_complexity == "low":
        # Use a smaller, faster model for simple tasks
        model = "gpt-3.5-turbo"
        max_tokens = 300
    elif task_complexity == "medium":
        # Default model for most tasks
        model = "gpt-4"
        max_tokens = 800
    else:  # high complexity
        # Use the most capable model for complex tasks
        model = "gpt-4"
        max_tokens = 2000
    
    return generate_text_with_llm(prompt, model, max_tokens)

# Task-specific wrappers
def generate_block_title(description):
    """Generate a simple block title (low complexity)"""
    prompt = f"Create a concise, clear title for a section about: {description}"
    return generate_with_appropriate_model(prompt, "low")

def generate_detailed_explanation(topic, context):
    """Generate a detailed explanation (high complexity)"""
    prompt = f"""
    Create a comprehensive explanation about {topic}.
    
    Context:
    {context}
    
    Include technical details, examples, and consider different perspectives.
    """
    return generate_with_appropriate_model(prompt, "high")
```

## Conclusion

BlockDoc's structured approach to content makes it an ideal format for LLM integration. By using the techniques in this tutorial, you can create powerful, efficient workflows that leverage the strengths of both BlockDoc and language models.

By breaking content into semantic blocks, you gain precise control over content generation, can target updates to specific sections, and maintain a clean, structured document that works beautifully with both human and AI authors.

For more examples of BlockDoc and LLM integration, check out the [LLM Integration Examples](../../examples/llm-integration/) directory.
</file>

<file path="examples/llm-integration/README.md">
# BlockDoc LLM Integration Examples

This directory contains examples demonstrating how to use BlockDoc with Language Models (LLMs) for content generation and manipulation.

## Features

- Generate complete documents with LLMs
- Update specific blocks in a document
- Structured content creation with semantic blocks
- Demonstrations of prompt engineering for block-specific content

## Getting Started

### Prerequisites

- Python 3.8 or higher
- BlockDoc package installed
- API key for an LLM provider (OpenAI, Anthropic, etc.)

### Setting Up

1. Set your LLM API key as an environment variable:

```bash
# For OpenAI
export OPENAI_API_KEY="your-api-key"

# For Anthropic
export ANTHROPIC_API_KEY="your-api-key"
```

2. Edit the `llm_content_generator.py` file to uncomment the section for your preferred LLM provider.

### Running the Example

1. Navigate to the BlockDoc root directory:

```bash
cd path/to/blockdoc-python
```

2. Generate a new article:

```bash
python examples/llm-integration/llm_content_generator.py --title "My LLM-Generated Article" --topic "structured content for AI applications"
```

3. Update a specific block in an existing article:

```bash
python examples/llm-integration/llm_content_generator.py --update --input examples/llm-integration/output/my-llm-generated-article.json --block-id introduction --instruction "Make it more concise and add a statistic about AI content generation"
```

## Command-line Options

### For Article Generation

- `--title`: Specify the article title (default: "BlockDoc: A Modern Approach to Structured Content")
- `--topic`: Specify the article topic (default: "structured content formats for modern applications")
- `--output-dir`: Directory to save the generated files (default: "./output")

### For Block Updates

- `--update`: Enable update mode
- `--input`: Path to the JSON file containing the document to update
- `--block-id`: ID of the block to update
- `--instruction`: Instructions for updating the block
- `--output-dir`: Directory to save the updated files (default: "./output")

## LLM Integration Approaches

This example demonstrates several key approaches for integrating BlockDoc with LLMs:

1. **Document Generation**: Creating complete documents with a structured approach
2. **Targeted Updates**: Updating specific blocks without regenerating the entire document
3. **Block-Specific Prompts**: Crafting prompts based on block type and context
4. **Parsing Structured Responses**: Converting LLM responses into structured BlockDoc blocks

## Extending the Example

You can extend this example in various ways:

1. **Additional Block Types**: Add support for generating and updating more block types
2. **Content Plans**: Implement a planning phase before generation
3. **Content Enhancement**: Add capabilities for enhancing existing content
4. **Bulk Operations**: Support batch operations on multiple blocks
5. **Interactive Editing**: Build an interactive editing workflow

## Making It Work with Your LLM Provider

The example includes commented sections for both OpenAI and Anthropic. To use with your preferred provider:

1. Uncomment the appropriate section in `llm_content_generator.py`
2. Install the required package (`pip install openai` or `pip install anthropic`)
3. Set your API key
4. Adjust parameters like model name as needed

## Output Files

The generator creates three files for each article:

1. `[title-slug].json`: The BlockDoc document structure in JSON format
2. `[title-slug].html`: The article rendered as an HTML page with basic styling
3. `[title-slug].md`: The article rendered as Markdown with YAML frontmatter

For updates, it creates:

1. `updated_[filename].json`: The updated document
2. `updated_[filename].html`: HTML preview of the updated document

## Best Practices for Prompt Engineering

When working with BlockDoc and LLMs, consider these best practices:

1. **Block-Specific Prompts**: Customize prompts based on block type
2. **Clear Instructions**: Be specific about the desired format and content
3. **Context Preservation**: Include surrounding context for coherent updates
4. **Response Parsing**: Implement robust parsing for structured responses
5. **Validation**: Always validate the document after LLM operations

## Learn More

- Explore the [BlockDoc Documentation](../../docs/) for more details on the API
- Check out the [LLM Integration Tutorial](../../docs/tutorials/llm-integration.md) for an in-depth guide
</file>

<file path="examples/output/markdown-converted.html">
<article class="blockdoc-article">
<h1 class="blockdoc-title">Markdown to BlockDoc Conversion</h1>
<div class="blockdoc-block blockdoc-text" data-block-id="text-6bde1965" data-block-type="text"><p>This is a demonstration of converting <strong>Markdown</strong> content to BlockDoc format.</p></div>
<div class="blockdoc-block blockdoc-heading" data-block-id="key-features" data-block-type="heading"><h2>Key Features</h2></div>
<div class="blockdoc-block blockdoc-text" data-block-id="text-5c1cd4c6" data-block-type="text"><p>BlockDoc makes it easy to work with structured content:</p></div>
<div class="blockdoc-block blockdoc-list" data-block-id="unordered-list-36e4adc8" data-block-type="list"><ul class="blockdoc-list blockdoc-list-unordered"><li>Maintains semantic structure</li><li>Preserves formatting</li><li>Creates meaningful block IDs</li></ul></div>
<div class="blockdoc-block blockdoc-heading" data-block-id="code-examples" data-block-type="heading"><h3>Code Examples</h3></div>
<div class="blockdoc-block blockdoc-text" data-block-id="text-0c25e226" data-block-type="text"><p>Here's an example of Python code:</p></div>
<div class="blockdoc-block blockdoc-code" data-block-id="code-python-ff977aa3" data-block-type="code">
    <pre class="blockdoc-pre">
      <code class="blockdoc-code language-python">
<div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">blockdoc</span><span class="w"> </span><span class="kn">import</span> <span class="n">markdown_to_blockdoc</span>
<span class="c1"># Convert markdown to BlockDoc</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">markdown_to_blockdoc</span><span class="p">(</span><span class="n">markdown_text</span><span class="p">)</span>
<span class="c1"># Export as JSON</span>
<span class="n">json_str</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">json_str</span><span class="p">)</span>
</pre></div>
      </code>
    </pre>
    </div>
<div class="blockdoc-block blockdoc-heading" data-block-id="images-and-media" data-block-type="heading"><h2>Images and Media</h2></div>
<div class="blockdoc-block blockdoc-text" data-block-id="text-c3fdfd77" data-block-type="text"><p>Images are properly converted:</p></div>
<div class="blockdoc-block blockdoc-image" data-block-id="image-101fc707" data-block-type="image"><figure class="blockdoc-figure"><img src="https://placehold.co/600x400?text=Example+Image" alt="Example image" class="blockdoc-image" /><figcaption class="blockdoc-caption">Example image caption</figcaption></figure></div>
<div class="blockdoc-block blockdoc-heading" data-block-id="block-quotes" data-block-type="heading"><h2>Block Quotes</h2></div>
<div class="blockdoc-block blockdoc-text" data-block-id="text-8a6ab0c7" data-block-type="text"><p>BlockDoc handles various content types:</p></div>
<div class="blockdoc-block blockdoc-quote" data-block-id="quote-25f02b35" data-block-type="quote"><blockquote class="blockdoc-quote"><p>This is a block quote that will be properly converted
to a BlockDoc quote block, preserving its formatting
and presentation.</p></blockquote><cite class="blockdoc-attribution">Attribution Source</cite></div>
<div class="blockdoc-block blockdoc-divider" data-block-id="divider-f94a9524" data-block-type="divider"><hr class="blockdoc-divider" /></div>
<div class="blockdoc-block blockdoc-heading" data-block-id="lists" data-block-type="heading"><h2>Lists</h2></div>
<div class="blockdoc-block blockdoc-list" data-block-id="ordered-list-414f8890" data-block-type="list"><ol class="blockdoc-list blockdoc-list-ordered"><li>Ordered lists work great</li><li>With multiple items</li><li>Preserving the numbering</li></ol></div>
<div class="blockdoc-block blockdoc-list" data-block-id="unordered-list-d682e69f" data-block-type="list"><ul class="blockdoc-list blockdoc-list-unordered"><li>Unordered lists too</li><li>With proper nesting</li><li>And formatting</li></ul></div>
<div class="blockdoc-block blockdoc-heading" data-block-id="the-end" data-block-type="heading"><h2>The End</h2></div>
<div class="blockdoc-block blockdoc-text" data-block-id="text-78faa450" data-block-type="text"><p>This example shows how Markdown can be seamlessly converted to BlockDoc format, preserving
the document structure while enabling all the benefits of block-based content.</p></div>
</article>
</file>

<file path="examples/output/markdown-converted.json">
{
  "article": {
    "title": "Markdown to BlockDoc Conversion",
    "metadata": {
      "author": "BlockDoc Team",
      "publishedDate": "2025-04-25T15:51:21.904700",
      "tags": [
        "markdown",
        "conversion",
        "example"
      ]
    },
    "blocks": [
      {
        "id": "text-6bde1965",
        "type": "text",
        "content": "This is a demonstration of converting **Markdown** content to BlockDoc format."
      },
      {
        "id": "key-features",
        "type": "heading",
        "content": "Key Features",
        "level": 2
      },
      {
        "id": "text-5c1cd4c6",
        "type": "text",
        "content": "BlockDoc makes it easy to work with structured content:"
      },
      {
        "id": "unordered-list-36e4adc8",
        "type": "list",
        "content": "",
        "items": [
          "Maintains semantic structure",
          "Preserves formatting",
          "Creates meaningful block IDs"
        ],
        "list_type": "unordered"
      },
      {
        "id": "code-examples",
        "type": "heading",
        "content": "Code Examples",
        "level": 3
      },
      {
        "id": "text-0c25e226",
        "type": "text",
        "content": "Here's an example of Python code:"
      },
      {
        "id": "code-python-ff977aa3",
        "type": "code",
        "content": "from blockdoc import markdown_to_blockdoc\n\n# Convert markdown to BlockDoc\ndoc = markdown_to_blockdoc(markdown_text)\n\n# Export as JSON\njson_str = doc.to_json()\nprint(json_str)",
        "language": "python"
      },
      {
        "id": "images-and-media",
        "type": "heading",
        "content": "Images and Media",
        "level": 2
      },
      {
        "id": "text-c3fdfd77",
        "type": "text",
        "content": "Images are properly converted:"
      },
      {
        "id": "image-101fc707",
        "type": "image",
        "content": "",
        "url": "https://placehold.co/600x400?text=Example+Image",
        "alt": "Example image",
        "caption": "Example image caption"
      },
      {
        "id": "block-quotes",
        "type": "heading",
        "content": "Block Quotes",
        "level": 2
      },
      {
        "id": "text-8a6ab0c7",
        "type": "text",
        "content": "BlockDoc handles various content types:"
      },
      {
        "id": "quote-25f02b35",
        "type": "quote",
        "content": "This is a block quote that will be properly converted\nto a BlockDoc quote block, preserving its formatting\nand presentation.",
        "attribution": "Attribution Source"
      },
      {
        "id": "divider-f94a9524",
        "type": "divider",
        "content": ""
      },
      {
        "id": "lists",
        "type": "heading",
        "content": "Lists",
        "level": 2
      },
      {
        "id": "ordered-list-414f8890",
        "type": "list",
        "content": "",
        "items": [
          "Ordered lists work great",
          "With multiple items",
          "Preserving the numbering"
        ],
        "list_type": "ordered"
      },
      {
        "id": "unordered-list-d682e69f",
        "type": "list",
        "content": "",
        "items": [
          "Unordered lists too",
          "With proper nesting",
          "And formatting"
        ],
        "list_type": "unordered"
      },
      {
        "id": "the-end",
        "type": "heading",
        "content": "The End",
        "level": 2
      },
      {
        "id": "text-78faa450",
        "type": "text",
        "content": "This example shows how Markdown can be seamlessly converted to BlockDoc format, preserving\nthe document structure while enabling all the benefits of block-based content."
      }
    ]
  }
}
</file>

<file path="examples/output/markdown-roundtrip.md">
# Markdown to BlockDoc Conversion

> Author: BlockDoc Team
> Published: Fri Apr 25 2025
> Tags: markdown, conversion, example

This is a demonstration of converting **Markdown** content to BlockDoc format.

## Key Features

BlockDoc makes it easy to work with structured content:

- Maintains semantic structure
- Preserves formatting
- Creates meaningful block IDs

### Code Examples

Here's an example of Python code:

```python
from blockdoc import markdown_to_blockdoc

# Convert markdown to BlockDoc
doc = markdown_to_blockdoc(markdown_text)

# Export as JSON
json_str = doc.to_json()
print(json_str)
```

## Images and Media

Images are properly converted:

![Example image](https://placehold.co/600x400?text=Example+Image)
*Example image caption*

## Block Quotes

BlockDoc handles various content types:

> This is a block quote that will be properly converted
> to a BlockDoc quote block, preserving its formatting
> and presentation.
>
> — Attribution Source

---

## Lists

1. Ordered lists work great
2. With multiple items
3. Preserving the numbering

- Unordered lists too
- With proper nesting
- And formatting

## The End

This example shows how Markdown can be seamlessly converted to BlockDoc format, preserving
the document structure while enabling all the benefits of block-based content.
</file>

<file path="examples/simple-blog/README.md">
# BlockDoc Simple Blog Example

This example demonstrates how to use BlockDoc to create and manage blog posts.

## Features

- Generate blog posts with a variety of block types
- Render blog posts to HTML, Markdown, and JSON
- Load blog structure from JSON templates
- Command-line interface for blog post generation

## Getting Started

### Prerequisites

- Python 3.8 or higher
- BlockDoc package installed

### Running the Example

1. Navigate to the BlockDoc root directory:

```bash
cd path/to/blockdoc-python
```

2. Run the blog generator with default settings:

```bash
python examples/simple-blog/blog_generator.py
```

This will create a sample blog post with default content and save it to the `examples/simple-blog/output` directory.

### Command-line Options

The blog generator supports several command-line options:

```bash
python examples/simple-blog/blog_generator.py --title "My Blog Post" --author "Your Name" --output-dir "./my-output"
```

Available options:

- `--title`: Specify the blog post title (default: "BlockDoc Blog Example")
- `--author`: Specify the blog post author (default: "BlockDoc Team")
- `--content`: Path to a JSON file containing the blog content structure
- `--output-dir`: Directory to save the generated files (default: "./output")

### Using a Custom Content Structure

You can define your blog post structure in a JSON file and use it with the `--content` option:

```bash
python examples/simple-blog/blog_generator.py --content "examples/simple-blog/sample_content.json"
```

## Content Structure

The JSON content structure should be an array of block definitions, each with at least a `type` and `id` property:

```json
[
  {
    "type": "text",
    "id": "introduction",
    "content": "This is the introduction paragraph."
  },
  {
    "type": "heading",
    "id": "section-1",
    "level": 2,
    "content": "First Section"
  },
  {
    "type": "list",
    "id": "key-points",
    "items": ["Point 1", "Point 2", "Point 3"],
    "list_type": "unordered"
  }
]
```

See the `sample_content.json` file for a complete example.

## Output Files

The generator creates three files for each blog post:

1. `[title-slug].json`: The BlockDoc document structure in JSON format
2. `[title-slug].html`: The blog post rendered as an HTML page with basic styling
3. `[title-slug].md`: The blog post rendered as Markdown with YAML frontmatter

## Using in Your Projects

This example can be adapted for various content creation workflows:

1. **Content Management System**: Use BlockDoc as the storage format for a CMS
2. **Static Site Generator**: Generate blog posts for static sites like Hugo or Jekyll
3. **LLM-powered Blogging**: Use LLMs to generate content in BlockDoc format
4. **Interactive Editors**: Build editors that save content in BlockDoc format

## Next Steps

- Explore the [BlockDoc Documentation](../../docs/) for more details on the API
- Check out the [LLM Integration Example](../llm-integration/) to see how to use BlockDoc with language models
</file>

<file path="examples/simple-blog/sample_content.json">
[
  {
    "type": "text",
    "id": "introduction",
    "content": "Welcome to this sample blog post created with **BlockDoc**! This post demonstrates how to structure content using different block types for maximum flexibility and control."
  },
  {
    "type": "heading",
    "id": "what-is-blockdoc",
    "level": 2,
    "content": "What is BlockDoc?"
  },
  {
    "type": "text",
    "id": "blockdoc-description",
    "content": "BlockDoc is a structured content format designed for creating, managing, and rendering content in a way that is optimized for both human authors and language models (LLMs). It provides a simple, intuitive structure that makes content easier to manipulate, update, and transform programmatically."
  },
  {
    "type": "image",
    "id": "blockdoc-structure",
    "url": "https://placehold.co/800x400?text=BlockDoc+Document+Structure",
    "alt": "Diagram showing BlockDoc document structure",
    "caption": "Figure 1: Visual representation of a BlockDoc document structure"
  },
  {
    "type": "heading",
    "id": "key-features",
    "level": 2,
    "content": "Key Features"
  },
  {
    "type": "list",
    "id": "features-list",
    "items": [
      "**Block-based architecture**: Content is organized into discrete, individually addressable blocks",
      "**Semantic IDs**: Each block has a meaningful identifier",
      "**LLM-friendly**: Designed for AI generation and targeted modifications",
      "**Framework-agnostic**: Works with any frontend or backend technology",
      "**Database-ready**: Easy to store in SQL or NoSQL databases"
    ],
    "list_type": "unordered"
  },
  {
    "type": "heading",
    "id": "code-example",
    "level": 2,
    "content": "Code Example"
  },
  {
    "type": "text",
    "id": "code-intro",
    "content": "Here's a simple example of how to create a BlockDoc document in Python:"
  },
  {
    "type": "code",
    "id": "python-code",
    "language": "python",
    "content": "from blockdoc import BlockDocDocument, Block\n\n# Create a new document\ndoc = BlockDocDocument({\n    \"title\": \"My First BlockDoc Post\",\n    \"metadata\": {\n        \"author\": \"Your Name\",\n        \"tags\": [\"blockdoc\", \"tutorial\"]\n    }\n})\n\n# Add blocks\ndoc.add_block(Block.text(\n    \"intro\",\n    \"Welcome to my **first** BlockDoc post!\"\n))\n\ndoc.add_block(Block.heading(\n    \"section-1\",\n    2,\n    \"Getting Started\"\n))\n\n# Render to different formats\nhtml = doc.render_to_html()\nmarkdown = doc.render_to_markdown()\njson_str = doc.to_json()"
  },
  {
    "type": "heading",
    "id": "block-types",
    "level": 2,
    "content": "Block Types"
  },
  {
    "type": "text",
    "id": "block-types-intro",
    "content": "BlockDoc supports a variety of block types to represent different kinds of content:"
  },
  {
    "type": "list",
    "id": "block-types-list",
    "items": [
      "**Text**: Markdown-formatted text content",
      "**Heading**: Section headings with levels 1-6",
      "**Image**: Images with URL, alt text, and optional caption",
      "**Code**: Code snippets with language highlighting",
      "**List**: Ordered or unordered lists",
      "**Quote**: Blockquotes with optional attribution",
      "**Embed**: Embedded content like videos or tweets",
      "**Divider**: Horizontal dividers between sections"
    ],
    "list_type": "unordered"
  },
  {
    "type": "quote",
    "id": "testimonial",
    "content": "BlockDoc has revolutionized how we structure content for our applications. The block-based approach makes it easy to update specific sections and render in different formats.",
    "attribution": "Jane Developer, AI Solutions Inc."
  },
  {
    "type": "heading",
    "id": "llm-integration",
    "level": 2,
    "content": "LLM Integration"
  },
  {
    "type": "text",
    "id": "llm-text",
    "content": "BlockDoc shines when integrated with Language Models (LLMs). Its structure allows for targeted content generation and updates, making it perfect for AI-assisted content workflows. Check out the [LLM integration example](../llm-integration/) for more details."
  },
  {
    "type": "divider",
    "id": "section-divider"
  },
  {
    "type": "heading",
    "id": "conclusion",
    "level": 2,
    "content": "Conclusion"
  },
  {
    "type": "text",
    "id": "conclusion-text",
    "content": "This sample blog post demonstrates how BlockDoc can be used to create structured content with a variety of block types. The JSON-based format makes it easy to store, manipulate, and render content in different ways.\n\nFor more information, check out the [BlockDoc documentation](../../docs/) and [examples](../)."
  }
]
</file>

<file path="examples/markdown_conversion_example.py">
SAMPLE_MARKDOWN = """# Markdown to BlockDoc Conversion
def main()
⋮----
doc = markdown_to_blockdoc(
⋮----
output_dir = os.path.join(os.path.dirname(__file__), "output")
⋮----
markdown = doc.render_to_markdown()
⋮----
html = doc.render_to_html()
</file>

<file path="examples/README.md">
# BlockDoc Examples

This directory contains examples demonstrating how to use BlockDoc in different scenarios.

## Available Examples

### Basic Example

The [basic_example.py](basic_example.py) script demonstrates fundamental BlockDoc functionality:

- Creating a document with various block types
- Working with the Block factory methods
- Validating documents against the schema
- Rendering to HTML and Markdown
- Updating block content
- Saving and loading documents

Run it with:

```bash
python examples/basic_example.py
```

### Simple Blog

The [simple-blog](simple-blog/) directory contains a more complete example of creating a blog using BlockDoc:

- Structured blog post creation
- Multiple rendering formats
- Template integration
- Content management workflow
- See the README in that directory for more details

### LLM Integration

The [llm-integration](llm-integration/) directory demonstrates how to use BlockDoc with Language Models:

- Content generation with LLMs
- Targeted updates to specific blocks
- Content enhancement workflows
- Translation examples
- See the README in that directory for more details

## Running the Examples

1. Make sure you have BlockDoc installed:

```bash
pip install blockdoc
```

2. Navigate to the BlockDoc root directory:

```bash
cd path/to/blockdoc-python
```

3. Run an example:

```bash
python examples/basic_example.py
```

## Output

Most examples generate output files in an `output` directory within the example directory. These typically include:

- JSON files containing the BlockDoc document structure
- HTML files showing rendered output
- Markdown files showing rendered output
- Any other relevant output files

## Creating Your Own Examples

If you create interesting examples using BlockDoc, we'd love to see them! Consider contributing to the project by submitting a pull request with your example.
</file>

<file path="tests/conversions/test_markdown.py">
def test_markdown_to_blockdoc_basic()
⋮----
markdown = """# Test Document
doc = markdown_to_blockdoc(markdown)
⋮----
def test_markdown_to_blockdoc_with_explicit_title()
⋮----
doc = markdown_to_blockdoc(markdown, title="Explicit Title")
⋮----
def test_markdown_to_blockdoc_with_metadata()
⋮----
metadata = {"author": "Test Author", "tags": ["test", "markdown"]}
doc = markdown_to_blockdoc(markdown, metadata=metadata)
⋮----
def test_markdown_to_blockdoc_blocks()
⋮----
markdown = """# Heading 1
⋮----
block_types = [block["type"] for block in doc.article["blocks"]]
⋮----
headings = [block for block in doc.article["blocks"] if block["type"] == "heading"]
⋮----
lists = [block for block in doc.article["blocks"] if block["type"] == "list"]
list_types = [l["list_type"] for l in lists]
⋮----
code_blocks = [block for block in doc.article["blocks"] if block["type"] == "code"]
⋮----
quotes = [block for block in doc.article["blocks"] if block["type"] == "quote"]
⋮----
def test_empty_markdown()
⋮----
doc = markdown_to_blockdoc("")
</file>

<file path=".gitignore">
blockdoc-js/

# Python bytecode
__pycache__/
*.py[cod]
*$py.class

# Distribution / packaging
dist/
build/
*.egg-info/

# Virtual environments
venv/
env/
ENV/

# Testing
.coverage
htmlcov/

# Development environments
.vscode/
.idea/

# OS specific
.DS_Store
</file>

<file path=".pre-commit-config.yaml">
repos:
-   repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.1.11
    hooks:
    -   id: ruff
        args: [ --fix ]
    -   id: ruff-format
-   repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
    -   id: trailing-whitespace
    -   id: end-of-file-fixer
    -   id: check-yaml
    -   id: check-added-large-files
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [1.1.0] - 2025-04-25

### Added

- New `markdown_to_blockdoc` converter for transforming Markdown documents to BlockDoc format
- Comprehensive parser that handles all core Markdown elements:
  - Headings (ATX and Setext styles)
  - Paragraphs with proper line break handling
  - Lists (ordered and unordered)
  - Code blocks with language detection
  - Block quotes with attribution
  - Images with captions
  - Horizontal rules
- Semantic ID generation based on content
- Example implementation in `examples/markdown_conversion_example.py`
- Test suite for the converter functionality

## [1.0.1] - 2024-09-15

### Fixed

- Fixed pyproject.toml syntax error and installation method in CI

## [1.0.0] - 2024-09-01

### Added

- Initial release of BlockDoc
- Core Block and BlockDocDocument classes
- HTML and Markdown renderers
- JSON schema validation
- Basic utility functions
</file>

<file path="CLAUDE.md">
# BlockDoc Project Information

## Development Commands

### Linting and Formatting

- Run linting: `./scripts/lint.sh` or `ruff check .`
- Run formatting: `./scripts/format.sh` or `ruff format .`
- Install dev dependencies: `pip install -e ".[dev]"`

### Testing

- Run tests: `pytest` or `pytest tests/`

## Code Style

This project uses ruff for code style enforcement with the following settings:
- Line length: 88 characters
- Use double quotes for strings
- Follow black-compatible formatting

## Project Structure

- `blockdoc/`: Main package source code
  - `core/`: Core functionality (Block and Document classes)
  - `renderers/`: HTML and Markdown renderers
  - `schema/`: JSON schema for BlockDoc
  - `utils/`: Utility functions
- `tests/`: Test suite
- `examples/`: Example applications
- `docs/`: Documentation
</file>

<file path="LICENSE">
The MIT License (MIT)

Copyright (c) 2025 Eric Berry <eric@berrydev.ai>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="MANIFEST.in">
include LICENSE
include README.md
include MANIFEST.in
include pyproject.toml
include setup.py

recursive-include blockdoc/schema *.json
recursive-include examples *.py
recursive-include tests *.py
</file>

<file path="blockdoc/api/__init__.py">

</file>

<file path="blockdoc/conversions/markdown.py">
metadata = {}
doc = BlockDocDocument({"title": title, "metadata": metadata})
⋮----
first_line = markdown_text.strip().split("\n")[0]
⋮----
extracted_title = first_line[2:].strip()
⋮----
markdown_text = "\n".join(markdown_text.strip().split("\n")[1:]).strip()
blocks = split_markdown_into_blocks(markdown_text)
⋮----
blockdoc_block = convert_block_to_blockdoc(block)
⋮----
def split_markdown_into_blocks(markdown_text: str) -> List[Dict[str, str]]
⋮----
lines = markdown_text.split("\n")
blocks = []
current_block = None
in_code_block = False
code_lang = ""
in_list = False
list_items = []
list_type = ""
current_list_indent = 0
in_quote = False
quote_lines = []
quote_has_attribution = False
i = 0
⋮----
line = lines[i]
stripped_line = line.strip()
⋮----
in_code_block = True
code_lang = stripped_line[3:].strip() or "plain"
current_block = {"type": "code", "content": "", "language": code_lang}
⋮----
heading_match = re.match(r"^(#{1,6})\s+(.+)$", stripped_line)
⋮----
level = len(heading_match.group(1))
content = heading_match.group(2).strip()
⋮----
next_line = lines[i + 1].strip()
⋮----
content = current_block["content"].strip()
⋮----
image_match = re.match(r"^!\[([^\]]*)\]\(([^)]+)\)(?:\s*(.*))?$", stripped_line)
⋮----
alt_text = image_match.group(1) or ""
url = image_match.group(2)
caption = image_match.group(3) or None
img_block = {"type": "image", "content": "", "url": url, "alt": alt_text}
⋮----
quote_line = stripped_line[1:].strip()
attribution_match = re.match(r"^[\u2014-]\s+(.+)$", quote_line)
⋮----
in_quote = True
⋮----
quote_has_attribution = True
attribution = attribution_match.group(1)
⋮----
quote_content = "\n".join(quote_lines).strip()
quote_block = {"type": "quote", "content": quote_content}
⋮----
# Handle lists
list_match = re.match(r"^(\s*)([-*+]|\d+\.)\s+(.+)$", stripped_line)
⋮----
indent = len(list_match.group(1))
marker = list_match.group(2)
item_content = list_match.group(3)
is_ordered = bool(re.match(r"\d+\.", marker))
⋮----
# Start of a new list
⋮----
in_list = True
current_list_indent = indent
list_items = [item_content]
list_type = "ordered" if is_ordered else "unordered"
⋮----
# Continuing a list
# Check if this is a new list (different indent or type)
⋮----
# Different list - end current one and start new
⋮----
# Same list - add item
⋮----
# Empty line - check if next non-empty line continues the list
next_i = i + 1
⋮----
next_line = lines[next_i]
next_match = re.match(r"^(\s*)([-*+]|\d+\.)\s+(.+)$", next_line)
⋮----
# Next line continues this list after blank line(s)
i = next_i
⋮----
# End of list
⋮----
# Not a list item - end list and process line again
⋮----
# Don't increment i, process this line again
⋮----
current_block = {"type": "text", "content": stripped_line}
⋮----
# Add a space unless the line was actually empty
⋮----
# This is an empty line within a text block (preserve it)
⋮----
# Handle unclosed blocks
⋮----
# Unclosed code block - best effort to add it
⋮----
def convert_block_to_blockdoc(block: Dict[str, str]) -> Optional[Block]
⋮----
block_type = block.get("type")
# Generate a semantic ID based on content
block_id = generate_block_id(block)
⋮----
content = block.get("content", "").strip()
if not content:  # Skip empty text blocks
⋮----
level = block.get("level", 2)
⋮----
language = block.get("language", "plain")
⋮----
url = block.get("url", "")
alt = block.get("alt", "")
caption = block.get("caption")
⋮----
items = block.get("items", [])
list_type = block.get("list_type", "unordered")
⋮----
attribution = block.get("attribution")
⋮----
# Unknown block type, convert to text
⋮----
# If anything goes wrong, return None
⋮----
def generate_block_id(block: Dict[str, str]) -> str
⋮----
# For headings, create an ID from the content
⋮----
# Convert to lowercase, replace spaces with hyphens, remove non-alphanumeric
slug = re.sub(r"[^\w\s-]", "", content.lower())
slug = re.sub(r"[\s-]+", "-", slug).strip("-")
return slug[:40]  # Limit length of ID
# For other block types, use the type as a prefix
⋮----
prefix = block_type
# For specific block types, enhance the ID
⋮----
prefix = f"code-{block.get('language')}"
⋮----
prefix = f"{block.get('list_type', 'unordered')}-list"
suffix = str(uuid.uuid4())[:8]
</file>

<file path="blockdoc/core/__init__.py">

</file>

<file path="blockdoc/core/block.py">
ALLOWED_TYPES = [
TYPE_REQUIREMENTS = {
class Block
⋮----
def __init__(self, data)
⋮----
required_props = TYPE_REQUIREMENTS.get(self.type, [])
⋮----
python_prop = prop
⋮----
python_prop = "list_type"
⋮----
def update(self, updates)
⋮----
updates_copy = updates.copy()
⋮----
def to_dict(self)
⋮----
result = {
⋮----
@classmethod
    def text(cls, id, content)
⋮----
@classmethod
    def heading(cls, id, level, content)
⋮----
@classmethod
    def image(cls, id, url, alt, caption=None)
⋮----
data = {
⋮----
@classmethod
    def code(cls, id, language, content)
⋮----
@classmethod
    def list(cls, id, items, list_type="unordered")
⋮----
@classmethod
    def quote(cls, id, content, attribution=None)
⋮----
@classmethod
    def embed(cls, id, url, embed_type, caption=None)
⋮----
@classmethod
    def divider(cls, id)
</file>

<file path="blockdoc/core/document.py">
class BlockDocDocument
⋮----
def __init__(self, options)
⋮----
title = options.get("title")
metadata = options.get("metadata", {})
blocks = options.get("blocks", [])
⋮----
def validate(self)
def add_block(self, block_data)
⋮----
block_data = block_data.to_dict()
# Check if ID already exists
⋮----
block = Block(block_data)
⋮----
def insert_block(self, block_data, position)
⋮----
# If it's already a Block instance, convert to dict
⋮----
def get_block(self, id)
def update_block(self, id, updates)
⋮----
index = -1
⋮----
index = i
⋮----
current_block = self.article["blocks"][index]
updated_data = {**current_block, **updates}
block = Block(updated_data)
⋮----
def remove_block(self, id)
def move_block(self, id, new_position)
⋮----
block = self.article["blocks"].pop(index)
⋮----
def render_to_html(self)
def render_to_markdown(self)
def to_dict(self)
def to_json(self, indent=2)
⋮----
@classmethod
    def from_dict(cls, data)
⋮----
article = data["article"]
⋮----
@classmethod
    def from_json(cls, json_str)
⋮----
data = json.loads(json_str)
</file>

<file path="blockdoc/renderers/__init__.py">

</file>

<file path="blockdoc/renderers/html.py">
def render_to_html(article)
⋮----
html = [
⋮----
def render_block(block)
⋮----
block_id = block.get("id", "")
block_type = block.get("type", "")
open_wrapper = f'<div class="blockdoc-block blockdoc-{block_type}" data-block-id="{block_id}" data-block-type="{block_type}">'
close_wrapper = "</div>"
⋮----
content = render_text_block(block)
⋮----
content = render_heading_block(block)
⋮----
content = render_image_block(block)
⋮----
content = render_code_block(block)
⋮----
content = render_list_block(block)
⋮----
content = render_quote_block(block)
⋮----
content = render_embed_block(block)
⋮----
content = render_divider_block()
⋮----
content = f"<p>Unknown block type: {block_type}</p>"
⋮----
def render_text_block(block)
def render_heading_block(block)
⋮----
level = block.get("level", 2)
content = block.get("content", "")
valid_level = min(max(int(level), 1), 6)
⋮----
def render_image_block(block)
⋮----
url = sanitize_url(block.get("url", ""))
alt = sanitize_html(block.get("alt", ""))
caption = block.get("caption")
img_html = f'<img src="{url}" alt="{alt}" class="blockdoc-image" />'
⋮----
def render_code_block(block)
⋮----
language = block.get("language", "")
⋮----
lexer = get_lexer_by_name(language)
⋮----
lexer = guess_lexer(content)
highlighted_code = highlight(content, lexer, HtmlFormatter())
⋮----
highlighted_code = sanitize_html(content)
⋮----
def render_list_block(block)
⋮----
items = block.get("items", [])
list_type = block.get("list_type", block.get("listType", "unordered"))
⋮----
tag = "ol" if list_type == "ordered" else "ul"
items_html = []
⋮----
rendered_item = markdown(item)
rendered_item = rendered_item.replace("<p>", "").replace("</p>", "")
⋮----
def render_quote_block(block)
⋮----
attribution = block.get("attribution")
html = f'<blockquote class="blockdoc-quote">{markdown(content)}</blockquote>'
⋮----
def render_embed_block(block)
⋮----
embed_type = block.get("embed_type", block.get("embedType", "generic"))
⋮----
video_id = extract_youtube_id(url)
⋮----
embed_html = f"""
⋮----
embed_html = "<p>Invalid YouTube URL</p>"
⋮----
def render_divider_block()
def extract_youtube_id(url)
⋮----
youtu_be_match = re.match(r"https?://youtu\.be/([a-zA-Z0-9_-]+)", url)
⋮----
youtube_match = re.match(
</file>

<file path="blockdoc/renderers/markdown.py">
def render_to_markdown(article)
⋮----
markdown = [f"# {article['title']}", ""]
⋮----
metadata = article["metadata"]
⋮----
date = datetime.fromisoformat(
⋮----
def render_block_to_markdown(block)
⋮----
block_type = block.get("type", "")
⋮----
def render_text_block_to_markdown(block)
def render_heading_block_to_markdown(block)
⋮----
level = block.get("level", 2)
content = block.get("content", "")
valid_level = min(max(int(level), 1), 6)
hashtags = "#" * valid_level
⋮----
def render_image_block_to_markdown(block)
⋮----
url = block.get("url", "")
alt = block.get("alt", "")
caption = block.get("caption")
markdown = f"![{alt}]({url})"
⋮----
def render_code_block_to_markdown(block)
⋮----
language = block.get("language", "")
⋮----
def render_list_block_to_markdown(block)
⋮----
items = block.get("items", [])
list_type = block.get("list_type", block.get("listType", "unordered"))
⋮----
markdown_items = []
⋮----
def render_quote_block_to_markdown(block)
⋮----
attribution = block.get("attribution")
markdown = "\n".join([f"> {line}" for line in content.split("\n")])
⋮----
def render_embed_block_to_markdown(block)
⋮----
embed_type = block.get("embed_type", block.get("embedType", "generic"))
markdown = f"[{embed_type or 'Embedded content'}: {url}]({url})"
</file>

<file path="blockdoc/schema/__init__.py">

</file>

<file path="blockdoc/schema/loader.py">
schema_path = os.path.join(os.path.dirname(__file__), "blockdoc.schema.json")
⋮----
schema = json.load(schema_file)
</file>

<file path="blockdoc/utils/__init__.py">

</file>

<file path="blockdoc/utils/sanitize.py">
def sanitize_html(html_content)
def sanitize_url(url)
</file>

<file path="docs/spec/blockdoc-specification.md">
# BlockDoc Specification

**Version:** 1.0.1
**Status:** Stable
**Maintainer:** BlockDoc Team

## Overview

BlockDoc is a structured content format designed for creating, managing, and rendering content in a way that is optimized for both human authors and language models (LLMs). It provides a simple, intuitive structure that makes content easier to manipulate, update, and transform programmatically.

## Document Structure

A BlockDoc document consists of a top-level `article` object with the following properties:

```json
{
  "article": {
    "title": "Document Title",
    "metadata": {
      "author": "Author Name",
      "publishedDate": "2025-03-23T10:00:00Z",
      "tags": ["tag1", "tag2"]
    },
    "blocks": [
      // Array of content blocks
    ]
  }
}
```

### Required Properties

- `title` (string): The document title
- `blocks` (array): An array of content blocks

### Optional Properties

- `metadata` (object): Additional document metadata
  - `author` (string): Document author
  - `publishedDate` (string): ISO 8601 date-time format
  - `tags` (array of strings): Content tags
  - Any other custom metadata properties

## Block Structure

Each block in the `blocks` array represents a discrete unit of content with the following structure:

```json
{
  "id": "unique-semantic-id",
  "type": "text",
  "content": "Content of the block, formatted according to the block type."
}
```

### Required Properties for All Blocks

- `id` (string): A unique, semantic identifier for the block (e.g., "introduction", "section-1-heading")
- `type` (string): The block type (e.g., "text", "heading")
- `content` (string): The content of the block, interpreted based on the block type

### Block Types

BlockDoc supports the following core block types:

#### 1. Text

Text blocks contain Markdown-formatted text.

```json
{
  "id": "intro-paragraph",
  "type": "text",
  "content": "This is **formatted** text with [links](https://example.com)."
}
```

#### 2. Heading

Heading blocks represent section titles with a specified level (1-6).

```json
{
  "id": "section-title",
  "type": "heading",
  "level": 2,
  "content": "Section Title"
}
```

**Additional Required Properties:**
- `level` (integer): Heading level, from 1 (highest) to 6 (lowest)

#### 3. Image

Image blocks represent visual content with a URL, alt text, and optional caption.

```json
{
  "id": "hero-image",
  "type": "image",
  "content": "",
  "url": "https://example.com/image.jpg",
  "alt": "Description of the image",
  "caption": "Optional image caption"
}
```

**Additional Required Properties:**
- `url` (string): The image URL
- `alt` (string): Alternative text for accessibility

**Optional Properties:**
- `caption` (string): Image caption

#### 4. Code

Code blocks contain programming code with syntax highlighting.

```json
{
  "id": "example-code",
  "type": "code",
  "language": "python",
  "content": "def hello_world():\n    print(\"Hello, World!\")"
}
```

**Additional Required Properties:**
- `language` (string): Programming language for syntax highlighting

#### 5. List

List blocks represent ordered or unordered lists.

```json
{
  "id": "feature-list",
  "type": "list",
  "list_type": "unordered",
  "items": [
    "First item",
    "Second item with **formatting**",
    "Third item with [link](https://example.com)"
  ]
}
```

**Additional Required Properties:**
- `items` (array of strings): List items, supporting Markdown formatting
- `list_type` (string): Either "ordered" or "unordered"

#### 6. Quote

Quote blocks represent quotations with optional attribution.

```json
{
  "id": "important-quote",
  "type": "quote",
  "content": "This is a quotation that might span multiple lines.",
  "attribution": "Source of the quote"
}
```

**Optional Properties:**
- `attribution` (string): Quote attribution

#### 7. Embed

Embed blocks represent embedded content from external sources.

```json
{
  "id": "video-embed",
  "type": "embed",
  "content": "",
  "url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
  "embed_type": "youtube",
  "caption": "Optional caption for the embedded content"
}
```

**Additional Required Properties:**
- `url` (string): URL of the embedded content
- `embed_type` (string): Type of embed ("youtube", "twitter", or "generic")

**Optional Properties:**
- `caption` (string): Caption for the embedded content

#### 8. Divider

Divider blocks represent horizontal separators between content sections.

```json
{
  "id": "section-divider",
  "type": "divider",
  "content": ""
}
```

## Naming Conventions

### Block IDs

Block IDs should be:
- Unique within the document
- Semantic in nature (describing the content's purpose)
- Lowercase with hyphens for separating words
- Composed of alphanumeric characters, hyphens, and underscores only

Examples of good block IDs:
- `introduction`
- `key-features`
- `section-1-heading`
- `code-example-python`

## Property Naming

BlockDoc follows a mixed naming convention to support interoperability:

- Python implementation primarily uses snake_case (`list_type`, `embed_type`)
- For compatibility with JavaScript, camelCase versions of properties (`listType`, `embedType`) are also recognized

## Best Practices

### Document Organization

1. **Semantic Structure**: Organize blocks in a logical flow with meaningful IDs
2. **Granularity**: Divide content into reasonably sized blocks for targeted modification
3. **Self-Contained Blocks**: Each block should function as a coherent unit of content

### Working with LLMs

1. **Clear Instructions**: When using LLMs to modify content, identify blocks by their semantic IDs
2. **Targeted Updates**: Request updates to specific blocks rather than the entire document
3. **Context Preservation**: Provide surrounding context when necessary for coherent updates

### Content Authoring

1. **Markdown in Text Blocks**: Use Markdown for formatting text content
2. **Semantic Headings**: Use heading levels appropriately to maintain document hierarchy
3. **Accessibility**: Always provide alt text for images and appropriate captions

## Extension Guidelines

BlockDoc can be extended with custom block types for domain-specific use cases:

1. Define a new block type with a descriptive name
2. Document the block type's required and optional properties
3. Implement rendering logic for the custom block type
4. Consider backward compatibility with core BlockDoc renderers

## Schema Validation

BlockDoc documents can be validated against the JSON schema available at:
- Python: `blockdoc/schema/blockdoc.schema.json`
- NPM: `blockdoc/dist/schema/blockdoc.schema.json`

## Use Cases

BlockDoc is particularly well-suited for:

1. **Content Management Systems**: Structured storage with granular update capability
2. **Documentation**: Technical documentation with code examples and structured sections
3. **LLM-powered applications**: Content generation and modification with semantic structure
4. **Blogs and Articles**: Structured content with rich multimedia support
5. **Educational Content**: Lessons and tutorials with mixed content types

## Comparison with Other Formats

| Feature | BlockDoc | Markdown | JSON | HTML |
|---------|----------|----------|------|------|
| Structured | ✓ | ✗ | ✓ | ✓ |
| Human-readable | ✓ | ✓ | ✗ | ✗ |
| Semantic IDs | ✓ | ✗ | ✗ | ✓ |
| Block-level targeting | ✓ | ✗ | ✓ | ✓ |
| Metadata support | ✓ | ✗ | ✓ | ✓ |
| Markdown in content | ✓ | ✓ | ✗ | ✗ |
| LLM-friendly | ✓ | ✓ | ✗ | ✗ |
| Database-ready | ✓ | ✗ | ✓ | ✗ |

## Version History

- **1.0.0** (2025-03-23): Initial stable release
- **0.9.0** (2025-02-15): Beta release with core block types
- **0.5.0** (2025-01-10): Alpha release for testing
</file>

<file path="examples/llm-integration/llm_content_generator.py">
def generate_with_llm(prompt, max_tokens=800)
def create_article_with_llm(title, topic)
⋮----
# Create a new document
article = BlockDocDocument(
# Generate introduction
intro_prompt = f"""Write an engaging introduction for an article titled "{title}" about {topic}.
intro_content = generate_with_llm(intro_prompt)
⋮----
# Generate a section about benefits/features
⋮----
benefits_prompt = f"""Create a list of 4-6 key benefits or features of {topic}.
benefits_content = generate_with_llm(benefits_prompt)
# Parse the list items from the response
benefits_items = []
⋮----
line = line.strip()
⋮----
# Generate a code example section
⋮----
code_prompt = f"""Create a Python code example related to {topic} using the BlockDoc library.
code_content = generate_with_llm(code_prompt)
# Extract the code from markdown code blocks if present
⋮----
code_parts = code_content.split("```")
⋮----
# Get the content inside the code block
code_block = code_parts[1]
# Remove language identifier if present
⋮----
code_block = code_block[code_block.find("\n") + 1 :]
code_content = code_block.strip()
⋮----
# Generate a use cases section
⋮----
use_cases_prompt = f"""Describe 4-5 practical use cases for {topic}.
use_cases_content = generate_with_llm(use_cases_prompt)
⋮----
# Add an image placeholder
⋮----
# Generate conclusion
⋮----
conclusion_prompt = f"""Write a conclusion for an article about {topic}.
conclusion_content = generate_with_llm(conclusion_prompt)
⋮----
def update_block_with_llm(document, block_id, instruction)
⋮----
# Get the existing block
block = document.get_block(block_id)
⋮----
block_type = block["type"]
⋮----
# Generate updated text content
prompt = f"""Here is an existing text block:
updated_content = generate_with_llm(prompt)
⋮----
# Generate updated heading
prompt = f"""Here is an existing heading:
⋮----
# Update list items
items = block.get("items", [])
items_text = "\n".join([f"- {item}" for item in items])
prompt = f"""Here is an existing list:
⋮----
# Parse updated list items
updated_items = []
⋮----
# Update code content
prompt = f"""Here is an existing code block in {block.get("language", "python")}:
⋮----
# Extract the code from markdown code blocks if present
⋮----
code_parts = updated_content.split("```")
⋮----
# Get the content inside the code block
⋮----
# Remove language identifier if present
⋮----
updated_content = code_block.strip()
⋮----
def main()
⋮----
parser = argparse.ArgumentParser(
⋮----
args = parser.parse_args()
# Create output directory if it doesn't exist
⋮----
# Update an existing document
⋮----
document = BlockDocDocument.from_json(f.read())
⋮----
document = update_block_with_llm(document, args.block_id, args.instruction)
# Save the updated document
output_file = os.path.basename(args.input)
updated_path = os.path.join(args.output_dir, f"updated_{output_file}")
⋮----
# Also save HTML for preview
html_path = os.path.join(
⋮----
# Create a new document
⋮----
document = create_article_with_llm(args.title, args.topic)
# Validate the document
⋮----
# Create a slug from the title for filenames
slug = args.title.lower().replace(" ", "-")
slug = "".join(c for c in slug if c.isalnum() or c == "-")
# Save as JSON
json_path = os.path.join(args.output_dir, f"{slug}.json")
⋮----
# Save as HTML
html_path = os.path.join(args.output_dir, f"{slug}.html")
⋮----
html = f"""<!DOCTYPE html>
⋮----
# Save as Markdown
md_path = os.path.join(args.output_dir, f"{slug}.md")
⋮----
frontmatter = f"""---
</file>

<file path="examples/simple-blog/blog_generator.py">
def create_blog_post(title, author, content_json=None)
⋮----
blog_post = BlockDocDocument(
⋮----
content_structure = json.load(f)
⋮----
block_type = item.get("type")
block_id = item.get("id")
⋮----
def main()
⋮----
parser = argparse.ArgumentParser(description="Generate a blog post using BlockDoc")
⋮----
args = parser.parse_args()
⋮----
# Create the blog post
⋮----
blog_post = create_blog_post(args.title, args.author, args.content)
# Validate the document
⋮----
# Create a slug from the title for filenames
slug = args.title.lower().replace(" ", "-")
slug = "".join(c for c in slug if c.isalnum() or c == "-")
# Save as JSON
json_path = os.path.join(args.output_dir, f"{slug}.json")
⋮----
# Render to HTML
html_path = os.path.join(args.output_dir, f"{slug}.html")
⋮----
# Add basic styling
html = """<!DOCTYPE html>
⋮----
md_path = os.path.join(args.output_dir, f"{slug}.md")
⋮----
frontmatter = f"""---
</file>

<file path="examples/basic_example.py">
def create_blog_post()
⋮----
blog_post = BlockDocDocument(
⋮----
quote_block = Block(
⋮----
def main()
⋮----
blog_post = create_blog_post()
⋮----
output_dir = os.path.join(os.path.dirname(__file__), "output")
⋮----
html = blog_post.render_to_html()
⋮----
markdown = blog_post.render_to_markdown()
</file>

<file path="scripts/format.sh">
echo "Running Ruff formatter..."
ruff format blockdoc tests examples
echo "Done!"
</file>

<file path="scripts/lint.sh">
echo "Running Ruff linter..."
ruff check blockdoc tests examples
echo "Running Ruff formatter..."
ruff format blockdoc tests examples
echo "Running mypy type checking..."
mypy blockdoc
echo "Done!"
</file>

<file path="tests/core/__init__.py">

</file>

<file path="tests/core/test_block.py">
def test_block_init()
⋮----
text_block = Block({"id": "intro", "type": "text", "content": "Hello world"})
⋮----
heading_block = Block(
⋮----
def test_block_init_missing_id()
def test_block_init_invalid_type()
def test_block_init_missing_required_props()
def test_block_update()
⋮----
block = Block({"id": "intro", "type": "text", "content": "Hello world"})
⋮----
def test_block_to_dict()
⋮----
block_data = {"id": "intro", "type": "text", "content": "Hello world"}
block = Block(block_data)
result = block.to_dict()
⋮----
def test_block_factory_methods()
⋮----
text_block = Block.text("intro", "Hello world")
⋮----
heading_block = Block.heading("title", 1, "Title")
⋮----
image_block = Block.image(
⋮----
code_block = Block.code("snippet", "javascript", 'console.log("Hello");')
⋮----
list_block = Block.list("items", ["Item 1", "Item 2"], "ordered")
⋮----
quote_block = Block.quote("quote", "Famous quote", "Famous person")
⋮----
embed_block = Block.embed(
⋮----
divider_block = Block.divider("separator")
</file>

<file path="tests/__init__.py">

</file>

<file path="CONTRIBUTING.md">
# Contributing to BlockDoc

Thank you for your interest in contributing to BlockDoc! This document provides guidelines and instructions for contributing to the project.

## Table of Contents

1. [Getting Started](#getting-started)
2. [Development Setup](#development-setup)
3. [Code Style](#code-style)
4. [Testing](#testing)
5. [Documentation](#documentation)
6. [Pull Request Process](#pull-request-process)
7. [Issue Reporting](#issue-reporting)
8. [Feature Requests](#feature-requests)
9. [Community Guidelines](#community-guidelines)

## Getting Started

Before contributing, please:

1. Familiarize yourself with the [BlockDoc documentation](docs/)
2. Check existing [issues](https://github.com/berrydev-ai/blockdoc-python/issues) to see if your issue/feature has been discussed
3. Check existing [pull requests](https://github.com/berrydev-ai/blockdoc-python/pulls) to avoid duplication

## Development Setup

1. Fork the repository
2. Clone your fork:
   ```bash
   git clone https://github.com/yourusername/blockdoc-python.git
   cd blockdoc-python
   ```
3. Set up the development environment:
   ```bash
   # Create a virtual environment
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   
   # Install development dependencies
   pip install -e ".[dev]"
   ```

## Code Style

BlockDoc follows [PEP 8](https://www.python.org/dev/peps/pep-0008/) with a few customizations:

- Line length: 88 characters
- Use docstrings for all public modules, functions, classes, and methods
- Type hints are encouraged for all functions
- Ruff is used for linting and formatting (compatible with Black style)

To check and fix code style:

```bash
# Run linting
ruff check blockdoc tests

# Run formatting
ruff format blockdoc tests

# Or use the provided scripts
./scripts/lint.sh
./scripts/format.sh
```

## Testing

We use pytest for testing. All new features should include tests, and bug fixes should include regression tests.

To run tests:

```bash
# Run all tests
pytest

# Run tests with coverage report
pytest --cov=blockdoc

# Run a specific test file
pytest tests/core/test_block.py
```

### Test Guidelines

1. Test files should be named `test_*.py`
2. Test functions should start with `test_`
3. Each test should be focused and test one specific behavior
4. Use fixtures where appropriate
5. Mock external services

## Documentation

Good documentation is crucial for BlockDoc. All new features should include:

1. Docstrings for all public API elements
2. Updates to relevant documentation files in the `docs/` directory
3. Example usage where appropriate

For docstrings, we follow the [Google style](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings):

```python
def example_function(param1, param2):
    """Short description of function.
    
    Longer description with more details about behavior,
    edge cases, etc.
    
    Args:
        param1 (type): Description of param1.
        param2 (type): Description of param2.
        
    Returns:
        type: Description of return value.
        
    Raises:
        ExceptionType: When and why this exception is raised.
    """
    # Implementation
```

## Pull Request Process

1. **Fork & Branch**: Create a branch in your fork for your contribution
2. **Implementation**: Make your changes, following code style and including tests
3. **Documentation**: Update documentation as needed
4. **Pull Request**: Submit a PR with a clear description:
   - What problem does it solve?
   - How was it tested?
   - Any breaking changes?
5. **Code Review**: Respond to any feedback from maintainers
6. **CI**: Ensure all CI checks pass

### PR Title and Description Guidelines

- Use clear, descriptive titles
- Reference any related issues using GitHub keywords (e.g., "Fixes #123")
- Describe what changes were made and why

## Issue Reporting

When reporting issues, please:

1. Check existing issues to avoid duplicates
2. Use the issue templates when available
3. Include clear reproduction steps
4. Mention your environment (Python version, OS, BlockDoc version)
5. Include any error messages or stack traces

## Feature Requests

For feature requests:

1. Clearly describe the problem the feature would solve
2. Suggest an approach if you have one in mind
3. Indicate if you're willing to help implement it

## Community Guidelines

We strive to maintain a welcoming and inclusive community. Please:

- Be respectful and considerate of others
- Focus on constructive feedback
- Be open to different viewpoints and experiences
- Gracefully accept constructive criticism

## License

By contributing to BlockDoc, you agree that your contributions will be licensed under the project's [MIT License](LICENSE).

Thank you for contributing to BlockDoc!
</file>

<file path=".github/workflows/python-lint.yml">
name: Python Linting
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        python -m pip install .[dev]
    - name: Lint and check formatting with ruff
      run: |
        ruff check blockdoc tests examples
        ruff format --check blockdoc tests examples
    - name: Type check with mypy
      run: |
        mypy blockdoc
</file>

<file path=".github/workflows/python-tests.yml">
name: Python Tests
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.10', '3.11', '3.12']
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        python -m pip install .[dev]
    - name: Run tests with pytest
      run: |
        python -m pytest --cov=blockdoc
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        fail_ci_if_error: false
</file>

<file path="tests/core/test_document.py">
def test_document_init()
⋮----
doc = BlockDocDocument({"title": "Test Document"})
⋮----
doc = BlockDocDocument(
⋮----
def test_document_init_missing_title()
def test_document_add_block()
⋮----
block = doc.add_block({"id": "intro", "type": "text", "content": "Introduction"})
⋮----
heading_block = Block.heading("heading", 2, "Section")
⋮----
def test_document_insert_block()
def test_document_get_block()
⋮----
block = doc.get_block("intro")
⋮----
block = doc.get_block("nonexistent")
⋮----
def test_document_update_block()
⋮----
updated_block = doc.update_block("intro", {"content": "Updated introduction"})
⋮----
def test_document_remove_block()
⋮----
result = doc.remove_block("intro")
⋮----
result = doc.remove_block("nonexistent")
⋮----
def test_document_move_block()
⋮----
result = doc.move_block("conclusion", 0)
⋮----
result = doc.move_block("nonexistent", 0)
⋮----
def test_document_to_dict()
⋮----
result = doc.to_dict()
⋮----
def test_document_to_json()
⋮----
json_str = doc.to_json()
data = json.loads(json_str)
⋮----
def test_document_from_dict()
⋮----
data = {
doc = BlockDocDocument.from_dict(data)
⋮----
def test_document_from_json()
⋮----
json_str = json.dumps(
doc = BlockDocDocument.from_json(json_str)
</file>

<file path="README.md">
# BlockDoc

A simple, powerful standard for structured content that works beautifully with LLMs, humans, and modern editors.

[![PyPI version](https://img.shields.io/pypi/v/blockdoc.svg)](https://pypi.org/project/blockdoc/)
[![Python versions](https://img.shields.io/pypi/pyversions/blockdoc.svg)](https://pypi.org/project/blockdoc/)
[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)

## Why BlockDoc?

BlockDoc provides a lightweight, flexible format for structured content that is:

- **LLM-friendly**: Optimized for AI generation and targeted modifications
- **Simple**: Flat structure with semantic IDs and minimal nesting
- **Extensible**: Core block types with room for custom extensions
- **Framework-agnostic**: Works with any frontend or backend technology
- **Database-ready**: Easy to store and query in SQL or NoSQL databases

## Core Concepts

BlockDoc is based on a block-based architecture where content is organized into discrete, individually addressable blocks. Each block has:

- A semantic ID (like 'intro', 'section-1')
- A block type ('text', 'heading', 'image', 'code')
- Content (in Markdown for text-based blocks)
- Optional metadata

This architecture enables:

- Targeted updates to specific sections
- Better organization of content
- Easy integration with LLMs
- Flexible rendering in different formats

### Core Block Types

1. **Text** - Standard paragraphs with Markdown support
2. **Heading** - Section headers with configurable levels
3. **Image** - Pictures with src, alt text, and optional caption
4. **Code** - Code blocks with syntax highlighting
5. **List** - Ordered or unordered lists
6. **Quote** - Blockquote content
7. **Embed** - Embedded content (videos, social media posts)
8. **Divider** - Horizontal rule/separator

### Design Principles

1. **Simplicity**: Minimal structure with only necessary properties
2. **LLM-Friendly**: Optimized for AI content generation and modification
3. **Human-Editable**: Clear, readable format for direct editing
4. **Database-Ready**: Easily stored in SQL or NoSQL databases
5. **Extensible**: Core types with support for custom block types
6. **Semantic**: Meaningful IDs for blocks rather than auto-generated IDs
7. **Portable**: Framework-agnostic with multiple render targets

```json
{
  "article": {
    "title": "Getting Started with BlockDoc",
    "blocks": [
      {
        "id": "intro",
        "type": "text",
        "content": "BlockDoc makes structured content **simple**."
      },
      {
        "id": "first-steps",
        "type": "heading",
        "level": 2,
        "content": "First Steps"
      },
      {
        "id": "step-one",
        "type": "text",
        "content": "Install BlockDoc using pip: `pip install blockdoc`"
      }
    ]
  }
}
```

## Installation

Install BlockDoc from PyPI:

```bash
pip install blockdoc
```

## Usage

```python
from blockdoc import BlockDocDocument, Block

# Create a new document
doc = BlockDocDocument({
    "title": "My First BlockDoc Post",
})

# Add blocks using factory methods
doc.add_block(Block.text("intro", "Welcome to my first post!"))
doc.add_block(Block.heading("section-1", 2, "Getting Started"))
doc.add_block(Block.text("content-1", "This is **formatted** content with [links](https://example.com)."))

# Render to HTML
html = doc.render_to_html()
print(html)

# Render to Markdown
markdown = doc.render_to_markdown()
print(markdown)

# Export to JSON
json_str = doc.to_json()
print(json_str)
```

### Working with LLMs

BlockDoc shines when generating or modifying content with LLMs:

```python
from blockdoc import BlockDocDocument
import openai

# Update a specific section using an LLM
async def update_section(document, block_id, prompt):
    block = document.get_block(block_id)
    
    response = await openai.chat.completions.create(
        model="gpt-4",
        messages=[
            {
                "role": "system",
                "content": f"Update the following content to {prompt}. Return only the updated content."
            },
            {
                "role": "user",
                "content": block["content"],
            },
        ],
    )
    
    document.update_block(block_id, {
        "content": response.choices[0].message.content,
    })
    
    return document
```

## Documentation

### Specification

- [Full Specification](https://github.com/berrydev-ai/blockdoc-python/blob/main/docs/spec/blockdoc-specification.md)

### API Reference

- [Block Class](https://github.com/berrydev-ai/blockdoc-python/blob/main/docs/api-docs/block.md)
- [BlockDocDocument Class](https://github.com/berrydev-ai/blockdoc-python/blob/main/docs/api-docs/document.md)
- [HTML Renderer](https://github.com/berrydev-ai/blockdoc-python/blob/main/docs/api-docs/renderers/html.md)
- [Markdown Renderer](https://github.com/berrydev-ai/blockdoc-python/blob/main/docs/api-docs/renderers/markdown.md)
- [Sanitization Utilities](https://github.com/berrydev-ai/blockdoc-python/blob/main/docs/api-docs/utils/sanitize.md)

### Tutorials

- [Getting Started](https://github.com/berrydev-ai/blockdoc-python/blob/main/docs/tutorials/getting-started.md)
- [Block Types](https://github.com/berrydev-ai/blockdoc-python/blob/main/docs/tutorials/block-types.md)
- [LLM Integration](https://github.com/berrydev-ai/blockdoc-python/blob/main/docs/tutorials/llm-integration.md)

### Examples

- [Simple Blog Generator](https://github.com/berrydev-ai/blockdoc-python/blob/main/examples/simple-blog/)
- [LLM Content Integration](https://github.com/berrydev-ai/blockdoc-python/blob/main/examples/llm-integration/)
- [Basic Usage Example](https://github.com/berrydev-ai/blockdoc-python/blob/main/examples/basic_example.py)

## Development

### Installation

```bash
# Clone the repository
git clone https://github.com/berrydev-ai/blockdoc-python.git
cd blockdoc-python

# Create a virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install development dependencies
pip install -e ".[dev]"
```

### Testing

BlockDoc uses pytest for testing. To run the tests:

```bash
# Run tests
pytest

# Run tests with coverage report
pytest --cov=blockdoc

# Run a specific test file
pytest tests/core/test_block.py

# Run linting and formatting with ruff
ruff check .
ruff format .
```

## Contributing

We welcome contributions! See [CONTRIBUTING.md](https://github.com/berrydev-ai/blockdoc-python/blob/main/CONTRIBUTING.md) for details on how to contribute, including our testing guidelines.

## License

[MIT](https://github.com/berrydev-ai/blockdoc-python/blob/main/LICENSE)
</file>

<file path="pyproject.toml">
[build-system]
requires = ["setuptools>=45", "wheel", "setuptools_scm>=6.2"]
build-backend = "setuptools.build_meta"

[tool.ruff]
target-version = "py37"
line-length = 88
exclude = [
    ".git",
    ".ruff_cache",
    "__pycache__",
    "build",
    "dist",
]

[tool.ruff.lint]
# Enable pycodestyle (E), Pyflakes (F), isort (I), and more
select = ["E", "F", "I", "W", "N", "UP", "B", "C4", "SIM", "ERA"]
ignore = ["E203"]

[tool.ruff.lint.isort]
known-first-party = ["blockdoc"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
line-ending = "auto"

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = "test_*.py"
addopts = "--cov=blockdoc"

[tool.mypy]
python_version = "3.12"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = false
disallow_incomplete_defs = false
</file>

<file path="blockdoc/__init__.py">
__all__ = [
__version__ = "1.1.0"
</file>

<file path="setup.py">
this_directory = os.path.abspath(os.path.dirname(__file__))
⋮----
long_description = f.read()
</file>

</files>
