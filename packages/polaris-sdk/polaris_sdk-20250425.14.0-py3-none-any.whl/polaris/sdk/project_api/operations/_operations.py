# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.3, generator: @autorest/python@6.26.7)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._serialization import Serializer
from .._vendor import raise_if_not_implemented

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
T = TypeVar("T")
ClsType = Optional[
    Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]
]
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_alerts_list_alerts_request(project_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/alerts"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_alerts_create_alert_request(project_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/alerts"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_alerts_get_alert_request(
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/alerts/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_alerts_update_alert_request(
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/alerts/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_alerts_patch_alert_request(
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/alerts/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_alerts_delete_alert_request(
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/alerts/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_alerts_list_alert_evaluations_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/alerts/{id}/evaluations"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_alerts_get_alert_evaluation_request(  # pylint: disable=name-too-long
    id: str, evaluation_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/alerts/{id}/evaluations/{evaluationId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "evaluationId": _SERIALIZER.url(
            "evaluation_id", evaluation_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_network_policy_get_project_network_policy_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/network-policy"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_network_policy_update_project_network_policy_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/network-policy"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_collections_list_collections_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/collections"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_collections_create_collection_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/collections"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_collections_describe_collection_request(  # pylint: disable=name-too-long
    id: int, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/collections/{id}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "id": _SERIALIZER.url("id", id, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_collections_update_collection_request(  # pylint: disable=name-too-long
    id: int, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/collections/{id}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "id": _SERIALIZER.url("id", id, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_collections_delete_collection_request(  # pylint: disable=name-too-long
    id: int, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/collections/{id}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "id": _SERIALIZER.url("id", id, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_collections_add_assets_to_collection_request(  # pylint: disable=name-too-long
    id: int, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/collections/{id}/assets"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "id": _SERIALIZER.url("id", id, "int"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_collections_remove_asset_from_collection_request(  # pylint: disable=name-too-long
    id: int,
    asset_type: Union[str, _models.CollectionAssetType],
    asset_id: str,
    project_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/collections/{id}/assets/{assetType}/{assetId}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "id": _SERIALIZER.url("id", id, "int"),
        "assetType": _SERIALIZER.url("asset_type", asset_type, "str"),
        "assetId": _SERIALIZER.url("asset_id", asset_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_collections_describe_favorites_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/favorites"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_collections_add_assets_to_favorites_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/favorites"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_collections_remove_asset_from_favorites_request(  # pylint: disable=name-too-long
    asset_id: str,
    asset_type: Union[str, _models.CollectionAssetType],
    project_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/favorites/{assetType}/{assetId}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "assetId": _SERIALIZER.url("asset_id", asset_id, "str"),
        "assetType": _SERIALIZER.url("asset_type", asset_type, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_connections_list_connections_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/connections"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_connections_create_connection_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/connections"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_connections_get_connection_request(
    name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/connections/{name}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "name": _SERIALIZER.url("name", name, "str", max_length=64, min_length=1),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_connections_update_connection_request(  # pylint: disable=name-too-long
    name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/connections/{name}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "name": _SERIALIZER.url("name", name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_connections_delete_connection_request(  # pylint: disable=name-too-long
    name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/connections/{name}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "name": _SERIALIZER.url("name", name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_connections_test_connection_request(  # pylint: disable=name-too-long
    name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/connections/{name}/test"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "name": _SERIALIZER.url("name", name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_connections_describe_connections_meta_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/connectionsMeta"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_dashboards_list_dashboard_summaries_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_dashboards_create_dashboard_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_dashboards_get_dashboard_request(
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_dashboards_update_dashboard_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_dashboards_patch_dashboard_request(
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_dashboards_delete_dashboard_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_dashboards_list_dashboard_data_cubes_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/data-cubes"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_dashboards_list_dashboard_pages_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/pages"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_dashboards_create_dashboard_page_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/pages"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_dashboards_get_dashboard_page_request(  # pylint: disable=name-too-long
    id: str, page_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/pages/{pageId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "pageId": _SERIALIZER.url(
            "page_id", page_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_dashboards_update_dashboard_page_request(  # pylint: disable=name-too-long
    id: str, page_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/pages/{pageId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "pageId": _SERIALIZER.url(
            "page_id", page_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_dashboards_patch_dashboard_page_request(  # pylint: disable=name-too-long
    id: str, page_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/pages/{pageId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "pageId": _SERIALIZER.url(
            "page_id", page_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_dashboards_delete_dashboard_page_request(  # pylint: disable=name-too-long
    id: str, page_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/pages/{pageId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "pageId": _SERIALIZER.url(
            "page_id", page_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_dashboards_list_dashboard_page_tiles_request(  # pylint: disable=name-too-long
    id: str, page_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/pages/{pageId}/tiles"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "pageId": _SERIALIZER.url(
            "page_id", page_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_dashboards_create_dashboard_page_tile_request(  # pylint: disable=name-too-long
    id: str, page_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/pages/{pageId}/tiles"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "pageId": _SERIALIZER.url(
            "page_id", page_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_dashboards_get_dashboard_page_tile_request(  # pylint: disable=name-too-long
    id: str, page_id: str, tile_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/pages/{pageId}/tiles/{tileId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "pageId": _SERIALIZER.url(
            "page_id", page_id, "str", max_length=255, min_length=1
        ),
        "tileId": _SERIALIZER.url(
            "tile_id", tile_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_dashboards_update_dashboard_page_tile_request(  # pylint: disable=name-too-long
    id: str, page_id: str, tile_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/pages/{pageId}/tiles/{tileId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "pageId": _SERIALIZER.url(
            "page_id", page_id, "str", max_length=255, min_length=1
        ),
        "tileId": _SERIALIZER.url(
            "tile_id", tile_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_dashboards_patch_dashboard_page_tile_request(  # pylint: disable=name-too-long
    id: str, page_id: str, tile_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/pages/{pageId}/tiles/{tileId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "pageId": _SERIALIZER.url(
            "page_id", page_id, "str", max_length=255, min_length=1
        ),
        "tileId": _SERIALIZER.url(
            "tile_id", tile_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_dashboards_delete_dashboard_page_tile_request(  # pylint: disable=name-too-long
    id: str, page_id: str, tile_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/dashboards/{id}/pages/{pageId}/tiles/{tileId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "pageId": _SERIALIZER.url(
            "page_id", page_id, "str", max_length=255, min_length=1
        ),
        "tileId": _SERIALIZER.url(
            "tile_id", tile_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_data_cubes_list_data_cube_summaries_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_data_cubes_create_data_cube_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_data_cubes_get_data_cube_request(
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_data_cubes_update_data_cube_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_data_cubes_patch_data_cube_request(
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_data_cubes_delete_data_cube_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_data_cubes_list_data_cube_dimensions_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}/dimensions"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_data_cubes_create_data_cube_dimension_request(  # pylint: disable=name-too-long
    id: str, project_id: str, *, order: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}/dimensions"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if order is not None:
        _params["order"] = _SERIALIZER.query("order", order, "int")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="POST", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_data_cubes_get_data_cube_dimension_request(  # pylint: disable=name-too-long
    id: str, dimension_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}/dimensions/{dimensionId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "dimensionId": _SERIALIZER.url(
            "dimension_id", dimension_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_data_cubes_update_data_cube_dimension_request(  # pylint: disable=name-too-long
    id: str, dimension_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}/dimensions/{dimensionId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "dimensionId": _SERIALIZER.url(
            "dimension_id", dimension_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_data_cubes_patch_data_cube_dimension_request(  # pylint: disable=name-too-long
    id: str, dimension_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}/dimensions/{dimensionId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "dimensionId": _SERIALIZER.url(
            "dimension_id", dimension_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_data_cubes_delete_data_cube_dimension_request(  # pylint: disable=name-too-long
    id: str, dimension_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}/dimensions/{dimensionId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "dimensionId": _SERIALIZER.url(
            "dimension_id", dimension_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_data_cubes_list_data_cube_measures_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}/measures"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_data_cubes_create_data_cube_measure_request(  # pylint: disable=name-too-long
    id: str, project_id: str, *, order: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}/measures"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if order is not None:
        _params["order"] = _SERIALIZER.query("order", order, "int")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="POST", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_data_cubes_get_data_cube_measure_request(  # pylint: disable=name-too-long
    id: str, measure_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}/measures/{measureId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "measureId": _SERIALIZER.url(
            "measure_id", measure_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_data_cubes_update_data_cube_measure_request(  # pylint: disable=name-too-long
    id: str, measure_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}/measures/{measureId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "measureId": _SERIALIZER.url(
            "measure_id", measure_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_data_cubes_patch_data_cube_measure_request(  # pylint: disable=name-too-long
    id: str, measure_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}/measures/{measureId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "measureId": _SERIALIZER.url(
            "measure_id", measure_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_data_cubes_delete_data_cube_measure_request(  # pylint: disable=name-too-long
    id: str, measure_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/data-cubes/{id}/measures/{measureId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "measureId": _SERIALIZER.url(
            "measure_id", measure_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_embedding_links_list_embedding_links_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/embedding-links"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_embedding_links_create_embedding_link_request(  # pylint: disable=name-too-long
    project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/embedding-links"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_embedding_links_get_embedding_link_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/embedding-links/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_embedding_links_update_embedding_link_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/embedding-links/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_embedding_links_patch_embedding_link_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/embedding-links/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_embedding_links_delete_embedding_link_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/embedding-links/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_embedding_links_create_embedding_link_secret_key_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "text/plain, application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/embedding-links/{id}/key"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_embedding_links_delete_embedding_link_secret_key_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/embedding-links/{id}/key"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_events_push_events_using_connection_request(  # pylint: disable=name-too-long
    connection_name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    # Construct URL
    _url = "/v1/projects/{projectId}/events/{connectionName}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "connectionName": _SERIALIZER.url("connection_name", connection_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_files_list_files_request(
    project_id: str,
    *,
    pagination_limit: int = 1000,
    pagination_offset: int = 0,
    search_string: Optional[str] = None,
    sort_column: Union[str, _models.FileSortColumn] = "uploaded_on_dt",
    sort_order: Union[str, _models.SortOrder] = "DESC",
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/files"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if pagination_limit is not None:
        _params["paginationLimit"] = _SERIALIZER.query(
            "pagination_limit", pagination_limit, "int", maximum=1000, minimum=1
        )
    if pagination_offset is not None:
        _params["paginationOffset"] = _SERIALIZER.query(
            "pagination_offset", pagination_offset, "int", minimum=0
        )
    if search_string is not None:
        _params["searchString"] = _SERIALIZER.query(
            "search_string", search_string, "str"
        )
    if sort_column is not None:
        _params["sortColumn"] = _SERIALIZER.query("sort_column", sort_column, "str")
    if sort_order is not None:
        _params["sortOrder"] = _SERIALIZER.query("sort_order", sort_order, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_files_get_file_metadata_request(
    name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/files/{name}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "name": _SERIALIZER.url("name", name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_files_delete_file_request(
    name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/files/{name}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "name": _SERIALIZER.url("name", name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_lookups_list_lookups_request(project_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/lookups"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_lookups_create_lookup_request(project_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/lookups"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_lookups_get_lookup_request(
    lookup_name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/lookups/{lookupName}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "lookupName": _SERIALIZER.url("lookup_name", lookup_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_lookups_update_lookup_request(
    lookup_name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/lookups/{lookupName}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "lookupName": _SERIALIZER.url("lookup_name", lookup_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_lookups_delete_lookup_request(
    lookup_name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/lookups/{lookupName}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "lookupName": _SERIALIZER.url("lookup_name", lookup_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_lookups_list_lookup_aliases_request(  # pylint: disable=name-too-long
    lookup_name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/lookups/{lookupName}/aliases"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "lookupName": _SERIALIZER.url("lookup_name", lookup_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_lookups_update_lookup_aliases_request(  # pylint: disable=name-too-long
    lookup_name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/lookups/{lookupName}/aliases"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "lookupName": _SERIALIZER.url("lookup_name", lookup_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_jobs_list_jobs_request(
    project_id: str,
    *,
    connection_name: Optional[List[str]] = None,
    execution_status: Optional[List[Union[str, _models.JobExecutionStatusV2]]] = None,
    health_status: Optional[List[Union[str, _models.JobHealthStatusV2]]] = None,
    pagination_limit: int = 100,
    pagination_offset: int = 0,
    search_string: Optional[str] = None,
    sort_column: Union[str, _models.JobSortSearchColumn] = "last_updated_date_time",
    sort_order: Union[str, _models.SortOrder] = "DESC",
    target_table_id: Optional[str] = None,
    target_table_name: Optional[str] = None,
    type: Optional[List[Union[str, _models.JobTypeV2]]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/jobs"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if connection_name is not None:
        _params["connectionName"] = _SERIALIZER.query(
            "connection_name", connection_name, "[str]"
        )
    if execution_status is not None:
        _params["executionStatus"] = _SERIALIZER.query(
            "execution_status", execution_status, "[str]"
        )
    if health_status is not None:
        _params["healthStatus"] = _SERIALIZER.query(
            "health_status", health_status, "[str]"
        )
    if pagination_limit is not None:
        _params["paginationLimit"] = _SERIALIZER.query(
            "pagination_limit", pagination_limit, "int", maximum=1000, minimum=1
        )
    if pagination_offset is not None:
        _params["paginationOffset"] = _SERIALIZER.query(
            "pagination_offset", pagination_offset, "int", minimum=0
        )
    if search_string is not None:
        _params["searchString"] = _SERIALIZER.query(
            "search_string", search_string, "str"
        )
    if sort_column is not None:
        _params["sortColumn"] = _SERIALIZER.query("sort_column", sort_column, "str")
    if sort_order is not None:
        _params["sortOrder"] = _SERIALIZER.query("sort_order", sort_order, "str")
    if target_table_id is not None:
        _params["targetTableId"] = _SERIALIZER.query(
            "target_table_id", target_table_id, "str"
        )
    if target_table_name is not None:
        _params["targetTableName"] = _SERIALIZER.query(
            "target_table_name", target_table_name, "str", max_length=255, min_length=1
        )
    if type is not None:
        _params["type"] = _SERIALIZER.query("type", type, "[str]")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_jobs_create_job_request(project_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/jobs"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_jobs_describe_job_request(
    job_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/jobs/{jobId}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_jobs_update_job_request(
    job_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/jobs/{jobId}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_jobs_describe_job_overall_progress_request(  # pylint: disable=name-too-long
    job_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/jobs/{jobId}/progress"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_jobs_describe_job_logs_request(
    job_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/jobs/{jobId}/logs"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_jobs_describe_job_metrics_request(
    job_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/jobs/{jobId}/metrics"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_jobs_reset_job_request(
    job_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/jobs/{jobId}/reset"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_jobs_describe_job_status_request(
    job_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/jobs/{jobId}/status"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_jobs_update_job_status_request(
    job_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/jobs/{jobId}/status"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_query_query_sync_request(project_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/query/sql"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_query_query_async_request(project_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/query/sql/statements"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_query_query_async_results_request(
    query_id: str,
    project_id: str,
    *,
    page: Optional[int] = None,
    result_format: Union[str, _models.ResultFormat] = "object",
    filename: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/query/sql/statements/{queryId}/results"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "queryId": _SERIALIZER.url("query_id", query_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if page is not None:
        _params["page"] = _SERIALIZER.query("page", page, "int")
    if result_format is not None:
        _params["resultFormat"] = _SERIALIZER.query(
            "result_format", result_format, "str"
        )
    if filename is not None:
        _params["filename"] = _SERIALIZER.query("filename", filename, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_query_query_async_status_request(
    query_id: str, project_id: str, *, detail: bool = False, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/query/sql/statements/{queryId}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "queryId": _SERIALIZER.url("query_id", query_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if detail is not None:
        _params["detail"] = _SERIALIZER.query("detail", detail, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_query_query_async_cancel_request(
    query_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/query/sql/statements/{queryId}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "queryId": _SERIALIZER.url("query_id", query_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_reports_list_reports_request(project_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/reports"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_reports_create_report_request(project_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/reports"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_reports_get_report_request(
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/reports/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_reports_update_report_request(
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/reports/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_reports_patch_report_request(
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/reports/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_reports_delete_report_request(
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/reports/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_reports_list_report_evaluations_request(  # pylint: disable=name-too-long
    id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/reports/{id}/evaluations"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_reports_get_report_evaluation_request(  # pylint: disable=name-too-long
    id: str, evaluation_id: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/reports/{id}/evaluations/{evaluationId}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str", max_length=255, min_length=1),
        "evaluationId": _SERIALIZER.url(
            "evaluation_id", evaluation_id, "str", max_length=255, min_length=1
        ),
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_tables_list_tables_request(
    project_id: str,
    *,
    partitioning_granularity: Optional[Union[str, _models.Enum118]] = None,
    segment_count: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/tables"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if partitioning_granularity is not None:
        _params["partitioningGranularity"] = _SERIALIZER.query(
            "partitioning_granularity", partitioning_granularity, "str"
        )
    if segment_count is not None:
        _params["segmentCount"] = _SERIALIZER.query(
            "segment_count", segment_count, "int", minimum=0
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_tables_create_table_request(project_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/tables"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_tables_describe_table_request(
    table_name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/tables/{tableName}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "tableName": _SERIALIZER.url(
            "table_name", table_name, "str", max_length=255, min_length=1
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_tables_update_table_request(
    table_name: str, project_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/tables/{tableName}"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "tableName": _SERIALIZER.url(
            "table_name", table_name, "str", max_length=255, min_length=1
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_tables_get_unused_segments_for_table_request(  # pylint: disable=name-too-long
    table_name: str,
    project_id: str,
    *,
    interval: Optional[str] = None,
    limit: int = 100,
    last_segment_id: Optional[str] = None,
    sort_order: Union[str, _models.SortOrder] = "DESC",
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/v1/projects/{projectId}/tables/{tableName}/unusedSegments"
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, "str"),
        "tableName": _SERIALIZER.url(
            "table_name", table_name, "str", max_length=255, min_length=1
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if interval is not None:
        _params["interval"] = _SERIALIZER.query("interval", interval, "str")
    if limit is not None:
        _params["limit"] = _SERIALIZER.query("limit", limit, "int")
    if last_segment_id is not None:
        _params["lastSegmentId"] = _SERIALIZER.query(
            "last_segment_id", last_segment_id, "str"
        )
    if sort_order is not None:
        _params["sortOrder"] = _SERIALIZER.query("sort_order", sort_order, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


class AlertsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`alerts` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def list_alerts(
        self, **kwargs: Any
    ) -> Union[_models.AlertListResponse, _models.ErrorResponse]:
        """List all alerts.

        Returns all alerts.

        :return: AlertListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.AlertListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_alerts_list_alerts_request(
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "AlertListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_alert(
        self,
        body: _models.AlertBody,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.AlertResponse, _models.ErrorResponse]:
        """Create an alert.

        Creates an alert.

        :param body: Required.
        :type body: ~polaris.sdk.project_api.models.AlertBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AlertResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_alert(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.AlertResponse, _models.ErrorResponse]:
        """Create an alert.

        Creates an alert.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AlertResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_alert(
        self, body: Union[_models.AlertBody, IO[bytes]], **kwargs: Any
    ) -> Union[_models.AlertResponse, _models.ErrorResponse]:
        """Create an alert.

        Creates an alert.

        :param body: Is either a AlertBody type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.AlertBody or IO[bytes]
        :return: AlertResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.AlertResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "AlertBody")

        _request = build_alerts_create_alert_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "AlertResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_alert(
        self, id: str, **kwargs: Any
    ) -> Union[_models.AlertResponse, _models.ErrorResponse]:
        """Get alert details.

        Returns details of a specified alert.

        :param id: Alert ID. Required.
        :type id: str
        :return: AlertResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.AlertResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_alerts_get_alert_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "AlertResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_alert(
        self,
        id: str,
        body: _models.AlertBody,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.AlertResponse, _models.ErrorResponse]:
        """Update an alert.

        Updates the details of an alert with a specified ID. You must provide all properties you want
        to retain in the alert, even if you don't want to update them. Polaris recreates the alert with
        the details you specify in the request.

        :param id: Alert ID. Required.
        :type id: str
        :param body: Alert ID. Required.
        :type body: ~polaris.sdk.project_api.models.AlertBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AlertResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_alert(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.AlertResponse, _models.ErrorResponse]:
        """Update an alert.

        Updates the details of an alert with a specified ID. You must provide all properties you want
        to retain in the alert, even if you don't want to update them. Polaris recreates the alert with
        the details you specify in the request.

        :param id: Alert ID. Required.
        :type id: str
        :param body: Alert ID. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AlertResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_alert(
        self, id: str, body: Union[_models.AlertBody, IO[bytes]], **kwargs: Any
    ) -> Union[_models.AlertResponse, _models.ErrorResponse]:
        """Update an alert.

        Updates the details of an alert with a specified ID. You must provide all properties you want
        to retain in the alert, even if you don't want to update them. Polaris recreates the alert with
        the details you specify in the request.

        :param id: Alert ID. Required.
        :type id: str
        :param body: Alert ID. Is either a AlertBody type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.AlertBody or IO[bytes]
        :return: AlertResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.AlertResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "AlertBody")

        _request = build_alerts_update_alert_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "AlertResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def patch_alert(
        self,
        id: str,
        body: _models.AlertPayload,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.AlertResponse, _models.ErrorResponse]:
        """Update specified alert properties.

        Updates the specified properties of an alert. Any properties omitted from the request retain
        their previous values. Polaris creates a new alert if the supplied alert ID doesn't exist.

        :param id: Alert ID. Required.
        :type id: str
        :param body: Alert updates. Required.
        :type body: ~polaris.sdk.project_api.models.AlertPayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: AlertResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def patch_alert(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.AlertResponse, _models.ErrorResponse]:
        """Update specified alert properties.

        Updates the specified properties of an alert. Any properties omitted from the request retain
        their previous values. Polaris creates a new alert if the supplied alert ID doesn't exist.

        :param id: Alert ID. Required.
        :type id: str
        :param body: Alert updates. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: AlertResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def patch_alert(
        self, id: str, body: Union[_models.AlertPayload, IO[bytes]], **kwargs: Any
    ) -> Union[_models.AlertResponse, _models.ErrorResponse]:
        """Update specified alert properties.

        Updates the specified properties of an alert. Any properties omitted from the request retain
        their previous values. Polaris creates a new alert if the supplied alert ID doesn't exist.

        :param id: Alert ID. Required.
        :type id: str
        :param body: Alert updates. Is either a AlertPayload type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.AlertPayload or IO[bytes]
        :return: AlertResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.AlertResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "AlertPayload")

        _request = build_alerts_patch_alert_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "AlertResponse", pipeline_response.http_response
            )

        if response.status_code == 201:
            deserialized = self._deserialize(
                "AlertResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_alert(self, id: str, **kwargs: Any) -> Optional[_models.ErrorResponse]:
        """Delete an alert.

        Deletes an alert.

        :param id: Alert ID. Required.
        :type id: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_alerts_delete_alert_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        deserialized = self._deserialize(
            "ErrorResponse", pipeline_response.http_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_alert_evaluations(
        self, id: str, **kwargs: Any
    ) -> Union[_models.AlertEvaluationListResponse, _models.ErrorResponse]:
        """Get alert evaluations.

        Returns all evaluations for an alert.

        :param id: Alert ID. Required.
        :type id: str
        :return: AlertEvaluationListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertEvaluationListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[
            Union[_models.AlertEvaluationListResponse, _models.ErrorResponse]
        ] = kwargs.pop("cls", None)

        _request = build_alerts_list_alert_evaluations_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "AlertEvaluationListResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_alert_evaluation(
        self, id: str, evaluation_id: str, **kwargs: Any
    ) -> Union[_models.AlertEvaluationPayload, _models.ErrorResponse]:
        """Get alert evaluation details.

        Returns information for a single alert evaluation.

        :param id: Alert ID. Required.
        :type id: str
        :param evaluation_id: Evaluation ID. Required.
        :type evaluation_id: str
        :return: AlertEvaluationPayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.AlertEvaluationPayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.AlertEvaluationPayload, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_alerts_get_alert_evaluation_request(
            id=id,
            evaluation_id=evaluation_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "AlertEvaluationPayload", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class NetworkPolicyOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`network_policy` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def get_project_network_policy(
        self, **kwargs: Any
    ) -> Union[_models.NetworkPolicy, _models.ErrorResponse]:
        """Get the network policy.

        Returns the network policy for a specified project.

        :return: NetworkPolicy or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.NetworkPolicy or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.NetworkPolicy, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_network_policy_get_project_network_policy_request(
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "NetworkPolicy", pipeline_response.http_response
            )

        if response.status_code == 401:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_project_network_policy(
        self,
        body: _models.NetworkPolicy,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.NetworkPolicy, _models.ErrorResponse]:
        """Update the network policy.

        Updates the network policy for a specified project.

        :param body: Network policy configuration to apply to the project. Required.
        :type body: ~polaris.sdk.project_api.models.NetworkPolicy
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: NetworkPolicy or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.NetworkPolicy or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_project_network_policy(
        self,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.NetworkPolicy, _models.ErrorResponse]:
        """Update the network policy.

        Updates the network policy for a specified project.

        :param body: Network policy configuration to apply to the project. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: NetworkPolicy or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.NetworkPolicy or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_project_network_policy(
        self, body: Union[_models.NetworkPolicy, IO[bytes]], **kwargs: Any
    ) -> Union[_models.NetworkPolicy, _models.ErrorResponse]:
        """Update the network policy.

        Updates the network policy for a specified project.

        :param body: Network policy configuration to apply to the project. Is either a NetworkPolicy
         type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.NetworkPolicy or IO[bytes]
        :return: NetworkPolicy or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.NetworkPolicy or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.NetworkPolicy, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "NetworkPolicy")

        _request = build_network_policy_update_project_network_policy_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "NetworkPolicy", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 401:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class CollectionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`collections` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def list_collections(
        self, **kwargs: Any
    ) -> Union[_models.CollectionListResponse, _models.ErrorResponse]:
        """List all collections.

        Returns all collections in a specified project.

        :return: CollectionListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.CollectionListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.CollectionListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_collections_list_collections_request(
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "CollectionListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_collection(
        self,
        body: _models.CollectionCreatePayload,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Collection, _models.ErrorResponse]:
        """Create a collection.

        Creates a collection in a specified project.

        :param body: Required.
        :type body: ~polaris.sdk.project_api.models.CollectionCreatePayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Collection or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Collection or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_collection(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.Collection, _models.ErrorResponse]:
        """Create a collection.

        Creates a collection in a specified project.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Collection or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Collection or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_collection(
        self, body: Union[_models.CollectionCreatePayload, IO[bytes]], **kwargs: Any
    ) -> Union[_models.Collection, _models.ErrorResponse]:
        """Create a collection.

        Creates a collection in a specified project.

        :param body: Is either a CollectionCreatePayload type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.CollectionCreatePayload or IO[bytes]
        :return: Collection or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Collection or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.Collection, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "CollectionCreatePayload")

        _request = build_collections_create_collection_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 409]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            deserialized = self._deserialize(
                "Collection", pipeline_response.http_response
            )

        if response.status_code == 409:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def describe_collection(
        self, id: int, **kwargs: Any
    ) -> Union[_models.Collection, _models.ErrorResponse]:
        """Get a collection.

        Returns a single collection in a specified project.

        :param id: Collection ID. Required.
        :type id: int
        :return: Collection or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Collection or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.Collection, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_collections_describe_collection_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "Collection", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_collection(
        self,
        id: int,
        body: _models.CollectionUpdatePayload,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.Collection, _models.ErrorResponse]:
        """Update specified collection properties.

        Updates a collection name and/or description.

        :param id: Collection ID. Required.
        :type id: int
        :param body: The collection updates. Required.
        :type body: ~polaris.sdk.project_api.models.CollectionUpdatePayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Collection or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Collection or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_collection(
        self,
        id: int,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.Collection, _models.ErrorResponse]:
        """Update specified collection properties.

        Updates a collection name and/or description.

        :param id: Collection ID. Required.
        :type id: int
        :param body: The collection updates. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: Collection or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Collection or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_collection(
        self,
        id: int,
        body: Union[_models.CollectionUpdatePayload, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.Collection, _models.ErrorResponse]:
        """Update specified collection properties.

        Updates a collection name and/or description.

        :param id: Collection ID. Required.
        :type id: int
        :param body: The collection updates. Is either a CollectionUpdatePayload type or a IO[bytes]
         type. Required.
        :type body: ~polaris.sdk.project_api.models.CollectionUpdatePayload or IO[bytes]
        :return: Collection or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Collection or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.Collection, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "CollectionUpdatePayload")

        _request = build_collections_update_collection_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "Collection", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_collection(
        self, id: int, **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Delete a collection.

        Deletes a single collection in a specified project.

        :param id: Collection ID. Required.
        :type id: int
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_collections_delete_collection_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def add_assets_to_collection(
        self,
        id: int,
        body: _models.CollectionAssetsPayload,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Collection, _models.ErrorResponse]:
        """Add assets to a collection.

        Adds specified assets to a collection.

        :param id: Collection ID. Required.
        :type id: int
        :param body: Assets to add to the collection. Required.
        :type body: ~polaris.sdk.project_api.models.CollectionAssetsPayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Collection or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Collection or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_assets_to_collection(
        self,
        id: int,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Collection, _models.ErrorResponse]:
        """Add assets to a collection.

        Adds specified assets to a collection.

        :param id: Collection ID. Required.
        :type id: int
        :param body: Assets to add to the collection. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Collection or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Collection or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add_assets_to_collection(
        self,
        id: int,
        body: Union[_models.CollectionAssetsPayload, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.Collection, _models.ErrorResponse]:
        """Add assets to a collection.

        Adds specified assets to a collection.

        :param id: Collection ID. Required.
        :type id: int
        :param body: Assets to add to the collection. Is either a CollectionAssetsPayload type or a
         IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.CollectionAssetsPayload or IO[bytes]
        :return: Collection or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Collection or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.Collection, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "CollectionAssetsPayload")

        _request = build_collections_add_assets_to_collection_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 409]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            deserialized = self._deserialize(
                "Collection", pipeline_response.http_response
            )

        if response.status_code == 409:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def remove_asset_from_collection(
        self,
        id: int,
        asset_type: Union[str, _models.CollectionAssetType],
        asset_id: str,
        **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Remove an asset from a collection.

        Removes a specified asset from a collection.

        :param id: Collection ID. Required.
        :type id: int
        :param asset_type: Collection asset type. Known values are: "dataCube", "dashboard", "alert",
         "report", "embedding", "table", "connection", and "file". Required.
        :type asset_type: str or ~polaris.sdk.project_api.models.CollectionAssetType
        :param asset_id: Collection asset ID. Required.
        :type asset_id: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_collections_remove_asset_from_collection_request(
            id=id,
            asset_type=asset_type,
            asset_id=asset_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def describe_favorites(
        self, **kwargs: Any
    ) -> Union[_models.Favorites, _models.ErrorResponse]:
        """List favorites.

        Returns all favorites for the authenticated user.

        :return: Favorites or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Favorites or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.Favorites, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_collections_describe_favorites_request(
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "Favorites", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def add_assets_to_favorites(
        self,
        body: _models.CollectionAssetsPayload,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Favorites, _models.ErrorResponse]:
        """Add assets to favorites.

        Adds specified assets to the authenticated user's favorites.

        :param body: Assets to add to favorites. Required.
        :type body: ~polaris.sdk.project_api.models.CollectionAssetsPayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Favorites or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Favorites or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add_assets_to_favorites(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.Favorites, _models.ErrorResponse]:
        """Add assets to favorites.

        Adds specified assets to the authenticated user's favorites.

        :param body: Assets to add to favorites. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Favorites or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Favorites or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add_assets_to_favorites(
        self, body: Union[_models.CollectionAssetsPayload, IO[bytes]], **kwargs: Any
    ) -> Union[_models.Favorites, _models.ErrorResponse]:
        """Add assets to favorites.

        Adds specified assets to the authenticated user's favorites.

        :param body: Assets to add to favorites. Is either a CollectionAssetsPayload type or a
         IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.CollectionAssetsPayload or IO[bytes]
        :return: Favorites or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.Favorites or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.Favorites, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "CollectionAssetsPayload")

        _request = build_collections_add_assets_to_favorites_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 409]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            deserialized = self._deserialize(
                "Favorites", pipeline_response.http_response
            )

        if response.status_code == 409:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def remove_asset_from_favorites(
        self,
        asset_id: str,
        asset_type: Union[str, _models.CollectionAssetType],
        **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Remove an asset from favorites.

        Removes a specified asset from the authenticated user's favorites.

        :param asset_id: Collection asset ID. Required.
        :type asset_id: str
        :param asset_type: Collection asset type. Known values are: "dataCube", "dashboard", "alert",
         "report", "embedding", "table", "connection", and "file". Required.
        :type asset_type: str or ~polaris.sdk.project_api.models.CollectionAssetType
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_collections_remove_asset_from_favorites_request(
            asset_id=asset_id,
            asset_type=asset_type,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ConnectionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`connections` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def list_connections(
        self, **kwargs: Any
    ) -> Union[_models.ConnectionListResponse, _models.ErrorResponse]:
        """List all connections.

        Returns all existing connections.

        :return: ConnectionListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ConnectionListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.ConnectionListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_connections_list_connections_request(
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "ConnectionListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_connection(
        self,
        body: _models.CreateConnectionRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.ConnectionResponse, _models.ErrorResponse]:
        """Create a connection.

        Creates a new connection.

        :param body: A connection to be created. Required.
        :type body: ~polaris.sdk.project_api.models.CreateConnectionRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ConnectionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_connection(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.ConnectionResponse, _models.ErrorResponse]:
        """Create a connection.

        Creates a new connection.

        :param body: A connection to be created. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ConnectionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_connection(
        self, body: Union[_models.CreateConnectionRequest, IO[bytes]], **kwargs: Any
    ) -> Union[_models.ConnectionResponse, _models.ErrorResponse]:
        """Create a connection.

        Creates a new connection.

        :param body: A connection to be created. Is either a CreateConnectionRequest type or a
         IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.CreateConnectionRequest or IO[bytes]
        :return: ConnectionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ConnectionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.ConnectionResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "CreateConnectionRequest")

        _request = build_connections_create_connection_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 409, 415]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "ConnectionResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 409:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 415:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_connection(
        self, name: str, **kwargs: Any
    ) -> Union[_models.ConnectionResponse, _models.ErrorResponse]:
        """Get connection details.

        Returns information for a single connection.

        :param name: The name of the connection to get. Required.
        :type name: str
        :return: ConnectionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ConnectionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.ConnectionResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_connections_get_connection_request(
            name=name,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "ConnectionResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_connection(
        self,
        name: str,
        body: _models.UpdateConnectionRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.ConnectionResponse, _models.ErrorResponse]:
        """Update a connection.

        Updates details for a specific connection.

        :param name: The name of the connection to update. Required.
        :type name: str
        :param body: The updated connection spec. Required.
        :type body: ~polaris.sdk.project_api.models.UpdateConnectionRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ConnectionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_connection(
        self,
        name: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.ConnectionResponse, _models.ErrorResponse]:
        """Update a connection.

        Updates details for a specific connection.

        :param name: The name of the connection to update. Required.
        :type name: str
        :param body: The updated connection spec. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ConnectionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ConnectionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_connection(
        self,
        name: str,
        body: Union[_models.UpdateConnectionRequest, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.ConnectionResponse, _models.ErrorResponse]:
        """Update a connection.

        Updates details for a specific connection.

        :param name: The name of the connection to update. Required.
        :type name: str
        :param body: The updated connection spec. Is either a UpdateConnectionRequest type or a
         IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.UpdateConnectionRequest or IO[bytes]
        :return: ConnectionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ConnectionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.ConnectionResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "UpdateConnectionRequest")

        _request = build_connections_update_connection_request(
            name=name,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 415]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "ConnectionResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 415:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_connection(
        self, name: str, **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Delete a connection.

        Deletes an existing connection.

        :param name: The name the connection to delete. Required.
        :type name: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_connections_delete_connection_request(
            name=name,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        deserialized = self._deserialize(
            "ErrorResponse", pipeline_response.http_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def test_connection(
        self, name: str, **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Test a connection.

        Checks whether an existing connection is valid.

        :param name: The name of the connection to test. Required.
        :type name: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_connections_test_connection_request(
            name=name,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 415]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        deserialized = self._deserialize(
            "ErrorResponse", pipeline_response.http_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def describe_connections_meta(
        self, **kwargs: Any
    ) -> Union[_models.ConnectionsMetaResponse, _models.ErrorResponse]:
        """Get meta information from connection.

        Returns meta information related to connections.

        :return: ConnectionsMetaResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ConnectionsMetaResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.ConnectionsMetaResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_connections_describe_connections_meta_request(
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "ConnectionsMetaResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class DashboardsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`dashboards` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def list_dashboard_summaries(
        self, **kwargs: Any
    ) -> Union[_models.DashboardListResponse, _models.ErrorResponse]:
        """List all dashboards.

        Returns all dashboards.

        :return: DashboardListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DashboardListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.DashboardListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_dashboards_list_dashboard_summaries_request(
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "DashboardListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_dashboard(
        self,
        body: _models.DashboardBody,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.DashboardResponse, _models.ErrorResponse]:
        """Create a dashboard.

        Creates a dashboard.

        :param body: Required.
        :type body: ~polaris.sdk.project_api.models.DashboardBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DashboardResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DashboardResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_dashboard(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.DashboardResponse, _models.ErrorResponse]:
        """Create a dashboard.

        Creates a dashboard.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DashboardResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DashboardResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_dashboard(
        self, body: Union[_models.DashboardBody, IO[bytes]], **kwargs: Any
    ) -> Union[_models.DashboardResponse, _models.ErrorResponse]:
        """Create a dashboard.

        Creates a dashboard.

        :param body: Is either a DashboardBody type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.DashboardBody or IO[bytes]
        :return: DashboardResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DashboardResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.DashboardResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DashboardBody")

        _request = build_dashboards_create_dashboard_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "DashboardResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_dashboard(
        self, id: str, **kwargs: Any
    ) -> Union[_models.DashboardResponse, _models.ErrorResponse]:
        """Get dashboard details.

        Returns details of a specified dashboard.

        :param id: Dashboard ID. Required.
        :type id: str
        :return: DashboardResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DashboardResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.DashboardResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_dashboards_get_dashboard_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "DashboardResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_dashboard(
        self,
        id: str,
        body: _models.DashboardBody,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.DashboardResponse, _models.ErrorResponse]:
        """Update a dashboard.

        Updates the details of a dashboard with a specified ID. You must provide all properties you
        want to retain in the dashboard, even if you don't want to update them. Polaris recreates the
        dashboard with the details you specify in the request.

        :param id: Dashboard ID. Required.
        :type id: str
        :param body: Dashboard to update. Required.
        :type body: ~polaris.sdk.project_api.models.DashboardBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DashboardResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DashboardResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_dashboard(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.DashboardResponse, _models.ErrorResponse]:
        """Update a dashboard.

        Updates the details of a dashboard with a specified ID. You must provide all properties you
        want to retain in the dashboard, even if you don't want to update them. Polaris recreates the
        dashboard with the details you specify in the request.

        :param id: Dashboard ID. Required.
        :type id: str
        :param body: Dashboard to update. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DashboardResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DashboardResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_dashboard(
        self, id: str, body: Union[_models.DashboardBody, IO[bytes]], **kwargs: Any
    ) -> Union[_models.DashboardResponse, _models.ErrorResponse]:
        """Update a dashboard.

        Updates the details of a dashboard with a specified ID. You must provide all properties you
        want to retain in the dashboard, even if you don't want to update them. Polaris recreates the
        dashboard with the details you specify in the request.

        :param id: Dashboard ID. Required.
        :type id: str
        :param body: Dashboard to update. Is either a DashboardBody type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.DashboardBody or IO[bytes]
        :return: DashboardResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DashboardResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.DashboardResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DashboardBody")

        _request = build_dashboards_update_dashboard_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "DashboardResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def patch_dashboard(
        self,
        id: str,
        body: _models.DashboardPayload,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.DashboardResponse, _models.ErrorResponse]:
        """Update specified dashboard properties.

        Updates the specified properties of a dashboard. Any properties omitted from the request retain
        their previous values. Polaris creates a new dashboard if the supplied dashboard ID doesn't
        exist.

        :param id: Dashboard ID. Required.
        :type id: str
        :param body: Dashboard updates. Required.
        :type body: ~polaris.sdk.project_api.models.DashboardPayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: DashboardResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DashboardResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def patch_dashboard(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.DashboardResponse, _models.ErrorResponse]:
        """Update specified dashboard properties.

        Updates the specified properties of a dashboard. Any properties omitted from the request retain
        their previous values. Polaris creates a new dashboard if the supplied dashboard ID doesn't
        exist.

        :param id: Dashboard ID. Required.
        :type id: str
        :param body: Dashboard updates. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: DashboardResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DashboardResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def patch_dashboard(
        self, id: str, body: Union[_models.DashboardPayload, IO[bytes]], **kwargs: Any
    ) -> Union[_models.DashboardResponse, _models.ErrorResponse]:
        """Update specified dashboard properties.

        Updates the specified properties of a dashboard. Any properties omitted from the request retain
        their previous values. Polaris creates a new dashboard if the supplied dashboard ID doesn't
        exist.

        :param id: Dashboard ID. Required.
        :type id: str
        :param body: Dashboard updates. Is either a DashboardPayload type or a IO[bytes] type.
         Required.
        :type body: ~polaris.sdk.project_api.models.DashboardPayload or IO[bytes]
        :return: DashboardResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DashboardResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.DashboardResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DashboardPayload")

        _request = build_dashboards_patch_dashboard_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize(
                "DashboardResponse", pipeline_response.http_response
            )

        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "DashboardResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_dashboard(
        self, id: str, **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Delete a dashboard.

        Deletes a dashboard.

        :param id: Dashboard ID. Required.
        :type id: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_dashboards_delete_dashboard_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        deserialized = self._deserialize(
            "ErrorResponse", pipeline_response.http_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_dashboard_data_cubes(
        self, id: str, **kwargs: Any
    ) -> Union[_models.DashboardDataCubeListResponse, _models.ErrorResponse]:
        """Get dashboard data cubes.

        Returns the data cubes associated with a dashboard via its tiles.

        :param id: Dashboard ID. Required.
        :type id: str
        :return: DashboardDataCubeListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DashboardDataCubeListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[
            Union[_models.DashboardDataCubeListResponse, _models.ErrorResponse]
        ] = kwargs.pop("cls", None)

        _request = build_dashboards_list_dashboard_data_cubes_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "DashboardDataCubeListResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_dashboard_pages(
        self, id: str, **kwargs: Any
    ) -> Union[_models.PageListResponse, _models.ErrorResponse]:
        """Get dashboard pages.

        Returns all pages for a dashboard.

        :param id: Dashboard ID. Required.
        :type id: str
        :return: PageListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.PageListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.PageListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_dashboards_list_dashboard_pages_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "PageListResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_dashboard_page(
        self,
        id: str,
        body: _models.PagePayload,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.PagePayload, _models.ErrorResponse]:
        """Create a dashboard page.

        Creates a dashboard page.

        :param id: Dashboard ID. Required.
        :type id: str
        :param body: Required.
        :type body: ~polaris.sdk.project_api.models.PagePayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PagePayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.PagePayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_dashboard_page(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.PagePayload, _models.ErrorResponse]:
        """Create a dashboard page.

        Creates a dashboard page.

        :param id: Dashboard ID. Required.
        :type id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PagePayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.PagePayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_dashboard_page(
        self, id: str, body: Union[_models.PagePayload, IO[bytes]], **kwargs: Any
    ) -> Union[_models.PagePayload, _models.ErrorResponse]:
        """Create a dashboard page.

        Creates a dashboard page.

        :param id: Dashboard ID. Required.
        :type id: str
        :param body: Is either a PagePayload type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.PagePayload or IO[bytes]
        :return: PagePayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.PagePayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.PagePayload, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "PagePayload")

        _request = build_dashboards_create_dashboard_page_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "PagePayload", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_dashboard_page(
        self, id: str, page_id: str, **kwargs: Any
    ) -> Union[_models.PagePayload, _models.ErrorResponse]:
        """Get page details.

        Returns information for a single dashboard page.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :return: PagePayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.PagePayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.PagePayload, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_dashboards_get_dashboard_page_request(
            id=id,
            page_id=page_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "PagePayload", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_dashboard_page(
        self,
        id: str,
        page_id: str,
        body: _models.PagePayload,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.PageResponse, _models.ErrorResponse]:
        """Update a page.

        Updates the details of a dashboard page with a specified ID. You must provide all properties
        you want to retain in the page even if you don't want to update them. Polaris recreates the
        page with the details you specify in the request.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param body: Page to update. Required.
        :type body: ~polaris.sdk.project_api.models.PagePayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PageResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.PageResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_dashboard_page(
        self,
        id: str,
        page_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.PageResponse, _models.ErrorResponse]:
        """Update a page.

        Updates the details of a dashboard page with a specified ID. You must provide all properties
        you want to retain in the page even if you don't want to update them. Polaris recreates the
        page with the details you specify in the request.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param body: Page to update. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PageResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.PageResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_dashboard_page(
        self,
        id: str,
        page_id: str,
        body: Union[_models.PagePayload, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.PageResponse, _models.ErrorResponse]:
        """Update a page.

        Updates the details of a dashboard page with a specified ID. You must provide all properties
        you want to retain in the page even if you don't want to update them. Polaris recreates the
        page with the details you specify in the request.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param body: Page to update. Is either a PagePayload type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.PagePayload or IO[bytes]
        :return: PageResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.PageResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.PageResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "PagePayload")

        _request = build_dashboards_update_dashboard_page_request(
            id=id,
            page_id=page_id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "PageResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def patch_dashboard_page(
        self,
        id: str,
        page_id: str,
        body: _models.PagePayload,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.PageResponse, _models.ErrorResponse]:
        """Update specified page properties.

        Updates the specified properties of a page. Polaris creates a new page if the supplied page ID
        doesn't exist.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param body: Page updates. Required.
        :type body: ~polaris.sdk.project_api.models.PagePayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PageResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.PageResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def patch_dashboard_page(
        self,
        id: str,
        page_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.PageResponse, _models.ErrorResponse]:
        """Update specified page properties.

        Updates the specified properties of a page. Polaris creates a new page if the supplied page ID
        doesn't exist.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param body: Page updates. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: PageResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.PageResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def patch_dashboard_page(
        self,
        id: str,
        page_id: str,
        body: Union[_models.PagePayload, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.PageResponse, _models.ErrorResponse]:
        """Update specified page properties.

        Updates the specified properties of a page. Polaris creates a new page if the supplied page ID
        doesn't exist.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param body: Page updates. Is either a PagePayload type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.PagePayload or IO[bytes]
        :return: PageResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.PageResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.PageResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "PagePayload")

        _request = build_dashboards_patch_dashboard_page_request(
            id=id,
            page_id=page_id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize(
                "PageResponse", pipeline_response.http_response
            )

        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "PageResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_dashboard_page(
        self, id: str, page_id: str, **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Delete a page.

        Deletes a page.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_dashboards_delete_dashboard_page_request(
            id=id,
            page_id=page_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        deserialized = self._deserialize(
            "ErrorResponse", pipeline_response.http_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_dashboard_page_tiles(
        self, id: str, page_id: str, **kwargs: Any
    ) -> Union[_models.TileListResponse, _models.ErrorResponse]:
        """Get dashboard page tiles.

        Returns all tiles for a dashboard page.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :return: TileListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TileListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.TileListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_dashboards_list_dashboard_page_tiles_request(
            id=id,
            page_id=page_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "TileListResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_dashboard_page_tile(
        self,
        id: str,
        page_id: str,
        body: _models.TileBody,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.TileResponse, _models.ErrorResponse]:
        """Create a dashboard page tile.

        Creates a new tile for a dashboard page.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param body: Required.
        :type body: ~polaris.sdk.project_api.models.TileBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TileResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TileResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_dashboard_page_tile(
        self,
        id: str,
        page_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.TileResponse, _models.ErrorResponse]:
        """Create a dashboard page tile.

        Creates a new tile for a dashboard page.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TileResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TileResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_dashboard_page_tile(
        self,
        id: str,
        page_id: str,
        body: Union[_models.TileBody, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.TileResponse, _models.ErrorResponse]:
        """Create a dashboard page tile.

        Creates a new tile for a dashboard page.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param body: Is either a TileBody type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.TileBody or IO[bytes]
        :return: TileResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TileResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.TileResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "TileBody")

        _request = build_dashboards_create_dashboard_page_tile_request(
            id=id,
            page_id=page_id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "TileResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_dashboard_page_tile(
        self, id: str, page_id: str, tile_id: str, **kwargs: Any
    ) -> Union[_models.TileResponse, _models.ErrorResponse]:
        """Get tile details.

        Returns the definition for a single dashboard tile.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param tile_id: Tile ID. Required.
        :type tile_id: str
        :return: TileResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TileResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.TileResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_dashboards_get_dashboard_page_tile_request(
            id=id,
            page_id=page_id,
            tile_id=tile_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "TileResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_dashboard_page_tile(
        self,
        id: str,
        page_id: str,
        tile_id: str,
        body: _models.TileBody,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.TileResponse, _models.ErrorResponse]:
        """Update a tile.

        Updates the details of a dashboard page tile with a specified ID. You must provide all
        properties you want to retain in the tile even if you don't want to update them. Polaris
        recreates the tile with the details you specify in the request.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param tile_id: Tile ID. Required.
        :type tile_id: str
        :param body: The tile to update. Required.
        :type body: ~polaris.sdk.project_api.models.TileBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TileResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TileResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_dashboard_page_tile(
        self,
        id: str,
        page_id: str,
        tile_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.TileResponse, _models.ErrorResponse]:
        """Update a tile.

        Updates the details of a dashboard page tile with a specified ID. You must provide all
        properties you want to retain in the tile even if you don't want to update them. Polaris
        recreates the tile with the details you specify in the request.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param tile_id: Tile ID. Required.
        :type tile_id: str
        :param body: The tile to update. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TileResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TileResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_dashboard_page_tile(
        self,
        id: str,
        page_id: str,
        tile_id: str,
        body: Union[_models.TileBody, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.TileResponse, _models.ErrorResponse]:
        """Update a tile.

        Updates the details of a dashboard page tile with a specified ID. You must provide all
        properties you want to retain in the tile even if you don't want to update them. Polaris
        recreates the tile with the details you specify in the request.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param tile_id: Tile ID. Required.
        :type tile_id: str
        :param body: The tile to update. Is either a TileBody type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.TileBody or IO[bytes]
        :return: TileResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TileResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.TileResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "TileBody")

        _request = build_dashboards_update_dashboard_page_tile_request(
            id=id,
            page_id=page_id,
            tile_id=tile_id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "TileResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def patch_dashboard_page_tile(
        self,
        id: str,
        page_id: str,
        tile_id: str,
        body: _models.TilePayload,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.TileResponse, _models.ErrorResponse]:
        """Update specified tile properties.

        Updates the specified properties of a dashboard page tile. Polaris creates a new tile if the
        supplied tile ID doesn't exist.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param tile_id: Tile ID. Required.
        :type tile_id: str
        :param body: Tile updates. Required.
        :type body: ~polaris.sdk.project_api.models.TilePayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: TileResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TileResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def patch_dashboard_page_tile(
        self,
        id: str,
        page_id: str,
        tile_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.TileResponse, _models.ErrorResponse]:
        """Update specified tile properties.

        Updates the specified properties of a dashboard page tile. Polaris creates a new tile if the
        supplied tile ID doesn't exist.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param tile_id: Tile ID. Required.
        :type tile_id: str
        :param body: Tile updates. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: TileResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TileResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def patch_dashboard_page_tile(
        self,
        id: str,
        page_id: str,
        tile_id: str,
        body: Union[_models.TilePayload, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.TileResponse, _models.ErrorResponse]:
        """Update specified tile properties.

        Updates the specified properties of a dashboard page tile. Polaris creates a new tile if the
        supplied tile ID doesn't exist.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param tile_id: Tile ID. Required.
        :type tile_id: str
        :param body: Tile updates. Is either a TilePayload type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.TilePayload or IO[bytes]
        :return: TileResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TileResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.TileResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "TilePayload")

        _request = build_dashboards_patch_dashboard_page_tile_request(
            id=id,
            page_id=page_id,
            tile_id=tile_id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize(
                "TileResponse", pipeline_response.http_response
            )

        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "TileResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_dashboard_page_tile(
        self, id: str, page_id: str, tile_id: str, **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Delete a tile.

        Deletes a dashboard page tile.

        :param id: Dashboard ID. Required.
        :type id: str
        :param page_id: Page ID. Required.
        :type page_id: str
        :param tile_id: Tile ID. Required.
        :type tile_id: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_dashboards_delete_dashboard_page_tile_request(
            id=id,
            page_id=page_id,
            tile_id=tile_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        deserialized = self._deserialize(
            "ErrorResponse", pipeline_response.http_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class DataCubesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`data_cubes` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def list_data_cube_summaries(
        self, **kwargs: Any
    ) -> Union[_models.DataCubeListResponse, _models.ErrorResponse]:
        """List all data cubes.

        Returns all data cubes.

        :return: DataCubeListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DataCubeListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.DataCubeListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_data_cubes_list_data_cube_summaries_request(
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "DataCubeListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_data_cube(
        self,
        body: _models.DataCubeBody,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.DatCubeResponse, _models.ErrorResponse]:
        """Create a data cube.

        Creates a data cube.

        :param body: Required.
        :type body: ~polaris.sdk.project_api.models.DataCubeBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatCubeResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DatCubeResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_data_cube(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.DatCubeResponse, _models.ErrorResponse]:
        """Create a data cube.

        Creates a data cube.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DatCubeResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DatCubeResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_data_cube(
        self, body: Union[_models.DataCubeBody, IO[bytes]], **kwargs: Any
    ) -> Union[_models.DatCubeResponse, _models.ErrorResponse]:
        """Create a data cube.

        Creates a data cube.

        :param body: Is either a DataCubeBody type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.DataCubeBody or IO[bytes]
        :return: DatCubeResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DatCubeResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.DatCubeResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DataCubeBody")

        _request = build_data_cubes_create_data_cube_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "DatCubeResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_data_cube(
        self, id: str, **kwargs: Any
    ) -> Union[_models.DataCubeResponse, _models.ErrorResponse]:
        """Get data cube details.

        Returns details of a specified data cube.

        :param id: Data cube identifier. Required.
        :type id: str
        :return: DataCubeResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DataCubeResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.DataCubeResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_data_cubes_get_data_cube_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "DataCubeResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_data_cube(
        self,
        id: str,
        body: _models.DataCubeBody,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.DataCubeResponse, _models.ErrorResponse]:
        """Update a data cube.

        Updates the details of a data cube with a specified ID. You must provide all properties you
        want to retain in the data cube, even if you don't want to update them. Polaris recreates the
        data cube with the details you specify in the request.

        :param id: Data cube identifier. Required.
        :type id: str
        :param body: The data cube to be updated. Required.
        :type body: ~polaris.sdk.project_api.models.DataCubeBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DataCubeResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DataCubeResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_data_cube(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.DataCubeResponse, _models.ErrorResponse]:
        """Update a data cube.

        Updates the details of a data cube with a specified ID. You must provide all properties you
        want to retain in the data cube, even if you don't want to update them. Polaris recreates the
        data cube with the details you specify in the request.

        :param id: Data cube identifier. Required.
        :type id: str
        :param body: The data cube to be updated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DataCubeResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DataCubeResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_data_cube(
        self, id: str, body: Union[_models.DataCubeBody, IO[bytes]], **kwargs: Any
    ) -> Union[_models.DataCubeResponse, _models.ErrorResponse]:
        """Update a data cube.

        Updates the details of a data cube with a specified ID. You must provide all properties you
        want to retain in the data cube, even if you don't want to update them. Polaris recreates the
        data cube with the details you specify in the request.

        :param id: Data cube identifier. Required.
        :type id: str
        :param body: The data cube to be updated. Is either a DataCubeBody type or a IO[bytes] type.
         Required.
        :type body: ~polaris.sdk.project_api.models.DataCubeBody or IO[bytes]
        :return: DataCubeResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DataCubeResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.DataCubeResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DataCubeBody")

        _request = build_data_cubes_update_data_cube_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "DataCubeResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def patch_data_cube(
        self,
        id: str,
        body: _models.DataCubePayload,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.DataCubeResponse, _models.ErrorResponse]:
        """Update specified data cube properties.

        Updates the specified properties of a data cube. Any properties omitted from the request retain
        their previous values. Polaris creates a new data cube if the supplied data cube ID doesn't
        exist.

        :param id: Data cube identifier. Required.
        :type id: str
        :param body: Data cube updates. Required.
        :type body: ~polaris.sdk.project_api.models.DataCubePayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: DataCubeResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DataCubeResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def patch_data_cube(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.DataCubeResponse, _models.ErrorResponse]:
        """Update specified data cube properties.

        Updates the specified properties of a data cube. Any properties omitted from the request retain
        their previous values. Polaris creates a new data cube if the supplied data cube ID doesn't
        exist.

        :param id: Data cube identifier. Required.
        :type id: str
        :param body: Data cube updates. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: DataCubeResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DataCubeResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def patch_data_cube(
        self, id: str, body: Union[_models.DataCubePayload, IO[bytes]], **kwargs: Any
    ) -> Union[_models.DataCubeResponse, _models.ErrorResponse]:
        """Update specified data cube properties.

        Updates the specified properties of a data cube. Any properties omitted from the request retain
        their previous values. Polaris creates a new data cube if the supplied data cube ID doesn't
        exist.

        :param id: Data cube identifier. Required.
        :type id: str
        :param body: Data cube updates. Is either a DataCubePayload type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.DataCubePayload or IO[bytes]
        :return: DataCubeResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DataCubeResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.DataCubeResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DataCubePayload")

        _request = build_data_cubes_patch_data_cube_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize(
                "DataCubeResponse", pipeline_response.http_response
            )

        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "DataCubeResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_data_cube(
        self, id: str, **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Delete a data cube.

        Deletes a data cube.

        :param id: Data cube identifier. Required.
        :type id: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_data_cubes_delete_data_cube_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        deserialized = self._deserialize(
            "ErrorResponse", pipeline_response.http_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_data_cube_dimensions(
        self, id: str, **kwargs: Any
    ) -> Union[_models.DimensionListResponse, _models.ErrorResponse]:
        """Get data cube dimensions.

        Returns all dimensions for a data cube.

        :param id: Data cube identifier. Required.
        :type id: str
        :return: DimensionListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DimensionListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.DimensionListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_data_cubes_list_data_cube_dimensions_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "DimensionListResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_data_cube_dimension(
        self,
        id: str,
        body: _models.DimensionPayload,
        *,
        order: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.DimensionResponse, _models.ErrorResponse]:
        """Create a data cube dimension.

        Creates a dimension for a data cube.

        :param id: Data cube identifier. Required.
        :type id: str
        :param body: Required.
        :type body: ~polaris.sdk.project_api.models.DimensionPayload
        :keyword order: Array order of the new dimension. Default value is None.
        :paramtype order: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DimensionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DimensionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_data_cube_dimension(
        self,
        id: str,
        body: IO[bytes],
        *,
        order: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.DimensionResponse, _models.ErrorResponse]:
        """Create a data cube dimension.

        Creates a dimension for a data cube.

        :param id: Data cube identifier. Required.
        :type id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword order: Array order of the new dimension. Default value is None.
        :paramtype order: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DimensionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DimensionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_data_cube_dimension(
        self,
        id: str,
        body: Union[_models.DimensionPayload, IO[bytes]],
        *,
        order: Optional[int] = None,
        **kwargs: Any
    ) -> Union[_models.DimensionResponse, _models.ErrorResponse]:
        """Create a data cube dimension.

        Creates a dimension for a data cube.

        :param id: Data cube identifier. Required.
        :type id: str
        :param body: Is either a DimensionPayload type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.DimensionPayload or IO[bytes]
        :keyword order: Array order of the new dimension. Default value is None.
        :paramtype order: int
        :return: DimensionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DimensionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.DimensionResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DimensionPayload")

        _request = build_data_cubes_create_data_cube_dimension_request(
            id=id,
            project_id=self._config.project_id,
            order=order,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "DimensionResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_data_cube_dimension(
        self, id: str, dimension_id: str, **kwargs: Any
    ) -> Union[_models.DimensionResponse, _models.ErrorResponse]:
        """Get dimension details.

        Returns information for a single data cube dimension.

        :param id: Data cube identifier. Required.
        :type id: str
        :param dimension_id: Dimension identifier. Required.
        :type dimension_id: str
        :return: DimensionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DimensionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.DimensionResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_data_cubes_get_data_cube_dimension_request(
            id=id,
            dimension_id=dimension_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "DimensionResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_data_cube_dimension(
        self,
        id: str,
        dimension_id: str,
        body: _models.DimensionPayload,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.DimensionResponse, _models.ErrorResponse]:
        """Update a dimension.

        Updates the details of a dimension with a specified ID. You must provide all properties you
        want to retain in the dimension even if you don't want to update them. Polaris recreates the
        dimension with the details you specify in the request.

        :param id: Data cube identifier. Required.
        :type id: str
        :param dimension_id: Dimension identifier. Required.
        :type dimension_id: str
        :param body: The dimension to be updated. Required.
        :type body: ~polaris.sdk.project_api.models.DimensionPayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DimensionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DimensionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_data_cube_dimension(
        self,
        id: str,
        dimension_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.DimensionResponse, _models.ErrorResponse]:
        """Update a dimension.

        Updates the details of a dimension with a specified ID. You must provide all properties you
        want to retain in the dimension even if you don't want to update them. Polaris recreates the
        dimension with the details you specify in the request.

        :param id: Data cube identifier. Required.
        :type id: str
        :param dimension_id: Dimension identifier. Required.
        :type dimension_id: str
        :param body: The dimension to be updated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DimensionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DimensionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_data_cube_dimension(
        self,
        id: str,
        dimension_id: str,
        body: Union[_models.DimensionPayload, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.DimensionResponse, _models.ErrorResponse]:
        """Update a dimension.

        Updates the details of a dimension with a specified ID. You must provide all properties you
        want to retain in the dimension even if you don't want to update them. Polaris recreates the
        dimension with the details you specify in the request.

        :param id: Data cube identifier. Required.
        :type id: str
        :param dimension_id: Dimension identifier. Required.
        :type dimension_id: str
        :param body: The dimension to be updated. Is either a DimensionPayload type or a IO[bytes]
         type. Required.
        :type body: ~polaris.sdk.project_api.models.DimensionPayload or IO[bytes]
        :return: DimensionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DimensionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.DimensionResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DimensionPayload")

        _request = build_data_cubes_update_data_cube_dimension_request(
            id=id,
            dimension_id=dimension_id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "DimensionResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def patch_data_cube_dimension(
        self,
        id: str,
        dimension_id: str,
        body: _models.DimensionPayload,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.DimensionResponse, _models.ErrorResponse]:
        """Update specified dimension properties.

        Updates the specified properties of a dimension. Any properties omitted from the request retain
        their previous values. Polaris creates a new dimension if the supplied dimension ID doesn't
        exist.

        :param id: Data cube identifier. Required.
        :type id: str
        :param dimension_id: Dimension identifier. Required.
        :type dimension_id: str
        :param body: Dimension updates. Required.
        :type body: ~polaris.sdk.project_api.models.DimensionPayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: DimensionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DimensionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def patch_data_cube_dimension(
        self,
        id: str,
        dimension_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.DimensionResponse, _models.ErrorResponse]:
        """Update specified dimension properties.

        Updates the specified properties of a dimension. Any properties omitted from the request retain
        their previous values. Polaris creates a new dimension if the supplied dimension ID doesn't
        exist.

        :param id: Data cube identifier. Required.
        :type id: str
        :param dimension_id: Dimension identifier. Required.
        :type dimension_id: str
        :param body: Dimension updates. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: DimensionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DimensionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def patch_data_cube_dimension(
        self,
        id: str,
        dimension_id: str,
        body: Union[_models.DimensionPayload, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.DimensionResponse, _models.ErrorResponse]:
        """Update specified dimension properties.

        Updates the specified properties of a dimension. Any properties omitted from the request retain
        their previous values. Polaris creates a new dimension if the supplied dimension ID doesn't
        exist.

        :param id: Data cube identifier. Required.
        :type id: str
        :param dimension_id: Dimension identifier. Required.
        :type dimension_id: str
        :param body: Dimension updates. Is either a DimensionPayload type or a IO[bytes] type.
         Required.
        :type body: ~polaris.sdk.project_api.models.DimensionPayload or IO[bytes]
        :return: DimensionResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.DimensionResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.DimensionResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DimensionPayload")

        _request = build_data_cubes_patch_data_cube_dimension_request(
            id=id,
            dimension_id=dimension_id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize(
                "DimensionResponse", pipeline_response.http_response
            )

        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "DimensionResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_data_cube_dimension(
        self, id: str, dimension_id: str, **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Delete a dimension.

        Deletes a dimension.

        :param id: Data cube identifier. Required.
        :type id: str
        :param dimension_id: Dimension identifier. Required.
        :type dimension_id: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_data_cubes_delete_data_cube_dimension_request(
            id=id,
            dimension_id=dimension_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        deserialized = self._deserialize(
            "ErrorResponse", pipeline_response.http_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_data_cube_measures(
        self, id: str, **kwargs: Any
    ) -> Union[_models.MeasureListResponse, _models.ErrorResponse]:
        """Get data cube measures.

        Returns all measures for a data cube.

        :param id: Data cube identifier. Required.
        :type id: str
        :return: MeasureListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.MeasureListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.MeasureListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_data_cubes_list_data_cube_measures_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "MeasureListResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_data_cube_measure(
        self,
        id: str,
        body: _models.MeasurePayload,
        *,
        order: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.MeasureResponse, _models.ErrorResponse]:
        """Create a data cube measure.

        Creates a measure for a data cube.

        :param id: Data cube identifier. Required.
        :type id: str
        :param body: Required.
        :type body: ~polaris.sdk.project_api.models.MeasurePayload
        :keyword order: Array order of the new measure. Default value is None.
        :paramtype order: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasureResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.MeasureResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_data_cube_measure(
        self,
        id: str,
        body: IO[bytes],
        *,
        order: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.MeasureResponse, _models.ErrorResponse]:
        """Create a data cube measure.

        Creates a measure for a data cube.

        :param id: Data cube identifier. Required.
        :type id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword order: Array order of the new measure. Default value is None.
        :paramtype order: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasureResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.MeasureResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_data_cube_measure(
        self,
        id: str,
        body: Union[_models.MeasurePayload, IO[bytes]],
        *,
        order: Optional[int] = None,
        **kwargs: Any
    ) -> Union[_models.MeasureResponse, _models.ErrorResponse]:
        """Create a data cube measure.

        Creates a measure for a data cube.

        :param id: Data cube identifier. Required.
        :type id: str
        :param body: Is either a MeasurePayload type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.MeasurePayload or IO[bytes]
        :keyword order: Array order of the new measure. Default value is None.
        :paramtype order: int
        :return: MeasureResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.MeasureResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.MeasureResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "MeasurePayload")

        _request = build_data_cubes_create_data_cube_measure_request(
            id=id,
            project_id=self._config.project_id,
            order=order,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "MeasureResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_data_cube_measure(
        self, id: str, measure_id: str, **kwargs: Any
    ) -> Union[_models.MeasureResponse, _models.ErrorResponse]:
        """Get measure details.

        Returns information for a single data cube measure.

        :param id: Data cube identifier. Required.
        :type id: str
        :param measure_id: Dimension identifier. Required.
        :type measure_id: str
        :return: MeasureResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.MeasureResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.MeasureResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_data_cubes_get_data_cube_measure_request(
            id=id,
            measure_id=measure_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "MeasureResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_data_cube_measure(
        self,
        id: str,
        measure_id: str,
        body: _models.MeasurePayload,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.MeasureResponse, _models.ErrorResponse]:
        """Update a measure.

        Updates the details of a measure with a specified ID. You must provide all properties you want
        to retain in the measure, even if you don't want to update them. Polaris recreates the measure
        with the details you specify in the request.

        :param id: Data cube identifier. Required.
        :type id: str
        :param measure_id: Dimension identifier. Required.
        :type measure_id: str
        :param body: Measure to be update. Required.
        :type body: ~polaris.sdk.project_api.models.MeasurePayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasureResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.MeasureResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_data_cube_measure(
        self,
        id: str,
        measure_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.MeasureResponse, _models.ErrorResponse]:
        """Update a measure.

        Updates the details of a measure with a specified ID. You must provide all properties you want
        to retain in the measure, even if you don't want to update them. Polaris recreates the measure
        with the details you specify in the request.

        :param id: Data cube identifier. Required.
        :type id: str
        :param measure_id: Dimension identifier. Required.
        :type measure_id: str
        :param body: Measure to be update. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: MeasureResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.MeasureResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_data_cube_measure(
        self,
        id: str,
        measure_id: str,
        body: Union[_models.MeasurePayload, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.MeasureResponse, _models.ErrorResponse]:
        """Update a measure.

        Updates the details of a measure with a specified ID. You must provide all properties you want
        to retain in the measure, even if you don't want to update them. Polaris recreates the measure
        with the details you specify in the request.

        :param id: Data cube identifier. Required.
        :type id: str
        :param measure_id: Dimension identifier. Required.
        :type measure_id: str
        :param body: Measure to be update. Is either a MeasurePayload type or a IO[bytes] type.
         Required.
        :type body: ~polaris.sdk.project_api.models.MeasurePayload or IO[bytes]
        :return: MeasureResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.MeasureResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.MeasureResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "MeasurePayload")

        _request = build_data_cubes_update_data_cube_measure_request(
            id=id,
            measure_id=measure_id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "MeasureResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def patch_data_cube_measure(
        self,
        id: str,
        measure_id: str,
        body: _models.MeasurePayload,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.MeasureResponse, _models.ErrorResponse]:
        """Update specified measure properties.

        Updates the specified properties of a measure. Any properties omitted from the request retain
        their previous values. Polaris creates a new measure if the supplied measure ID doesn't exist.

        :param id: Data cube identifier. Required.
        :type id: str
        :param measure_id: Dimension identifier. Required.
        :type measure_id: str
        :param body: Measure updates. Required.
        :type body: ~polaris.sdk.project_api.models.MeasurePayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: MeasureResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.MeasureResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def patch_data_cube_measure(
        self,
        id: str,
        measure_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.MeasureResponse, _models.ErrorResponse]:
        """Update specified measure properties.

        Updates the specified properties of a measure. Any properties omitted from the request retain
        their previous values. Polaris creates a new measure if the supplied measure ID doesn't exist.

        :param id: Data cube identifier. Required.
        :type id: str
        :param measure_id: Dimension identifier. Required.
        :type measure_id: str
        :param body: Measure updates. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: MeasureResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.MeasureResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def patch_data_cube_measure(
        self,
        id: str,
        measure_id: str,
        body: Union[_models.MeasurePayload, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.MeasureResponse, _models.ErrorResponse]:
        """Update specified measure properties.

        Updates the specified properties of a measure. Any properties omitted from the request retain
        their previous values. Polaris creates a new measure if the supplied measure ID doesn't exist.

        :param id: Data cube identifier. Required.
        :type id: str
        :param measure_id: Dimension identifier. Required.
        :type measure_id: str
        :param body: Measure updates. Is either a MeasurePayload type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.MeasurePayload or IO[bytes]
        :return: MeasureResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.MeasureResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.MeasureResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "MeasurePayload")

        _request = build_data_cubes_patch_data_cube_measure_request(
            id=id,
            measure_id=measure_id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize(
                "MeasureResponse", pipeline_response.http_response
            )

        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "MeasureResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_data_cube_measure(
        self, id: str, measure_id: str, **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Delete a measure.

        Deletes a measure.

        :param id: Data cube identifier. Required.
        :type id: str
        :param measure_id: Dimension identifier. Required.
        :type measure_id: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_data_cubes_delete_data_cube_measure_request(
            id=id,
            measure_id=measure_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        deserialized = self._deserialize(
            "ErrorResponse", pipeline_response.http_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class EmbeddingLinksOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`embedding_links` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def list_embedding_links(
        self, **kwargs: Any
    ) -> Union[_models.EmbeddingLinkListResponse, _models.ErrorResponse]:
        """Get embedding links.

        Returns all links to embedded visualizations.

        :return: EmbeddingLinkListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.EmbeddingLinkListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[
            Union[_models.EmbeddingLinkListResponse, _models.ErrorResponse]
        ] = kwargs.pop("cls", None)

        _request = build_embedding_links_list_embedding_links_request(
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "EmbeddingLinkListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_embedding_link(
        self,
        body: _models.EmbeddingLinkRequestPayload,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.LinkResponse, _models.ErrorResponse]:
        """Create an embedding link.

        Creates a link to an embedded visualization.

        :param body: Required.
        :type body: ~polaris.sdk.project_api.models.EmbeddingLinkRequestPayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LinkResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LinkResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_embedding_link(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.LinkResponse, _models.ErrorResponse]:
        """Create an embedding link.

        Creates a link to an embedded visualization.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LinkResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LinkResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_embedding_link(
        self, body: Union[_models.EmbeddingLinkRequestPayload, IO[bytes]], **kwargs: Any
    ) -> Union[_models.LinkResponse, _models.ErrorResponse]:
        """Create an embedding link.

        Creates a link to an embedded visualization.

        :param body: Is either a EmbeddingLinkRequestPayload type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.EmbeddingLinkRequestPayload or IO[bytes]
        :return: LinkResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LinkResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.LinkResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "EmbeddingLinkRequestPayload")

        _request = build_embedding_links_create_embedding_link_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "LinkResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_embedding_link(
        self, id: str, **kwargs: Any
    ) -> Union[_models.LinkResponse, _models.ErrorResponse]:
        """Get embedding link details.

        Returns information for a single link to an embedded visualization.

        :param id: Embedding link ID. Required.
        :type id: str
        :return: LinkResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LinkResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.LinkResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_embedding_links_get_embedding_link_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "LinkResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_embedding_link(
        self,
        id: str,
        body: _models.EmbeddingLinkRequestPayload,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.LinkResponse, _models.ErrorResponse]:
        """Update an embedding link.

        Updates a link to an embedded visualization.

        :param id: Embedding link ID. Required.
        :type id: str
        :param body: Link to update. Required.
        :type body: ~polaris.sdk.project_api.models.EmbeddingLinkRequestPayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LinkResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LinkResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_embedding_link(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.LinkResponse, _models.ErrorResponse]:
        """Update an embedding link.

        Updates a link to an embedded visualization.

        :param id: Embedding link ID. Required.
        :type id: str
        :param body: Link to update. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LinkResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LinkResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_embedding_link(
        self,
        id: str,
        body: Union[_models.EmbeddingLinkRequestPayload, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.LinkResponse, _models.ErrorResponse]:
        """Update an embedding link.

        Updates a link to an embedded visualization.

        :param id: Embedding link ID. Required.
        :type id: str
        :param body: Link to update. Is either a EmbeddingLinkRequestPayload type or a IO[bytes] type.
         Required.
        :type body: ~polaris.sdk.project_api.models.EmbeddingLinkRequestPayload or IO[bytes]
        :return: LinkResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LinkResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.LinkResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "EmbeddingLinkRequestPayload")

        _request = build_embedding_links_update_embedding_link_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "LinkResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def patch_embedding_link(
        self,
        id: str,
        body: _models.EmbeddingLinkRequestPayload,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.LinkResponse, _models.ErrorResponse]:
        """Update specified embedding link properties.

        Updates the specified properties of an embedding link. Any properties omitted from the request
        retain their previous values. Polaris creates a new embedding link if the supplied link ID
        doesn't exist.

        :param id: Embedding link ID. Required.
        :type id: str
        :param body: Embedding link updates. Required.
        :type body: ~polaris.sdk.project_api.models.EmbeddingLinkRequestPayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: LinkResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LinkResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def patch_embedding_link(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.LinkResponse, _models.ErrorResponse]:
        """Update specified embedding link properties.

        Updates the specified properties of an embedding link. Any properties omitted from the request
        retain their previous values. Polaris creates a new embedding link if the supplied link ID
        doesn't exist.

        :param id: Embedding link ID. Required.
        :type id: str
        :param body: Embedding link updates. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: LinkResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LinkResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def patch_embedding_link(
        self,
        id: str,
        body: Union[_models.EmbeddingLinkRequestPayload, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.LinkResponse, _models.ErrorResponse]:
        """Update specified embedding link properties.

        Updates the specified properties of an embedding link. Any properties omitted from the request
        retain their previous values. Polaris creates a new embedding link if the supplied link ID
        doesn't exist.

        :param id: Embedding link ID. Required.
        :type id: str
        :param body: Embedding link updates. Is either a EmbeddingLinkRequestPayload type or a
         IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.EmbeddingLinkRequestPayload or IO[bytes]
        :return: LinkResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LinkResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.LinkResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "EmbeddingLinkRequestPayload")

        _request = build_embedding_links_patch_embedding_link_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "LinkResponse", pipeline_response.http_response
            )

        if response.status_code == 201:
            deserialized = self._deserialize(
                "LinkResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_embedding_link(
        self, id: str, **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Delete an embedding link.

        Deletes a link to an embedded visualization.

        :param id: Embedding link ID. Required.
        :type id: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_embedding_links_delete_embedding_link_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        deserialized = self._deserialize(
            "ErrorResponse", pipeline_response.http_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def create_embedding_link_secret_key(
        self, id: str, **kwargs: Any
    ) -> Union[str, _models.ErrorResponse]:
        """Create a secret key for an embedding link.

        Creates an ECDSA private key that is required to access the embedding link.

        :param id: Embedding link ID. Required.
        :type id: str
        :return: str or ErrorResponse
        :rtype: str or ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[str, _models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_embedding_links_create_embedding_link_secret_key_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            deserialized = self._deserialize("str", pipeline_response.http_response)

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_embedding_link_secret_key(
        self, id: str, **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Delete a secret key for an embedding link.

        Deletes the ECDSA public key associated with an embedding link. After deletion the link will
        function as a public link.

        :param id: Embedding link ID. Required.
        :type id: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_embedding_links_delete_embedding_link_secret_key_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        deserialized = self._deserialize(
            "ErrorResponse", pipeline_response.http_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class EventsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`events` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def push_events_using_connection(
        self,
        connection_name: str,
        body: Optional[bytes] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Push events to a Polaris connection.

        Sends data from an application source to a Polaris connection.

        :param connection_name: The name of the connection to push data to. Note that for legacy tables
         created via the v1 API, the connection name is named after the table ID. Required.
        :type connection_name: str
        :param body: Default value is None.
        :type body: bytes
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def push_events_using_connection(
        self,
        connection_name: str,
        body: Optional[IO[bytes]] = None,
        *,
        content_type: str = "application/octet-stream",
        **kwargs: Any
    ) -> None:
        """Push events to a Polaris connection.

        Sends data from an application source to a Polaris connection.

        :param connection_name: The name of the connection to push data to. Note that for legacy tables
         created via the v1 API, the connection name is named after the table ID. Required.
        :type connection_name: str
        :param body: Default value is None.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Known values are: 'application/json', 'application/octet-stream'. Default value is
         "application/octet-stream".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def push_events_using_connection(  # pylint: disable=inconsistent-return-statements
        self,
        connection_name: str,
        body: Optional[Union[bytes, IO[bytes]]] = None,
        **kwargs: Any
    ) -> None:
        """Push events to a Polaris connection.

        Sends data from an application source to a Polaris connection.

        :param connection_name: The name of the connection to push data to. Note that for legacy tables
         created via the v1 API, the connection name is named after the table ID. Required.
        :type connection_name: str
        :param body: Is either a bytes type or a IO[bytes] type. Default value is None.
        :type body: bytes or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[None] = kwargs.pop("cls", None)

        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            content_type = content_type or "application/octet-stream"
            _content = body
        else:
            if body is not None:
                _json = self._serialize.body(body, "bytearray")
            else:
                _json = None
            content_type = content_type or "application/json"

        _request = build_events_push_events_using_connection_request(
            connection_name=connection_name,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 429]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class FilesOperations:  # pylint: disable=abstract-class-instantiated
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`files` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

        raise_if_not_implemented(
            self.__class__,
            [
                "upload_file",
            ],
        )

    @distributed_trace
    def list_files(
        self,
        *,
        pagination_limit: int = 1000,
        pagination_offset: int = 0,
        search_string: Optional[str] = None,
        sort_column: Union[str, _models.FileSortColumn] = "uploaded_on_dt",
        sort_order: Union[str, _models.SortOrder] = "DESC",
        **kwargs: Any
    ) -> Union[_models.FileListResponse, _models.ErrorResponse]:
        """List files.

        List files.

        :keyword pagination_limit: A result limit for pagination. Default value is 1000.
        :paramtype pagination_limit: int
        :keyword pagination_offset: A result offset for pagination. Default value is 0.
        :paramtype pagination_offset: int
        :keyword search_string: Filter the results to only include files that have the provided string
         contained within one of their fields. Default value is None.
        :paramtype search_string: str
        :keyword sort_column: The column to sort file results by. Known values are:
         "compression_format", "data_format", "digest_algo", "digest_hash", "name", "size_bytes",
         "uploaded_by_user_name", and "uploaded_on_dt". Default value is "uploaded_on_dt".
        :paramtype sort_column: str or ~polaris.sdk.project_api.models.FileSortColumn
        :keyword sort_order: The order to sort file results by. Known values are: "ASC" and "DESC".
         Default value is "DESC".
        :paramtype sort_order: str or ~polaris.sdk.project_api.models.SortOrder
        :return: FileListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.FileListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FileListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_files_list_files_request(
            project_id=self._config.project_id,
            pagination_limit=pagination_limit,
            pagination_offset=pagination_offset,
            search_string=search_string,
            sort_column=sort_column,
            sort_order=sort_order,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "FileListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_file_metadata(
        self, name: str, **kwargs: Any
    ) -> Union[_models.FileMetadata, _models.ErrorResponse]:
        """Get file details.

        Returns information for a single file.

        :param name: Name of the file (may contain slashes). Required.
        :type name: str
        :return: FileMetadata or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.FileMetadata or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.FileMetadata, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_files_get_file_metadata_request(
            name=name,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "FileMetadata", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_file(self, name: str, **kwargs: Any) -> Optional[_models.ErrorResponse]:
        """Delete a file.

        Deletes a file.

        :param name: Name of the file (may contain slashes). Required.
        :type name: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_files_delete_file_request(
            name=name,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class LookupsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`lookups` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def list_lookups(
        self, **kwargs: Any
    ) -> Union[_models.LookupListResponse, _models.ErrorResponse]:
        """List all lookups.

        Returns all lookups in a specified project.

        :return: LookupListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LookupListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.LookupListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_lookups_list_lookups_request(
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "LookupListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_lookup(
        self,
        body: _models.CreateLookupRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.LookupResponse, _models.ErrorResponse]:
        """Create a lookup.

        Creates a lookup in a specified project.

        :param body: A lookup to be created. Required.
        :type body: ~polaris.sdk.project_api.models.CreateLookupRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LookupResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LookupResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_lookup(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.LookupResponse, _models.ErrorResponse]:
        """Create a lookup.

        Creates a lookup in a specified project.

        :param body: A lookup to be created. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LookupResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LookupResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_lookup(
        self, body: Union[_models.CreateLookupRequest, IO[bytes]], **kwargs: Any
    ) -> Union[_models.LookupResponse, _models.ErrorResponse]:
        """Create a lookup.

        Creates a lookup in a specified project.

        :param body: A lookup to be created. Is either a CreateLookupRequest type or a IO[bytes] type.
         Required.
        :type body: ~polaris.sdk.project_api.models.CreateLookupRequest or IO[bytes]
        :return: LookupResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LookupResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.LookupResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "CreateLookupRequest")

        _request = build_lookups_create_lookup_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 409]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "LookupResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 409:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_lookup(
        self, lookup_name: str, **kwargs: Any
    ) -> Union[_models.LookupResponse, _models.ErrorResponse]:
        """Get lookup details.

        Returns details for a specified lookup.

        :param lookup_name: The name of a lookup. Required.
        :type lookup_name: str
        :return: LookupResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LookupResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.LookupResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_lookups_get_lookup_request(
            lookup_name=lookup_name,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "LookupResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_lookup(
        self,
        lookup_name: str,
        body: _models.UpdateLookupRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.LookupResponse, _models.ErrorResponse]:
        """Update a lookup.

        Updates the details of a specified lookup.

        :param lookup_name: The name of a lookup. Required.
        :type lookup_name: str
        :param body: The updated lookup request. Required.
        :type body: ~polaris.sdk.project_api.models.UpdateLookupRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LookupResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LookupResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_lookup(
        self,
        lookup_name: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.LookupResponse, _models.ErrorResponse]:
        """Update a lookup.

        Updates the details of a specified lookup.

        :param lookup_name: The name of a lookup. Required.
        :type lookup_name: str
        :param body: The updated lookup request. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LookupResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LookupResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_lookup(
        self,
        lookup_name: str,
        body: Union[_models.UpdateLookupRequest, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.LookupResponse, _models.ErrorResponse]:
        """Update a lookup.

        Updates the details of a specified lookup.

        :param lookup_name: The name of a lookup. Required.
        :type lookup_name: str
        :param body: The updated lookup request. Is either a UpdateLookupRequest type or a IO[bytes]
         type. Required.
        :type body: ~polaris.sdk.project_api.models.UpdateLookupRequest or IO[bytes]
        :return: LookupResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LookupResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.LookupResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "UpdateLookupRequest")

        _request = build_lookups_update_lookup_request(
            lookup_name=lookup_name,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "LookupResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_lookup(
        self, lookup_name: str, **kwargs: Any
    ) -> Optional[_models.ErrorResponse]:
        """Delete a lookup.

        Deletes a lookup in a specified project.

        :param lookup_name: The name of a lookup. Required.
        :type lookup_name: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_lookups_delete_lookup_request(
            lookup_name=lookup_name,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_lookup_aliases(
        self, lookup_name: str, **kwargs: Any
    ) -> Union[_models.LookupAliasListResponse, _models.ErrorResponse]:
        """List all aliases for a lookup.

        Returns all aliases for a specified lookup.

        :param lookup_name: The name of a lookup. Required.
        :type lookup_name: str
        :return: LookupAliasListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LookupAliasListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.LookupAliasListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_lookups_list_lookup_aliases_request(
            lookup_name=lookup_name,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "LookupAliasListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_lookup_aliases(
        self,
        lookup_name: str,
        body: _models.UpdateLookupAliasesRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.LookupAliasListResponse, _models.ErrorResponse]:
        """Create or update aliases for a lookup.

        Create or update the aliases for a specified lookup. You must provide the details of all
        aliases you want to retain for the lookup, even if you don't want to update them. Polaris
        recreates the lookup's aliases with the details you specify in the request. Polaris creates a
        new alias if the supplied alias name doesn't exist.

        :param lookup_name: The name of a lookup. Required.
        :type lookup_name: str
        :param body: A lookup alias to be created or updated. Required.
        :type body: ~polaris.sdk.project_api.models.UpdateLookupAliasesRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LookupAliasListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LookupAliasListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_lookup_aliases(
        self,
        lookup_name: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.LookupAliasListResponse, _models.ErrorResponse]:
        """Create or update aliases for a lookup.

        Create or update the aliases for a specified lookup. You must provide the details of all
        aliases you want to retain for the lookup, even if you don't want to update them. Polaris
        recreates the lookup's aliases with the details you specify in the request. Polaris creates a
        new alias if the supplied alias name doesn't exist.

        :param lookup_name: The name of a lookup. Required.
        :type lookup_name: str
        :param body: A lookup alias to be created or updated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LookupAliasListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LookupAliasListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_lookup_aliases(
        self,
        lookup_name: str,
        body: Union[_models.UpdateLookupAliasesRequest, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.LookupAliasListResponse, _models.ErrorResponse]:
        """Create or update aliases for a lookup.

        Create or update the aliases for a specified lookup. You must provide the details of all
        aliases you want to retain for the lookup, even if you don't want to update them. Polaris
        recreates the lookup's aliases with the details you specify in the request. Polaris creates a
        new alias if the supplied alias name doesn't exist.

        :param lookup_name: The name of a lookup. Required.
        :type lookup_name: str
        :param body: A lookup alias to be created or updated. Is either a UpdateLookupAliasesRequest
         type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.UpdateLookupAliasesRequest or IO[bytes]
        :return: LookupAliasListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.LookupAliasListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.LookupAliasListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "UpdateLookupAliasesRequest")

        _request = build_lookups_update_lookup_aliases_request(
            lookup_name=lookup_name,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "LookupAliasListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class JobsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`jobs` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def list_jobs(
        self,
        *,
        connection_name: Optional[List[str]] = None,
        execution_status: Optional[
            List[Union[str, _models.JobExecutionStatusV2]]
        ] = None,
        health_status: Optional[List[Union[str, _models.JobHealthStatusV2]]] = None,
        pagination_limit: int = 100,
        pagination_offset: int = 0,
        search_string: Optional[str] = None,
        sort_column: Union[str, _models.JobSortSearchColumn] = "last_updated_date_time",
        sort_order: Union[str, _models.SortOrder] = "DESC",
        target_table_id: Optional[str] = None,
        target_table_name: Optional[str] = None,
        type: Optional[List[Union[str, _models.JobTypeV2]]] = None,
        **kwargs: Any
    ) -> Union[_models.JobListResponse, _models.ErrorResponse]:
        """List all jobs.

        Returns all jobs.

        :keyword connection_name: The connection to filter jobs by. Default value is None.
        :paramtype connection_name: list[str]
        :keyword execution_status: Filters results with a certain execution status. For example, to
         list running jobs only, use the address
         ``/v1/projects/{projectId}/jobs?executionStatus=running``. Default value is None.
        :paramtype execution_status: list[str or ~polaris.sdk.project_api.models.JobExecutionStatusV2]
        :keyword health_status: Filters results with a certain health status. For example, to list jobs
         with warnings or errors, use the address
         ``/v1/projects/{projectId}/jobs?healthStatus=warn&healthStatus=error``. Default value is None.
        :paramtype health_status: list[str or ~polaris.sdk.project_api.models.JobHealthStatusV2]
        :keyword pagination_limit: A result limit for pagination. Default value is 100.
        :paramtype pagination_limit: int
        :keyword pagination_offset: A result offset for pagination. Default value is 0.
        :paramtype pagination_offset: int
        :keyword search_string: Filter results to those jobs where the given string is contained in one
         of the job's fields. Default value is None.
        :paramtype search_string: str
        :keyword sort_column: Sort results by one of the following fields:


         * ``created_by_user_name``     : User that created the job.
         * ``created_date_time``        : Date the job was created.
         * ``execution_status``         : Job's execution status.
         * ``last_updated_date_time``   : Date the job was last updated.
         * ``source_name``              : Job's source name, such as a connection name.
         * ``source_type``              : Job's source type, such as ``connection`` or ``table``.
         * ``source_connection_name``   : Deprecated, use ``source_name`` instead.
         * ``source_table_name``        : Deprecated, use ``source_name`` instead.
         * ``target_table_name``        : Table that the job targets.
         * ``type``                     : Job type. Known values are: "created_by_user_name",
         "created_date_time", "execution_status", "last_updated_date_time", "source_name",
         "source_type", "source_connection_name", "source_table_name", "target_table_name", and "type".
         Default value is "last_updated_date_time".
        :paramtype sort_column: str or ~polaris.sdk.project_api.models.JobSortSearchColumn
        :keyword sort_order: The order to sort job results by. Known values are: "ASC" and "DESC".
         Default value is "DESC".
        :paramtype sort_order: str or ~polaris.sdk.project_api.models.SortOrder
        :keyword target_table_id: Filters results for jobs associated with a particular target table
         id. Default value is None.
        :paramtype target_table_id: str
        :keyword target_table_name: Filters results for jobs associated with a particular target table
         name. Default value is None.
        :paramtype target_table_name: str
        :keyword type: Filters results with a certain job type. For example, to select batch and
         streaming jobs, use the address ``/v1/projects/{projectId}/jobs?type=batch&type=streaming``.
         Default value is None.
        :paramtype type: list[str or ~polaris.sdk.project_api.models.JobTypeV2]
        :return: JobListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.JobListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_jobs_list_jobs_request(
            project_id=self._config.project_id,
            connection_name=connection_name,
            execution_status=execution_status,
            health_status=health_status,
            pagination_limit=pagination_limit,
            pagination_offset=pagination_offset,
            search_string=search_string,
            sort_column=sort_column,
            sort_order=sort_order,
            target_table_id=target_table_id,
            target_table_name=target_table_name,
            type=type,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "JobListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_job(
        self,
        body: _models.CreateJobRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.JobResponse, _models.ErrorResponse]:
        """Create a job.

        Creates a job.

        :param body: A job to be created. Required.
        :type body: ~polaris.sdk.project_api.models.CreateJobRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JobResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_job(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.JobResponse, _models.ErrorResponse]:
        """Create a job.

        Creates a job.

        :param body: A job to be created. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JobResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_job(
        self, body: Union[_models.CreateJobRequest, IO[bytes]], **kwargs: Any
    ) -> Union[_models.JobResponse, _models.ErrorResponse]:
        """Create a job.

        Creates a job.

        :param body: A job to be created. Is either a CreateJobRequest type or a IO[bytes] type.
         Required.
        :type body: ~polaris.sdk.project_api.models.CreateJobRequest or IO[bytes]
        :return: JobResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.JobResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "CreateJobRequest")

        _request = build_jobs_create_job_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 415]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "JobResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 415:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def describe_job(
        self, job_id: str, **kwargs: Any
    ) -> Union[_models.JobResponse, _models.ErrorResponse]:
        """Get job details.

        Returns information for a single job.

        :param job_id: The server-generated ID of the job for which to get the metadata. Required.
        :type job_id: str
        :return: JobResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.JobResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_jobs_describe_job_request(
            job_id=job_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "JobResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_job(
        self,
        job_id: str,
        body: _models.UpdateJobStatusRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.JobResponse, _models.ErrorResponse]:
        """Update a job.

        Updates the execution status of a job.

        Although you can continue to use this PUT request to update a job's status,
        it's recommended to use the `POST request <#tag/projectJobs/operation/updateJobStatus>`_
        to the job status endpoint.

        :param job_id: The server-generated ID of the job for which to get the metadata. Required.
        :type job_id: str
        :param body: The job to be updated. Required.
        :type body: ~polaris.sdk.project_api.models.UpdateJobStatusRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JobResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_job(
        self,
        job_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.JobResponse, _models.ErrorResponse]:
        """Update a job.

        Updates the execution status of a job.

        Although you can continue to use this PUT request to update a job's status,
        it's recommended to use the `POST request <#tag/projectJobs/operation/updateJobStatus>`_
        to the job status endpoint.

        :param job_id: The server-generated ID of the job for which to get the metadata. Required.
        :type job_id: str
        :param body: The job to be updated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JobResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_job(
        self,
        job_id: str,
        body: Union[_models.UpdateJobStatusRequest, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.JobResponse, _models.ErrorResponse]:
        """Update a job.

        Updates the execution status of a job.

        Although you can continue to use this PUT request to update a job's status,
        it's recommended to use the `POST request <#tag/projectJobs/operation/updateJobStatus>`_
        to the job status endpoint.

        :param job_id: The server-generated ID of the job for which to get the metadata. Required.
        :type job_id: str
        :param body: The job to be updated. Is either a UpdateJobStatusRequest type or a IO[bytes]
         type. Required.
        :type body: ~polaris.sdk.project_api.models.UpdateJobStatusRequest or IO[bytes]
        :return: JobResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.JobResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "UpdateJobStatusRequest")

        _request = build_jobs_update_job_request(
            job_id=job_id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 415]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "JobResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 415:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def describe_job_overall_progress(
        self, job_id: str, **kwargs: Any
    ) -> Union[_models.JobProgressResponse, _models.ErrorResponse]:
        """Get job overall progress.

        Returns progress for a job.

        :param job_id: The server-generated ID of the job for which to get the metadata. Required.
        :type job_id: str
        :return: JobProgressResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobProgressResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.JobProgressResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_jobs_describe_job_overall_progress_request(
            job_id=job_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "JobProgressResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def describe_job_logs(
        self, job_id: str, **kwargs: Any
    ) -> Union[_models.JobLogsResponse, _models.ErrorResponse]:
        """Get job logs.

        Returns logs for a job.

        :param job_id: The server-generated ID of the job for which to get the metadata. Required.
        :type job_id: str
        :return: JobLogsResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobLogsResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.JobLogsResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_jobs_describe_job_logs_request(
            job_id=job_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "JobLogsResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def describe_job_metrics(
        self, job_id: str, **kwargs: Any
    ) -> Union[_models.JobMetricsResponse, _models.ErrorResponse]:
        """Get job metrics.

        Returns detailed metrics about a job.

        :param job_id: The server-generated ID of the job for which to get the metadata. Required.
        :type job_id: str
        :return: JobMetricsResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobMetricsResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.JobMetricsResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_jobs_describe_job_metrics_request(
            job_id=job_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "JobMetricsResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def reset_job(self, job_id: str, **kwargs: Any) -> Optional[_models.ErrorResponse]:
        """Reset job to apply streaming ingestion offset.

        Resets a streaming ingestion job.
        This resets the point from which Polaris ingests streaming data to
        ``readFromPoint`` set in current streaming ingestion jobs. Only applies
        when there was a previous streaming ingestion job that used the same
        topic or stream name for the same target table. For more information,
        see `Reset streaming job offset <https://docs.imply.io/ui/saas/help/api-reset.html>`_.

        :param job_id: The server-generated ID of the job. Required.
        :type job_id: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_jobs_reset_job_request(
            job_id=job_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def describe_job_status(
        self, job_id: str, **kwargs: Any
    ) -> Union[_models.JobStatusResponse, _models.ErrorResponse]:
        """Get job execution status.

        Returns the execution status for a job.

        :param job_id: Server-generated job ID. Required.
        :type job_id: str
        :return: JobStatusResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobStatusResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.JobStatusResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_jobs_describe_job_status_request(
            job_id=job_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "JobStatusResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_job_status(
        self,
        job_id: str,
        body: _models.UpdateJobStatusRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.JobStatusResponse, _models.ErrorResponse]:
        """Update job execution status.

        Updates the execution status of a job.

        Use this request to cancel any ingestion job in progress or to
        suspend and resume a streaming ingestion job.

        You can't update data deletion jobs.

        Prefer this method over `Updating a job <#tag/projectJobs/operation/updateJobInProject>`_.

        :param job_id: Server-generated job ID. Required.
        :type job_id: str
        :param body: A request to update the job's execution status. Required.
        :type body: ~polaris.sdk.project_api.models.UpdateJobStatusRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JobStatusResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobStatusResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_job_status(
        self,
        job_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.JobStatusResponse, _models.ErrorResponse]:
        """Update job execution status.

        Updates the execution status of a job.

        Use this request to cancel any ingestion job in progress or to
        suspend and resume a streaming ingestion job.

        You can't update data deletion jobs.

        Prefer this method over `Updating a job <#tag/projectJobs/operation/updateJobInProject>`_.

        :param job_id: Server-generated job ID. Required.
        :type job_id: str
        :param body: A request to update the job's execution status. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JobStatusResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobStatusResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_job_status(
        self,
        job_id: str,
        body: Union[_models.UpdateJobStatusRequest, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.JobStatusResponse, _models.ErrorResponse]:
        """Update job execution status.

        Updates the execution status of a job.

        Use this request to cancel any ingestion job in progress or to
        suspend and resume a streaming ingestion job.

        You can't update data deletion jobs.

        Prefer this method over `Updating a job <#tag/projectJobs/operation/updateJobInProject>`_.

        :param job_id: Server-generated job ID. Required.
        :type job_id: str
        :param body: A request to update the job's execution status. Is either a UpdateJobStatusRequest
         type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.UpdateJobStatusRequest or IO[bytes]
        :return: JobStatusResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.JobStatusResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.JobStatusResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "UpdateJobStatusRequest")

        _request = build_jobs_update_job_status_request(
            job_id=job_id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 415]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "JobStatusResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 415:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class QueryOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`query` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def query_sync(
        self,
        body: _models.SqlRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[List[JSON], _models.SqlErrorResponse]:
        """Query precached data.

        Submits a synchronous SQL query against precached data including real-time streaming data.
        Returns a JSON object with the query results.
        This request doesn't query data that's offloaded from precache and is only in deep storage.

        Polaris directly returns query results in the HTTP response body.
        You can't cancel a synchronous query.

        :param body: The SQL query and additional properties to control query execution and result
         format. Required.
        :type body: ~polaris.sdk.project_api.models.SqlRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of JSON or SqlErrorResponse
        :rtype: list[JSON] or ~polaris.sdk.project_api.models.SqlErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def query_sync(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[List[JSON], _models.SqlErrorResponse]:
        """Query precached data.

        Submits a synchronous SQL query against precached data including real-time streaming data.
        Returns a JSON object with the query results.
        This request doesn't query data that's offloaded from precache and is only in deep storage.

        Polaris directly returns query results in the HTTP response body.
        You can't cancel a synchronous query.

        :param body: The SQL query and additional properties to control query execution and result
         format. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of JSON or SqlErrorResponse
        :rtype: list[JSON] or ~polaris.sdk.project_api.models.SqlErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def query_sync(
        self, body: Union[_models.SqlRequest, IO[bytes]], **kwargs: Any
    ) -> Union[List[JSON], _models.SqlErrorResponse]:
        """Query precached data.

        Submits a synchronous SQL query against precached data including real-time streaming data.
        Returns a JSON object with the query results.
        This request doesn't query data that's offloaded from precache and is only in deep storage.

        Polaris directly returns query results in the HTTP response body.
        You can't cancel a synchronous query.

        :param body: The SQL query and additional properties to control query execution and result
         format. Is either a SqlRequest type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.SqlRequest or IO[bytes]
        :return: list of JSON or SqlErrorResponse
        :rtype: list[JSON] or ~polaris.sdk.project_api.models.SqlErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[List[JSON], _models.SqlErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "SqlRequest")

        _request = build_query_query_sync_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "[object]", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "SqlErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def query_async(
        self,
        body: _models.SqlRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.SqlStatus, _models.SqlErrorResponseWrapper]:
        """Query all data asynchronously.

        Submits a SQL query against real-time data as well as data in deep storage.

        Queries precached data as well as data offloaded from precache.
        The response body doesn't return query results. To get query results, see
        `Get results for an async query <#tag/projectQuery/operation/queryAsyncResults>`_.

        :param body: The SQL query and additional properties to control query execution and result
         format. Required.
        :type body: ~polaris.sdk.project_api.models.SqlRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SqlStatus or SqlErrorResponseWrapper
        :rtype: ~polaris.sdk.project_api.models.SqlStatus or
         ~polaris.sdk.project_api.models.SqlErrorResponseWrapper
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def query_async(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.SqlStatus, _models.SqlErrorResponseWrapper]:
        """Query all data asynchronously.

        Submits a SQL query against real-time data as well as data in deep storage.

        Queries precached data as well as data offloaded from precache.
        The response body doesn't return query results. To get query results, see
        `Get results for an async query <#tag/projectQuery/operation/queryAsyncResults>`_.

        :param body: The SQL query and additional properties to control query execution and result
         format. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SqlStatus or SqlErrorResponseWrapper
        :rtype: ~polaris.sdk.project_api.models.SqlStatus or
         ~polaris.sdk.project_api.models.SqlErrorResponseWrapper
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def query_async(
        self, body: Union[_models.SqlRequest, IO[bytes]], **kwargs: Any
    ) -> Union[_models.SqlStatus, _models.SqlErrorResponseWrapper]:
        """Query all data asynchronously.

        Submits a SQL query against real-time data as well as data in deep storage.

        Queries precached data as well as data offloaded from precache.
        The response body doesn't return query results. To get query results, see
        `Get results for an async query <#tag/projectQuery/operation/queryAsyncResults>`_.

        :param body: The SQL query and additional properties to control query execution and result
         format. Is either a SqlRequest type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.SqlRequest or IO[bytes]
        :return: SqlStatus or SqlErrorResponseWrapper
        :rtype: ~polaris.sdk.project_api.models.SqlStatus or
         ~polaris.sdk.project_api.models.SqlErrorResponseWrapper
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.SqlStatus, _models.SqlErrorResponseWrapper]] = (
            kwargs.pop("cls", None)
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "SqlRequest")

        _request = build_query_query_async_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "SqlStatus", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "SqlErrorResponseWrapper", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def query_async_results(
        self,
        query_id: str,
        *,
        page: Optional[int] = None,
        result_format: Union[str, _models.ResultFormat] = "object",
        filename: Optional[str] = None,
        **kwargs: Any
    ) -> Union[List[JSON], _models.SqlErrorResponse]:
        """Get results for an async query.

        Retrieves results for a completed query.

        This request doesn’t return results when the async query performs an ingestion job,
        that is, a query starting with INSERT or REPLACE.
        To get the status of the ingestion job, see `Get job execution status
        <#tag/projectJobs/operation/describeJobStatus>`_.

        Results are separated into pages, so you can use the optional ``page`` parameter to refine the
        results you get.
        Polaris returns information about the composition of each page and its page number (\\ ``id``\\
        ).

        For information about pages, see `Get status of an async query
        <#tag/projectQuery/operation/queryAsyncStatus>`_.
        If you don't specify a page number, the API returns all results sequentially in the same
        response.

        :param query_id: The server-generated ID of the query. Required.
        :type query_id: str
        :keyword page: Fetch results based on page numbers. If not specified, all results are returned
         sequentially starting from page 0 to *N* in the same response. Default value is None.
        :paramtype page: int
        :keyword result_format: Defines the format in which the results are presented. Known values
         are: "object", "array", "objectLines", "arrayLines", and "csv". Default value is "object".
        :paramtype result_format: str or ~polaris.sdk.project_api.models.ResultFormat
        :keyword filename: Attaches a ``Content-Disposition`` header to the response with the value of
         ``attachment; filename={filename}``. This header prompts web browsers to save the results as a
         file instead of showing them inline. The filename must not be longer than 255 characters and
         must not contain the characters ``/``\\ , ``\\``\\ , ``:``\\ , ``*``\\ , ``?``\\ , ``"``\\ ,
         ``<``\\ , ``>``\\ , ``|``\\ , ``\\0``\\ , ``\\n``\\ , or ``\\r``. Default value is None.
        :paramtype filename: str
        :return: list of JSON or SqlErrorResponse
        :rtype: list[JSON] or ~polaris.sdk.project_api.models.SqlErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[List[JSON], _models.SqlErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_query_query_async_results_request(
            query_id=query_id,
            project_id=self._config.project_id,
            page=page,
            result_format=result_format,
            filename=filename,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "[object]", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "SqlErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "SqlErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "SqlErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def query_async_status(
        self, query_id: str, *, detail: bool = False, **kwargs: Any
    ) -> _models.SqlStatus:
        """Get status of an async query.

        Retrieves information about the query associated with the given query ID.

        The response matches the response from
        `submitting an async query <#tag/projectQuery/operation/queryAsync>`_
        if the query is accepted or running.

        :param query_id: The server-generated ID of the query. Required.
        :type query_id: str
        :keyword detail: Fetch additional details about the query, which includes the information about
         different stages, counters for each stage, and any warnings. Default value is False.
        :paramtype detail: bool
        :return: SqlStatus
        :rtype: ~polaris.sdk.project_api.models.SqlStatus
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SqlStatus] = kwargs.pop("cls", None)

        _request = build_query_query_async_status_request(
            query_id=query_id,
            project_id=self._config.project_id,
            detail=detail,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = self._deserialize("SqlStatus", pipeline_response.http_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def query_async_cancel(
        self, query_id: str, **kwargs: Any
    ) -> Optional[_models.SqlErrorResponse]:
        """Cancel an async query.

        Cancels a running or accepted async query.

        :param query_id: The server-generated ID of the query. Required.
        :type query_id: str
        :return: SqlErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.SqlErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.SqlErrorResponse]] = kwargs.pop("cls", None)

        _request = build_query_query_async_cancel_request(
            query_id=query_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 404:
            deserialized = self._deserialize(
                "SqlErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class ReportsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`reports` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def list_reports(
        self, **kwargs: Any
    ) -> Union[_models.ReportListResponse, _models.ErrorResponse]:
        """List all reports.

        Returns all reports.

        :return: ReportListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.ReportListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_reports_list_reports_request(
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "ReportListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_report(
        self,
        body: _models.ReportBody,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.ReportResponse, _models.ErrorResponse]:
        """Create a report.

        Creates a report.

        :param body: Required.
        :type body: ~polaris.sdk.project_api.models.ReportBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ReportResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_report(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.ReportResponse, _models.ErrorResponse]:
        """Create a report.

        Creates a report.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ReportResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_report(
        self, body: Union[_models.ReportBody, IO[bytes]], **kwargs: Any
    ) -> Union[_models.ReportResponse, _models.ErrorResponse]:
        """Create a report.

        Creates a report.

        :param body: Is either a ReportBody type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.ReportBody or IO[bytes]
        :return: ReportResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.ReportResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "ReportBody")

        _request = build_reports_create_report_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "ReportResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_report(
        self, id: str, **kwargs: Any
    ) -> Union[_models.ReportResponse, _models.ErrorResponse]:
        """Get report details.

        Returns details of a specified report.

        :param id: Report ID. Required.
        :type id: str
        :return: ReportResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.ReportResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_reports_get_report_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "ReportResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_report(
        self,
        id: str,
        body: _models.ReportBody,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.ReportResponse, _models.ErrorResponse]:
        """Update a report.

        Updates the details of a report with a specified ID. You must provide all properties you want
        to retain in the report, even if you don't want to update them. Polaris recreates the report
        with the details you specify in the request.

        :param id: Report ID. Required.
        :type id: str
        :param body: Report ID. Required.
        :type body: ~polaris.sdk.project_api.models.ReportBody
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ReportResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_report(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.ReportResponse, _models.ErrorResponse]:
        """Update a report.

        Updates the details of a report with a specified ID. You must provide all properties you want
        to retain in the report, even if you don't want to update them. Polaris recreates the report
        with the details you specify in the request.

        :param id: Report ID. Required.
        :type id: str
        :param body: Report ID. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ReportResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_report(
        self, id: str, body: Union[_models.ReportBody, IO[bytes]], **kwargs: Any
    ) -> Union[_models.ReportResponse, _models.ErrorResponse]:
        """Update a report.

        Updates the details of a report with a specified ID. You must provide all properties you want
        to retain in the report, even if you don't want to update them. Polaris recreates the report
        with the details you specify in the request.

        :param id: Report ID. Required.
        :type id: str
        :param body: Report ID. Is either a ReportBody type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.ReportBody or IO[bytes]
        :return: ReportResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.ReportResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "ReportBody")

        _request = build_reports_update_report_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "ReportResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def patch_report(
        self,
        id: str,
        body: _models.ReportPayload,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.ReportResponse, _models.ErrorResponse]:
        """Update specified report properties.

        Updates the specified properties of a report. Any properties omitted from the request retain
        their previous values. Polaris creates a new report if the supplied report ID doesn't exist.

        :param id: Report ID. Required.
        :type id: str
        :param body: Report updates. Required.
        :type body: ~polaris.sdk.project_api.models.ReportPayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ReportResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def patch_report(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> Union[_models.ReportResponse, _models.ErrorResponse]:
        """Update specified report properties.

        Updates the specified properties of a report. Any properties omitted from the request retain
        their previous values. Polaris creates a new report if the supplied report ID doesn't exist.

        :param id: Report ID. Required.
        :type id: str
        :param body: Report updates. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: ReportResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def patch_report(
        self, id: str, body: Union[_models.ReportPayload, IO[bytes]], **kwargs: Any
    ) -> Union[_models.ReportResponse, _models.ErrorResponse]:
        """Update specified report properties.

        Updates the specified properties of a report. Any properties omitted from the request retain
        their previous values. Polaris creates a new report if the supplied report ID doesn't exist.

        :param id: Report ID. Required.
        :type id: str
        :param body: Report updates. Is either a ReportPayload type or a IO[bytes] type. Required.
        :type body: ~polaris.sdk.project_api.models.ReportPayload or IO[bytes]
        :return: ReportResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.ReportResponse, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "ReportPayload")

        _request = build_reports_patch_report_request(
            id=id,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 400, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "ReportResponse", pipeline_response.http_response
            )

        if response.status_code == 201:
            deserialized = self._deserialize(
                "ReportResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_report(self, id: str, **kwargs: Any) -> Optional[_models.ErrorResponse]:
        """Delete a report.

        Deletes a report.

        :param id: Report ID. Required.
        :type id: str
        :return: ErrorResponse or None
        :rtype: ~polaris.sdk.project_api.models.ErrorResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ErrorResponse]] = kwargs.pop("cls", None)

        _request = build_reports_delete_report_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        deserialized = self._deserialize(
            "ErrorResponse", pipeline_response.http_response
        )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_report_evaluations(
        self, id: str, **kwargs: Any
    ) -> Union[_models.ReportEvaluationListResponse, _models.ErrorResponse]:
        """Get report evaluations.

        Returns all evaluations for a specified report.

        :param id: Report ID. Required.
        :type id: str
        :return: ReportEvaluationListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportEvaluationListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[
            Union[_models.ReportEvaluationListResponse, _models.ErrorResponse]
        ] = kwargs.pop("cls", None)

        _request = build_reports_list_report_evaluations_request(
            id=id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "ReportEvaluationListResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_report_evaluation(
        self, id: str, evaluation_id: str, **kwargs: Any
    ) -> Union[_models.ReportEvaluationPayload, _models.ErrorResponse]:
        """Get report evaluation details.

        Returns information for a single report evaluation.

        :param id: Report ID. Required.
        :type id: str
        :param evaluation_id: Evaluation ID. Required.
        :type evaluation_id: str
        :return: ReportEvaluationPayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.ReportEvaluationPayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.ReportEvaluationPayload, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_reports_get_report_evaluation_request(
            id=id,
            evaluation_id=evaluation_id,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "ReportEvaluationPayload", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 500:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TablesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~polaris.sdk.project_api.ImplyPolarisProjectClient`'s
        :attr:`tables` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def list_tables(
        self,
        *,
        partitioning_granularity: Optional[Union[str, _models.Enum118]] = None,
        segment_count: Optional[int] = None,
        **kwargs: Any
    ) -> Union[_models.TableListResponse, _models.ErrorResponse]:
        """List all tables in a project.

        Returns all available tables for a project.

        :keyword partitioning_granularity: Filters results by the partitioning granularity specified.
         Known values are: "second", "minute", "five_minute", "ten_minute", "fifteen_minute",
         "thirty_minute", "hour", "six_hour", "eight_hour", "day", "week", "month", "quarter", "year",
         and "all". Default value is None.
        :paramtype partitioning_granularity: str or ~polaris.sdk.project_api.models.Enum118
        :keyword segment_count: Filters results by the number of segments specified. Default value is
         None.
        :paramtype segment_count: int
        :return: TableListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TableListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.TableListResponse, _models.ErrorResponse]] = (
            kwargs.pop("cls", None)
        )

        _request = build_tables_list_tables_request(
            project_id=self._config.project_id,
            partitioning_granularity=partitioning_granularity,
            segment_count=segment_count,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "TableListResponse", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_table(
        self,
        body: _models.TablePayload,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.TablePayload, _models.ErrorResponse]:
        """Create a table.

        Creates a table.

        :param body: A table to be created. Required.
        :type body: ~polaris.sdk.project_api.models.TablePayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TablePayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TablePayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_table(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.TablePayload, _models.ErrorResponse]:
        """Create a table.

        Creates a table.

        :param body: A table to be created. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TablePayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TablePayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_table(
        self, body: Union[_models.TablePayload, IO[bytes]], **kwargs: Any
    ) -> Union[_models.TablePayload, _models.ErrorResponse]:
        """Create a table.

        Creates a table.

        :param body: A table to be created. Is either a TablePayload type or a IO[bytes] type.
         Required.
        :type body: ~polaris.sdk.project_api.models.TablePayload or IO[bytes]
        :return: TablePayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TablePayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.TablePayload, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "TablePayload")

        _request = build_tables_create_table_request(
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 409, 415]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 201:
            response_headers["Location"] = self._deserialize(
                "str", response.headers.get("Location")
            )

            deserialized = self._deserialize(
                "TablePayload", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 409:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 415:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def describe_table(
        self, table_name: str, **kwargs: Any
    ) -> Union[_models.TablePayload, _models.ErrorResponse]:
        """Get table details.

        Returns information for a single table.

        :param table_name: Name of the table for which to get information. Required.
        :type table_name: str
        :return: TablePayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TablePayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Union[_models.TablePayload, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        _request = build_tables_describe_table_request(
            table_name=table_name,
            project_id=self._config.project_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "TablePayload", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_table(
        self,
        table_name: str,
        body: _models.TablePayload,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.TablePayload, _models.ErrorResponse]:
        """Update a table.

        Updates a table.

        You can add columns to a table's schema at any point.
        You can only update or remove columns from a table's schema when
        the table is empty and has no active ingestion jobs.

        :param table_name: Name of the table for which to get information. Required.
        :type table_name: str
        :param body: The table to be updated. Required.
        :type body: ~polaris.sdk.project_api.models.TablePayload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TablePayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TablePayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_table(
        self,
        table_name: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.TablePayload, _models.ErrorResponse]:
        """Update a table.

        Updates a table.

        You can add columns to a table's schema at any point.
        You can only update or remove columns from a table's schema when
        the table is empty and has no active ingestion jobs.

        :param table_name: Name of the table for which to get information. Required.
        :type table_name: str
        :param body: The table to be updated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TablePayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TablePayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_table(
        self,
        table_name: str,
        body: Union[_models.TablePayload, IO[bytes]],
        **kwargs: Any
    ) -> Union[_models.TablePayload, _models.ErrorResponse]:
        """Update a table.

        Updates a table.

        You can add columns to a table's schema at any point.
        You can only update or remove columns from a table's schema when
        the table is empty and has no active ingestion jobs.

        :param table_name: Name of the table for which to get information. Required.
        :type table_name: str
        :param body: The table to be updated. Is either a TablePayload type or a IO[bytes] type.
         Required.
        :type body: ~polaris.sdk.project_api.models.TablePayload or IO[bytes]
        :return: TablePayload or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.TablePayload or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Union[_models.TablePayload, _models.ErrorResponse]] = kwargs.pop(
            "cls", None
        )

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "TablePayload")

        _request = build_tables_update_table_request(
            table_name=table_name,
            project_id=self._config.project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 404, 409, 415]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "TablePayload", pipeline_response.http_response
            )

        if response.status_code == 400:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 409:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if response.status_code == 415:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_unused_segments_for_table(
        self,
        table_name: str,
        *,
        interval: Optional[str] = None,
        limit: int = 100,
        last_segment_id: Optional[str] = None,
        sort_order: Union[str, _models.SortOrder] = "DESC",
        **kwargs: Any
    ) -> Union[_models.SegmentMetadataListResponse, _models.ErrorResponse]:
        """Get table's unused segments.

        Returns list of unused segments for the specified table matching query parameters given.

        :param table_name: Name of the table for which to get information. Required.
        :type table_name: str
        :keyword interval: Filters results for unused segments by the time interval specified. Default
         value is None.
        :paramtype interval: str
        :keyword limit: The maximum number of segments to return in the response. Default value is 100.
        :paramtype limit: int
        :keyword last_segment_id: The segmentId to use as a marker from which to search. If ``sortOrder
         = ASC`` or not specified,  all segments
         returned will have a segmentId that is strictly greater than this. If ``sortOrder = DESC``\\ ,
         all segments
         returned will have a segmentId that is strictly less than this. Default value is None.
        :paramtype last_segment_id: str
        :keyword sort_order: The order with which the resulting segments should be sorted with respect
         to their ``segmentId``.
         If not specified, the order of the results is not guaranteed. Known values are: "ASC" and
         "DESC". Default value is "DESC".
        :paramtype sort_order: str or ~polaris.sdk.project_api.models.SortOrder
        :return: SegmentMetadataListResponse or ErrorResponse
        :rtype: ~polaris.sdk.project_api.models.SegmentMetadataListResponse or
         ~polaris.sdk.project_api.models.ErrorResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[
            Union[_models.SegmentMetadataListResponse, _models.ErrorResponse]
        ] = kwargs.pop("cls", None)

        _request = build_tables_get_unused_segments_for_table_request(
            table_name=table_name,
            project_id=self._config.project_id,
            interval=interval,
            limit=limit,
            last_segment_id=last_segment_id,
            sort_order=sort_order,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize(
                "SegmentMetadataListResponse", pipeline_response.http_response
            )

        if response.status_code == 404:
            deserialized = self._deserialize(
                "ErrorResponse", pipeline_response.http_response
            )

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
