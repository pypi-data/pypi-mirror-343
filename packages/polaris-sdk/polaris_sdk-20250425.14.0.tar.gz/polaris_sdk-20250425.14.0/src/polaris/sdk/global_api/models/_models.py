# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.3, generator: @autorest/python@6.26.7)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import datetime
import sys
from typing import Any, Dict, IO, List, Optional, TYPE_CHECKING, Union

from .. import _serialization

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore

if TYPE_CHECKING:
    from .. import models as _models
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object


class AbsoluteCompare(_serialization.Model):
    """Absolute time comparison.

    All required parameters must be populated in order to send to server.

    :ivar type: Required. "absolute"
    :vartype type: str or ~polaris.sdk.global_api.models.AbsoluteCompareType
    :ivar interval: Defines a start and end boundary for a time range. Required.
    :vartype interval: ~polaris.sdk.global_api.models.TimeRange
    """

    _validation = {
        "type": {"required": True},
        "interval": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "interval": {"key": "interval", "type": "TimeRange"},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.AbsoluteCompareType"],
        interval: "_models.TimeRange",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Required. "absolute"
        :paramtype type: str or ~polaris.sdk.global_api.models.AbsoluteCompareType
        :keyword interval: Defines a start and end boundary for a time range. Required.
        :paramtype interval: ~polaris.sdk.global_api.models.TimeRange
        """
        super().__init__(**kwargs)
        self.type = type
        self.interval = interval


class AccessKeySecretsProperties(_serialization.Model):
    """Properties for connection secrets using access key authorization credentials.

    :ivar access_key_id: Access key ID. Only used for the access key ID of an AWS access key.
    :vartype access_key_id: str
    :ivar access_key_secret: Secret access key. AWS IAM access key or Azure storage account access
     key.
    :vartype access_key_secret: str
    """

    _attribute_map = {
        "access_key_id": {"key": "accessKeyId", "type": "str"},
        "access_key_secret": {"key": "accessKeySecret", "type": "str"},
    }

    def __init__(
        self,
        *,
        access_key_id: Optional[str] = None,
        access_key_secret: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword access_key_id: Access key ID. Only used for the access key ID of an AWS access key.
        :paramtype access_key_id: str
        :keyword access_key_secret: Secret access key. AWS IAM access key or Azure storage account
         access key.
        :paramtype access_key_secret: str
        """
        super().__init__(**kwargs)
        self.access_key_id = access_key_id
        self.access_key_secret = access_key_secret


class ConnectionSecretsOptionalPayload(_serialization.Model):
    """Type of connection secrets.
    The following secrets types are supported:


    * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
    * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
    * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
    use a Confluent Schema Registry API key and secret.
    * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
    * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
    * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
    Cloud connections.
    * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    NoneSecretsOptionalPayload, AccessKeySecretsOptionalPayload, AwsIamRoleSecretsOptionalPayload,
    HttpBasicAuthSecretsOptionalPayload, ConfluentSecretsOptionalPayload,
    SasTokenSecretsOptionalPayload, SaslPlainSecretsOptionalPayload,
    SaslScramSecretsOptionalPayload

    All required parameters must be populated in order to send to server.

    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    _subtype_map = {
        "type": {
            "NoneSecretsOptionalPayload": "NoneSecretsOptionalPayload",
            "access_key": "AccessKeySecretsOptionalPayload",
            "aws_iam": "AwsIamRoleSecretsOptionalPayload",
            "basic": "HttpBasicAuthSecretsOptionalPayload",
            "confluent": "ConfluentSecretsOptionalPayload",
            "sas_token": "SasTokenSecretsOptionalPayload",
            "sasl_plain": "SaslPlainSecretsOptionalPayload",
            "sasl_scram": "SaslScramSecretsOptionalPayload",
        }
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: Optional[str] = None


class AccessKeySecretsOptionalPayload(
    ConnectionSecretsOptionalPayload, AccessKeySecretsProperties
):
    """Credentials for access key authentication using an AWS access key or Azure Shared Key.

    All required parameters must be populated in order to send to server.

    :ivar access_key_id: Access key ID. Only used for the access key ID of an AWS access key.
    :vartype access_key_id: str
    :ivar access_key_secret: Secret access key. AWS IAM access key or Azure storage account access
     key.
    :vartype access_key_secret: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "access_key_id": {"key": "accessKeyId", "type": "str"},
        "access_key_secret": {"key": "accessKeySecret", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self,
        *,
        access_key_id: Optional[str] = None,
        access_key_secret: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword access_key_id: Access key ID. Only used for the access key ID of an AWS access key.
        :paramtype access_key_id: str
        :keyword access_key_secret: Secret access key. AWS IAM access key or Azure storage account
         access key.
        :paramtype access_key_secret: str
        """
        super().__init__(
            access_key_id=access_key_id, access_key_secret=access_key_secret, **kwargs
        )
        self.access_key_id = access_key_id
        self.access_key_secret = access_key_secret
        self.type: str = "access_key"


class AccessKeySecretsPropertiesRequired(AccessKeySecretsProperties):
    """AccessKeySecretsPropertiesRequired.

    :ivar access_key_id: Access key ID. Only used for the access key ID of an AWS access key.
    :vartype access_key_id: str
    :ivar access_key_secret: Secret access key. AWS IAM access key or Azure storage account access
     key.
    :vartype access_key_secret: str
    """


class ConnectionSecretsRequiredPayload(_serialization.Model):
    """Type of connection secrets.
    The following secrets types are supported:


    * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
    * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
    * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
    use a Confluent Schema Registry API key and secret.
    * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
    * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
    * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
    Cloud connections.
    * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    NoneSecretsRequiredPayload, AccessKeySecretsRequiredPayload, AwsIamRoleSecretsRequiredPayload,
    HttpBasicAuthSecretsRequiredPayload, ConfluentSecretsRequiredPayload,
    SasTokenSecretsRequiredPayload, SaslPlainSecretsRequiredPayload,
    SaslScramSecretsRequiredPayload

    All required parameters must be populated in order to send to server.

    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    _subtype_map = {
        "type": {
            "NoneSecretsRequiredPayload": "NoneSecretsRequiredPayload",
            "access_key": "AccessKeySecretsRequiredPayload",
            "aws_iam": "AwsIamRoleSecretsRequiredPayload",
            "basic": "HttpBasicAuthSecretsRequiredPayload",
            "confluent": "ConfluentSecretsRequiredPayload",
            "sas_token": "SasTokenSecretsRequiredPayload",
            "sasl_plain": "SaslPlainSecretsRequiredPayload",
            "sasl_scram": "SaslScramSecretsRequiredPayload",
        }
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: Optional[str] = None


class AccessKeySecretsRequiredPayload(
    ConnectionSecretsRequiredPayload, AccessKeySecretsPropertiesRequired
):
    """Credentials for access key authentication using an AWS access key or Azure Shared Key.

    All required parameters must be populated in order to send to server.

    :ivar access_key_id: Access key ID. Only used for the access key ID of an AWS access key.
    :vartype access_key_id: str
    :ivar access_key_secret: Secret access key. AWS IAM access key or Azure storage account access
     key.
    :vartype access_key_secret: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "access_key_id": {"key": "accessKeyId", "type": "str"},
        "access_key_secret": {"key": "accessKeySecret", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self,
        *,
        access_key_id: Optional[str] = None,
        access_key_secret: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword access_key_id: Access key ID. Only used for the access key ID of an AWS access key.
        :paramtype access_key_id: str
        :keyword access_key_secret: Secret access key. AWS IAM access key or Azure storage account
         access key.
        :paramtype access_key_secret: str
        """
        super().__init__(
            access_key_id=access_key_id, access_key_secret=access_key_secret, **kwargs
        )
        self.access_key_id = access_key_id
        self.access_key_secret = access_key_secret
        self.type: str = "access_key"


class AccessList(_serialization.Model):
    """Configure user access to the asset."""


class AggregateTableColumn(_serialization.Model):
    """A column of an ``aggregate`` type table.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AggregateTableDimensionColumn, AggregateTableMeasureColumn

    All required parameters must be populated in order to send to server.

    :ivar type: The column type for an aggregate table:


     * ``dimension`` - Columns that are stored as is. These columns are used as the grouping keys
     for aggregation.
     * ``measure``   - Columns that are aggregated during ingestion. Required. Known values are:
     "dimension" and "measure".
    :vartype type: str or ~polaris.sdk.global_api.models.AggregateTableColumnType
    :ivar name: The name of the table column. Required.
    :vartype name: str
    """

    _validation = {
        "type": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "name": {"key": "name", "type": "str"},
    }

    _subtype_map = {
        "type": {
            "dimension": "AggregateTableDimensionColumn",
            "measure": "AggregateTableMeasureColumn",
        }
    }

    def __init__(self, *, name: str, **kwargs: Any) -> None:
        """
        :keyword name: The name of the table column. Required.
        :paramtype name: str
        """
        super().__init__(**kwargs)
        self.type: Optional[str] = None
        self.name = name


class AggregateTableDimensionColumn(AggregateTableColumn):
    """Columns that are stored as is. Polaris does not change the values in these columns from the
    source input.

    All required parameters must be populated in order to send to server.

    :ivar type: The column type for an aggregate table:


     * ``dimension`` - Columns that are stored as is. These columns are used as the grouping keys
     for aggregation.
     * ``measure``   - Columns that are aggregated during ingestion. Required. Known values are:
     "dimension" and "measure".
    :vartype type: str or ~polaris.sdk.global_api.models.AggregateTableColumnType
    :ivar name: The name of the table column. Required.
    :vartype name: str
    :ivar data_type: The expected data type of the column. Reserve the ``timestamp`` data type for
     the primary timestamp column ``__time``. Required. Known values are: "bigint", "complex<json>",
     "double", "float", "geo", "HLLSketch", "ipAddress", "ipPrefix", "json", "long",
     "longStringPair", "doubleArray", "floatArray", "longArray", "stringArray",
     "quantilesDoublesSketch", "string", "thetaSketch", "ingest_timeseries", "timestamp", "varchar",
     and "variance".
    :vartype data_type: str or ~polaris.sdk.global_api.models.TableColumnDataType
    """

    _validation = {
        "type": {"required": True},
        "name": {"required": True},
        "data_type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "data_type": {"key": "dataType", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        data_type: Union[str, "_models.TableColumnDataType"],
        **kwargs: Any
    ) -> None:
        """
        :keyword name: The name of the table column. Required.
        :paramtype name: str
        :keyword data_type: The expected data type of the column. Reserve the ``timestamp`` data type
         for the primary timestamp column ``__time``. Required. Known values are: "bigint",
         "complex<json>", "double", "float", "geo", "HLLSketch", "ipAddress", "ipPrefix", "json",
         "long", "longStringPair", "doubleArray", "floatArray", "longArray", "stringArray",
         "quantilesDoublesSketch", "string", "thetaSketch", "ingest_timeseries", "timestamp", "varchar",
         and "variance".
        :paramtype data_type: str or ~polaris.sdk.global_api.models.TableColumnDataType
        """
        super().__init__(name=name, **kwargs)
        self.type: str = "dimension"
        self.data_type = data_type


class AggregateTableMeasureColumn(AggregateTableColumn):
    """Columns that are summarized during ingestion time using an aggregation function.

    All required parameters must be populated in order to send to server.

    :ivar type: The column type for an aggregate table:


     * ``dimension`` - Columns that are stored as is. These columns are used as the grouping keys
     for aggregation.
     * ``measure``   - Columns that are aggregated during ingestion. Required. Known values are:
     "dimension" and "measure".
    :vartype type: str or ~polaris.sdk.global_api.models.AggregateTableColumnType
    :ivar name: The name of the table column. Required.
    :vartype name: str
    :ivar data_type: The expected data type of an aggregate table measure column. Required. Known
     values are: "bigint", "double", "float", "HLLSketch", "long", "longStringPair",
     "quantilesDoublesSketch", "string", "thetaSketch", "ingest_timeseries", "varchar", and
     "variance".
    :vartype data_type: str or ~polaris.sdk.global_api.models.AggregateTableMeasureColumnDataType
    """

    _validation = {
        "type": {"required": True},
        "name": {"required": True},
        "data_type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "data_type": {"key": "dataType", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        data_type: Union[str, "_models.AggregateTableMeasureColumnDataType"],
        **kwargs: Any
    ) -> None:
        """
        :keyword name: The name of the table column. Required.
        :paramtype name: str
        :keyword data_type: The expected data type of an aggregate table measure column. Required.
         Known values are: "bigint", "double", "float", "HLLSketch", "long", "longStringPair",
         "quantilesDoublesSketch", "string", "thetaSketch", "ingest_timeseries", "varchar", and
         "variance".
        :paramtype data_type: str or ~polaris.sdk.global_api.models.AggregateTableMeasureColumnDataType
        """
        super().__init__(name=name, **kwargs)
        self.type: str = "measure"
        self.data_type = data_type


class TablePayload(_serialization.Model):
    """A table.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AggregateTablePayload, DetailTablePayload

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar name: The unique, immutable name of the table. Required.
    :vartype name: str
    :ivar type: Visualization type. Required. Known values are: "table", "detail", and "aggregate".
    :vartype type: str or ~polaris.sdk.global_api.models.TableType
    :ivar version: The version number of the table. Newly created tables are always initialized at
     version 0. Do not provide the version number when creating a table. When updating a table,
     provide the current table version number. If the version number in the request is not the
     current version, Polaris raises a ``409 Conflict`` error. In that case, retrieve the latest
     version and retry the request to avoid concurrently conflicting changes. Required.
    :vartype version: int
    :ivar availability: The availability status of the table:


     * ``available``   - All data in table is available for querying.
     * ``deleting``    - The table is being deleted.
     * ``unavailable`` - Not all data in the table is available for querying. Known values are:
     "available", "deleting", and "unavailable".
    :vartype availability: str or ~polaris.sdk.global_api.models.TableAvailability
    :ivar clustering_columns: Table columns to use for clustering. Polaris sorts table columns
     within the partition based
     on their order in this array.

     For aggregate tables, only dimensions (not measures) are supported for clustering.
     If a nonexistent column is specified, Polaris raises a ``400 Bad Request``
     error.

     For more information, see `Clustering
     <https://docs.imply.io/ui/saas/help/partitioning.html>`_.
    :vartype clustering_columns: list[str]
    :ivar created_by_user: The user who created the initial object.
    :vartype created_by_user: ~polaris.sdk.global_api.models.CreatedByUserResponse
    :ivar created_on_timestamp: The date and time this object was created in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype created_on_timestamp: ~datetime.datetime
    :ivar description: The table's description, limited to 1000 characters.
    :vartype description: str
    :ivar id: A generated, permanently unique ID for this table.
    :vartype id: str
    :ivar modified_by_user: The user who modified the object last.
    :vartype modified_by_user: ~polaris.sdk.global_api.models.ModifiedByUserResponse
    :ivar modified_on_timestamp: The date and time this table was last modified in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype modified_on_timestamp: ~datetime.datetime
    :ivar partitioning_granularity: The `time partitioning
     <https://docs.imply.io/ui/saas/help/partitioning.html>`_ of the table. The ``all`` granularity
     groups all data into a single bucket. The ``week`` granularity is deprecated. You can't create
     a new table with the time partitioning set to ``week``. A table sourced by a lookup can only
     use all partitioning. You can’t change this setting on a table that’s actively used by a
     lookup. Known values are: "second", "minute", "five_minute", "ten_minute", "fifteen_minute",
     "thirty_minute", "hour", "six_hour", "eight_hour", "day", "week", "month", "quarter", "year",
     and "all".
    :vartype partitioning_granularity: str or
     ~polaris.sdk.global_api.models.TablePartitioningGranularity
    :ivar queryable_schema: The queryable schema of the table. May include undeclared columns (in
     flexible tables only) or declared columns (in strict or flexible tables).
    :vartype queryable_schema: list[~polaris.sdk.global_api.models.DruidTableColumn]
    :ivar storage_policy: Policy specifying the time range of data to retain or precache.


     * The ``retain`` storage policy determines how long to keep data after which it is deleted.
     * The ``cached`` storage policy determines how long to keep data precached.
       Outside of the ``cached`` policy time range, data isn't precached and only resides in lower
     cost deep storage.

     By default, Polaris retains all data and precaches all data.
     You can’t set a custom storage policy for a table that’s actively used by a lookup.
     For more information, see
     `Data lifecycle management
     <https://docs.imply.io/ui/saas/help/data-lifecycle-management.html>`_.
    :vartype storage_policy: ~polaris.sdk.global_api.models.TableStoragePolicy
    :ivar schema_mode: The table's schema enforcement mode. For more information, see `Introduction
     to tables <https://docs.imply.io/ui/saas/help/tables.html>`_. Known values are: "flexible" and
     "strict".
    :vartype schema_mode: str or ~polaris.sdk.global_api.models.TableSchemaMode
    :ivar segment_compacted_bytes: Total compacted bytes of the table.
    :vartype segment_compacted_bytes: int
    :ivar segment_count: The number of segments in the table.
    :vartype segment_count: int
    :ivar segment_total_bytes: Total bytes of the table.
    :vartype segment_total_bytes: int
    :ivar precached_data_size_bytes: The total size of the table in bytes.
    :vartype precached_data_size_bytes: int
    :ivar total_data_size_bytes: The total size of the table in bytes.
    :vartype total_data_size_bytes: int
    :ivar total_rows: The total number of rows stored in the table.
    :vartype total_rows: int
    """

    _validation = {
        "name": {"required": True, "max_length": 255, "min_length": 1},
        "type": {"required": True},
        "version": {"required": True},
        "availability": {"readonly": True},
        "created_by_user": {"readonly": True},
        "created_on_timestamp": {"readonly": True},
        "id": {"readonly": True},
        "modified_by_user": {"readonly": True},
        "modified_on_timestamp": {"readonly": True},
        "queryable_schema": {"readonly": True},
        "segment_compacted_bytes": {"readonly": True},
        "segment_count": {"readonly": True},
        "segment_total_bytes": {"readonly": True},
        "precached_data_size_bytes": {"readonly": True},
        "total_data_size_bytes": {"readonly": True},
        "total_rows": {"readonly": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "version": {"key": "version", "type": "int"},
        "availability": {"key": "availability", "type": "str"},
        "clustering_columns": {"key": "clusteringColumns", "type": "[str]"},
        "created_by_user": {"key": "createdByUser", "type": "CreatedByUserResponse"},
        "created_on_timestamp": {"key": "createdOnTimestamp", "type": "iso-8601"},
        "description": {"key": "description", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "modified_by_user": {"key": "modifiedByUser", "type": "ModifiedByUserResponse"},
        "modified_on_timestamp": {"key": "modifiedOnTimestamp", "type": "iso-8601"},
        "partitioning_granularity": {"key": "partitioningGranularity", "type": "str"},
        "queryable_schema": {"key": "queryableSchema", "type": "[DruidTableColumn]"},
        "storage_policy": {"key": "storagePolicy", "type": "TableStoragePolicy"},
        "schema_mode": {"key": "schemaMode", "type": "str"},
        "segment_compacted_bytes": {"key": "segmentCompactedBytes", "type": "int"},
        "segment_count": {"key": "segmentCount", "type": "int"},
        "segment_total_bytes": {"key": "segmentTotalBytes", "type": "int"},
        "precached_data_size_bytes": {"key": "precachedDataSizeBytes", "type": "int"},
        "total_data_size_bytes": {"key": "totalDataSizeBytes", "type": "int"},
        "total_rows": {"key": "totalRows", "type": "int"},
    }

    _subtype_map = {
        "type": {"aggregate": "AggregateTablePayload", "detail": "DetailTablePayload"}
    }

    def __init__(
        self,
        *,
        name: str,
        version: int = 0,
        clustering_columns: Optional[List[str]] = None,
        description: Optional[str] = None,
        partitioning_granularity: Union[
            str, "_models.TablePartitioningGranularity"
        ] = "day",
        storage_policy: Optional["_models.TableStoragePolicy"] = None,
        schema_mode: Optional[Union[str, "_models.TableSchemaMode"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: The unique, immutable name of the table. Required.
        :paramtype name: str
        :keyword version: The version number of the table. Newly created tables are always initialized
         at version 0. Do not provide the version number when creating a table. When updating a table,
         provide the current table version number. If the version number in the request is not the
         current version, Polaris raises a ``409 Conflict`` error. In that case, retrieve the latest
         version and retry the request to avoid concurrently conflicting changes. Required.
        :paramtype version: int
        :keyword clustering_columns: Table columns to use for clustering. Polaris sorts table columns
         within the partition based
         on their order in this array.

         For aggregate tables, only dimensions (not measures) are supported for clustering.
         If a nonexistent column is specified, Polaris raises a ``400 Bad Request``
         error.

         For more information, see `Clustering
         <https://docs.imply.io/ui/saas/help/partitioning.html>`_.
        :paramtype clustering_columns: list[str]
        :keyword description: The table's description, limited to 1000 characters.
        :paramtype description: str
        :keyword partitioning_granularity: The `time partitioning
         <https://docs.imply.io/ui/saas/help/partitioning.html>`_ of the table. The ``all`` granularity
         groups all data into a single bucket. The ``week`` granularity is deprecated. You can't create
         a new table with the time partitioning set to ``week``. A table sourced by a lookup can only
         use all partitioning. You can’t change this setting on a table that’s actively used by a
         lookup. Known values are: "second", "minute", "five_minute", "ten_minute", "fifteen_minute",
         "thirty_minute", "hour", "six_hour", "eight_hour", "day", "week", "month", "quarter", "year",
         and "all".
        :paramtype partitioning_granularity: str or
         ~polaris.sdk.global_api.models.TablePartitioningGranularity
        :keyword storage_policy: Policy specifying the time range of data to retain or precache.


         * The ``retain`` storage policy determines how long to keep data after which it is deleted.
         * The ``cached`` storage policy determines how long to keep data precached.
           Outside of the ``cached`` policy time range, data isn't precached and only resides in lower
         cost deep storage.

         By default, Polaris retains all data and precaches all data.
         You can’t set a custom storage policy for a table that’s actively used by a lookup.
         For more information, see
         `Data lifecycle management
         <https://docs.imply.io/ui/saas/help/data-lifecycle-management.html>`_.
        :paramtype storage_policy: ~polaris.sdk.global_api.models.TableStoragePolicy
        :keyword schema_mode: The table's schema enforcement mode. For more information, see
         `Introduction to tables <https://docs.imply.io/ui/saas/help/tables.html>`_. Known values are:
         "flexible" and "strict".
        :paramtype schema_mode: str or ~polaris.sdk.global_api.models.TableSchemaMode
        """
        super().__init__(**kwargs)
        self.name = name
        self.type: Optional[str] = None
        self.version = version
        self.availability = None
        self.clustering_columns = clustering_columns
        self.created_by_user = None
        self.created_on_timestamp = None
        self.description = description
        self.id = None
        self.modified_by_user = None
        self.modified_on_timestamp = None
        self.partitioning_granularity = partitioning_granularity
        self.queryable_schema = None
        self.storage_policy = storage_policy
        self.schema_mode = schema_mode
        self.segment_compacted_bytes = None
        self.segment_count = None
        self.segment_total_bytes = None
        self.precached_data_size_bytes = None
        self.total_data_size_bytes = None
        self.total_rows = None


class AggregateTablePayload(TablePayload):
    """An aggregate table "rolls up" or aggregates multiple rows of data to reduce the number of rows
    in a table and improve query performance. Aggregate tables may provide significant performance
    advantages when the application only needs aggregate level information at some time resolution.
    See `Introduction to data rollup <https://docs.imply.io/ui/saas/help/rollup.html>`_ for more
    details.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar name: The unique, immutable name of the table. Required.
    :vartype name: str
    :ivar type: Visualization type. Required. Known values are: "table", "detail", and "aggregate".
    :vartype type: str or ~polaris.sdk.global_api.models.TableType
    :ivar version: The version number of the table. Newly created tables are always initialized at
     version 0. Do not provide the version number when creating a table. When updating a table,
     provide the current table version number. If the version number in the request is not the
     current version, Polaris raises a ``409 Conflict`` error. In that case, retrieve the latest
     version and retry the request to avoid concurrently conflicting changes. Required.
    :vartype version: int
    :ivar availability: The availability status of the table:


     * ``available``   - All data in table is available for querying.
     * ``deleting``    - The table is being deleted.
     * ``unavailable`` - Not all data in the table is available for querying. Known values are:
     "available", "deleting", and "unavailable".
    :vartype availability: str or ~polaris.sdk.global_api.models.TableAvailability
    :ivar clustering_columns: Table columns to use for clustering. Polaris sorts table columns
     within the partition based
     on their order in this array.

     For aggregate tables, only dimensions (not measures) are supported for clustering.
     If a nonexistent column is specified, Polaris raises a ``400 Bad Request``
     error.

     For more information, see `Clustering
     <https://docs.imply.io/ui/saas/help/partitioning.html>`_.
    :vartype clustering_columns: list[str]
    :ivar created_by_user: The user who created the initial object.
    :vartype created_by_user: ~polaris.sdk.global_api.models.CreatedByUserResponse
    :ivar created_on_timestamp: The date and time this object was created in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype created_on_timestamp: ~datetime.datetime
    :ivar description: The table's description, limited to 1000 characters.
    :vartype description: str
    :ivar id: A generated, permanently unique ID for this table.
    :vartype id: str
    :ivar modified_by_user: The user who modified the object last.
    :vartype modified_by_user: ~polaris.sdk.global_api.models.ModifiedByUserResponse
    :ivar modified_on_timestamp: The date and time this table was last modified in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype modified_on_timestamp: ~datetime.datetime
    :ivar partitioning_granularity: The `time partitioning
     <https://docs.imply.io/ui/saas/help/partitioning.html>`_ of the table. The ``all`` granularity
     groups all data into a single bucket. The ``week`` granularity is deprecated. You can't create
     a new table with the time partitioning set to ``week``. A table sourced by a lookup can only
     use all partitioning. You can’t change this setting on a table that’s actively used by a
     lookup. Known values are: "second", "minute", "five_minute", "ten_minute", "fifteen_minute",
     "thirty_minute", "hour", "six_hour", "eight_hour", "day", "week", "month", "quarter", "year",
     and "all".
    :vartype partitioning_granularity: str or
     ~polaris.sdk.global_api.models.TablePartitioningGranularity
    :ivar queryable_schema: The queryable schema of the table. May include undeclared columns (in
     flexible tables only) or declared columns (in strict or flexible tables).
    :vartype queryable_schema: list[~polaris.sdk.global_api.models.DruidTableColumn]
    :ivar storage_policy: Policy specifying the time range of data to retain or precache.


     * The ``retain`` storage policy determines how long to keep data after which it is deleted.
     * The ``cached`` storage policy determines how long to keep data precached.
       Outside of the ``cached`` policy time range, data isn't precached and only resides in lower
     cost deep storage.

     By default, Polaris retains all data and precaches all data.
     You can’t set a custom storage policy for a table that’s actively used by a lookup.
     For more information, see
     `Data lifecycle management
     <https://docs.imply.io/ui/saas/help/data-lifecycle-management.html>`_.
    :vartype storage_policy: ~polaris.sdk.global_api.models.TableStoragePolicy
    :ivar schema_mode: The table's schema enforcement mode. For more information, see `Introduction
     to tables <https://docs.imply.io/ui/saas/help/tables.html>`_. Known values are: "flexible" and
     "strict".
    :vartype schema_mode: str or ~polaris.sdk.global_api.models.TableSchemaMode
    :ivar segment_compacted_bytes: Total compacted bytes of the table.
    :vartype segment_compacted_bytes: int
    :ivar segment_count: The number of segments in the table.
    :vartype segment_count: int
    :ivar segment_total_bytes: Total bytes of the table.
    :vartype segment_total_bytes: int
    :ivar precached_data_size_bytes: The total size of the table in bytes.
    :vartype precached_data_size_bytes: int
    :ivar total_data_size_bytes: The total size of the table in bytes.
    :vartype total_data_size_bytes: int
    :ivar total_rows: The total number of rows stored in the table.
    :vartype total_rows: int
    :ivar query_granularity: The table's rollup granularity. Determines how to bucket data across
     the time dimension, such as aggregating data by hour.
     When set, ``queryGranularity`` overrides the rollup granularity in ``timeResolution``.
    :vartype query_granularity: ~polaris.sdk.global_api.models.GranularityPayload
    :ivar schema: The table's schema. The order of the elements determines the order of the columns
     in the Polaris UI and in ``SELECT *`` SQL queries.
    :vartype schema: list[~polaris.sdk.global_api.models.AggregateTableColumn]
    :ivar time_resolution: The table's rollup granularity. See `Introduction to data rollup
     <https://docs.imply.io/ui/saas/help/rollup.html>`_ for more details.

     You can specify a variable duration or a time zone and origin for a ``period``\\ -type query
     granularity.
     When set, ``queryGranularity`` overrides the rollup granularity in ``timeResolution``. Known
     values are: "millisecond", "second", "minute", "fifteen_minute", "thirty_minute", "hour",
     "day", "week", "month", "quarter", "year", and "all".
    :vartype time_resolution: str or ~polaris.sdk.global_api.models.TimeResolution
    """

    _validation = {
        "name": {"required": True, "max_length": 255, "min_length": 1},
        "type": {"required": True},
        "version": {"required": True},
        "availability": {"readonly": True},
        "created_by_user": {"readonly": True},
        "created_on_timestamp": {"readonly": True},
        "id": {"readonly": True},
        "modified_by_user": {"readonly": True},
        "modified_on_timestamp": {"readonly": True},
        "queryable_schema": {"readonly": True},
        "segment_compacted_bytes": {"readonly": True},
        "segment_count": {"readonly": True},
        "segment_total_bytes": {"readonly": True},
        "precached_data_size_bytes": {"readonly": True},
        "total_data_size_bytes": {"readonly": True},
        "total_rows": {"readonly": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "version": {"key": "version", "type": "int"},
        "availability": {"key": "availability", "type": "str"},
        "clustering_columns": {"key": "clusteringColumns", "type": "[str]"},
        "created_by_user": {"key": "createdByUser", "type": "CreatedByUserResponse"},
        "created_on_timestamp": {"key": "createdOnTimestamp", "type": "iso-8601"},
        "description": {"key": "description", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "modified_by_user": {"key": "modifiedByUser", "type": "ModifiedByUserResponse"},
        "modified_on_timestamp": {"key": "modifiedOnTimestamp", "type": "iso-8601"},
        "partitioning_granularity": {"key": "partitioningGranularity", "type": "str"},
        "queryable_schema": {"key": "queryableSchema", "type": "[DruidTableColumn]"},
        "storage_policy": {"key": "storagePolicy", "type": "TableStoragePolicy"},
        "schema_mode": {"key": "schemaMode", "type": "str"},
        "segment_compacted_bytes": {"key": "segmentCompactedBytes", "type": "int"},
        "segment_count": {"key": "segmentCount", "type": "int"},
        "segment_total_bytes": {"key": "segmentTotalBytes", "type": "int"},
        "precached_data_size_bytes": {"key": "precachedDataSizeBytes", "type": "int"},
        "total_data_size_bytes": {"key": "totalDataSizeBytes", "type": "int"},
        "total_rows": {"key": "totalRows", "type": "int"},
        "query_granularity": {"key": "queryGranularity", "type": "GranularityPayload"},
        "schema": {"key": "schema", "type": "[AggregateTableColumn]"},
        "time_resolution": {"key": "timeResolution", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        name: str,
        version: int = 0,
        clustering_columns: Optional[List[str]] = None,
        description: Optional[str] = None,
        partitioning_granularity: Union[
            str, "_models.TablePartitioningGranularity"
        ] = "day",
        storage_policy: Optional["_models.TableStoragePolicy"] = None,
        schema_mode: Optional[Union[str, "_models.TableSchemaMode"]] = None,
        query_granularity: Optional["_models.GranularityPayload"] = None,
        schema: List["_models.AggregateTableColumn"] = [],
        time_resolution: Union[str, "_models.TimeResolution"] = "millisecond",
        **kwargs: Any
    ) -> None:
        """
        :keyword name: The unique, immutable name of the table. Required.
        :paramtype name: str
        :keyword version: The version number of the table. Newly created tables are always initialized
         at version 0. Do not provide the version number when creating a table. When updating a table,
         provide the current table version number. If the version number in the request is not the
         current version, Polaris raises a ``409 Conflict`` error. In that case, retrieve the latest
         version and retry the request to avoid concurrently conflicting changes. Required.
        :paramtype version: int
        :keyword clustering_columns: Table columns to use for clustering. Polaris sorts table columns
         within the partition based
         on their order in this array.

         For aggregate tables, only dimensions (not measures) are supported for clustering.
         If a nonexistent column is specified, Polaris raises a ``400 Bad Request``
         error.

         For more information, see `Clustering
         <https://docs.imply.io/ui/saas/help/partitioning.html>`_.
        :paramtype clustering_columns: list[str]
        :keyword description: The table's description, limited to 1000 characters.
        :paramtype description: str
        :keyword partitioning_granularity: The `time partitioning
         <https://docs.imply.io/ui/saas/help/partitioning.html>`_ of the table. The ``all`` granularity
         groups all data into a single bucket. The ``week`` granularity is deprecated. You can't create
         a new table with the time partitioning set to ``week``. A table sourced by a lookup can only
         use all partitioning. You can’t change this setting on a table that’s actively used by a
         lookup. Known values are: "second", "minute", "five_minute", "ten_minute", "fifteen_minute",
         "thirty_minute", "hour", "six_hour", "eight_hour", "day", "week", "month", "quarter", "year",
         and "all".
        :paramtype partitioning_granularity: str or
         ~polaris.sdk.global_api.models.TablePartitioningGranularity
        :keyword storage_policy: Policy specifying the time range of data to retain or precache.


         * The ``retain`` storage policy determines how long to keep data after which it is deleted.
         * The ``cached`` storage policy determines how long to keep data precached.
           Outside of the ``cached`` policy time range, data isn't precached and only resides in lower
         cost deep storage.

         By default, Polaris retains all data and precaches all data.
         You can’t set a custom storage policy for a table that’s actively used by a lookup.
         For more information, see
         `Data lifecycle management
         <https://docs.imply.io/ui/saas/help/data-lifecycle-management.html>`_.
        :paramtype storage_policy: ~polaris.sdk.global_api.models.TableStoragePolicy
        :keyword schema_mode: The table's schema enforcement mode. For more information, see
         `Introduction to tables <https://docs.imply.io/ui/saas/help/tables.html>`_. Known values are:
         "flexible" and "strict".
        :paramtype schema_mode: str or ~polaris.sdk.global_api.models.TableSchemaMode
        :keyword query_granularity: The table's rollup granularity. Determines how to bucket data
         across the time dimension, such as aggregating data by hour.
         When set, ``queryGranularity`` overrides the rollup granularity in ``timeResolution``.
        :paramtype query_granularity: ~polaris.sdk.global_api.models.GranularityPayload
        :keyword schema: The table's schema. The order of the elements determines the order of the
         columns in the Polaris UI and in ``SELECT *`` SQL queries.
        :paramtype schema: list[~polaris.sdk.global_api.models.AggregateTableColumn]
        :keyword time_resolution: The table's rollup granularity. See `Introduction to data rollup
         <https://docs.imply.io/ui/saas/help/rollup.html>`_ for more details.

         You can specify a variable duration or a time zone and origin for a ``period``\\ -type query
         granularity.
         When set, ``queryGranularity`` overrides the rollup granularity in ``timeResolution``. Known
         values are: "millisecond", "second", "minute", "fifteen_minute", "thirty_minute", "hour",
         "day", "week", "month", "quarter", "year", and "all".
        :paramtype time_resolution: str or ~polaris.sdk.global_api.models.TimeResolution
        """
        super().__init__(
            name=name,
            version=version,
            clustering_columns=clustering_columns,
            description=description,
            partitioning_granularity=partitioning_granularity,
            storage_policy=storage_policy,
            schema_mode=schema_mode,
            **kwargs
        )
        self.type: str = "aggregate"
        self.query_granularity = query_granularity
        self.schema = schema
        self.time_resolution = time_resolution


class AlertPayload(_serialization.Model):
    """Alert conditions and evaluation criteria.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar owner: User ID of the alert owner. The owner can modify the alert and its recipient list.
    :vartype owner: str
    :ivar title: Alert title to display in the Polaris UI, and in emails and webhooks.
    :vartype title: str
    :ivar data_cube: Identifies the data cube that the alert is based on.
    :vartype data_cube: str
    :ivar date_time_to_start: Date and time to start triggering alerts. The timezone is UTC.
    :vartype date_time_to_start: str
    :ivar instance: Optional instance ID to use for the alert configuration.
    :vartype instance: str
    :ivar type: Specify ``overall`` to evaluate against a measure, and ``within-split`` to evaluate
     against a dimension. Known values are: "overall" and "within-split".
    :vartype type: str or ~polaris.sdk.global_api.models.AlertType
    :ivar check_frequency: How often Polaris evaluates alert criteria, expressed as an `ISO 8601
     duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype check_frequency: ~datetime.timedelta
    :ivar time_frame: Controls the amount of data Polaris considers when evaluating the alert
     criteria based upon a time interval,
     expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype time_frame: ~datetime.timedelta
    :ivar compare: For a relative condition, such as when a measure changes by a certain value,
     specify a comparison period or set a custom period. When not provided, the alert triggers
     based
     on an absolute condition, such as when a certain measure is greater than a certain value.
    :vartype compare: ~polaris.sdk.global_api.models.Compare
    :ivar filter: You can define one or more filters to restrict the alert data Polaris gathers
     during alert evaluation.
     You can't define a static time filter.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar splits: Dimension values to use when alert type is ``within-split``.
    :vartype splits: any
    :ivar condition_operation: Select whether one or all conditions must be true to trigger the
     alert. Known values are: "and" and "or".
    :vartype condition_operation: str or ~polaris.sdk.global_api.models.ConditionOperation
    :ivar conditions: Specify one or more conditions to trigger your alert.
     If you specify more than one condition, you can set the ``conditionOperation`` property to
     determine whether one or all conditions must be true to trigger the alert.
    :vartype conditions: list[~polaris.sdk.global_api.models.AlertCondition]
    :ivar severity: Severity determines the alert's color and icon in the Polaris UI. Known values
     are: "info", "warning", "error", and "ok".
    :vartype severity: str or ~polaris.sdk.global_api.models.Severity
    :ivar read_access: List of users with read access to the alert.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar recipients: List of users to notify when the alert triggers.
    :vartype recipients: ~polaris.sdk.global_api.models.AccessList
    :ivar admins: List of users who can modify the alert.
    :vartype admins: ~polaris.sdk.global_api.models.AccessList
    :ivar webhooks: Webhooks to call when the alert is triggered.
    :vartype webhooks: list[~polaris.sdk.global_api.models.Webhook]
    :ivar disabled: Disables the alert. Polaris doesn't evaluate disabled alerts or trigger
     notifications.
    :vartype disabled: bool
    :ivar send_email_to_recipients: Send email notifications to the alert recipients when the alert
     triggers.
    :vartype send_email_to_recipients: bool
    :ivar latest_data_strategy_override: Override the latest data strategy for the alert. If not
     specified, Polaris uses the
     latest data strategy from the data cube.
    :vartype latest_data_strategy_override: str
    :ivar external_emails: External email addresses to notify when the alert triggers.
    :vartype external_emails: list[str]
    :ivar example_query: Parameterized query string Polaris uses to evaluate the alert. Evaluates
     to ``true``
     or ``false``. You can copy the example query, customize it, and run it with a parameter for
     the upper time bound to determine whether it would trigger the alert (\\ ``true``\\ ) or not
     (\\ ``false``\\ ).
    :vartype example_query: str
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
        "owner": {"max_length": 255, "min_length": 1},
        "data_cube": {"max_length": 255, "min_length": 1},
        "example_query": {"readonly": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "owner": {"key": "owner", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "date_time_to_start": {"key": "dateTimeToStart", "type": "str"},
        "instance": {"key": "instance", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "check_frequency": {"key": "checkFrequency", "type": "duration"},
        "time_frame": {"key": "timeFrame", "type": "duration"},
        "compare": {"key": "compare", "type": "Compare"},
        "filter": {"key": "filter", "type": "Filter"},
        "splits": {"key": "splits", "type": "object"},
        "condition_operation": {"key": "conditionOperation", "type": "str"},
        "conditions": {"key": "conditions", "type": "[AlertCondition]"},
        "severity": {"key": "severity", "type": "str"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "recipients": {"key": "recipients", "type": "AccessList"},
        "admins": {"key": "admins", "type": "AccessList"},
        "webhooks": {"key": "webhooks", "type": "[Webhook]"},
        "disabled": {"key": "disabled", "type": "bool"},
        "send_email_to_recipients": {"key": "sendEmailToRecipients", "type": "bool"},
        "latest_data_strategy_override": {
            "key": "latestDataStrategyOverride",
            "type": "str",
        },
        "external_emails": {"key": "externalEmails", "type": "[str]"},
        "example_query": {"key": "exampleQuery", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        owner: Optional[str] = None,
        title: Optional[str] = None,
        data_cube: Optional[str] = None,
        date_time_to_start: Optional[str] = None,
        instance: Optional[str] = None,
        type: Optional[Union[str, "_models.AlertType"]] = None,
        check_frequency: Optional[datetime.timedelta] = None,
        time_frame: Optional[datetime.timedelta] = None,
        compare: Optional["_models.Compare"] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        splits: Optional[Any] = None,
        condition_operation: Optional[Union[str, "_models.ConditionOperation"]] = None,
        conditions: Optional[List["_models.AlertCondition"]] = None,
        severity: Union[str, "_models.Severity"] = "info",
        read_access: Optional["_models.AccessList"] = None,
        recipients: Optional["_models.AccessList"] = None,
        admins: Optional["_models.AccessList"] = None,
        webhooks: Optional[List["_models.Webhook"]] = None,
        disabled: Optional[bool] = None,
        send_email_to_recipients: Optional[bool] = None,
        latest_data_strategy_override: Optional[str] = None,
        external_emails: Optional[List[str]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword owner: User ID of the alert owner. The owner can modify the alert and its recipient
         list.
        :paramtype owner: str
        :keyword title: Alert title to display in the Polaris UI, and in emails and webhooks.
        :paramtype title: str
        :keyword data_cube: Identifies the data cube that the alert is based on.
        :paramtype data_cube: str
        :keyword date_time_to_start: Date and time to start triggering alerts. The timezone is UTC.
        :paramtype date_time_to_start: str
        :keyword instance: Optional instance ID to use for the alert configuration.
        :paramtype instance: str
        :keyword type: Specify ``overall`` to evaluate against a measure, and ``within-split`` to
         evaluate against a dimension. Known values are: "overall" and "within-split".
        :paramtype type: str or ~polaris.sdk.global_api.models.AlertType
        :keyword check_frequency: How often Polaris evaluates alert criteria, expressed as an `ISO 8601
         duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype check_frequency: ~datetime.timedelta
        :keyword time_frame: Controls the amount of data Polaris considers when evaluating the alert
         criteria based upon a time interval,
         expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype time_frame: ~datetime.timedelta
        :keyword compare: For a relative condition, such as when a measure changes by a certain value,
         specify a comparison period or set a custom period. When not provided, the alert triggers
         based
         on an absolute condition, such as when a certain measure is greater than a certain value.
        :paramtype compare: ~polaris.sdk.global_api.models.Compare
        :keyword filter: You can define one or more filters to restrict the alert data Polaris gathers
         during alert evaluation.
         You can't define a static time filter.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword splits: Dimension values to use when alert type is ``within-split``.
        :paramtype splits: any
        :keyword condition_operation: Select whether one or all conditions must be true to trigger the
         alert. Known values are: "and" and "or".
        :paramtype condition_operation: str or ~polaris.sdk.global_api.models.ConditionOperation
        :keyword conditions: Specify one or more conditions to trigger your alert.
         If you specify more than one condition, you can set the ``conditionOperation`` property to
         determine whether one or all conditions must be true to trigger the alert.
        :paramtype conditions: list[~polaris.sdk.global_api.models.AlertCondition]
        :keyword severity: Severity determines the alert's color and icon in the Polaris UI. Known
         values are: "info", "warning", "error", and "ok".
        :paramtype severity: str or ~polaris.sdk.global_api.models.Severity
        :keyword read_access: List of users with read access to the alert.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword recipients: List of users to notify when the alert triggers.
        :paramtype recipients: ~polaris.sdk.global_api.models.AccessList
        :keyword admins: List of users who can modify the alert.
        :paramtype admins: ~polaris.sdk.global_api.models.AccessList
        :keyword webhooks: Webhooks to call when the alert is triggered.
        :paramtype webhooks: list[~polaris.sdk.global_api.models.Webhook]
        :keyword disabled: Disables the alert. Polaris doesn't evaluate disabled alerts or trigger
         notifications.
        :paramtype disabled: bool
        :keyword send_email_to_recipients: Send email notifications to the alert recipients when the
         alert triggers.
        :paramtype send_email_to_recipients: bool
        :keyword latest_data_strategy_override: Override the latest data strategy for the alert. If not
         specified, Polaris uses the
         latest data strategy from the data cube.
        :paramtype latest_data_strategy_override: str
        :keyword external_emails: External email addresses to notify when the alert triggers.
        :paramtype external_emails: list[str]
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.owner = owner
        self.title = title
        self.data_cube = data_cube
        self.date_time_to_start = date_time_to_start
        self.instance = instance
        self.type = type
        self.check_frequency = check_frequency
        self.time_frame = time_frame
        self.compare = compare
        self.filter = filter
        self.splits = splits
        self.condition_operation = condition_operation
        self.conditions = conditions
        self.severity = severity
        self.read_access = read_access
        self.recipients = recipients
        self.admins = admins
        self.webhooks = webhooks
        self.disabled = disabled
        self.send_email_to_recipients = send_email_to_recipients
        self.latest_data_strategy_override = latest_data_strategy_override
        self.external_emails = external_emails
        self.example_query = None


class AlertBody(AlertPayload):
    """AlertBody.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar owner: User ID of the alert owner. The owner can modify the alert and its recipient list.
    :vartype owner: str
    :ivar title: Alert title to display in the Polaris UI, and in emails and webhooks.
    :vartype title: str
    :ivar data_cube: Identifies the data cube that the alert is based on.
    :vartype data_cube: str
    :ivar date_time_to_start: Date and time to start triggering alerts. The timezone is UTC.
    :vartype date_time_to_start: str
    :ivar instance: Optional instance ID to use for the alert configuration.
    :vartype instance: str
    :ivar type: Specify ``overall`` to evaluate against a measure, and ``within-split`` to evaluate
     against a dimension. Known values are: "overall" and "within-split".
    :vartype type: str or ~polaris.sdk.global_api.models.AlertType
    :ivar check_frequency: How often Polaris evaluates alert criteria, expressed as an `ISO 8601
     duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype check_frequency: ~datetime.timedelta
    :ivar time_frame: Controls the amount of data Polaris considers when evaluating the alert
     criteria based upon a time interval,
     expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype time_frame: ~datetime.timedelta
    :ivar compare: For a relative condition, such as when a measure changes by a certain value,
     specify a comparison period or set a custom period. When not provided, the alert triggers
     based
     on an absolute condition, such as when a certain measure is greater than a certain value.
    :vartype compare: ~polaris.sdk.global_api.models.Compare
    :ivar filter: You can define one or more filters to restrict the alert data Polaris gathers
     during alert evaluation.
     You can't define a static time filter.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar splits: Dimension values to use when alert type is ``within-split``.
    :vartype splits: any
    :ivar condition_operation: Select whether one or all conditions must be true to trigger the
     alert. Known values are: "and" and "or".
    :vartype condition_operation: str or ~polaris.sdk.global_api.models.ConditionOperation
    :ivar conditions: Specify one or more conditions to trigger your alert.
     If you specify more than one condition, you can set the ``conditionOperation`` property to
     determine whether one or all conditions must be true to trigger the alert.
    :vartype conditions: list[~polaris.sdk.global_api.models.AlertCondition]
    :ivar severity: Severity determines the alert's color and icon in the Polaris UI. Known values
     are: "info", "warning", "error", and "ok".
    :vartype severity: str or ~polaris.sdk.global_api.models.Severity
    :ivar read_access: List of users with read access to the alert.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar recipients: List of users to notify when the alert triggers.
    :vartype recipients: ~polaris.sdk.global_api.models.AccessList
    :ivar admins: List of users who can modify the alert.
    :vartype admins: ~polaris.sdk.global_api.models.AccessList
    :ivar webhooks: Webhooks to call when the alert is triggered.
    :vartype webhooks: list[~polaris.sdk.global_api.models.Webhook]
    :ivar disabled: Disables the alert. Polaris doesn't evaluate disabled alerts or trigger
     notifications.
    :vartype disabled: bool
    :ivar send_email_to_recipients: Send email notifications to the alert recipients when the alert
     triggers.
    :vartype send_email_to_recipients: bool
    :ivar latest_data_strategy_override: Override the latest data strategy for the alert. If not
     specified, Polaris uses the
     latest data strategy from the data cube.
    :vartype latest_data_strategy_override: str
    :ivar external_emails: External email addresses to notify when the alert triggers.
    :vartype external_emails: list[str]
    :ivar example_query: Parameterized query string Polaris uses to evaluate the alert. Evaluates
     to ``true``
     or ``false``. You can copy the example query, customize it, and run it with a parameter for
     the upper time bound to determine whether it would trigger the alert (\\ ``true``\\ ) or not
     (\\ ``false``\\ ).
    :vartype example_query: str
    """


class AlertCondition(_serialization.Model):
    """Condition that must be true for the alert to trigger.

    All required parameters must be populated in order to send to server.

    :ivar type: Specify ``value`` to evaluate against an absolute value, ``delta`` to evaluate
     against the
     change in absolute value, or ``percent-delta`` to evaluate against the percentage change
     in the measure value. Required. Known values are: "value", "delta", and "percent-delta".
    :vartype type: str or ~polaris.sdk.global_api.models.AlertConditionType
    :ivar measure: Measure to evaluate. Required.
    :vartype measure: str
    :ivar condition: Operator to use when evaluating the measure. Required. Known values are:
     "lessThan" and "greaterThan".
    :vartype condition: str or ~polaris.sdk.global_api.models.AlertConditionOperator
    :ivar value: Value to compare against the measure. Required.
    :vartype value: float
    """

    _validation = {
        "type": {"required": True},
        "measure": {"required": True, "max_length": 255, "min_length": 1},
        "condition": {"required": True},
        "value": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "measure": {"key": "measure", "type": "str"},
        "condition": {"key": "condition", "type": "str"},
        "value": {"key": "value", "type": "float"},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.AlertConditionType"],
        measure: str,
        condition: Union[str, "_models.AlertConditionOperator"],
        value: float,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Specify ``value`` to evaluate against an absolute value, ``delta`` to evaluate
         against the
         change in absolute value, or ``percent-delta`` to evaluate against the percentage change
         in the measure value. Required. Known values are: "value", "delta", and "percent-delta".
        :paramtype type: str or ~polaris.sdk.global_api.models.AlertConditionType
        :keyword measure: Measure to evaluate. Required.
        :paramtype measure: str
        :keyword condition: Operator to use when evaluating the measure. Required. Known values are:
         "lessThan" and "greaterThan".
        :paramtype condition: str or ~polaris.sdk.global_api.models.AlertConditionOperator
        :keyword value: Value to compare against the measure. Required.
        :paramtype value: float
        """
        super().__init__(**kwargs)
        self.type = type
        self.measure = measure
        self.condition = condition
        self.value = value


class AlertEvaluationError(_serialization.Model):
    """Error that occurred during alert evaluation.

    All required parameters must be populated in order to send to server.

    :ivar type: Type of error that occurred during alert evaluation. Required. Known values are:
     "internal-error", "webhook-error", "email-error", and "misconfiguration-error".
    :vartype type: str or ~polaris.sdk.global_api.models.AlertEvaluationErrorType
    :ivar message: Error message. Required.
    :vartype message: str
    """

    _validation = {
        "type": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "message": {"key": "message", "type": "str"},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.AlertEvaluationErrorType"],
        message: str,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Type of error that occurred during alert evaluation. Required. Known values are:
         "internal-error", "webhook-error", "email-error", and "misconfiguration-error".
        :paramtype type: str or ~polaris.sdk.global_api.models.AlertEvaluationErrorType
        :keyword message: Error message. Required.
        :paramtype message: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.message = message


class AlertEvaluationListResponse(_serialization.Model):
    """List of alert evaluations.

    All required parameters must be populated in order to send to server.

    :ivar values: Array of alert evaluations. Required.
    :vartype values: list[~polaris.sdk.global_api.models.AlertEvaluationPayload]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[AlertEvaluationPayload]"},
    }

    def __init__(
        self, *, values: List["_models.AlertEvaluationPayload"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Array of alert evaluations. Required.
        :paramtype values: list[~polaris.sdk.global_api.models.AlertEvaluationPayload]
        """
        super().__init__(**kwargs)
        self.values = values


class AlertEvaluationPayload(_serialization.Model):
    """Single instance of an alert trigger, its conditions, and the value of the data.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID. Required.
    :vartype id: str
    :ivar alert_id: ID of the related alert. Required.
    :vartype alert_id: str
    :ivar alert: Payloads of the related alert.
    :vartype alert: ~polaris.sdk.global_api.models.AlertPayload
    :ivar trigger_date: Timestamp of the alert trigger. Required.
    :vartype trigger_date: ~datetime.datetime
    :ivar max_date: Timestamp of the latest data used to evaluate the alert. Required.
    :vartype max_date: ~datetime.datetime
    :ivar title: Alert title. Required.
    :vartype title: str
    :ivar summaries: Summary of the alert evaluation. Required.
    :vartype summaries: list[~polaris.sdk.global_api.models.AlertEvaluationSummary]
    :ivar errors: Errors that occurred during alert evaluation. Required.
    :vartype errors: list[~polaris.sdk.global_api.models.AlertEvaluationError]
    :ivar queries: Queries Polaris ran to evaluate the alert.
    :vartype queries: list[str]
    """

    _validation = {
        "id": {"required": True, "max_length": 255, "min_length": 1},
        "alert_id": {"required": True, "max_length": 255, "min_length": 1},
        "trigger_date": {"required": True},
        "max_date": {"required": True},
        "title": {"required": True},
        "summaries": {"required": True},
        "errors": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "alert_id": {"key": "alertId", "type": "str"},
        "alert": {"key": "alert", "type": "AlertPayload"},
        "trigger_date": {"key": "triggerDate", "type": "iso-8601"},
        "max_date": {"key": "maxDate", "type": "iso-8601"},
        "title": {"key": "title", "type": "str"},
        "summaries": {"key": "summaries", "type": "[AlertEvaluationSummary]"},
        "errors": {"key": "errors", "type": "[AlertEvaluationError]"},
        "queries": {"key": "queries", "type": "[str]"},
    }

    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        alert_id: str,
        trigger_date: datetime.datetime,
        max_date: datetime.datetime,
        title: str,
        summaries: List["_models.AlertEvaluationSummary"],
        errors: List["_models.AlertEvaluationError"],
        additional_properties: Optional[Dict[str, Any]] = None,
        alert: Optional["_models.AlertPayload"] = None,
        queries: Optional[List[str]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID. Required.
        :paramtype id: str
        :keyword alert_id: ID of the related alert. Required.
        :paramtype alert_id: str
        :keyword alert: Payloads of the related alert.
        :paramtype alert: ~polaris.sdk.global_api.models.AlertPayload
        :keyword trigger_date: Timestamp of the alert trigger. Required.
        :paramtype trigger_date: ~datetime.datetime
        :keyword max_date: Timestamp of the latest data used to evaluate the alert. Required.
        :paramtype max_date: ~datetime.datetime
        :keyword title: Alert title. Required.
        :paramtype title: str
        :keyword summaries: Summary of the alert evaluation. Required.
        :paramtype summaries: list[~polaris.sdk.global_api.models.AlertEvaluationSummary]
        :keyword errors: Errors that occurred during alert evaluation. Required.
        :paramtype errors: list[~polaris.sdk.global_api.models.AlertEvaluationError]
        :keyword queries: Queries Polaris ran to evaluate the alert.
        :paramtype queries: list[str]
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.alert_id = alert_id
        self.alert = alert
        self.trigger_date = trigger_date
        self.max_date = max_date
        self.title = title
        self.summaries = summaries
        self.errors = errors
        self.queries = queries


class AlertEvaluationSummary(_serialization.Model):
    """Summary of the alert evaluation.

    All required parameters must be populated in order to send to server.

    :ivar value: Formatted measure value that triggered the alert. Required.
    :vartype value: str
    :ivar event: Description of the event that triggered the alert. Required.
    :vartype event: str
    :ivar event_data: Raw evaluation data. Required.
    :vartype event_data: list[~polaris.sdk.global_api.models.AlertEvaluationSummaryData]
    """

    _validation = {
        "value": {"required": True},
        "event": {"required": True},
        "event_data": {"required": True},
    }

    _attribute_map = {
        "value": {"key": "value", "type": "str"},
        "event": {"key": "event", "type": "str"},
        "event_data": {"key": "eventData", "type": "[AlertEvaluationSummaryData]"},
    }

    def __init__(
        self,
        *,
        value: str,
        event: str,
        event_data: List["_models.AlertEvaluationSummaryData"],
        **kwargs: Any
    ) -> None:
        """
        :keyword value: Formatted measure value that triggered the alert. Required.
        :paramtype value: str
        :keyword event: Description of the event that triggered the alert. Required.
        :paramtype event: str
        :keyword event_data: Raw evaluation data. Required.
        :paramtype event_data: list[~polaris.sdk.global_api.models.AlertEvaluationSummaryData]
        """
        super().__init__(**kwargs)
        self.value = value
        self.event = event
        self.event_data = event_data


class AlertEvaluationSummaryData(_serialization.Model):
    """Raw alert evaluation result.

    All required parameters must be populated in order to send to server.

    :ivar summary: Formatted description of the evaluation result. Required.
    :vartype summary: str
    :ivar current_value: Formatted value of the measure that triggered the alert. Required.
    :vartype current_value: str
    :ivar previous_value: Formatted value of the measure that triggered the alert in the previous
     evaluation. Required.
    :vartype previous_value: str
    :ivar raw_delta: Formatted delta between the current and previous values, if there was a
     previous value.
    :vartype raw_delta: str
    :ivar percent_delta: Formatted percentage change between the current and previous values, if
     there was a previous value.
    :vartype percent_delta: str
    :ivar dimension_id: ID of the dimension that triggered the alert.
    :vartype dimension_id: str
    :ivar dimension_value: Value of the dimension that triggered the alert.
    :vartype dimension_value: str
    :ivar measure_title: Title of the measure that triggered the alert. Required.
    :vartype measure_title: str
    :ivar condition_trigger_value: Raw value defined in the alert condition. Required.
    :vartype condition_trigger_value: float
    :ivar type: Specify ``value`` to evaluate against an absolute value, ``delta`` to evaluate
     against the
     change in absolute value, or ``percent-delta`` to evaluate against the percentage change
     in the measure value. Required. Known values are: "value", "delta", and "percent-delta".
    :vartype type: str or ~polaris.sdk.global_api.models.AlertConditionType
    :ivar condition: Specify ``lessThan`` to trigger the alert when the measure value is less than
     the specified
     value, or ``greaterThan`` to trigger the alert when the measure value is greater than the
     specified value. Required. Known values are: "lessThan" and "greaterThan".
    :vartype condition: str or ~polaris.sdk.global_api.models.AlertConditionOperator
    :ivar triggered: Whether the evaluation was triggered. Required.
    :vartype triggered: bool
    """

    _validation = {
        "summary": {"required": True},
        "current_value": {"required": True},
        "previous_value": {"required": True},
        "dimension_id": {"max_length": 255, "min_length": 1},
        "measure_title": {"required": True},
        "condition_trigger_value": {"required": True},
        "type": {"required": True},
        "condition": {"required": True},
        "triggered": {"required": True},
    }

    _attribute_map = {
        "summary": {"key": "summary", "type": "str"},
        "current_value": {"key": "currentValue", "type": "str"},
        "previous_value": {"key": "previousValue", "type": "str"},
        "raw_delta": {"key": "rawDelta", "type": "str"},
        "percent_delta": {"key": "percentDelta", "type": "str"},
        "dimension_id": {"key": "dimensionId", "type": "str"},
        "dimension_value": {"key": "dimensionValue", "type": "str"},
        "measure_title": {"key": "measureTitle", "type": "str"},
        "condition_trigger_value": {"key": "conditionTriggerValue", "type": "float"},
        "type": {"key": "type", "type": "str"},
        "condition": {"key": "condition", "type": "str"},
        "triggered": {"key": "triggered", "type": "bool"},
    }

    def __init__(
        self,
        *,
        summary: str,
        current_value: str,
        previous_value: str,
        measure_title: str,
        condition_trigger_value: float,
        type: Union[str, "_models.AlertConditionType"],
        condition: Union[str, "_models.AlertConditionOperator"],
        triggered: bool,
        raw_delta: Optional[str] = None,
        percent_delta: Optional[str] = None,
        dimension_id: Optional[str] = None,
        dimension_value: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword summary: Formatted description of the evaluation result. Required.
        :paramtype summary: str
        :keyword current_value: Formatted value of the measure that triggered the alert. Required.
        :paramtype current_value: str
        :keyword previous_value: Formatted value of the measure that triggered the alert in the
         previous evaluation. Required.
        :paramtype previous_value: str
        :keyword raw_delta: Formatted delta between the current and previous values, if there was a
         previous value.
        :paramtype raw_delta: str
        :keyword percent_delta: Formatted percentage change between the current and previous values, if
         there was a previous value.
        :paramtype percent_delta: str
        :keyword dimension_id: ID of the dimension that triggered the alert.
        :paramtype dimension_id: str
        :keyword dimension_value: Value of the dimension that triggered the alert.
        :paramtype dimension_value: str
        :keyword measure_title: Title of the measure that triggered the alert. Required.
        :paramtype measure_title: str
        :keyword condition_trigger_value: Raw value defined in the alert condition. Required.
        :paramtype condition_trigger_value: float
        :keyword type: Specify ``value`` to evaluate against an absolute value, ``delta`` to evaluate
         against the
         change in absolute value, or ``percent-delta`` to evaluate against the percentage change
         in the measure value. Required. Known values are: "value", "delta", and "percent-delta".
        :paramtype type: str or ~polaris.sdk.global_api.models.AlertConditionType
        :keyword condition: Specify ``lessThan`` to trigger the alert when the measure value is less
         than the specified
         value, or ``greaterThan`` to trigger the alert when the measure value is greater than the
         specified value. Required. Known values are: "lessThan" and "greaterThan".
        :paramtype condition: str or ~polaris.sdk.global_api.models.AlertConditionOperator
        :keyword triggered: Whether the evaluation was triggered. Required.
        :paramtype triggered: bool
        """
        super().__init__(**kwargs)
        self.summary = summary
        self.current_value = current_value
        self.previous_value = previous_value
        self.raw_delta = raw_delta
        self.percent_delta = percent_delta
        self.dimension_id = dimension_id
        self.dimension_value = dimension_value
        self.measure_title = measure_title
        self.condition_trigger_value = condition_trigger_value
        self.type = type
        self.condition = condition
        self.triggered = triggered


class AlertListResponse(_serialization.Model):
    """Array of alerts.

    All required parameters must be populated in order to send to server.

    :ivar values: Array of alerts. Required.
    :vartype values: list[~polaris.sdk.global_api.models.AlertListResponseValuesItem]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[AlertListResponseValuesItem]"},
    }

    def __init__(
        self, *, values: List["_models.AlertListResponseValuesItem"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Array of alerts. Required.
        :paramtype values: list[~polaris.sdk.global_api.models.AlertListResponseValuesItem]
        """
        super().__init__(**kwargs)
        self.values = values


class AuditRecord(_serialization.Model):
    """Time and user ID related to asset creation and modification.

    All required parameters must be populated in order to send to server.

    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    """

    _validation = {
        "created_at": {"required": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
    }

    def __init__(
        self,
        *,
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        """
        super().__init__(**kwargs)
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by


class AlertListResponseValuesItem(AuditRecord, AlertPayload):
    """AlertListResponseValuesItem.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar owner: User ID of the alert owner. The owner can modify the alert and its recipient list.
    :vartype owner: str
    :ivar title: Alert title to display in the Polaris UI, and in emails and webhooks.
    :vartype title: str
    :ivar data_cube: Identifies the data cube that the alert is based on.
    :vartype data_cube: str
    :ivar date_time_to_start: Date and time to start triggering alerts. The timezone is UTC.
    :vartype date_time_to_start: str
    :ivar instance: Optional instance ID to use for the alert configuration.
    :vartype instance: str
    :ivar type: Specify ``overall`` to evaluate against a measure, and ``within-split`` to evaluate
     against a dimension. Known values are: "overall" and "within-split".
    :vartype type: str or ~polaris.sdk.global_api.models.AlertType
    :ivar check_frequency: How often Polaris evaluates alert criteria, expressed as an `ISO 8601
     duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype check_frequency: ~datetime.timedelta
    :ivar time_frame: Controls the amount of data Polaris considers when evaluating the alert
     criteria based upon a time interval,
     expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype time_frame: ~datetime.timedelta
    :ivar compare: For a relative condition, such as when a measure changes by a certain value,
     specify a comparison period or set a custom period. When not provided, the alert triggers
     based
     on an absolute condition, such as when a certain measure is greater than a certain value.
    :vartype compare: ~polaris.sdk.global_api.models.Compare
    :ivar filter: You can define one or more filters to restrict the alert data Polaris gathers
     during alert evaluation.
     You can't define a static time filter.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar splits: Dimension values to use when alert type is ``within-split``.
    :vartype splits: any
    :ivar condition_operation: Select whether one or all conditions must be true to trigger the
     alert. Known values are: "and" and "or".
    :vartype condition_operation: str or ~polaris.sdk.global_api.models.ConditionOperation
    :ivar conditions: Specify one or more conditions to trigger your alert.
     If you specify more than one condition, you can set the ``conditionOperation`` property to
     determine whether one or all conditions must be true to trigger the alert.
    :vartype conditions: list[~polaris.sdk.global_api.models.AlertCondition]
    :ivar severity: Severity determines the alert's color and icon in the Polaris UI. Known values
     are: "info", "warning", "error", and "ok".
    :vartype severity: str or ~polaris.sdk.global_api.models.Severity
    :ivar read_access: List of users with read access to the alert.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar recipients: List of users to notify when the alert triggers.
    :vartype recipients: ~polaris.sdk.global_api.models.AccessList
    :ivar admins: List of users who can modify the alert.
    :vartype admins: ~polaris.sdk.global_api.models.AccessList
    :ivar webhooks: Webhooks to call when the alert is triggered.
    :vartype webhooks: list[~polaris.sdk.global_api.models.Webhook]
    :ivar disabled: Disables the alert. Polaris doesn't evaluate disabled alerts or trigger
     notifications.
    :vartype disabled: bool
    :ivar send_email_to_recipients: Send email notifications to the alert recipients when the alert
     triggers.
    :vartype send_email_to_recipients: bool
    :ivar latest_data_strategy_override: Override the latest data strategy for the alert. If not
     specified, Polaris uses the
     latest data strategy from the data cube.
    :vartype latest_data_strategy_override: str
    :ivar external_emails: External email addresses to notify when the alert triggers.
    :vartype external_emails: list[str]
    :ivar example_query: Parameterized query string Polaris uses to evaluate the alert. Evaluates
     to ``true``
     or ``false``. You can copy the example query, customize it, and run it with a parameter for
     the upper time bound to determine whether it would trigger the alert (\\ ``true``\\ ) or not
     (\\ ``false``\\ ).
    :vartype example_query: str
    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
        "owner": {"max_length": 255, "min_length": 1},
        "data_cube": {"max_length": 255, "min_length": 1},
        "example_query": {"readonly": True},
        "created_at": {"required": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "owner": {"key": "owner", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "date_time_to_start": {"key": "dateTimeToStart", "type": "str"},
        "instance": {"key": "instance", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "check_frequency": {"key": "checkFrequency", "type": "duration"},
        "time_frame": {"key": "timeFrame", "type": "duration"},
        "compare": {"key": "compare", "type": "Compare"},
        "filter": {"key": "filter", "type": "Filter"},
        "splits": {"key": "splits", "type": "object"},
        "condition_operation": {"key": "conditionOperation", "type": "str"},
        "conditions": {"key": "conditions", "type": "[AlertCondition]"},
        "severity": {"key": "severity", "type": "str"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "recipients": {"key": "recipients", "type": "AccessList"},
        "admins": {"key": "admins", "type": "AccessList"},
        "webhooks": {"key": "webhooks", "type": "[Webhook]"},
        "disabled": {"key": "disabled", "type": "bool"},
        "send_email_to_recipients": {"key": "sendEmailToRecipients", "type": "bool"},
        "latest_data_strategy_override": {
            "key": "latestDataStrategyOverride",
            "type": "str",
        },
        "external_emails": {"key": "externalEmails", "type": "[str]"},
        "example_query": {"key": "exampleQuery", "type": "str"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        owner: Optional[str] = None,
        title: Optional[str] = None,
        data_cube: Optional[str] = None,
        date_time_to_start: Optional[str] = None,
        instance: Optional[str] = None,
        type: Optional[Union[str, "_models.AlertType"]] = None,
        check_frequency: Optional[datetime.timedelta] = None,
        time_frame: Optional[datetime.timedelta] = None,
        compare: Optional["_models.Compare"] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        splits: Optional[Any] = None,
        condition_operation: Optional[Union[str, "_models.ConditionOperation"]] = None,
        conditions: Optional[List["_models.AlertCondition"]] = None,
        severity: Union[str, "_models.Severity"] = "info",
        read_access: Optional["_models.AccessList"] = None,
        recipients: Optional["_models.AccessList"] = None,
        admins: Optional["_models.AccessList"] = None,
        webhooks: Optional[List["_models.Webhook"]] = None,
        disabled: Optional[bool] = None,
        send_email_to_recipients: Optional[bool] = None,
        latest_data_strategy_override: Optional[str] = None,
        external_emails: Optional[List[str]] = None,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword owner: User ID of the alert owner. The owner can modify the alert and its recipient
         list.
        :paramtype owner: str
        :keyword title: Alert title to display in the Polaris UI, and in emails and webhooks.
        :paramtype title: str
        :keyword data_cube: Identifies the data cube that the alert is based on.
        :paramtype data_cube: str
        :keyword date_time_to_start: Date and time to start triggering alerts. The timezone is UTC.
        :paramtype date_time_to_start: str
        :keyword instance: Optional instance ID to use for the alert configuration.
        :paramtype instance: str
        :keyword type: Specify ``overall`` to evaluate against a measure, and ``within-split`` to
         evaluate against a dimension. Known values are: "overall" and "within-split".
        :paramtype type: str or ~polaris.sdk.global_api.models.AlertType
        :keyword check_frequency: How often Polaris evaluates alert criteria, expressed as an `ISO 8601
         duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype check_frequency: ~datetime.timedelta
        :keyword time_frame: Controls the amount of data Polaris considers when evaluating the alert
         criteria based upon a time interval,
         expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype time_frame: ~datetime.timedelta
        :keyword compare: For a relative condition, such as when a measure changes by a certain value,
         specify a comparison period or set a custom period. When not provided, the alert triggers
         based
         on an absolute condition, such as when a certain measure is greater than a certain value.
        :paramtype compare: ~polaris.sdk.global_api.models.Compare
        :keyword filter: You can define one or more filters to restrict the alert data Polaris gathers
         during alert evaluation.
         You can't define a static time filter.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword splits: Dimension values to use when alert type is ``within-split``.
        :paramtype splits: any
        :keyword condition_operation: Select whether one or all conditions must be true to trigger the
         alert. Known values are: "and" and "or".
        :paramtype condition_operation: str or ~polaris.sdk.global_api.models.ConditionOperation
        :keyword conditions: Specify one or more conditions to trigger your alert.
         If you specify more than one condition, you can set the ``conditionOperation`` property to
         determine whether one or all conditions must be true to trigger the alert.
        :paramtype conditions: list[~polaris.sdk.global_api.models.AlertCondition]
        :keyword severity: Severity determines the alert's color and icon in the Polaris UI. Known
         values are: "info", "warning", "error", and "ok".
        :paramtype severity: str or ~polaris.sdk.global_api.models.Severity
        :keyword read_access: List of users with read access to the alert.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword recipients: List of users to notify when the alert triggers.
        :paramtype recipients: ~polaris.sdk.global_api.models.AccessList
        :keyword admins: List of users who can modify the alert.
        :paramtype admins: ~polaris.sdk.global_api.models.AccessList
        :keyword webhooks: Webhooks to call when the alert is triggered.
        :paramtype webhooks: list[~polaris.sdk.global_api.models.Webhook]
        :keyword disabled: Disables the alert. Polaris doesn't evaluate disabled alerts or trigger
         notifications.
        :paramtype disabled: bool
        :keyword send_email_to_recipients: Send email notifications to the alert recipients when the
         alert triggers.
        :paramtype send_email_to_recipients: bool
        :keyword latest_data_strategy_override: Override the latest data strategy for the alert. If not
         specified, Polaris uses the
         latest data strategy from the data cube.
        :paramtype latest_data_strategy_override: str
        :keyword external_emails: External email addresses to notify when the alert triggers.
        :paramtype external_emails: list[str]
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        """
        super().__init__(
            created_at=created_at,
            created_by=created_by,
            updated_at=updated_at,
            updated_by=updated_by,
            additional_properties=additional_properties,
            id=id,
            owner=owner,
            title=title,
            data_cube=data_cube,
            date_time_to_start=date_time_to_start,
            instance=instance,
            type=type,
            check_frequency=check_frequency,
            time_frame=time_frame,
            compare=compare,
            filter=filter,
            splits=splits,
            condition_operation=condition_operation,
            conditions=conditions,
            severity=severity,
            read_access=read_access,
            recipients=recipients,
            admins=admins,
            webhooks=webhooks,
            disabled=disabled,
            send_email_to_recipients=send_email_to_recipients,
            latest_data_strategy_override=latest_data_strategy_override,
            external_emails=external_emails,
            **kwargs
        )
        self.additional_properties = additional_properties
        self.id = id
        self.owner = owner
        self.title = title
        self.data_cube = data_cube
        self.date_time_to_start = date_time_to_start
        self.instance = instance
        self.type = type
        self.check_frequency = check_frequency
        self.time_frame = time_frame
        self.compare = compare
        self.filter = filter
        self.splits = splits
        self.condition_operation = condition_operation
        self.conditions = conditions
        self.severity = severity
        self.read_access = read_access
        self.recipients = recipients
        self.admins = admins
        self.webhooks = webhooks
        self.disabled = disabled
        self.send_email_to_recipients = send_email_to_recipients
        self.latest_data_strategy_override = latest_data_strategy_override
        self.external_emails = external_emails
        self.example_query = None
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by


class AlertResponse(AuditRecord, AlertPayload):
    """AlertResponse.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar owner: User ID of the alert owner. The owner can modify the alert and its recipient list.
    :vartype owner: str
    :ivar title: Alert title to display in the Polaris UI, and in emails and webhooks.
    :vartype title: str
    :ivar data_cube: Identifies the data cube that the alert is based on.
    :vartype data_cube: str
    :ivar date_time_to_start: Date and time to start triggering alerts. The timezone is UTC.
    :vartype date_time_to_start: str
    :ivar instance: Optional instance ID to use for the alert configuration.
    :vartype instance: str
    :ivar type: Specify ``overall`` to evaluate against a measure, and ``within-split`` to evaluate
     against a dimension. Known values are: "overall" and "within-split".
    :vartype type: str or ~polaris.sdk.global_api.models.AlertType
    :ivar check_frequency: How often Polaris evaluates alert criteria, expressed as an `ISO 8601
     duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype check_frequency: ~datetime.timedelta
    :ivar time_frame: Controls the amount of data Polaris considers when evaluating the alert
     criteria based upon a time interval,
     expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype time_frame: ~datetime.timedelta
    :ivar compare: For a relative condition, such as when a measure changes by a certain value,
     specify a comparison period or set a custom period. When not provided, the alert triggers
     based
     on an absolute condition, such as when a certain measure is greater than a certain value.
    :vartype compare: ~polaris.sdk.global_api.models.Compare
    :ivar filter: You can define one or more filters to restrict the alert data Polaris gathers
     during alert evaluation.
     You can't define a static time filter.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar splits: Dimension values to use when alert type is ``within-split``.
    :vartype splits: any
    :ivar condition_operation: Select whether one or all conditions must be true to trigger the
     alert. Known values are: "and" and "or".
    :vartype condition_operation: str or ~polaris.sdk.global_api.models.ConditionOperation
    :ivar conditions: Specify one or more conditions to trigger your alert.
     If you specify more than one condition, you can set the ``conditionOperation`` property to
     determine whether one or all conditions must be true to trigger the alert.
    :vartype conditions: list[~polaris.sdk.global_api.models.AlertCondition]
    :ivar severity: Severity determines the alert's color and icon in the Polaris UI. Known values
     are: "info", "warning", "error", and "ok".
    :vartype severity: str or ~polaris.sdk.global_api.models.Severity
    :ivar read_access: List of users with read access to the alert.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar recipients: List of users to notify when the alert triggers.
    :vartype recipients: ~polaris.sdk.global_api.models.AccessList
    :ivar admins: List of users who can modify the alert.
    :vartype admins: ~polaris.sdk.global_api.models.AccessList
    :ivar webhooks: Webhooks to call when the alert is triggered.
    :vartype webhooks: list[~polaris.sdk.global_api.models.Webhook]
    :ivar disabled: Disables the alert. Polaris doesn't evaluate disabled alerts or trigger
     notifications.
    :vartype disabled: bool
    :ivar send_email_to_recipients: Send email notifications to the alert recipients when the alert
     triggers.
    :vartype send_email_to_recipients: bool
    :ivar latest_data_strategy_override: Override the latest data strategy for the alert. If not
     specified, Polaris uses the
     latest data strategy from the data cube.
    :vartype latest_data_strategy_override: str
    :ivar external_emails: External email addresses to notify when the alert triggers.
    :vartype external_emails: list[str]
    :ivar example_query: Parameterized query string Polaris uses to evaluate the alert. Evaluates
     to ``true``
     or ``false``. You can copy the example query, customize it, and run it with a parameter for
     the upper time bound to determine whether it would trigger the alert (\\ ``true``\\ ) or not
     (\\ ``false``\\ ).
    :vartype example_query: str
    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
        "owner": {"max_length": 255, "min_length": 1},
        "data_cube": {"max_length": 255, "min_length": 1},
        "example_query": {"readonly": True},
        "created_at": {"required": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "owner": {"key": "owner", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "date_time_to_start": {"key": "dateTimeToStart", "type": "str"},
        "instance": {"key": "instance", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "check_frequency": {"key": "checkFrequency", "type": "duration"},
        "time_frame": {"key": "timeFrame", "type": "duration"},
        "compare": {"key": "compare", "type": "Compare"},
        "filter": {"key": "filter", "type": "Filter"},
        "splits": {"key": "splits", "type": "object"},
        "condition_operation": {"key": "conditionOperation", "type": "str"},
        "conditions": {"key": "conditions", "type": "[AlertCondition]"},
        "severity": {"key": "severity", "type": "str"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "recipients": {"key": "recipients", "type": "AccessList"},
        "admins": {"key": "admins", "type": "AccessList"},
        "webhooks": {"key": "webhooks", "type": "[Webhook]"},
        "disabled": {"key": "disabled", "type": "bool"},
        "send_email_to_recipients": {"key": "sendEmailToRecipients", "type": "bool"},
        "latest_data_strategy_override": {
            "key": "latestDataStrategyOverride",
            "type": "str",
        },
        "external_emails": {"key": "externalEmails", "type": "[str]"},
        "example_query": {"key": "exampleQuery", "type": "str"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        owner: Optional[str] = None,
        title: Optional[str] = None,
        data_cube: Optional[str] = None,
        date_time_to_start: Optional[str] = None,
        instance: Optional[str] = None,
        type: Optional[Union[str, "_models.AlertType"]] = None,
        check_frequency: Optional[datetime.timedelta] = None,
        time_frame: Optional[datetime.timedelta] = None,
        compare: Optional["_models.Compare"] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        splits: Optional[Any] = None,
        condition_operation: Optional[Union[str, "_models.ConditionOperation"]] = None,
        conditions: Optional[List["_models.AlertCondition"]] = None,
        severity: Union[str, "_models.Severity"] = "info",
        read_access: Optional["_models.AccessList"] = None,
        recipients: Optional["_models.AccessList"] = None,
        admins: Optional["_models.AccessList"] = None,
        webhooks: Optional[List["_models.Webhook"]] = None,
        disabled: Optional[bool] = None,
        send_email_to_recipients: Optional[bool] = None,
        latest_data_strategy_override: Optional[str] = None,
        external_emails: Optional[List[str]] = None,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword owner: User ID of the alert owner. The owner can modify the alert and its recipient
         list.
        :paramtype owner: str
        :keyword title: Alert title to display in the Polaris UI, and in emails and webhooks.
        :paramtype title: str
        :keyword data_cube: Identifies the data cube that the alert is based on.
        :paramtype data_cube: str
        :keyword date_time_to_start: Date and time to start triggering alerts. The timezone is UTC.
        :paramtype date_time_to_start: str
        :keyword instance: Optional instance ID to use for the alert configuration.
        :paramtype instance: str
        :keyword type: Specify ``overall`` to evaluate against a measure, and ``within-split`` to
         evaluate against a dimension. Known values are: "overall" and "within-split".
        :paramtype type: str or ~polaris.sdk.global_api.models.AlertType
        :keyword check_frequency: How often Polaris evaluates alert criteria, expressed as an `ISO 8601
         duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype check_frequency: ~datetime.timedelta
        :keyword time_frame: Controls the amount of data Polaris considers when evaluating the alert
         criteria based upon a time interval,
         expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype time_frame: ~datetime.timedelta
        :keyword compare: For a relative condition, such as when a measure changes by a certain value,
         specify a comparison period or set a custom period. When not provided, the alert triggers
         based
         on an absolute condition, such as when a certain measure is greater than a certain value.
        :paramtype compare: ~polaris.sdk.global_api.models.Compare
        :keyword filter: You can define one or more filters to restrict the alert data Polaris gathers
         during alert evaluation.
         You can't define a static time filter.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword splits: Dimension values to use when alert type is ``within-split``.
        :paramtype splits: any
        :keyword condition_operation: Select whether one or all conditions must be true to trigger the
         alert. Known values are: "and" and "or".
        :paramtype condition_operation: str or ~polaris.sdk.global_api.models.ConditionOperation
        :keyword conditions: Specify one or more conditions to trigger your alert.
         If you specify more than one condition, you can set the ``conditionOperation`` property to
         determine whether one or all conditions must be true to trigger the alert.
        :paramtype conditions: list[~polaris.sdk.global_api.models.AlertCondition]
        :keyword severity: Severity determines the alert's color and icon in the Polaris UI. Known
         values are: "info", "warning", "error", and "ok".
        :paramtype severity: str or ~polaris.sdk.global_api.models.Severity
        :keyword read_access: List of users with read access to the alert.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword recipients: List of users to notify when the alert triggers.
        :paramtype recipients: ~polaris.sdk.global_api.models.AccessList
        :keyword admins: List of users who can modify the alert.
        :paramtype admins: ~polaris.sdk.global_api.models.AccessList
        :keyword webhooks: Webhooks to call when the alert is triggered.
        :paramtype webhooks: list[~polaris.sdk.global_api.models.Webhook]
        :keyword disabled: Disables the alert. Polaris doesn't evaluate disabled alerts or trigger
         notifications.
        :paramtype disabled: bool
        :keyword send_email_to_recipients: Send email notifications to the alert recipients when the
         alert triggers.
        :paramtype send_email_to_recipients: bool
        :keyword latest_data_strategy_override: Override the latest data strategy for the alert. If not
         specified, Polaris uses the
         latest data strategy from the data cube.
        :paramtype latest_data_strategy_override: str
        :keyword external_emails: External email addresses to notify when the alert triggers.
        :paramtype external_emails: list[str]
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        """
        super().__init__(
            created_at=created_at,
            created_by=created_by,
            updated_at=updated_at,
            updated_by=updated_by,
            additional_properties=additional_properties,
            id=id,
            owner=owner,
            title=title,
            data_cube=data_cube,
            date_time_to_start=date_time_to_start,
            instance=instance,
            type=type,
            check_frequency=check_frequency,
            time_frame=time_frame,
            compare=compare,
            filter=filter,
            splits=splits,
            condition_operation=condition_operation,
            conditions=conditions,
            severity=severity,
            read_access=read_access,
            recipients=recipients,
            admins=admins,
            webhooks=webhooks,
            disabled=disabled,
            send_email_to_recipients=send_email_to_recipients,
            latest_data_strategy_override=latest_data_strategy_override,
            external_emails=external_emails,
            **kwargs
        )
        self.additional_properties = additional_properties
        self.id = id
        self.owner = owner
        self.title = title
        self.data_cube = data_cube
        self.date_time_to_start = date_time_to_start
        self.instance = instance
        self.type = type
        self.check_frequency = check_frequency
        self.time_frame = time_frame
        self.compare = compare
        self.filter = filter
        self.splits = splits
        self.condition_operation = condition_operation
        self.conditions = conditions
        self.severity = severity
        self.read_access = read_access
        self.recipients = recipients
        self.admins = admins
        self.webhooks = webhooks
        self.disabled = disabled
        self.send_email_to_recipients = send_email_to_recipients
        self.latest_data_strategy_override = latest_data_strategy_override
        self.external_emails = external_emails
        self.example_query = None
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by


class AllAccessList(_serialization.Model):
    """Access control list for an asset indicating that all users have access.

    All required parameters must be populated in order to send to server.

    :ivar access: Required. "all"
    :vartype access: str or ~polaris.sdk.global_api.models.AllAccessListAccess
    """

    _validation = {
        "access": {"required": True},
    }

    _attribute_map = {
        "access": {"key": "access", "type": "str"},
    }

    def __init__(
        self, *, access: Union[str, "_models.AllAccessListAccess"], **kwargs: Any
    ) -> None:
        """
        :keyword access: Required. "all"
        :paramtype access: str or ~polaris.sdk.global_api.models.AllAccessListAccess
        """
        super().__init__(**kwargs)
        self.access = access


class ApiKeyInfo(_serialization.Model):
    """ApiKeyInfo.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: A generated, permanently unique ID for this API key.
    :vartype id: str
    :ivar permissions: The list of permissions for the API key.
    :vartype permissions: list[str]
    """

    _validation = {
        "id": {"readonly": True},
        "permissions": {"readonly": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "str"},
        "permissions": {"key": "permissions", "type": "[str]"},
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.id = None
        self.permissions = None


class ApiKeyListRepresentation(_serialization.Model):
    """ApiKeyListRepresentation.

    All required parameters must be populated in order to send to server.

    :ivar items: Required.
    :vartype items: list[~polaris.sdk.global_api.models.ApiKeyRepresentation]
    """

    _validation = {
        "items": {"required": True},
    }

    _attribute_map = {
        "items": {"key": "items", "type": "[ApiKeyRepresentation]"},
    }

    def __init__(
        self, *, items: List["_models.ApiKeyRepresentation"], **kwargs: Any
    ) -> None:
        """
        :keyword items: Required.
        :paramtype items: list[~polaris.sdk.global_api.models.ApiKeyRepresentation]
        """
        super().__init__(**kwargs)
        self.items = items


class ApiKeyRepresentation(_serialization.Model):
    """ApiKeyRepresentation.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: A generated, permanently unique ID for this API key.
    :vartype id: str
    :ivar name: A human-readable name provided by the user.
    :vartype name: str
    :ivar description: A human-readable description provided by the user.
    :vartype description: str
    :ivar api_key: The secret key that authorizes the use of Polaris APIs. This property is only
     returned when a key is created.
    :vartype api_key: str
    :ivar redacted_api_key: A redacted version of the API key to help identify it.
    :vartype redacted_api_key: str
    :ivar permissions: The list of permissions for the API key.
    :vartype permissions: list[any]
    :ivar created_by: The user.
    :vartype created_by: ~polaris.sdk.global_api.models.User
    :ivar last_modified_by: The user.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.User
    :ivar created_on: Time of creation.
    :vartype created_on: ~datetime.datetime
    :ivar last_modified_on: Time last modified.
    :vartype last_modified_on: ~datetime.datetime
    """

    _validation = {
        "id": {"readonly": True},
        "api_key": {"readonly": True},
        "redacted_api_key": {"readonly": True},
        "created_by": {"readonly": True},
        "last_modified_by": {"readonly": True},
        "created_on": {"readonly": True},
        "last_modified_on": {"readonly": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "api_key": {"key": "apiKey", "type": "str"},
        "redacted_api_key": {"key": "redactedApiKey", "type": "str"},
        "permissions": {"key": "permissions", "type": "[object]"},
        "created_by": {"key": "createdBy", "type": "User"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "User"},
        "created_on": {"key": "createdOn", "type": "iso-8601"},
        "last_modified_on": {"key": "lastModifiedOn", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        permissions: Optional[List[Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: A human-readable name provided by the user.
        :paramtype name: str
        :keyword description: A human-readable description provided by the user.
        :paramtype description: str
        :keyword permissions: The list of permissions for the API key.
        :paramtype permissions: list[any]
        """
        super().__init__(**kwargs)
        self.id = None
        self.name = name
        self.description = description
        self.api_key = None
        self.redacted_api_key = None
        self.permissions = permissions
        self.created_by = None
        self.last_modified_by = None
        self.created_on = None
        self.last_modified_on = None


class AppColorPalette(_serialization.Model):
    """Color palette for the Polaris UI. Use the 6-character hex format for all colors.

    :ivar primary: A custom color to appear across the Polaris UI, including icons, links, and
     buttons.
    :vartype primary: str
    :ivar compare: A custom color for compare pills in data cube and dashboard views.
    :vartype compare: str
    :ivar dimension: A custom color for dimension pills in data cube and dashboard views.
    :vartype dimension: str
    :ivar measure: A custom color for measure pills in data cube and dashboard views.
    :vartype measure: str
    """

    _validation = {
        "primary": {"pattern": r"^#[\da-fA-F]{6}$"},
        "compare": {"pattern": r"^#[\da-fA-F]{6}$"},
        "dimension": {"pattern": r"^#[\da-fA-F]{6}$"},
        "measure": {"pattern": r"^#[\da-fA-F]{6}$"},
    }

    _attribute_map = {
        "primary": {"key": "primary", "type": "str"},
        "compare": {"key": "compare", "type": "str"},
        "dimension": {"key": "dimension", "type": "str"},
        "measure": {"key": "measure", "type": "str"},
    }

    def __init__(
        self,
        *,
        primary: Optional[str] = None,
        compare: Optional[str] = None,
        dimension: Optional[str] = None,
        measure: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword primary: A custom color to appear across the Polaris UI, including icons, links, and
         buttons.
        :paramtype primary: str
        :keyword compare: A custom color for compare pills in data cube and dashboard views.
        :paramtype compare: str
        :keyword dimension: A custom color for dimension pills in data cube and dashboard views.
        :paramtype dimension: str
        :keyword measure: A custom color for measure pills in data cube and dashboard views.
        :paramtype measure: str
        """
        super().__init__(**kwargs)
        self.primary = primary
        self.compare = compare
        self.dimension = dimension
        self.measure = measure


class ApplicationName(_serialization.Model):
    """Application name for an organization.

    :ivar app_name: Application name.
    :vartype app_name: str
    """

    _attribute_map = {
        "app_name": {"key": "appName", "type": "str"},
    }

    def __init__(self, *, app_name: Optional[str] = None, **kwargs: Any) -> None:
        """
        :keyword app_name: Application name.
        :paramtype app_name: str
        """
        super().__init__(**kwargs)
        self.app_name = app_name


class ModificationRecord(_serialization.Model):
    """A record of the last time customizations were modified.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar last_modified_by: The user who last modified the customizations.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.User
    :ivar last_update_timestamp: Date and time of the last update in ISO 8601 format.
    :vartype last_update_timestamp: ~datetime.datetime
    """

    _validation = {
        "last_modified_by": {"readonly": True},
    }

    _attribute_map = {
        "last_modified_by": {"key": "lastModifiedBy", "type": "User"},
        "last_update_timestamp": {"key": "lastUpdateTimestamp", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        last_update_timestamp: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword last_update_timestamp: Date and time of the last update in ISO 8601 format.
        :paramtype last_update_timestamp: ~datetime.datetime
        """
        super().__init__(**kwargs)
        self.last_modified_by = None
        self.last_update_timestamp = last_update_timestamp


class ApplicationNameResponse(ApplicationName, ModificationRecord):
    """Response that includes an application name and its modification record.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar last_modified_by: The user who last modified the customizations.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.User
    :ivar last_update_timestamp: Date and time of the last update in ISO 8601 format.
    :vartype last_update_timestamp: ~datetime.datetime
    :ivar app_name: Application name.
    :vartype app_name: str
    """

    _validation = {
        "last_modified_by": {"readonly": True},
    }

    _attribute_map = {
        "last_modified_by": {"key": "lastModifiedBy", "type": "User"},
        "last_update_timestamp": {"key": "lastUpdateTimestamp", "type": "iso-8601"},
        "app_name": {"key": "appName", "type": "str"},
    }

    def __init__(
        self,
        *,
        last_update_timestamp: Optional[datetime.datetime] = None,
        app_name: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword last_update_timestamp: Date and time of the last update in ISO 8601 format.
        :paramtype last_update_timestamp: ~datetime.datetime
        :keyword app_name: Application name.
        :paramtype app_name: str
        """
        super().__init__(
            app_name=app_name, last_update_timestamp=last_update_timestamp, **kwargs
        )
        self.last_modified_by = None
        self.last_update_timestamp = last_update_timestamp
        self.app_name = app_name


class Attribute(_serialization.Model):
    """Column metadata for the associated data source.

    All required parameters must be populated in order to send to server.

    :ivar name: Column name. Required.
    :vartype name: str
    :ivar type: The concrete type for a single datum. Known values are: "NULL", "BOOLEAN",
     "NUMBER", "TIME", "STRING", "NUMBER_RANGE", "IP", "TIME_SERIES", "TIME_RANGE", "STRING_RANGE",
     "SET", "SET/NULL", "SET/BOOLEAN", "SET/NUMBER", "SET/TIME", "SET/STRING", "SET/NUMBER_RANGE",
     "SET/TIME_RANGE", "SET/IP", "SET/STRING_RANGE", and "DATASET".
    :vartype type: str or ~polaris.sdk.global_api.models.PlywoodType
    :ivar native_type: Column type.
    :vartype native_type: str
    :ivar unsplitable:
    :vartype unsplitable: bool
    :ivar maker: Dictionary of :code:`<any>`.
    :vartype maker: dict[str, any]
    :ivar cardinality:
    :vartype cardinality: float
    :ivar range: Range of values.
    :vartype range: ~polaris.sdk.global_api.models.PlywoodRange
    :ivar terms_delegate:
    :vartype terms_delegate: str
    """

    _validation = {
        "name": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "native_type": {"key": "nativeType", "type": "str"},
        "unsplitable": {"key": "unsplitable", "type": "bool"},
        "maker": {"key": "maker", "type": "{object}"},
        "cardinality": {"key": "cardinality", "type": "float"},
        "range": {"key": "range", "type": "PlywoodRange"},
        "terms_delegate": {"key": "termsDelegate", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        type: Optional[Union[str, "_models.PlywoodType"]] = None,
        native_type: Optional[str] = None,
        unsplitable: Optional[bool] = None,
        maker: Optional[Dict[str, Any]] = None,
        cardinality: Optional[float] = None,
        range: Optional["_models.PlywoodRange"] = None,
        terms_delegate: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Column name. Required.
        :paramtype name: str
        :keyword type: The concrete type for a single datum. Known values are: "NULL", "BOOLEAN",
         "NUMBER", "TIME", "STRING", "NUMBER_RANGE", "IP", "TIME_SERIES", "TIME_RANGE", "STRING_RANGE",
         "SET", "SET/NULL", "SET/BOOLEAN", "SET/NUMBER", "SET/TIME", "SET/STRING", "SET/NUMBER_RANGE",
         "SET/TIME_RANGE", "SET/IP", "SET/STRING_RANGE", and "DATASET".
        :paramtype type: str or ~polaris.sdk.global_api.models.PlywoodType
        :keyword native_type: Column type.
        :paramtype native_type: str
        :keyword unsplitable:
        :paramtype unsplitable: bool
        :keyword maker: Dictionary of :code:`<any>`.
        :paramtype maker: dict[str, any]
        :keyword cardinality:
        :paramtype cardinality: float
        :keyword range: Range of values.
        :paramtype range: ~polaris.sdk.global_api.models.PlywoodRange
        :keyword terms_delegate:
        :paramtype terms_delegate: str
        """
        super().__init__(**kwargs)
        self.name = name
        self.type = type
        self.native_type = native_type
        self.unsplitable = unsplitable
        self.maker = maker
        self.cardinality = cardinality
        self.range = range
        self.terms_delegate = terms_delegate


class AuditEvent(_serialization.Model):
    """AuditEvent.

    All required parameters must be populated in order to send to server.

    :ivar time: Date and time the audit event was created in ISO 8601 format. Required.
    :vartype time: ~datetime.datetime
    :ivar account_id: Organization identifier. Required.
    :vartype account_id: str
    :ivar ip: IP address.
    :vartype ip: str
    :ivar region: Cloud region of the project where the audit event occurred.
    :vartype region: str
    :ivar type: Type of the audit event. Required. Known values are: "IMPERSONATED", "LOGIN",
     "LOGIN_FAILED", "LOGOUT", "PASSWORD_RESET_REQUESTED", "PASSWORD_UPDATED",
     "USER_INVITE_ACCEPTED", "APIKEY_CREATED", "APIKEY_DELETED", "APIKEY_NAME_UPDATED",
     "APIKEY_DESCRIPTION_UPDATED", "APIKEY_PERMISSIONS_ADDED", "APIKEY_PERMISSIONS_REMOVED",
     "APIKEY_SCOPE_ALL_PROJECTS", "APIKEY_SCOPE_SPECIFIC_PROJECTS", "APIKEY_UPDATED",
     "GROUP_CREATED", "GROUP_DELETED", "GROUP_MEMBER_ADDED", "GROUP_MEMBER_REMOVED",
     "GROUP_NAME_CHANGED", "GROUP_PERMISSIONS_ADDED", "GROUP_PERMISSIONS_REMOVED",
     "GROUP_SCOPE_ALL_PROJECTS", "GROUP_SCOPE_SPECIFIC_PROJECTS", "GROUP_UPDATED", "USER_CREATED",
     "USER_DELETED", "USER_DISABLED", "USER_ENABLED", "USER_INVITE_SENT", "USER_NAME_CHANGED",
     "USER_PASSWORD_RESET", "USER_GROUPS_ADDED", "USER_GROUPS_REMOVED", and "USER_UPDATED".
    :vartype type: str or ~polaris.sdk.global_api.models.AuditEventType
    :ivar category: Category of the audit event. Required. Known values are: "AUTH" and "ADMIN".
    :vartype category: str or ~polaris.sdk.global_api.models.AuditEventCategory
    :ivar resource: The name or path of the affected resource.
    :vartype resource: str
    :ivar actor_type: Type of user that triggered the audit event. Required. Known values are:
     "unknown", "apikey", "user", and "imply-admin".
    :vartype actor_type: str or ~polaris.sdk.global_api.models.AuditEventActorType
    :ivar actor_id: Identifier of user that triggered the audit event.
    :vartype actor_id: str
    :ivar actor_name: Name of user that triggered the audit event.
    :vartype actor_name: str
    :ivar summary: A human-readable description of what happened. Required.
    :vartype summary: str
    :ivar context: Metadata to describe the audit event.
    :vartype context: ~polaris.sdk.global_api.models.AuditEventContext
    """

    _validation = {
        "time": {"required": True},
        "account_id": {"required": True},
        "type": {"required": True},
        "category": {"required": True},
        "actor_type": {"required": True},
        "summary": {"required": True},
    }

    _attribute_map = {
        "time": {"key": "time", "type": "iso-8601"},
        "account_id": {"key": "accountId", "type": "str"},
        "ip": {"key": "ip", "type": "str"},
        "region": {"key": "region", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "category": {"key": "category", "type": "str"},
        "resource": {"key": "resource", "type": "str"},
        "actor_type": {"key": "actorType", "type": "str"},
        "actor_id": {"key": "actorId", "type": "str"},
        "actor_name": {"key": "actorName", "type": "str"},
        "summary": {"key": "summary", "type": "str"},
        "context": {"key": "context", "type": "AuditEventContext"},
    }

    def __init__(
        self,
        *,
        time: datetime.datetime,
        account_id: str,
        type: Union[str, "_models.AuditEventType"],
        category: Union[str, "_models.AuditEventCategory"],
        actor_type: Union[str, "_models.AuditEventActorType"],
        summary: str,
        ip: Optional[str] = None,
        region: Optional[str] = None,
        resource: Optional[str] = None,
        actor_id: Optional[str] = None,
        actor_name: Optional[str] = None,
        context: Optional["_models.AuditEventContext"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword time: Date and time the audit event was created in ISO 8601 format. Required.
        :paramtype time: ~datetime.datetime
        :keyword account_id: Organization identifier. Required.
        :paramtype account_id: str
        :keyword ip: IP address.
        :paramtype ip: str
        :keyword region: Cloud region of the project where the audit event occurred.
        :paramtype region: str
        :keyword type: Type of the audit event. Required. Known values are: "IMPERSONATED", "LOGIN",
         "LOGIN_FAILED", "LOGOUT", "PASSWORD_RESET_REQUESTED", "PASSWORD_UPDATED",
         "USER_INVITE_ACCEPTED", "APIKEY_CREATED", "APIKEY_DELETED", "APIKEY_NAME_UPDATED",
         "APIKEY_DESCRIPTION_UPDATED", "APIKEY_PERMISSIONS_ADDED", "APIKEY_PERMISSIONS_REMOVED",
         "APIKEY_SCOPE_ALL_PROJECTS", "APIKEY_SCOPE_SPECIFIC_PROJECTS", "APIKEY_UPDATED",
         "GROUP_CREATED", "GROUP_DELETED", "GROUP_MEMBER_ADDED", "GROUP_MEMBER_REMOVED",
         "GROUP_NAME_CHANGED", "GROUP_PERMISSIONS_ADDED", "GROUP_PERMISSIONS_REMOVED",
         "GROUP_SCOPE_ALL_PROJECTS", "GROUP_SCOPE_SPECIFIC_PROJECTS", "GROUP_UPDATED", "USER_CREATED",
         "USER_DELETED", "USER_DISABLED", "USER_ENABLED", "USER_INVITE_SENT", "USER_NAME_CHANGED",
         "USER_PASSWORD_RESET", "USER_GROUPS_ADDED", "USER_GROUPS_REMOVED", and "USER_UPDATED".
        :paramtype type: str or ~polaris.sdk.global_api.models.AuditEventType
        :keyword category: Category of the audit event. Required. Known values are: "AUTH" and "ADMIN".
        :paramtype category: str or ~polaris.sdk.global_api.models.AuditEventCategory
        :keyword resource: The name or path of the affected resource.
        :paramtype resource: str
        :keyword actor_type: Type of user that triggered the audit event. Required. Known values are:
         "unknown", "apikey", "user", and "imply-admin".
        :paramtype actor_type: str or ~polaris.sdk.global_api.models.AuditEventActorType
        :keyword actor_id: Identifier of user that triggered the audit event.
        :paramtype actor_id: str
        :keyword actor_name: Name of user that triggered the audit event.
        :paramtype actor_name: str
        :keyword summary: A human-readable description of what happened. Required.
        :paramtype summary: str
        :keyword context: Metadata to describe the audit event.
        :paramtype context: ~polaris.sdk.global_api.models.AuditEventContext
        """
        super().__init__(**kwargs)
        self.time = time
        self.account_id = account_id
        self.ip = ip
        self.region = region
        self.type = type
        self.category = category
        self.resource = resource
        self.actor_type = actor_type
        self.actor_id = actor_id
        self.actor_name = actor_name
        self.summary = summary
        self.context = context


class AuditEventContext(_serialization.Model):
    """Metadata to describe the audit event.

    :ivar reason: The reason for an event occurring.
    :vartype reason: str
    :ivar by: Who caused the event if not the actor. For example in the case of impersonation.
    :vartype by: str
    :ivar original: JSON representation of affected resource before the event.
    :vartype original: str
    :ivar representation: JSON representation of affected resource after the event.
    :vartype representation: str
    """

    _attribute_map = {
        "reason": {"key": "reason", "type": "str"},
        "by": {"key": "by", "type": "str"},
        "original": {"key": "original", "type": "str"},
        "representation": {"key": "representation", "type": "str"},
    }

    def __init__(
        self,
        *,
        reason: Optional[str] = None,
        by: Optional[str] = None,
        original: Optional[str] = None,
        representation: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword reason: The reason for an event occurring.
        :paramtype reason: str
        :keyword by: Who caused the event if not the actor. For example in the case of impersonation.
        :paramtype by: str
        :keyword original: JSON representation of affected resource before the event.
        :paramtype original: str
        :keyword representation: JSON representation of affected resource after the event.
        :paramtype representation: str
        """
        super().__init__(**kwargs)
        self.reason = reason
        self.by = by
        self.original = original
        self.representation = representation


class AuditEventList(_serialization.Model):
    """AuditEventList.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.AuditEvent]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[AuditEvent]"},
    }

    def __init__(self, *, values: List["_models.AuditEvent"], **kwargs: Any) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.AuditEvent]
        """
        super().__init__(**kwargs)
        self.values = values


class DataFormatSettings(_serialization.Model):
    """Data format settings that apply to all files in the ingestion job. Polaris automatically
    detects the file type based on the file extension. If you specify a value that does not match
    the automatically detected type, Polaris attempts to ingest based on the user-specified value.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    KafkaFormatSettingsKeyFormat, KafkaFormatSettingsValueFormat, KinesisFormatSettingsValueFormat,
    AvroOcfFormatSettings, AvroStreamFormatSettings, CsvFormatSettings, KafkaFormatSettings,
    KinesisFormatSettings, JsonFormatSettings, OrcFormatSettings, ParquetFormatSettings,
    ProtobufFormatSettings

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    """

    _validation = {
        "format": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
    }

    _subtype_map = {
        "format": {
            "KafkaFormatSettings-keyFormat": "KafkaFormatSettingsKeyFormat",
            "KafkaFormatSettings-valueFormat": "KafkaFormatSettingsValueFormat",
            "KinesisFormatSettings-valueFormat": "KinesisFormatSettingsValueFormat",
            "avro_ocf": "AvroOcfFormatSettings",
            "avro_stream": "AvroStreamFormatSettings",
            "csv": "CsvFormatSettings",
            "kafka": "KafkaFormatSettings",
            "kinesis": "KinesisFormatSettings",
            "nd-json": "JsonFormatSettings",
            "orc": "OrcFormatSettings",
            "parquet": "ParquetFormatSettings",
            "protobuf": "ProtobufFormatSettings",
        }
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.format: Optional[str] = None


class AvroOcfFormatSettings(DataFormatSettings):
    """AvroOcfFormatSettings.

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    :ivar binary_as_string: Specifies if the bytes Avro column which is not logically marked as a
     string or enum type should be treated as a UTF-8 encoded string.
    :vartype binary_as_string: bool
    :ivar extract_unions_by_type: If you want to operate on individual members of a union, set
     ``extractUnionsByType`` on the Avro parser.
     This configuration expands union values into nested objects according to the following rules:


     * Primitive types and unnamed complex types are keyed by their type name, such as ``int`` and
     ``string``.
     * Named `complex types <https://avro.apache.org/docs/1.10.2/spec.html#schema_complex>`_ are
     keyed by their names.
       Complex types include ``record``\\ , ``fixed``\\ , and ``enum``.
     * The Avro null type is elided as its value can only ever be null.
    :vartype extract_unions_by_type: bool
    :ivar flatten_spec: A Druid ``flattenSpec`` object for pre-processing the input Avro OCF . For
     more information, see `FlattenSpec
     <https://docs.imply.io/latest/druid/ingestion/data-formats/#flattenspec>`_. Flatten specs are
     supported for backwards compatibility and will continue to be supported indefinitely, but they
     are deprecated. We recommend migrating to JSON columns and the related SQL functions like
     ``JSON_VALUE``.
    :vartype flatten_spec: dict[str, any]
    :ivar schema: Define a reader schema to be used when parsing Avro records.
     This is useful if you want to override the reader schema included in the Avro OCF file data.
     For example:

     .. code-block::

        {
             "type": "record",
             "namespace": "com.example",
             "name": "FullName",
             "fields": [
               { "name": "first", "type": "string" },
               { "name": "last", "type": "string" }
             ]
        }.
    :vartype schema: dict[str, any]
    """

    _validation = {
        "format": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
        "binary_as_string": {"key": "binaryAsString", "type": "bool"},
        "extract_unions_by_type": {"key": "extractUnionsByType", "type": "bool"},
        "flatten_spec": {"key": "flattenSpec", "type": "{object}"},
        "schema": {"key": "schema", "type": "{object}"},
    }

    def __init__(
        self,
        *,
        binary_as_string: bool = False,
        extract_unions_by_type: bool = False,
        flatten_spec: Optional[Dict[str, Any]] = None,
        schema: Optional[Dict[str, Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword binary_as_string: Specifies if the bytes Avro column which is not logically marked as
         a string or enum type should be treated as a UTF-8 encoded string.
        :paramtype binary_as_string: bool
        :keyword extract_unions_by_type: If you want to operate on individual members of a union, set
         ``extractUnionsByType`` on the Avro parser.
         This configuration expands union values into nested objects according to the following rules:


         * Primitive types and unnamed complex types are keyed by their type name, such as ``int`` and
         ``string``.
         * Named `complex types <https://avro.apache.org/docs/1.10.2/spec.html#schema_complex>`_ are
         keyed by their names.
           Complex types include ``record``\\ , ``fixed``\\ , and ``enum``.
         * The Avro null type is elided as its value can only ever be null.
        :paramtype extract_unions_by_type: bool
        :keyword flatten_spec: A Druid ``flattenSpec`` object for pre-processing the input Avro OCF .
         For more information, see `FlattenSpec
         <https://docs.imply.io/latest/druid/ingestion/data-formats/#flattenspec>`_. Flatten specs are
         supported for backwards compatibility and will continue to be supported indefinitely, but they
         are deprecated. We recommend migrating to JSON columns and the related SQL functions like
         ``JSON_VALUE``.
        :paramtype flatten_spec: dict[str, any]
        :keyword schema: Define a reader schema to be used when parsing Avro records.
         This is useful if you want to override the reader schema included in the Avro OCF file data.
         For example:

         .. code-block::

            {
                 "type": "record",
                 "namespace": "com.example",
                 "name": "FullName",
                 "fields": [
                   { "name": "first", "type": "string" },
                   { "name": "last", "type": "string" }
                 ]
            }.
        :paramtype schema: dict[str, any]
        """
        super().__init__(**kwargs)
        self.format: str = "avro_ocf"
        self.binary_as_string = binary_as_string
        self.extract_unions_by_type = extract_unions_by_type
        self.flatten_spec = flatten_spec
        self.schema = schema


class AvroStreamFormatSettings(DataFormatSettings):
    """AvroStreamFormatSettings.

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    :ivar parse_schema_provider: A parse schema provider describes the source of schema information
     used to parse input data. These are used for input data types that have external schemas (i.e.,
     where the schema is not stored with the data itself), such as Protobuf and Avro. Required.
    :vartype parse_schema_provider: ~polaris.sdk.global_api.models.ParseSchemaProvider
    :ivar binary_as_string: For a bytes Avro column that is not logically marked as a string or
     enum type, specifies if the column should be treated as a UTF-8 encoded string.
    :vartype binary_as_string: bool
    :ivar extract_unions_by_type: If you want to operate on individual members of a union, set
     ``extractUnionsByType`` on the Avro parser.
     This configuration expands union values into nested objects according to the following rules:


     * Primitive types and unnamed complex types are keyed by their type name, such as ``int`` and
     ``string``.
     * Named `complex types <https://avro.apache.org/docs/1.10.2/spec.html#schema_complex>`_ are
     keyed by their names.
       Complex types include ``record``\\ , ``fixed``\\ , and ``enum``.
     * The Avro null type is elided as its value can only ever be null.
    :vartype extract_unions_by_type: bool
    :ivar flatten_spec: A Druid ``flattenSpec`` object for pre-processing the input Avro Stream.
     For more information, see `FlattenSpec
     <https://docs.imply.io/latest/druid/ingestion/data-formats/#flattenspec>`_.
    :vartype flatten_spec: dict[str, any]
    """

    _validation = {
        "format": {"required": True},
        "parse_schema_provider": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
        "parse_schema_provider": {
            "key": "parseSchemaProvider",
            "type": "ParseSchemaProvider",
        },
        "binary_as_string": {"key": "binaryAsString", "type": "bool"},
        "extract_unions_by_type": {"key": "extractUnionsByType", "type": "bool"},
        "flatten_spec": {"key": "flattenSpec", "type": "{object}"},
    }

    def __init__(
        self,
        *,
        parse_schema_provider: "_models.ParseSchemaProvider",
        binary_as_string: bool = False,
        extract_unions_by_type: bool = False,
        flatten_spec: Optional[Dict[str, Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword parse_schema_provider: A parse schema provider describes the source of schema
         information used to parse input data. These are used for input data types that have external
         schemas (i.e., where the schema is not stored with the data itself), such as Protobuf and Avro.
         Required.
        :paramtype parse_schema_provider: ~polaris.sdk.global_api.models.ParseSchemaProvider
        :keyword binary_as_string: For a bytes Avro column that is not logically marked as a string or
         enum type, specifies if the column should be treated as a UTF-8 encoded string.
        :paramtype binary_as_string: bool
        :keyword extract_unions_by_type: If you want to operate on individual members of a union, set
         ``extractUnionsByType`` on the Avro parser.
         This configuration expands union values into nested objects according to the following rules:


         * Primitive types and unnamed complex types are keyed by their type name, such as ``int`` and
         ``string``.
         * Named `complex types <https://avro.apache.org/docs/1.10.2/spec.html#schema_complex>`_ are
         keyed by their names.
           Complex types include ``record``\\ , ``fixed``\\ , and ``enum``.
         * The Avro null type is elided as its value can only ever be null.
        :paramtype extract_unions_by_type: bool
        :keyword flatten_spec: A Druid ``flattenSpec`` object for pre-processing the input Avro Stream.
         For more information, see `FlattenSpec
         <https://docs.imply.io/latest/druid/ingestion/data-formats/#flattenspec>`_.
        :paramtype flatten_spec: dict[str, any]
        """
        super().__init__(**kwargs)
        self.format: str = "avro_stream"
        self.parse_schema_provider = parse_schema_provider
        self.binary_as_string = binary_as_string
        self.extract_unions_by_type = extract_unions_by_type
        self.flatten_spec = flatten_spec


class AwsIamRoleSecretsProperties(_serialization.Model):
    """Properties specific to AWS IAM role secrets.

    :ivar aws_assumed_role_arn: The AWS assumed IAM role to use for additional permissions. Ensure
     you have the correct roles and permissions in AWS Identity and Access Management (IAM). See
     `Access to AWS resources <https://docs.imply.io/ui/saas/help/secure-aws-access.html>`_.
    :vartype aws_assumed_role_arn: str
    """

    _attribute_map = {
        "aws_assumed_role_arn": {"key": "awsAssumedRoleArn", "type": "str"},
    }

    def __init__(
        self, *, aws_assumed_role_arn: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword aws_assumed_role_arn: The AWS assumed IAM role to use for additional permissions.
         Ensure you have the correct roles and permissions in AWS Identity and Access Management (IAM).
         See `Access to AWS resources <https://docs.imply.io/ui/saas/help/secure-aws-access.html>`_.
        :paramtype aws_assumed_role_arn: str
        """
        super().__init__(**kwargs)
        self.aws_assumed_role_arn = aws_assumed_role_arn


class AwsIamRoleSecretsOptionalPayload(
    ConnectionSecretsOptionalPayload, AwsIamRoleSecretsProperties
):
    """Configuration and credentials for IAM role authentication.

    All required parameters must be populated in order to send to server.

    :ivar aws_assumed_role_arn: The AWS assumed IAM role to use for additional permissions. Ensure
     you have the correct roles and permissions in AWS Identity and Access Management (IAM). See
     `Access to AWS resources <https://docs.imply.io/ui/saas/help/secure-aws-access.html>`_.
    :vartype aws_assumed_role_arn: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "aws_assumed_role_arn": {"key": "awsAssumedRoleArn", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self, *, aws_assumed_role_arn: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword aws_assumed_role_arn: The AWS assumed IAM role to use for additional permissions.
         Ensure you have the correct roles and permissions in AWS Identity and Access Management (IAM).
         See `Access to AWS resources <https://docs.imply.io/ui/saas/help/secure-aws-access.html>`_.
        :paramtype aws_assumed_role_arn: str
        """
        super().__init__(aws_assumed_role_arn=aws_assumed_role_arn, **kwargs)
        self.aws_assumed_role_arn = aws_assumed_role_arn
        self.type: str = "aws_iam"


class AwsIamRoleSecretsPropertiesRequired(AwsIamRoleSecretsProperties):
    """AwsIamRoleSecretsPropertiesRequired.

    :ivar aws_assumed_role_arn: The AWS assumed IAM role to use for additional permissions. Ensure
     you have the correct roles and permissions in AWS Identity and Access Management (IAM). See
     `Access to AWS resources <https://docs.imply.io/ui/saas/help/secure-aws-access.html>`_.
    :vartype aws_assumed_role_arn: str
    """


class AwsIamRoleSecretsRequiredPayload(
    ConnectionSecretsRequiredPayload, AwsIamRoleSecretsPropertiesRequired
):
    """Configuration and credentials for IAM role authentication.

    All required parameters must be populated in order to send to server.

    :ivar aws_assumed_role_arn: The AWS assumed IAM role to use for additional permissions. Ensure
     you have the correct roles and permissions in AWS Identity and Access Management (IAM). See
     `Access to AWS resources <https://docs.imply.io/ui/saas/help/secure-aws-access.html>`_.
    :vartype aws_assumed_role_arn: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "aws_assumed_role_arn": {"key": "awsAssumedRoleArn", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self, *, aws_assumed_role_arn: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword aws_assumed_role_arn: The AWS assumed IAM role to use for additional permissions.
         Ensure you have the correct roles and permissions in AWS Identity and Access Management (IAM).
         See `Access to AWS resources <https://docs.imply.io/ui/saas/help/secure-aws-access.html>`_.
        :paramtype aws_assumed_role_arn: str
        """
        super().__init__(aws_assumed_role_arn=aws_assumed_role_arn, **kwargs)
        self.aws_assumed_role_arn = aws_assumed_role_arn
        self.type: str = "aws_iam"


class AzureConnectionProperties(_serialization.Model):
    """Properties specific to an Azure blob storage connection.

    :ivar storage_account: Name of the storage account in Azure Blob Storage.
    :vartype storage_account: str
    :ivar container: Name of the container in the specified storage account in Azure Blob Storage.
    :vartype container: str
    :ivar prefix: Prefix to restrict the connection to specific blobs.
    :vartype prefix: str
    """

    _attribute_map = {
        "storage_account": {"key": "storageAccount", "type": "str"},
        "container": {"key": "container", "type": "str"},
        "prefix": {"key": "prefix", "type": "str"},
    }

    def __init__(
        self,
        *,
        storage_account: Optional[str] = None,
        container: Optional[str] = None,
        prefix: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword storage_account: Name of the storage account in Azure Blob Storage.
        :paramtype storage_account: str
        :keyword container: Name of the container in the specified storage account in Azure Blob
         Storage.
        :paramtype container: str
        :keyword prefix: Prefix to restrict the connection to specific blobs.
        :paramtype prefix: str
        """
        super().__init__(**kwargs)
        self.storage_account = storage_account
        self.container = container
        self.prefix = prefix


class AzureConnectionPropertiesRequired(AzureConnectionProperties):
    """AzureConnectionPropertiesRequired.

    :ivar storage_account: Name of the storage account in Azure Blob Storage.
    :vartype storage_account: str
    :ivar container: Name of the container in the specified storage account in Azure Blob Storage.
    :vartype container: str
    :ivar prefix: Prefix to restrict the connection to specific blobs.
    :vartype prefix: str
    """


class ConnectionSecretsRequiredPropertiesOptional(
    _serialization.Model
):  # pylint: disable=name-too-long
    """ConnectionSecretsRequiredPropertiesOptional.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
    """

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsRequiredPayload"},
    }

    def __init__(
        self,
        *,
        secrets: Optional["_models.ConnectionSecretsRequiredPayload"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
        """
        super().__init__(**kwargs)
        self.secrets = secrets


class ConnectionResponse(_serialization.Model):
    """An abstract connection.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AzureConnectionResponse, ConfluentConnectionResponse,
    ConfluentSchemaRegistryConnectionResponse, KafkaConnectionResponse, KinesisConnectionResponse,
    PushStreamingConnectionResponse, S3ConnectionResponse

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar modified_by_user: Required.
    :vartype modified_by_user: ~polaris.sdk.global_api.models.ConnectionResponseModifiedByUser
    :ivar modified_on_timestamp: Required.
    :vartype modified_on_timestamp: str
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar submitted_by_user: Required.
    :vartype submitted_by_user: ~polaris.sdk.global_api.models.ConnectionResponseSubmittedByUser
    :ivar submitted_on_timestamp: Required.
    :vartype submitted_on_timestamp: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "modified_by_user": {"required": True, "readonly": True},
        "modified_on_timestamp": {"required": True, "readonly": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "submitted_by_user": {"required": True, "readonly": True},
        "submitted_on_timestamp": {"required": True, "readonly": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "modified_by_user": {
            "key": "modifiedByUser",
            "type": "ConnectionResponseModifiedByUser",
        },
        "modified_on_timestamp": {"key": "modifiedOnTimestamp", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "submitted_by_user": {
            "key": "submittedByUser",
            "type": "ConnectionResponseSubmittedByUser",
        },
        "submitted_on_timestamp": {"key": "submittedOnTimestamp", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    _subtype_map = {
        "type": {
            "azure": "AzureConnectionResponse",
            "confluent": "ConfluentConnectionResponse",
            "confluent_schema_registry": "ConfluentSchemaRegistryConnectionResponse",
            "kafka": "KafkaConnectionResponse",
            "kinesis": "KinesisConnectionResponse",
            "push_streaming": "PushStreamingConnectionResponse",
            "s3": "S3ConnectionResponse",
        }
    }

    def __init__(
        self, *, name: str, description: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(**kwargs)
        self.modified_by_user = None
        self.modified_on_timestamp = None
        self.name = name
        self.submitted_by_user = None
        self.submitted_on_timestamp = None
        self.type: Optional[str] = None
        self.description = description


class AzureConnectionResponse(
    ConnectionResponse,
    AzureConnectionPropertiesRequired,
    ConnectionSecretsRequiredPropertiesOptional,
):
    """An Azure blob storage connection.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
    :ivar storage_account: Name of the storage account in Azure Blob Storage.
    :vartype storage_account: str
    :ivar container: Name of the container in the specified storage account in Azure Blob Storage.
    :vartype container: str
    :ivar prefix: Prefix to restrict the connection to specific blobs.
    :vartype prefix: str
    :ivar modified_by_user: Required.
    :vartype modified_by_user: ~polaris.sdk.global_api.models.ConnectionResponseModifiedByUser
    :ivar modified_on_timestamp: Required.
    :vartype modified_on_timestamp: str
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar submitted_by_user: Required.
    :vartype submitted_by_user: ~polaris.sdk.global_api.models.ConnectionResponseSubmittedByUser
    :ivar submitted_on_timestamp: Required.
    :vartype submitted_on_timestamp: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "modified_by_user": {"required": True, "readonly": True},
        "modified_on_timestamp": {"required": True, "readonly": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "submitted_by_user": {"required": True, "readonly": True},
        "submitted_on_timestamp": {"required": True, "readonly": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsRequiredPayload"},
        "storage_account": {"key": "storageAccount", "type": "str"},
        "container": {"key": "container", "type": "str"},
        "prefix": {"key": "prefix", "type": "str"},
        "modified_by_user": {
            "key": "modifiedByUser",
            "type": "ConnectionResponseModifiedByUser",
        },
        "modified_on_timestamp": {"key": "modifiedOnTimestamp", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "submitted_by_user": {
            "key": "submittedByUser",
            "type": "ConnectionResponseSubmittedByUser",
        },
        "submitted_on_timestamp": {"key": "submittedOnTimestamp", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        secrets: Optional["_models.ConnectionSecretsRequiredPayload"] = None,
        storage_account: Optional[str] = None,
        container: Optional[str] = None,
        prefix: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
        :keyword storage_account: Name of the storage account in Azure Blob Storage.
        :paramtype storage_account: str
        :keyword container: Name of the container in the specified storage account in Azure Blob
         Storage.
        :paramtype container: str
        :keyword prefix: Prefix to restrict the connection to specific blobs.
        :paramtype prefix: str
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            name=name,
            description=description,
            storage_account=storage_account,
            container=container,
            prefix=prefix,
            secrets=secrets,
            **kwargs
        )
        self.secrets = secrets
        self.storage_account = storage_account
        self.container = container
        self.prefix = prefix
        self.type: str = "azure"
        self.modified_by_user = None
        self.modified_on_timestamp = None
        self.name = name
        self.submitted_by_user = None
        self.submitted_on_timestamp = None
        self.description = description


class JobSourceSummary(_serialization.Model):
    """Source summary of the job.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AzureJobSourceSummary, ConnectionJobSourceSummary, InlineJobSourceSummary, S3JobSourceSummary,
    TableJobSourceSummary, UploadedJobSourceSummary

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    _subtype_map = {
        "type": {
            "azure": "AzureJobSourceSummary",
            "connection": "ConnectionJobSourceSummary",
            "inline": "InlineJobSourceSummary",
            "s3": "S3JobSourceSummary",
            "table": "TableJobSourceSummary",
            "uploaded": "UploadedJobSourceSummary",
        }
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: Optional[str] = None


class AzureJobSourceSummary(JobSourceSummary):
    """A summary of an Azure blob source input.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    :ivar connection_name: Name of the connection to ingest from. Required.
    :vartype connection_name: str
    """

    _validation = {
        "type": {"required": True},
        "connection_name": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "connection_name": {"key": "connectionName", "type": "str"},
    }

    def __init__(self, *, connection_name: str, **kwargs: Any) -> None:
        """
        :keyword connection_name: Name of the connection to ingest from. Required.
        :paramtype connection_name: str
        """
        super().__init__(**kwargs)
        self.type: str = "azure"
        self.connection_name = connection_name


class JobSourceV2(_serialization.Model):
    """Source input of the job.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    SqlJobSourceV2, AzureJobSourceV2, ConnectionJobSourceV2, InlineJobSourceV2, S3JobSourceV2,
    TableJobSourceV2, UploadedJobSourceV2

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    _subtype_map = {
        "type": {
            "SqlJobSourceV2": "SqlJobSourceV2",
            "azure": "AzureJobSourceV2",
            "connection": "ConnectionJobSourceV2",
            "inline": "InlineJobSourceV2",
            "s3": "S3JobSourceV2",
            "table": "TableJobSourceV2",
            "uploaded": "UploadedJobSourceV2",
        }
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: Optional[str] = None


class AzureJobSourceV2(JobSourceV2):
    """An Azure blob source input. Designate one of ``uris``\\ , ``prefixes``\\ , ``objects``\\ , or
    ``pattern`` for the data to ingest.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    :ivar connection_name: Name of the connection to ingest from. Required.
    :vartype connection_name: str
    :ivar input_schema: The schema of input data in terms of a list of input field names and their
     respective data types. Required.
    :vartype input_schema: list[~polaris.sdk.global_api.models.FieldNameAndDataType]
    :ivar format_settings: Data format settings that apply to all files in the ingestion job.
     Polaris automatically detects the file type based on the file extension. If you specify a value
     that does not match the automatically detected type, Polaris attempts to ingest based on the
     user-specified value.
    :vartype format_settings: ~polaris.sdk.global_api.models.DataFormatSettings
    :ivar objects: JSON array of Azure blobs to ingest from the connection.
    :vartype objects: list[str]
    :ivar pattern: Glob pattern matching against the names of Azure containers and folders. Polaris
     will ingest objects that match the pattern.
    :vartype pattern: str
    :ivar prefixes: JSON array of Azure blob prefixes. Polaris will ingest everything with the
     specified prefixes aside from empty objects.
    :vartype prefixes: list[str]
    :ivar uris: JSON array of URIs of Azure blobs to ingest.
    :vartype uris: list[str]
    """

    _validation = {
        "type": {"required": True},
        "connection_name": {"required": True},
        "input_schema": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "connection_name": {"key": "connectionName", "type": "str"},
        "input_schema": {"key": "inputSchema", "type": "[FieldNameAndDataType]"},
        "format_settings": {"key": "formatSettings", "type": "DataFormatSettings"},
        "objects": {"key": "objects", "type": "[str]"},
        "pattern": {"key": "pattern", "type": "str"},
        "prefixes": {"key": "prefixes", "type": "[str]"},
        "uris": {"key": "uris", "type": "[str]"},
    }

    def __init__(
        self,
        *,
        connection_name: str,
        input_schema: List["_models.FieldNameAndDataType"] = [],
        format_settings: Optional["_models.DataFormatSettings"] = None,
        objects: Optional[List[str]] = None,
        pattern: Optional[str] = None,
        prefixes: Optional[List[str]] = None,
        uris: Optional[List[str]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword connection_name: Name of the connection to ingest from. Required.
        :paramtype connection_name: str
        :keyword input_schema: The schema of input data in terms of a list of input field names and
         their respective data types. Required.
        :paramtype input_schema: list[~polaris.sdk.global_api.models.FieldNameAndDataType]
        :keyword format_settings: Data format settings that apply to all files in the ingestion job.
         Polaris automatically detects the file type based on the file extension. If you specify a value
         that does not match the automatically detected type, Polaris attempts to ingest based on the
         user-specified value.
        :paramtype format_settings: ~polaris.sdk.global_api.models.DataFormatSettings
        :keyword objects: JSON array of Azure blobs to ingest from the connection.
        :paramtype objects: list[str]
        :keyword pattern: Glob pattern matching against the names of Azure containers and folders.
         Polaris will ingest objects that match the pattern.
        :paramtype pattern: str
        :keyword prefixes: JSON array of Azure blob prefixes. Polaris will ingest everything with the
         specified prefixes aside from empty objects.
        :paramtype prefixes: list[str]
        :keyword uris: JSON array of URIs of Azure blobs to ingest.
        :paramtype uris: list[str]
        """
        super().__init__(**kwargs)
        self.type: str = "azure"
        self.connection_name = connection_name
        self.input_schema = input_schema
        self.format_settings = format_settings
        self.objects = objects
        self.pattern = pattern
        self.prefixes = prefixes
        self.uris = uris


class JobResponse(_serialization.Model):
    """A job response.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    BatchJobResponse, DeleteDataJobResponse, DropTableJobResponse, RestoreDataJobResponse,
    SqlJobResponse, StreamingJobResponse

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: Required. Known values are: "pending", "running", "completed", "idle",
     "canceled", "failed", "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobResponseExecutionStatus
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar spec: An abstract request to create a job. Required.
    :vartype spec: ~polaris.sdk.global_api.models.CreateJobRequest
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True, "readonly": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "spec": {"required": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "spec": {"key": "spec", "type": "CreateJobRequest"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
    }

    _subtype_map = {
        "type": {
            "batch": "BatchJobResponse",
            "delete_data": "DeleteDataJobResponse",
            "drop_table": "DropTableJobResponse",
            "restore_data": "RestoreDataJobResponse",
            "sql": "SqlJobResponse",
            "streaming": "StreamingJobResponse",
        }
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        spec: "_models.CreateJobRequest",
        target: "_models.JobTargetV2",
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword spec: An abstract request to create a job. Required.
        :paramtype spec: ~polaris.sdk.global_api.models.CreateJobRequest
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        """
        super().__init__(**kwargs)
        self.created_by = None
        self.created_timestamp = None
        self.desired_execution_status = desired_execution_status
        self.execution_status = None
        self.health = None
        self.id = None
        self.last_modified_by = None
        self.last_updated_timestamp = None
        self.spec = spec
        self.target = target
        self.type: Optional[str] = None
        self.completed_timestamp = None
        self.started_timestamp = None


class BatchJobResponse(JobResponse):
    """A batch job response.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: Required. Known values are: "pending", "running", "completed", "idle",
     "canceled", "failed", "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobResponseExecutionStatus
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar spec: An abstract request to create a job. Required.
    :vartype spec: ~polaris.sdk.global_api.models.CreateJobRequest
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    :ivar source: Source input of the job. Required.
    :vartype source: ~polaris.sdk.global_api.models.JobSourceV2
    :ivar context: Context parameters used to specify various query configuration parameters. For
     more information, see `SQL ingestion reference
     <https://docs.imply.io/ui/saas/help/sql-ingestion-reference.html>`_.
    :vartype context: dict[str, any]
    :ivar filter_expression: SQL expression to use for filtering the source data. For more
     information, see `Filter data to ingest
     <https://docs.imply.io/ui/saas/help//ingest-with-filters.html>`_.
    :vartype filter_expression: str
    :ivar ingestion_mode: Mode of ingestion:


     * ``append``  - Append newly ingested data to the existing data. To ingest a certain time
     range of source data,
       apply a `filter expression <https://docs.imply.io/ui/saas/help/ingest-with-filters.html>`_
     to filter by a given time interval.
     * ``replace`` - Overwrite existing data for specific time intervals or all data in the table.
       Specify specific time intervals in ``target.intervals``\\ , or set ``"replaceAll": true``.
       To restrict the time interval of what data Polaris ingests, use
       `filter expressions <https://docs.imply.io/ui/saas/help/ingest-with-filters.html>`_. Known
     values are: "append" and "replace".
    :vartype ingestion_mode: str or ~polaris.sdk.global_api.models.IngestionModeV2
    :ivar mappings: Relationship between the input fields and the output columns of a table's
     schema.
     Define the Polaris column name in ``columnName``\\ , and specify how the column is defined
     with respect to the input fields in ``expression``. ``expression`` must be a valid SQL
     expression.

     For batch ingestion jobs, you must include a mapping for each field. Polaris ignores
     unmapped input fields. Streaming ingestion jobs may apply schema auto-discovery for
     Polaris to discover input fields and map them directly to table dimensions.
     Always specify a mapping for ``__time`` and when you want to transform an input field.

     For more information, see
     `Map and transform data with input expressions
     <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_
     and `Schema auto-discovery on ingestion jobs
     <https://docs.imply.io/ui/saas/help/job-auto-discovery.html>`_.
    :vartype mappings: list[~polaris.sdk.global_api.models.InputToTableSchemaMapping]
    :ivar max_parse_exceptions: Configuration parameter that specifies the maximum number of parse
     exceptions that a task can tolerate before failing.
    :vartype max_parse_exceptions: int
    :ivar query: The SQL equivalent of this batch job.
    :vartype query: str
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True, "readonly": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "spec": {"required": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
        "source": {"required": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "spec": {"key": "spec", "type": "CreateJobRequest"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
        "source": {"key": "source", "type": "JobSourceV2"},
        "context": {"key": "context", "type": "{object}"},
        "filter_expression": {"key": "filterExpression", "type": "str"},
        "ingestion_mode": {"key": "ingestionMode", "type": "str"},
        "mappings": {"key": "mappings", "type": "[InputToTableSchemaMapping]"},
        "max_parse_exceptions": {"key": "maxParseExceptions", "type": "int"},
        "query": {"key": "query", "type": "str"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        spec: "_models.CreateJobRequest",
        target: "_models.JobTargetV2",
        source: "_models.JobSourceV2",
        context: Optional[Dict[str, Any]] = None,
        filter_expression: Optional[str] = None,
        ingestion_mode: Union[str, "_models.IngestionModeV2"] = "append",
        mappings: List["_models.InputToTableSchemaMapping"] = [],
        max_parse_exceptions: int = 2147483647,
        query: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword spec: An abstract request to create a job. Required.
        :paramtype spec: ~polaris.sdk.global_api.models.CreateJobRequest
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        :keyword source: Source input of the job. Required.
        :paramtype source: ~polaris.sdk.global_api.models.JobSourceV2
        :keyword context: Context parameters used to specify various query configuration parameters.
         For more information, see `SQL ingestion reference
         <https://docs.imply.io/ui/saas/help/sql-ingestion-reference.html>`_.
        :paramtype context: dict[str, any]
        :keyword filter_expression: SQL expression to use for filtering the source data. For more
         information, see `Filter data to ingest
         <https://docs.imply.io/ui/saas/help//ingest-with-filters.html>`_.
        :paramtype filter_expression: str
        :keyword ingestion_mode: Mode of ingestion:


         * ``append``  - Append newly ingested data to the existing data. To ingest a certain time
         range of source data,
           apply a `filter expression <https://docs.imply.io/ui/saas/help/ingest-with-filters.html>`_
         to filter by a given time interval.
         * ``replace`` - Overwrite existing data for specific time intervals or all data in the table.
           Specify specific time intervals in ``target.intervals``\\ , or set ``"replaceAll": true``.
           To restrict the time interval of what data Polaris ingests, use
           `filter expressions <https://docs.imply.io/ui/saas/help/ingest-with-filters.html>`_. Known
         values are: "append" and "replace".
        :paramtype ingestion_mode: str or ~polaris.sdk.global_api.models.IngestionModeV2
        :keyword mappings: Relationship between the input fields and the output columns of a table's
         schema.
         Define the Polaris column name in ``columnName``\\ , and specify how the column is defined
         with respect to the input fields in ``expression``. ``expression`` must be a valid SQL
         expression.

         For batch ingestion jobs, you must include a mapping for each field. Polaris ignores
         unmapped input fields. Streaming ingestion jobs may apply schema auto-discovery for
         Polaris to discover input fields and map them directly to table dimensions.
         Always specify a mapping for ``__time`` and when you want to transform an input field.

         For more information, see
         `Map and transform data with input expressions
         <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_
         and `Schema auto-discovery on ingestion jobs
         <https://docs.imply.io/ui/saas/help/job-auto-discovery.html>`_.
        :paramtype mappings: list[~polaris.sdk.global_api.models.InputToTableSchemaMapping]
        :keyword max_parse_exceptions: Configuration parameter that specifies the maximum number of
         parse exceptions that a task can tolerate before failing.
        :paramtype max_parse_exceptions: int
        :keyword query: The SQL equivalent of this batch job.
        :paramtype query: str
        """
        super().__init__(
            desired_execution_status=desired_execution_status,
            spec=spec,
            target=target,
            **kwargs
        )
        self.type: str = "batch"
        self.source = source
        self.context = context
        self.filter_expression = filter_expression
        self.ingestion_mode = ingestion_mode
        self.mappings = mappings
        self.max_parse_exceptions = max_parse_exceptions
        self.query = query


class JobSummaryResponse(_serialization.Model):
    """A summarized response of a job, returned as part of a JobListResponse.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    BatchJobSummaryResponse, DeleteDataJobSummaryResponse, DropTableJobSummaryResponse,
    RestoreDataJobSummaryResponse, SqlJobSummaryResponse, StreamingJobSummaryResponse

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: The execution status of the job.


     * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
     awaiting resources.
     * ``running``   - The job is currently in progress.
     * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
     warnings or errors.
     * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
     to ingest.
     * ``canceled``  - The job was canceled by the user.
     * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
     the failure.
     * ``suspended`` - The job is suspended by the user.
     * ``unknown``   - The execution status of the job is not known. This state typically occurs
     when a downstream error prevents retrieval of the job execution status. If a job persists in
     this state for an extended period of time (more than a few minutes), please contact Imply.
     Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
     "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
    }

    _subtype_map = {
        "type": {
            "batch": "BatchJobSummaryResponse",
            "delete_data": "DeleteDataJobSummaryResponse",
            "drop_table": "DropTableJobSummaryResponse",
            "restore_data": "RestoreDataJobSummaryResponse",
            "sql": "SqlJobSummaryResponse",
            "streaming": "StreamingJobSummaryResponse",
        }
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        execution_status: Union[str, "_models.JobExecutionStatusV2"],
        target: "_models.JobTargetV2",
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword execution_status: The execution status of the job.


         * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
         awaiting resources.
         * ``running``   - The job is currently in progress.
         * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
         warnings or errors.
         * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
         to ingest.
         * ``canceled``  - The job was canceled by the user.
         * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
         the failure.
         * ``suspended`` - The job is suspended by the user.
         * ``unknown``   - The execution status of the job is not known. This state typically occurs
         when a downstream error prevents retrieval of the job execution status. If a job persists in
         this state for an extended period of time (more than a few minutes), please contact Imply.
         Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
         "suspended", and "unknown".
        :paramtype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        """
        super().__init__(**kwargs)
        self.created_by = None
        self.created_timestamp = None
        self.desired_execution_status = desired_execution_status
        self.execution_status = execution_status
        self.health = None
        self.id = None
        self.last_modified_by = None
        self.last_updated_timestamp = None
        self.target = target
        self.type: Optional[str] = None
        self.completed_timestamp = None
        self.started_timestamp = None


class BatchJobSummaryResponse(JobSummaryResponse):
    """A batch ingestion job. The only source types allowed for this job are ``table`` and
    ``uploaded``.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: The execution status of the job.


     * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
     awaiting resources.
     * ``running``   - The job is currently in progress.
     * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
     warnings or errors.
     * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
     to ingest.
     * ``canceled``  - The job was canceled by the user.
     * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
     the failure.
     * ``suspended`` - The job is suspended by the user.
     * ``unknown``   - The execution status of the job is not known. This state typically occurs
     when a downstream error prevents retrieval of the job execution status. If a job persists in
     this state for an extended period of time (more than a few minutes), please contact Imply.
     Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
     "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    :ivar source: Source summary of the job. Required.
    :vartype source: ~polaris.sdk.global_api.models.JobSourceSummary
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
        "source": {"required": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
        "source": {"key": "source", "type": "JobSourceSummary"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        execution_status: Union[str, "_models.JobExecutionStatusV2"],
        target: "_models.JobTargetV2",
        source: "_models.JobSourceSummary",
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword execution_status: The execution status of the job.


         * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
         awaiting resources.
         * ``running``   - The job is currently in progress.
         * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
         warnings or errors.
         * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
         to ingest.
         * ``canceled``  - The job was canceled by the user.
         * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
         the failure.
         * ``suspended`` - The job is suspended by the user.
         * ``unknown``   - The execution status of the job is not known. This state typically occurs
         when a downstream error prevents retrieval of the job execution status. If a job persists in
         this state for an extended period of time (more than a few minutes), please contact Imply.
         Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
         "suspended", and "unknown".
        :paramtype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        :keyword source: Source summary of the job. Required.
        :paramtype source: ~polaris.sdk.global_api.models.JobSourceSummary
        """
        super().__init__(
            desired_execution_status=desired_execution_status,
            execution_status=execution_status,
            target=target,
            **kwargs
        )
        self.type: str = "batch"
        self.source = source


class BooleanFilter(_serialization.Model):
    """A filter applied to a boolean dimension.

    :ivar filter_type: "boolean"
    :vartype filter_type: str or ~polaris.sdk.global_api.models.BooleanFilterType
    :ivar dimension:
    :vartype dimension: str
    :ivar operator: "eq"
    :vartype operator: str or ~polaris.sdk.global_api.models.BooleanFilterOperator
    :ivar value:
    :vartype value: bool
    """

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "dimension": {"key": "dimension", "type": "str"},
        "operator": {"key": "operator", "type": "str"},
        "value": {"key": "value", "type": "bool"},
    }

    def __init__(
        self,
        *,
        filter_type: Optional[Union[str, "_models.BooleanFilterType"]] = None,
        dimension: Optional[str] = None,
        operator: Optional[Union[str, "_models.BooleanFilterOperator"]] = None,
        value: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword filter_type: "boolean"
        :paramtype filter_type: str or ~polaris.sdk.global_api.models.BooleanFilterType
        :keyword dimension:
        :paramtype dimension: str
        :keyword operator: "eq"
        :paramtype operator: str or ~polaris.sdk.global_api.models.BooleanFilterOperator
        :keyword value:
        :paramtype value: bool
        """
        super().__init__(**kwargs)
        self.filter_type = filter_type
        self.dimension = dimension
        self.operator = operator
        self.value = value


class BubbleChart(_serialization.Model):
    """BubbleChart.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "bubble-chart"
    :vartype type: str or ~polaris.sdk.global_api.models.BubbleChartType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar bubbles: Dimensions to be shown by the bubbles. Required.
    :vartype bubbles: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 2},
        "bubbles": {"required": True, "max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "bubbles": {"key": "bubbles", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        bubbles: List[Any],
        type: Optional[Union[str, "_models.BubbleChartType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "bubble-chart"
        :paramtype type: str or ~polaris.sdk.global_api.models.BubbleChartType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword bubbles: Dimensions to be shown by the bubbles. Required.
        :paramtype bubbles: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.bubbles = bubbles


class Collection(_serialization.Model):
    """Collection object.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar id: Collection ID. Required.
    :vartype id: int
    :ivar name: Name of the collection. Required.
    :vartype name: str
    :ivar description: Description of the collection. Required.
    :vartype description: str
    :ivar assets: Required.
    :vartype assets: list[~polaris.sdk.global_api.models.CollectionAsset]
    :ivar created_by: The user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.User
    :ivar created_at: Date and time the collection was created, in ISO 8601 format. Required.
    :vartype created_at: ~datetime.datetime
    :ivar updated_by: The user. Required.
    :vartype updated_by: ~polaris.sdk.global_api.models.User
    :ivar updated_at: Date and time of the last update in ISO 8601 format. Required.
    :vartype updated_at: ~datetime.datetime
    """

    _validation = {
        "id": {"required": True, "readonly": True},
        "name": {"required": True},
        "description": {"required": True},
        "assets": {"required": True},
        "created_by": {"required": True, "readonly": True},
        "created_at": {"required": True},
        "updated_by": {"required": True, "readonly": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "assets": {"key": "assets", "type": "[CollectionAsset]"},
        "created_by": {"key": "createdBy", "type": "User"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "User"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        name: str,
        description: str,
        assets: List["_models.CollectionAsset"],
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the collection. Required.
        :paramtype name: str
        :keyword description: Description of the collection. Required.
        :paramtype description: str
        :keyword assets: Required.
        :paramtype assets: list[~polaris.sdk.global_api.models.CollectionAsset]
        :keyword created_at: Date and time the collection was created, in ISO 8601 format. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword updated_at: Date and time of the last update in ISO 8601 format. Required.
        :paramtype updated_at: ~datetime.datetime
        """
        super().__init__(**kwargs)
        self.id = None
        self.name = name
        self.description = description
        self.assets = assets
        self.created_by = None
        self.created_at = created_at
        self.updated_by = None
        self.updated_at = updated_at


class CollectionAsset(_serialization.Model):
    """An asset in a collection.

    All required parameters must be populated in order to send to server.

    :ivar id: Collection asset ID. Required.
    :vartype id: str
    :ivar type: Collection asset type. Required. Known values are: "dataCube", "dashboard",
     "alert", "report", "embedding", "table", "connection", and "file".
    :vartype type: str or ~polaris.sdk.global_api.models.CollectionAssetType
    """

    _validation = {
        "id": {"required": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        type: Union[str, "_models.CollectionAssetType"],
        **kwargs: Any
    ) -> None:
        """
        :keyword id: Collection asset ID. Required.
        :paramtype id: str
        :keyword type: Collection asset type. Required. Known values are: "dataCube", "dashboard",
         "alert", "report", "embedding", "table", "connection", and "file".
        :paramtype type: str or ~polaris.sdk.global_api.models.CollectionAssetType
        """
        super().__init__(**kwargs)
        self.id = id
        self.type = type


class CollectionAssetsPayload(_serialization.Model):
    """Assets payload.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.CollectionAsset]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[CollectionAsset]"},
    }

    def __init__(
        self, *, values: List["_models.CollectionAsset"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.CollectionAsset]
        """
        super().__init__(**kwargs)
        self.values = values


class CollectionCreatePayload(_serialization.Model):
    """Collection payload used for creation.

    All required parameters must be populated in order to send to server.

    :ivar name: Name of the collection. Required.
    :vartype name: str
    :ivar description: Description of the collection.
    :vartype description: str
    """

    _validation = {
        "name": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self, *, name: str, description: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the collection. Required.
        :paramtype name: str
        :keyword description: Description of the collection.
        :paramtype description: str
        """
        super().__init__(**kwargs)
        self.name = name
        self.description = description


class CollectionListResponse(_serialization.Model):
    """A list of collections.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.Collection]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[Collection]"},
    }

    def __init__(self, *, values: List["_models.Collection"], **kwargs: Any) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.Collection]
        """
        super().__init__(**kwargs)
        self.values = values


class CollectionUpdatePayload(_serialization.Model):
    """Collection updates.

    :ivar name: Name of the collection.
    :vartype name: str
    :ivar description: Description of the collection.
    :vartype description: str
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the collection.
        :paramtype name: str
        :keyword description: Description of the collection.
        :paramtype description: str
        """
        super().__init__(**kwargs)
        self.name = name
        self.description = description


class Compare(_serialization.Model):
    """A comparison for Pivot Classic data cubes.

    All required parameters must be populated in order to send to server.

    :ivar type: Required. Known values are: "absolute", "relative", "time-relative",
     "time-absolute", "unfilter", "filter", and "measure".
    :vartype type: str or ~polaris.sdk.global_api.models.CompareType
    :ivar duration: Time period to compare against, expressed as an `ISO 8601 Duration
     <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
     Only used for time-relative comparisons.
    :vartype duration: ~datetime.timedelta
    :ivar interval: Defines a start and end boundary for a time range.
    :vartype interval: ~polaris.sdk.global_api.models.TimeRange
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "duration": {"key": "duration", "type": "duration"},
        "interval": {"key": "interval", "type": "TimeRange"},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.CompareType"],
        duration: Optional[datetime.timedelta] = None,
        interval: Optional["_models.TimeRange"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Required. Known values are: "absolute", "relative", "time-relative",
         "time-absolute", "unfilter", "filter", and "measure".
        :paramtype type: str or ~polaris.sdk.global_api.models.CompareType
        :keyword duration: Time period to compare against, expressed as an `ISO 8601 Duration
         <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
         Only used for time-relative comparisons.
        :paramtype duration: ~datetime.timedelta
        :keyword interval: Defines a start and end boundary for a time range.
        :paramtype interval: ~polaris.sdk.global_api.models.TimeRange
        """
        super().__init__(**kwargs)
        self.type = type
        self.duration = duration
        self.interval = interval


class Comparison(_serialization.Model):
    """Comparison.

    All required parameters must be populated in order to send to server.

    :ivar compare_type: Required. Known values are: "absolute", "relative", "time-relative",
     "time-absolute", "unfilter", "filter", and "measure".
    :vartype compare_type: str or ~polaris.sdk.global_api.models.CompareType
    :ivar duration:
    :vartype duration: str
    :ivar absolute_starting_date:
    :vartype absolute_starting_date: str
    :ivar dimension: Anything.
    :vartype dimension: any
    :ivar measure:
    :vartype measure: ~polaris.sdk.global_api.models.Measure
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    """

    _validation = {
        "compare_type": {"required": True},
    }

    _attribute_map = {
        "compare_type": {"key": "compareType", "type": "str"},
        "duration": {"key": "duration", "type": "str"},
        "absolute_starting_date": {"key": "absoluteStartingDate", "type": "str"},
        "dimension": {"key": "dimension", "type": "object"},
        "measure": {"key": "measure", "type": "Measure"},
        "filter": {"key": "filter", "type": "Filter"},
    }

    def __init__(
        self,
        *,
        compare_type: Union[str, "_models.CompareType"],
        duration: Optional[str] = None,
        absolute_starting_date: Optional[str] = None,
        dimension: Optional[Any] = None,
        measure: Optional["_models.Measure"] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        **kwargs: Any
    ) -> None:
        """
        :keyword compare_type: Required. Known values are: "absolute", "relative", "time-relative",
         "time-absolute", "unfilter", "filter", and "measure".
        :paramtype compare_type: str or ~polaris.sdk.global_api.models.CompareType
        :keyword duration:
        :paramtype duration: str
        :keyword absolute_starting_date:
        :paramtype absolute_starting_date: str
        :keyword dimension: Anything.
        :paramtype dimension: any
        :keyword measure:
        :paramtype measure: ~polaris.sdk.global_api.models.Measure
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        """
        super().__init__(**kwargs)
        self.compare_type = compare_type
        self.duration = duration
        self.absolute_starting_date = absolute_starting_date
        self.dimension = dimension
        self.measure = measure
        self.filter = filter


class ComparisonColors(_serialization.Model):
    """Determines the display coloring for increased and decreased values.

    All required parameters must be populated in order to send to server.

    :ivar label: Comparison label. Required.
    :vartype label: str
    :ivar increase: Color to use for increased values, expressed as a HEX color code. Required.
    :vartype increase: str
    :ivar decrease: Color to use for decreased values, expressed as a HEX color code. Required.
    :vartype decrease: str
    """

    _validation = {
        "label": {"required": True},
        "increase": {"required": True},
        "decrease": {"required": True},
    }

    _attribute_map = {
        "label": {"key": "label", "type": "str"},
        "increase": {"key": "increase", "type": "str"},
        "decrease": {"key": "decrease", "type": "str"},
    }

    def __init__(
        self, *, label: str, increase: str, decrease: str, **kwargs: Any
    ) -> None:
        """
        :keyword label: Comparison label. Required.
        :paramtype label: str
        :keyword increase: Color to use for increased values, expressed as a HEX color code. Required.
        :paramtype increase: str
        :keyword decrease: Color to use for decreased values, expressed as a HEX color code. Required.
        :paramtype decrease: str
        """
        super().__init__(**kwargs)
        self.label = label
        self.increase = increase
        self.decrease = decrease


class NetworkPolicyDetails(_serialization.Model):
    """The property name is the IPv4 address or CIDR.
    The property value is an object that describes the network policy.
    For example, ``entries`` may contain the following policy:

    .. code-block::

       "entries": {
           "192.0.2.255": {
               "description": "Example IPv4 address",
               "policy": "allow"
           }
       }.

    All required parameters must be populated in order to send to server.

    :ivar description: Description of the network policy. Required.
    :vartype description: str
    :ivar policy: Allow access from the specified IP address or CIDR. Required. "allow"
    :vartype policy: str or ~polaris.sdk.global_api.models.NetworkPolicyDetailsPolicy
    """

    _validation = {
        "description": {"required": True},
        "policy": {"required": True},
    }

    _attribute_map = {
        "description": {"key": "description", "type": "str"},
        "policy": {"key": "policy", "type": "str"},
    }

    def __init__(
        self,
        *,
        description: str,
        policy: Union[str, "_models.NetworkPolicyDetailsPolicy"],
        **kwargs: Any
    ) -> None:
        """
        :keyword description: Description of the network policy. Required.
        :paramtype description: str
        :keyword policy: Allow access from the specified IP address or CIDR. Required. "allow"
        :paramtype policy: str or ~polaris.sdk.global_api.models.NetworkPolicyDetailsPolicy
        """
        super().__init__(**kwargs)
        self.description = description
        self.policy = policy


class Components16X07DtSchemasNetworkpolicyPropertiesEntriesAdditionalproperties(
    NetworkPolicyDetails
):  # pylint: disable=name-too-long
    """Components16X07DtSchemasNetworkpolicyPropertiesEntriesAdditionalproperties.

    All required parameters must be populated in order to send to server.

    :ivar description: Description of the network policy. Required.
    :vartype description: str
    :ivar policy: Allow access from the specified IP address or CIDR. Required. "allow"
    :vartype policy: str or ~polaris.sdk.global_api.models.NetworkPolicyDetailsPolicy
    """


class ConfluentConnectionProperties(_serialization.Model):
    """Properties specific to a Confluent connection.

    :ivar bootstrap_servers: List of host and port pairs used for establishing the initial
     connection to the Kafka cluster.
    :vartype bootstrap_servers: str
    :ivar topic_name: The topic name or a regular expression that identifies the Kafka topics.
    :vartype topic_name: str
    :ivar topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris looks
     for a single topic with the exact name in ``topicName``. If true, Polaris treats ``topicName``
     as a regular expression to match topic names. Use this option to ingest data from multiple
     topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
     ``topic23`` but not ``topicAB``.
    :vartype topic_name_is_pattern: bool
    """

    _attribute_map = {
        "bootstrap_servers": {"key": "bootstrapServers", "type": "str"},
        "topic_name": {"key": "topicName", "type": "str"},
        "topic_name_is_pattern": {"key": "topicNameIsPattern", "type": "bool"},
    }

    def __init__(
        self,
        *,
        bootstrap_servers: Optional[str] = None,
        topic_name: Optional[str] = None,
        topic_name_is_pattern: bool = False,
        **kwargs: Any
    ) -> None:
        """
        :keyword bootstrap_servers: List of host and port pairs used for establishing the initial
         connection to the Kafka cluster.
        :paramtype bootstrap_servers: str
        :keyword topic_name: The topic name or a regular expression that identifies the Kafka topics.
        :paramtype topic_name: str
        :keyword topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris
         looks for a single topic with the exact name in ``topicName``. If true, Polaris treats
         ``topicName`` as a regular expression to match topic names. Use this option to ingest data from
         multiple topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
         ``topic23`` but not ``topicAB``.
        :paramtype topic_name_is_pattern: bool
        """
        super().__init__(**kwargs)
        self.bootstrap_servers = bootstrap_servers
        self.topic_name = topic_name
        self.topic_name_is_pattern = topic_name_is_pattern


class ConfluentConnectionPropertiesRequired(ConfluentConnectionProperties):
    """ConfluentConnectionPropertiesRequired.

    :ivar bootstrap_servers: List of host and port pairs used for establishing the initial
     connection to the Kafka cluster.
    :vartype bootstrap_servers: str
    :ivar topic_name: The topic name or a regular expression that identifies the Kafka topics.
    :vartype topic_name: str
    :ivar topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris looks
     for a single topic with the exact name in ``topicName``. If true, Polaris treats ``topicName``
     as a regular expression to match topic names. Use this option to ingest data from multiple
     topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
     ``topic23`` but not ``topicAB``.
    :vartype topic_name_is_pattern: bool
    """


class ConfluentConnectionResponse(
    ConnectionResponse,
    ConfluentConnectionPropertiesRequired,
    ConnectionSecretsRequiredPropertiesOptional,
):
    """A Confluent connection.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
    :ivar bootstrap_servers: List of host and port pairs used for establishing the initial
     connection to the Kafka cluster.
    :vartype bootstrap_servers: str
    :ivar topic_name: The topic name or a regular expression that identifies the Kafka topics.
    :vartype topic_name: str
    :ivar topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris looks
     for a single topic with the exact name in ``topicName``. If true, Polaris treats ``topicName``
     as a regular expression to match topic names. Use this option to ingest data from multiple
     topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
     ``topic23`` but not ``topicAB``.
    :vartype topic_name_is_pattern: bool
    :ivar modified_by_user: Required.
    :vartype modified_by_user: ~polaris.sdk.global_api.models.ConnectionResponseModifiedByUser
    :ivar modified_on_timestamp: Required.
    :vartype modified_on_timestamp: str
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar submitted_by_user: Required.
    :vartype submitted_by_user: ~polaris.sdk.global_api.models.ConnectionResponseSubmittedByUser
    :ivar submitted_on_timestamp: Required.
    :vartype submitted_on_timestamp: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "modified_by_user": {"required": True, "readonly": True},
        "modified_on_timestamp": {"required": True, "readonly": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "submitted_by_user": {"required": True, "readonly": True},
        "submitted_on_timestamp": {"required": True, "readonly": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsRequiredPayload"},
        "bootstrap_servers": {"key": "bootstrapServers", "type": "str"},
        "topic_name": {"key": "topicName", "type": "str"},
        "topic_name_is_pattern": {"key": "topicNameIsPattern", "type": "bool"},
        "modified_by_user": {
            "key": "modifiedByUser",
            "type": "ConnectionResponseModifiedByUser",
        },
        "modified_on_timestamp": {"key": "modifiedOnTimestamp", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "submitted_by_user": {
            "key": "submittedByUser",
            "type": "ConnectionResponseSubmittedByUser",
        },
        "submitted_on_timestamp": {"key": "submittedOnTimestamp", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        secrets: Optional["_models.ConnectionSecretsRequiredPayload"] = None,
        bootstrap_servers: Optional[str] = None,
        topic_name: Optional[str] = None,
        topic_name_is_pattern: bool = False,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
        :keyword bootstrap_servers: List of host and port pairs used for establishing the initial
         connection to the Kafka cluster.
        :paramtype bootstrap_servers: str
        :keyword topic_name: The topic name or a regular expression that identifies the Kafka topics.
        :paramtype topic_name: str
        :keyword topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris
         looks for a single topic with the exact name in ``topicName``. If true, Polaris treats
         ``topicName`` as a regular expression to match topic names. Use this option to ingest data from
         multiple topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
         ``topic23`` but not ``topicAB``.
        :paramtype topic_name_is_pattern: bool
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            name=name,
            description=description,
            bootstrap_servers=bootstrap_servers,
            topic_name=topic_name,
            topic_name_is_pattern=topic_name_is_pattern,
            secrets=secrets,
            **kwargs
        )
        self.secrets = secrets
        self.bootstrap_servers = bootstrap_servers
        self.topic_name = topic_name
        self.topic_name_is_pattern = topic_name_is_pattern
        self.type: str = "confluent"
        self.modified_by_user = None
        self.modified_on_timestamp = None
        self.name = name
        self.submitted_by_user = None
        self.submitted_on_timestamp = None
        self.description = description


class ConfluentSchemaRegistryConnectionProperties(
    _serialization.Model
):  # pylint: disable=name-too-long
    """Properties specific to a Confluent schema registry connection.

    :ivar urls: List of URLs of Schema Registry instances to look up schemas.
    :vartype urls: list[str]
    """

    _attribute_map = {
        "urls": {"key": "urls", "type": "[str]"},
    }

    def __init__(self, *, urls: List[str] = [], **kwargs: Any) -> None:
        """
        :keyword urls: List of URLs of Schema Registry instances to look up schemas.
        :paramtype urls: list[str]
        """
        super().__init__(**kwargs)
        self.urls = urls


class ConfluentSchemaRegistryConnectionResponse(
    ConnectionResponse,
    ConfluentSchemaRegistryConnectionProperties,
    ConnectionSecretsRequiredPropertiesOptional,
):  # pylint: disable=name-too-long
    """A Confluent schema registry connection.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
    :ivar urls: List of URLs of Schema Registry instances to look up schemas.
    :vartype urls: list[str]
    :ivar modified_by_user: Required.
    :vartype modified_by_user: ~polaris.sdk.global_api.models.ConnectionResponseModifiedByUser
    :ivar modified_on_timestamp: Required.
    :vartype modified_on_timestamp: str
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar submitted_by_user: Required.
    :vartype submitted_by_user: ~polaris.sdk.global_api.models.ConnectionResponseSubmittedByUser
    :ivar submitted_on_timestamp: Required.
    :vartype submitted_on_timestamp: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "modified_by_user": {"required": True, "readonly": True},
        "modified_on_timestamp": {"required": True, "readonly": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "submitted_by_user": {"required": True, "readonly": True},
        "submitted_on_timestamp": {"required": True, "readonly": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsRequiredPayload"},
        "urls": {"key": "urls", "type": "[str]"},
        "modified_by_user": {
            "key": "modifiedByUser",
            "type": "ConnectionResponseModifiedByUser",
        },
        "modified_on_timestamp": {"key": "modifiedOnTimestamp", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "submitted_by_user": {
            "key": "submittedByUser",
            "type": "ConnectionResponseSubmittedByUser",
        },
        "submitted_on_timestamp": {"key": "submittedOnTimestamp", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        secrets: Optional["_models.ConnectionSecretsRequiredPayload"] = None,
        urls: List[str] = [],
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
        :keyword urls: List of URLs of Schema Registry instances to look up schemas.
        :paramtype urls: list[str]
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            name=name, description=description, urls=urls, secrets=secrets, **kwargs
        )
        self.secrets = secrets
        self.urls = urls
        self.type: str = "confluent_schema_registry"
        self.modified_by_user = None
        self.modified_on_timestamp = None
        self.name = name
        self.submitted_by_user = None
        self.submitted_on_timestamp = None
        self.description = description


class ConfluentSecretsProperties(_serialization.Model):
    """Properties specific to Confluent connection secrets.

    :ivar key: The key of a `Confluent Cloud API key
     <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
     with Kafka access.
    :vartype key: str
    :ivar secret: The secret of a `Confluent Cloud API key
     <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
     with Kafka access.
    :vartype secret: str
    """

    _attribute_map = {
        "key": {"key": "key", "type": "str"},
        "secret": {"key": "secret", "type": "str"},
    }

    def __init__(
        self, *, key: Optional[str] = None, secret: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword key: The key of a `Confluent Cloud API key
         <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
         with Kafka access.
        :paramtype key: str
        :keyword secret: The secret of a `Confluent Cloud API key
         <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
         with Kafka access.
        :paramtype secret: str
        """
        super().__init__(**kwargs)
        self.key = key
        self.secret = secret


class ConfluentSecretsOptionalPayload(
    ConnectionSecretsOptionalPayload, ConfluentSecretsProperties
):
    """A legacy payload for Confluent connection secrets.

    All required parameters must be populated in order to send to server.

    :ivar key: The key of a `Confluent Cloud API key
     <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
     with Kafka access.
    :vartype key: str
    :ivar secret: The secret of a `Confluent Cloud API key
     <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
     with Kafka access.
    :vartype secret: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "key": {"key": "key", "type": "str"},
        "secret": {"key": "secret", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self, *, key: Optional[str] = None, secret: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword key: The key of a `Confluent Cloud API key
         <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
         with Kafka access.
        :paramtype key: str
        :keyword secret: The secret of a `Confluent Cloud API key
         <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
         with Kafka access.
        :paramtype secret: str
        """
        super().__init__(key=key, secret=secret, **kwargs)
        self.key = key
        self.secret = secret
        self.type: str = "confluent"


class ConfluentSecretsPropertiesRequired(ConfluentSecretsProperties):
    """ConfluentSecretsPropertiesRequired.

    :ivar key: The key of a `Confluent Cloud API key
     <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
     with Kafka access.
    :vartype key: str
    :ivar secret: The secret of a `Confluent Cloud API key
     <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
     with Kafka access.
    :vartype secret: str
    """


class ConfluentSecretsRequiredPayload(
    ConnectionSecretsRequiredPayload, ConfluentSecretsPropertiesRequired
):
    """A legacy payload for Confluent connection secrets.

    All required parameters must be populated in order to send to server.

    :ivar key: The key of a `Confluent Cloud API key
     <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
     with Kafka access.
    :vartype key: str
    :ivar secret: The secret of a `Confluent Cloud API key
     <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
     with Kafka access.
    :vartype secret: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "key": {"key": "key", "type": "str"},
        "secret": {"key": "secret", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self, *, key: Optional[str] = None, secret: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword key: The key of a `Confluent Cloud API key
         <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
         with Kafka access.
        :paramtype key: str
        :keyword secret: The secret of a `Confluent Cloud API key
         <https://docs.confluent.io/cloud/current/access-management/authenticate/api-keys/api-keys.html>`_
         with Kafka access.
        :paramtype secret: str
        """
        super().__init__(key=key, secret=secret, **kwargs)
        self.key = key
        self.secret = secret
        self.type: str = "confluent"


class ConnectionJobSourceSummary(JobSourceSummary):
    """A summary of a source that is external to Polaris.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    :ivar connection_name: Name of the connection to ingest from. Required.
    :vartype connection_name: str
    """

    _validation = {
        "type": {"required": True},
        "connection_name": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "connection_name": {"key": "connectionName", "type": "str"},
    }

    def __init__(self, *, connection_name: str, **kwargs: Any) -> None:
        """
        :keyword connection_name: Name of the connection to ingest from. Required.
        :paramtype connection_name: str
        """
        super().__init__(**kwargs)
        self.type: str = "connection"
        self.connection_name = connection_name


class ConnectionJobSourceV2(JobSourceV2):
    """A source that is external to Polaris. Data in this source is pulled into Polaris.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    :ivar connection_name: Name of the connection to ingest from. Required.
    :vartype connection_name: str
    :ivar format_settings: Data format settings that apply to all files in the ingestion job.
     Polaris automatically detects the file type based on the file extension. If you specify a value
     that does not match the automatically detected type, Polaris attempts to ingest based on the
     user-specified value.
    :vartype format_settings: ~polaris.sdk.global_api.models.DataFormatSettings
    :ivar input_schema: The schema of input data in terms of a list of input field names and their
     respective data types.
    :vartype input_schema: list[~polaris.sdk.global_api.models.FieldNameAndDataType]
    """

    _validation = {
        "type": {"required": True},
        "connection_name": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "connection_name": {"key": "connectionName", "type": "str"},
        "format_settings": {"key": "formatSettings", "type": "DataFormatSettings"},
        "input_schema": {"key": "inputSchema", "type": "[FieldNameAndDataType]"},
    }

    def __init__(
        self,
        *,
        connection_name: str,
        format_settings: Optional["_models.DataFormatSettings"] = None,
        input_schema: List["_models.FieldNameAndDataType"] = [],
        **kwargs: Any
    ) -> None:
        """
        :keyword connection_name: Name of the connection to ingest from. Required.
        :paramtype connection_name: str
        :keyword format_settings: Data format settings that apply to all files in the ingestion job.
         Polaris automatically detects the file type based on the file extension. If you specify a value
         that does not match the automatically detected type, Polaris attempts to ingest based on the
         user-specified value.
        :paramtype format_settings: ~polaris.sdk.global_api.models.DataFormatSettings
        :keyword input_schema: The schema of input data in terms of a list of input field names and
         their respective data types.
        :paramtype input_schema: list[~polaris.sdk.global_api.models.FieldNameAndDataType]
        """
        super().__init__(**kwargs)
        self.type: str = "connection"
        self.connection_name = connection_name
        self.format_settings = format_settings
        self.input_schema = input_schema


class ConnectionListResponse(_serialization.Model):
    """A list of connection objects.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.ConnectionResponse]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[ConnectionResponse]"},
    }

    def __init__(
        self, *, values: List["_models.ConnectionResponse"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.ConnectionResponse]
        """
        super().__init__(**kwargs)
        self.values = values


class ParseSchemaProvider(_serialization.Model):
    """A parse schema provider describes the source of schema information used to parse input data.
    These are used for input data types that have external schemas (i.e., where the schema is not
    stored with the data itself), such as Protobuf and Avro.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    ConnectionParseSchemaProvider, InlineAvroParseSchemaProvider, InlineProtobufParseSchemaProvider

    All required parameters must be populated in order to send to server.

    :ivar type: Data format:


     * ``connection`` - Retrieves the parse schema from an external source defined by a connection.
     * ``inline-avro`` - An inline Avro schema.
     * ``inline-protobuf`` - An inline compiled Protobuf descriptor, encoded as a Base64 string.
     Required. Known values are: "connection", "inline-avro", and "inline-protobuf".
    :vartype type: str or ~polaris.sdk.global_api.models.ParseSchemaProviderType
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    _subtype_map = {
        "type": {
            "connection": "ConnectionParseSchemaProvider",
            "inline-avro": "InlineAvroParseSchemaProvider",
            "inline-protobuf": "InlineProtobufParseSchemaProvider",
        }
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: Optional[str] = None


class ConnectionParseSchemaProvider(ParseSchemaProvider):
    """ConnectionParseSchemaProvider.

    All required parameters must be populated in order to send to server.

    :ivar type: Data format:


     * ``connection`` - Retrieves the parse schema from an external source defined by a connection.
     * ``inline-avro`` - An inline Avro schema.
     * ``inline-protobuf`` - An inline compiled Protobuf descriptor, encoded as a Base64 string.
     Required. Known values are: "connection", "inline-avro", and "inline-protobuf".
    :vartype type: str or ~polaris.sdk.global_api.models.ParseSchemaProviderType
    :ivar connection_name: Name of the connection that provides the parse schema.
    :vartype connection_name: str
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "connection_name": {"key": "connectionName", "type": "str"},
    }

    def __init__(self, *, connection_name: Optional[str] = None, **kwargs: Any) -> None:
        """
        :keyword connection_name: Name of the connection that provides the parse schema.
        :paramtype connection_name: str
        """
        super().__init__(**kwargs)
        self.type: str = "connection"
        self.connection_name = connection_name


class UserV2(_serialization.Model):
    """A user.

    All required parameters must be populated in order to send to server.

    :ivar username: The username of the user. Required.
    :vartype username: str
    :ivar user_id: The unique ID of the user. Required.
    :vartype user_id: str
    """

    _validation = {
        "username": {"required": True},
        "user_id": {"required": True},
    }

    _attribute_map = {
        "username": {"key": "username", "type": "str"},
        "user_id": {"key": "userId", "type": "str"},
    }

    def __init__(self, *, username: str, user_id: str, **kwargs: Any) -> None:
        """
        :keyword username: The username of the user. Required.
        :paramtype username: str
        :keyword user_id: The unique ID of the user. Required.
        :paramtype user_id: str
        """
        super().__init__(**kwargs)
        self.username = username
        self.user_id = user_id


class ModifiedByUserResponse(UserV2):
    """The user who modified the object last.

    All required parameters must be populated in order to send to server.

    :ivar username: The username of the user. Required.
    :vartype username: str
    :ivar user_id: The unique ID of the user. Required.
    :vartype user_id: str
    """


class ConnectionResponseModifiedByUser(ModifiedByUserResponse):
    """ConnectionResponseModifiedByUser.

    All required parameters must be populated in order to send to server.

    :ivar username: The username of the user. Required.
    :vartype username: str
    :ivar user_id: The unique ID of the user. Required.
    :vartype user_id: str
    """


class CreatedByUserResponse(UserV2):
    """The user who created the initial object.

    All required parameters must be populated in order to send to server.

    :ivar username: The username of the user. Required.
    :vartype username: str
    :ivar user_id: The unique ID of the user. Required.
    :vartype user_id: str
    """


class ConnectionResponseSubmittedByUser(CreatedByUserResponse):
    """ConnectionResponseSubmittedByUser.

    All required parameters must be populated in order to send to server.

    :ivar username: The username of the user. Required.
    :vartype username: str
    :ivar user_id: The unique ID of the user. Required.
    :vartype user_id: str
    """


class ConnectionSecretsOptionalProperties(_serialization.Model):
    """ConnectionSecretsOptionalProperties.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
    """

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsOptionalPayload"},
    }

    def __init__(
        self,
        *,
        secrets: Optional["_models.ConnectionSecretsOptionalPayload"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
        """
        super().__init__(**kwargs)
        self.secrets = secrets


class ConnectionSecretsRequiredProperties(_serialization.Model):
    """ConnectionSecretsRequiredProperties.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
     Required.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
    """

    _validation = {
        "secrets": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsRequiredPayload"},
    }

    def __init__(
        self, *, secrets: "_models.ConnectionSecretsRequiredPayload", **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
         Required.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
        """
        super().__init__(**kwargs)
        self.secrets = secrets


class ConnectionsMetaResponse(_serialization.Model):
    """Meta information related to connections.

    :ivar external_id: The external ID to use when granting access to your AWS resources.
    :vartype external_id: str
    :ivar imply_arn: The AWS IAM policies to grant Imply access to.
    :vartype imply_arn: str
    """

    _attribute_map = {
        "external_id": {"key": "externalId", "type": "str"},
        "imply_arn": {"key": "implyArn", "type": "str"},
    }

    def __init__(
        self,
        *,
        external_id: Optional[str] = None,
        imply_arn: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword external_id: The external ID to use when granting access to your AWS resources.
        :paramtype external_id: str
        :keyword imply_arn: The AWS IAM policies to grant Imply access to.
        :paramtype imply_arn: str
        """
        super().__init__(**kwargs)
        self.external_id = external_id
        self.imply_arn = imply_arn


class CreateConnectionRequest(_serialization.Model):
    """An abstract request to create a connection.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CreateAzureConnectionRequest, CreateConfluentConnectionRequest,
    CreateConfluentSchemaRegistryConnectionRequest, CreateKafkaConnectionRequest,
    CreateKinesisConnectionRequest, CreatePushStreamingConnectionRequest, CreateS3ConnectionRequest

    All required parameters must be populated in order to send to server.

    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "type": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    _subtype_map = {
        "type": {
            "azure": "CreateAzureConnectionRequest",
            "confluent": "CreateConfluentConnectionRequest",
            "confluent_schema_registry": "CreateConfluentSchemaRegistryConnectionRequest",
            "kafka": "CreateKafkaConnectionRequest",
            "kinesis": "CreateKinesisConnectionRequest",
            "push_streaming": "CreatePushStreamingConnectionRequest",
            "s3": "CreateS3ConnectionRequest",
        }
    }

    def __init__(
        self, *, name: str, description: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(**kwargs)
        self.name = name
        self.type: Optional[str] = None
        self.description = description


class CreateAzureConnectionRequest(
    CreateConnectionRequest,
    AzureConnectionPropertiesRequired,
    ConnectionSecretsRequiredProperties,
):
    """A request to create an Azure blob storage connection.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
     Required.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
    :ivar storage_account: Name of the storage account in Azure Blob Storage.
    :vartype storage_account: str
    :ivar container: Name of the container in the specified storage account in Azure Blob Storage.
    :vartype container: str
    :ivar prefix: Prefix to restrict the connection to specific blobs.
    :vartype prefix: str
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "secrets": {"required": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsRequiredPayload"},
        "storage_account": {"key": "storageAccount", "type": "str"},
        "container": {"key": "container", "type": "str"},
        "prefix": {"key": "prefix", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        secrets: "_models.ConnectionSecretsRequiredPayload",
        name: str,
        storage_account: Optional[str] = None,
        container: Optional[str] = None,
        prefix: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
         Required.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
        :keyword storage_account: Name of the storage account in Azure Blob Storage.
        :paramtype storage_account: str
        :keyword container: Name of the container in the specified storage account in Azure Blob
         Storage.
        :paramtype container: str
        :keyword prefix: Prefix to restrict the connection to specific blobs.
        :paramtype prefix: str
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            name=name,
            description=description,
            storage_account=storage_account,
            container=container,
            prefix=prefix,
            secrets=secrets,
            **kwargs
        )
        self.secrets = secrets
        self.storage_account = storage_account
        self.container = container
        self.prefix = prefix
        self.type: str = "azure"
        self.name = name
        self.description = description


class CreateJobRequest(_serialization.Model):
    """An abstract request to create a job.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CreateBatchJobRequest, CreateDeleteDataJobRequest, CreateDropTableJobRequest,
    CreateRestoreDataJobRequest, CreateSqlJobRequest, CreateStreamingJobRequest

    All required parameters must be populated in order to send to server.

    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    _subtype_map = {
        "type": {
            "batch": "CreateBatchJobRequest",
            "delete_data": "CreateDeleteDataJobRequest",
            "drop_table": "CreateDropTableJobRequest",
            "restore_data": "CreateRestoreDataJobRequest",
            "sql": "CreateSqlJobRequest",
            "streaming": "CreateStreamingJobRequest",
        }
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: Optional[str] = None


class CreateBatchJobRequest(CreateJobRequest):
    """A batch ingestion job. The only source types allowed for this job are ``table`` and
    ``uploaded``. If you ingest into a table that's used as a lookup source, the job must set the
    partitioning granularity to ``ALL``\\ , and must set replaceAll to ``true``. If the job
    produces more data than fits in a single segment, Polaris fails the job with the error
    ``TooManySegmentsInTimeChunkFault``.

    All required parameters must be populated in order to send to server.

    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar source: Source input of the job. Required.
    :vartype source: ~polaris.sdk.global_api.models.JobSourceV2
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar context: Context parameters used to specify various query configuration parameters. For
     more information, see `SQL ingestion reference
     <https://docs.imply.io/ui/saas/help/sql-ingestion-reference.html>`_.
    :vartype context: dict[str, any]
    :ivar clustering_columns: Optional columns to use for clustering. If specified, will take
     precedence over clustering columns defined
     on a table. Polaris sorts columns within a partition based on their order in this array.

     For jobs targeting aggregate tables, only dimensions (not measures) are supported for
     clustering.

     For more information, see `Clustering
     <https://docs.imply.io/ui/saas/help/partitioning.html>`_.
    :vartype clustering_columns: list[str]
    :ivar create_table_if_not_exists: Whether the job should create the table if it doesn't already
     exist. For more information, see `Introduction to tables
     <https://docs.imply.io/ui/saas/help/tables.html>`_.
    :vartype create_table_if_not_exists: bool
    :ivar filter_expression: SQL expression to use for filtering the source data. For more
     information, see `Filter data to ingest
     <https://docs.imply.io/ui/saas/help//ingest-with-filters.html>`_.
    :vartype filter_expression: str
    :ivar ingestion_mode: Mode of ingestion:


     * ``append``  - Append newly ingested data to the existing data. To ingest a certain time
     range of source data,
       apply a `filter expression <https://docs.imply.io/ui/saas/help/ingest-with-filters.html>`_
     to filter by a given time interval.
     * ``replace`` - Overwrite existing data for specific time intervals or all data in the table.
       Specify specific time intervals in ``target.intervals``\\ , or set ``"replaceAll": true``.
       To restrict the time interval of what data Polaris ingests, use
       `filter expressions <https://docs.imply.io/ui/saas/help/ingest-with-filters.html>`_. Known
     values are: "append" and "replace".
    :vartype ingestion_mode: str or ~polaris.sdk.global_api.models.IngestionModeV2
    :ivar mappings: Relationship between the input fields and the output columns of a table's
     schema.
     Define the Polaris column name in ``columnName``\\ , and specify how the column is defined
     with respect to the input fields in ``expression``. ``expression`` must be a valid SQL
     expression.

     For batch ingestion jobs, you must include a mapping for each field. Polaris ignores
     unmapped input fields. Streaming ingestion jobs may apply schema auto-discovery for
     Polaris to discover input fields and map them directly to table dimensions.
     Always specify a mapping for ``__time`` and when you want to transform an input field.

     For more information, see
     `Map and transform data with input expressions
     <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_
     and `Schema auto-discovery on ingestion jobs
     <https://docs.imply.io/ui/saas/help/job-auto-discovery.html>`_.
    :vartype mappings: list[~polaris.sdk.global_api.models.InputToTableSchemaMapping]
    :ivar max_parse_exceptions: Configuration parameter that specifies the maximum number of parse
     exceptions that a task can tolerate before failing.
    :vartype max_parse_exceptions: int
    :ivar partitioned_by: Optional `time partitioning
     <https://docs.imply.io/ui/saas/help/partitioning.html>`_. If specified,
     takes precedence over the time partitioning defined on the target table.
     If unspecified, defaults to the time partitioning of the table.

     When ingesting into a lookup table, you can only set ``all`` partitioning. Known values are:
     "second", "minute", "five_minute", "ten_minute", "fifteen_minute", "thirty_minute", "hour",
     "six_hour", "eight_hour", "day", "month", "quarter", "year", and "all".
    :vartype partitioned_by: str or ~polaris.sdk.global_api.models.PartitioningGranularity
    :ivar replace_all: Replace all data with this job. Don't set this to true when the job's
     ingestion mode is ``append`` or when ``target.intervals`` is specified.
    :vartype replace_all: bool
    """

    _validation = {
        "type": {"required": True},
        "source": {"required": True},
        "target": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "source": {"key": "source", "type": "JobSourceV2"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "context": {"key": "context", "type": "{object}"},
        "clustering_columns": {"key": "clusteringColumns", "type": "[str]"},
        "create_table_if_not_exists": {"key": "createTableIfNotExists", "type": "bool"},
        "filter_expression": {"key": "filterExpression", "type": "str"},
        "ingestion_mode": {"key": "ingestionMode", "type": "str"},
        "mappings": {"key": "mappings", "type": "[InputToTableSchemaMapping]"},
        "max_parse_exceptions": {"key": "maxParseExceptions", "type": "int"},
        "partitioned_by": {"key": "partitionedBy", "type": "str"},
        "replace_all": {"key": "replaceAll", "type": "bool"},
    }

    def __init__(
        self,
        *,
        source: "_models.JobSourceV2",
        target: "_models.JobTargetV2",
        context: Optional[Dict[str, Any]] = None,
        clustering_columns: Optional[List[str]] = None,
        create_table_if_not_exists: bool = False,
        filter_expression: Optional[str] = None,
        ingestion_mode: Union[str, "_models.IngestionModeV2"] = "append",
        mappings: List["_models.InputToTableSchemaMapping"] = [],
        max_parse_exceptions: int = 2147483647,
        partitioned_by: Optional[Union[str, "_models.PartitioningGranularity"]] = None,
        replace_all: bool = False,
        **kwargs: Any
    ) -> None:
        """
        :keyword source: Source input of the job. Required.
        :paramtype source: ~polaris.sdk.global_api.models.JobSourceV2
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        :keyword context: Context parameters used to specify various query configuration parameters.
         For more information, see `SQL ingestion reference
         <https://docs.imply.io/ui/saas/help/sql-ingestion-reference.html>`_.
        :paramtype context: dict[str, any]
        :keyword clustering_columns: Optional columns to use for clustering. If specified, will take
         precedence over clustering columns defined
         on a table. Polaris sorts columns within a partition based on their order in this array.

         For jobs targeting aggregate tables, only dimensions (not measures) are supported for
         clustering.

         For more information, see `Clustering
         <https://docs.imply.io/ui/saas/help/partitioning.html>`_.
        :paramtype clustering_columns: list[str]
        :keyword create_table_if_not_exists: Whether the job should create the table if it doesn't
         already exist. For more information, see `Introduction to tables
         <https://docs.imply.io/ui/saas/help/tables.html>`_.
        :paramtype create_table_if_not_exists: bool
        :keyword filter_expression: SQL expression to use for filtering the source data. For more
         information, see `Filter data to ingest
         <https://docs.imply.io/ui/saas/help//ingest-with-filters.html>`_.
        :paramtype filter_expression: str
        :keyword ingestion_mode: Mode of ingestion:


         * ``append``  - Append newly ingested data to the existing data. To ingest a certain time
         range of source data,
           apply a `filter expression <https://docs.imply.io/ui/saas/help/ingest-with-filters.html>`_
         to filter by a given time interval.
         * ``replace`` - Overwrite existing data for specific time intervals or all data in the table.
           Specify specific time intervals in ``target.intervals``\\ , or set ``"replaceAll": true``.
           To restrict the time interval of what data Polaris ingests, use
           `filter expressions <https://docs.imply.io/ui/saas/help/ingest-with-filters.html>`_. Known
         values are: "append" and "replace".
        :paramtype ingestion_mode: str or ~polaris.sdk.global_api.models.IngestionModeV2
        :keyword mappings: Relationship between the input fields and the output columns of a table's
         schema.
         Define the Polaris column name in ``columnName``\\ , and specify how the column is defined
         with respect to the input fields in ``expression``. ``expression`` must be a valid SQL
         expression.

         For batch ingestion jobs, you must include a mapping for each field. Polaris ignores
         unmapped input fields. Streaming ingestion jobs may apply schema auto-discovery for
         Polaris to discover input fields and map them directly to table dimensions.
         Always specify a mapping for ``__time`` and when you want to transform an input field.

         For more information, see
         `Map and transform data with input expressions
         <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_
         and `Schema auto-discovery on ingestion jobs
         <https://docs.imply.io/ui/saas/help/job-auto-discovery.html>`_.
        :paramtype mappings: list[~polaris.sdk.global_api.models.InputToTableSchemaMapping]
        :keyword max_parse_exceptions: Configuration parameter that specifies the maximum number of
         parse exceptions that a task can tolerate before failing.
        :paramtype max_parse_exceptions: int
        :keyword partitioned_by: Optional `time partitioning
         <https://docs.imply.io/ui/saas/help/partitioning.html>`_. If specified,
         takes precedence over the time partitioning defined on the target table.
         If unspecified, defaults to the time partitioning of the table.

         When ingesting into a lookup table, you can only set ``all`` partitioning. Known values are:
         "second", "minute", "five_minute", "ten_minute", "fifteen_minute", "thirty_minute", "hour",
         "six_hour", "eight_hour", "day", "month", "quarter", "year", and "all".
        :paramtype partitioned_by: str or ~polaris.sdk.global_api.models.PartitioningGranularity
        :keyword replace_all: Replace all data with this job. Don't set this to true when the job's
         ingestion mode is ``append`` or when ``target.intervals`` is specified.
        :paramtype replace_all: bool
        """
        super().__init__(**kwargs)
        self.type: str = "batch"
        self.source = source
        self.target = target
        self.context = context
        self.clustering_columns = clustering_columns
        self.create_table_if_not_exists = create_table_if_not_exists
        self.filter_expression = filter_expression
        self.ingestion_mode = ingestion_mode
        self.mappings = mappings
        self.max_parse_exceptions = max_parse_exceptions
        self.partitioned_by = partitioned_by
        self.replace_all = replace_all


class CreateConfluentConnectionRequest(
    CreateConnectionRequest,
    ConfluentConnectionPropertiesRequired,
    ConnectionSecretsRequiredProperties,
):
    """A request to create a Confluent connection.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
     Required.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
    :ivar bootstrap_servers: List of host and port pairs used for establishing the initial
     connection to the Kafka cluster.
    :vartype bootstrap_servers: str
    :ivar topic_name: The topic name or a regular expression that identifies the Kafka topics.
    :vartype topic_name: str
    :ivar topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris looks
     for a single topic with the exact name in ``topicName``. If true, Polaris treats ``topicName``
     as a regular expression to match topic names. Use this option to ingest data from multiple
     topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
     ``topic23`` but not ``topicAB``.
    :vartype topic_name_is_pattern: bool
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "secrets": {"required": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsRequiredPayload"},
        "bootstrap_servers": {"key": "bootstrapServers", "type": "str"},
        "topic_name": {"key": "topicName", "type": "str"},
        "topic_name_is_pattern": {"key": "topicNameIsPattern", "type": "bool"},
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        secrets: "_models.ConnectionSecretsRequiredPayload",
        name: str,
        bootstrap_servers: Optional[str] = None,
        topic_name: Optional[str] = None,
        topic_name_is_pattern: bool = False,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
         Required.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
        :keyword bootstrap_servers: List of host and port pairs used for establishing the initial
         connection to the Kafka cluster.
        :paramtype bootstrap_servers: str
        :keyword topic_name: The topic name or a regular expression that identifies the Kafka topics.
        :paramtype topic_name: str
        :keyword topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris
         looks for a single topic with the exact name in ``topicName``. If true, Polaris treats
         ``topicName`` as a regular expression to match topic names. Use this option to ingest data from
         multiple topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
         ``topic23`` but not ``topicAB``.
        :paramtype topic_name_is_pattern: bool
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            name=name,
            description=description,
            bootstrap_servers=bootstrap_servers,
            topic_name=topic_name,
            topic_name_is_pattern=topic_name_is_pattern,
            secrets=secrets,
            **kwargs
        )
        self.secrets = secrets
        self.bootstrap_servers = bootstrap_servers
        self.topic_name = topic_name
        self.topic_name_is_pattern = topic_name_is_pattern
        self.type: str = "confluent"
        self.name = name
        self.description = description


class CreateConfluentSchemaRegistryConnectionRequest(
    CreateConnectionRequest,
    ConfluentSchemaRegistryConnectionProperties,
    ConnectionSecretsRequiredProperties,
):  # pylint: disable=name-too-long
    """A request to create a Confluent schema registry connection.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
     Required.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
    :ivar urls: List of URLs of Schema Registry instances to look up schemas.
    :vartype urls: list[str]
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "secrets": {"required": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsRequiredPayload"},
        "urls": {"key": "urls", "type": "[str]"},
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        secrets: "_models.ConnectionSecretsRequiredPayload",
        name: str,
        urls: List[str] = [],
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
         Required.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
        :keyword urls: List of URLs of Schema Registry instances to look up schemas.
        :paramtype urls: list[str]
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            name=name, description=description, urls=urls, secrets=secrets, **kwargs
        )
        self.secrets = secrets
        self.urls = urls
        self.type: str = "confluent_schema_registry"
        self.name = name
        self.description = description


class CreateDeleteDataJobRequest(CreateJobRequest):
    """A data deletion job, targeting either an interval of data in a table or, if ``deleteAll`` is
    set, all data in the table.

    All required parameters must be populated in order to send to server.

    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar delete_all: Set to true to delete all data for this table. The table itself is not
     dropped.
    :vartype delete_all: bool
    :ivar soft_delete: Set to true for soft deletion. Polaris schedules the data for permanent
     deletion after 30 days.
    :vartype soft_delete: bool
    :ivar versions: List of segment versions in the specified interval to restore or delete.
    :vartype versions: list[str]
    """

    _validation = {
        "type": {"required": True},
        "target": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "delete_all": {"key": "deleteAll", "type": "bool"},
        "soft_delete": {"key": "softDelete", "type": "bool"},
        "versions": {"key": "versions", "type": "[str]"},
    }

    def __init__(
        self,
        *,
        target: "_models.JobTargetV2",
        delete_all: bool = False,
        soft_delete: bool = False,
        versions: Optional[List[str]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        :keyword delete_all: Set to true to delete all data for this table. The table itself is not
         dropped.
        :paramtype delete_all: bool
        :keyword soft_delete: Set to true for soft deletion. Polaris schedules the data for permanent
         deletion after 30 days.
        :paramtype soft_delete: bool
        :keyword versions: List of segment versions in the specified interval to restore or delete.
        :paramtype versions: list[str]
        """
        super().__init__(**kwargs)
        self.type: str = "delete_data"
        self.target = target
        self.delete_all = delete_all
        self.soft_delete = soft_delete
        self.versions = versions


class CreateDropTableJobRequest(CreateJobRequest):
    """Drops a table and deletes of all its data. The table will not exist after this job completes.

    All required parameters must be populated in order to send to server.

    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar soft_delete: Set to true for soft deletion. Polaris schedules the data for permanent
     deletion after 30 days.
    :vartype soft_delete: bool
    """

    _validation = {
        "type": {"required": True},
        "target": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "soft_delete": {"key": "softDelete", "type": "bool"},
    }

    def __init__(
        self, *, target: "_models.JobTargetV2", soft_delete: bool = False, **kwargs: Any
    ) -> None:
        """
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        :keyword soft_delete: Set to true for soft deletion. Polaris schedules the data for permanent
         deletion after 30 days.
        :paramtype soft_delete: bool
        """
        super().__init__(**kwargs)
        self.type: str = "drop_table"
        self.target = target
        self.soft_delete = soft_delete


class KafkaConnectionProperties(_serialization.Model):
    """Properties specific to a Kafka connection.

    :ivar bootstrap_servers: List of host and port pairs used for establishing the initial
     connection to the Kafka cluster.
    :vartype bootstrap_servers: str
    :ivar client_rack: A rack identifier for this client. This can be any string value which
     indicates where this client is physically located. It corresponds with the broker config
     'broker.rack'.
    :vartype client_rack: str
    :ivar ssl: SSL authentication and encryption settings.
    :vartype ssl: ~polaris.sdk.global_api.models.KafkaConnectionPropertiesSsl
    :ivar topic_name: The topic name or a regular expression that identifies the Kafka topics.
    :vartype topic_name: str
    :ivar topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris looks
     for a single topic with the exact name in ``topicName``. If true, Polaris treats ``topicName``
     as a regular expression to match topic names. Use this option to ingest data from multiple
     topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
     ``topic23`` but not ``topicAB``.
    :vartype topic_name_is_pattern: bool
    """

    _attribute_map = {
        "bootstrap_servers": {"key": "bootstrapServers", "type": "str"},
        "client_rack": {"key": "clientRack", "type": "str"},
        "ssl": {"key": "ssl", "type": "KafkaConnectionPropertiesSsl"},
        "topic_name": {"key": "topicName", "type": "str"},
        "topic_name_is_pattern": {"key": "topicNameIsPattern", "type": "bool"},
    }

    def __init__(
        self,
        *,
        bootstrap_servers: Optional[str] = None,
        client_rack: Optional[str] = None,
        ssl: Optional["_models.KafkaConnectionPropertiesSsl"] = None,
        topic_name: Optional[str] = None,
        topic_name_is_pattern: bool = False,
        **kwargs: Any
    ) -> None:
        """
        :keyword bootstrap_servers: List of host and port pairs used for establishing the initial
         connection to the Kafka cluster.
        :paramtype bootstrap_servers: str
        :keyword client_rack: A rack identifier for this client. This can be any string value which
         indicates where this client is physically located. It corresponds with the broker config
         'broker.rack'.
        :paramtype client_rack: str
        :keyword ssl: SSL authentication and encryption settings.
        :paramtype ssl: ~polaris.sdk.global_api.models.KafkaConnectionPropertiesSsl
        :keyword topic_name: The topic name or a regular expression that identifies the Kafka topics.
        :paramtype topic_name: str
        :keyword topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris
         looks for a single topic with the exact name in ``topicName``. If true, Polaris treats
         ``topicName`` as a regular expression to match topic names. Use this option to ingest data from
         multiple topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
         ``topic23`` but not ``topicAB``.
        :paramtype topic_name_is_pattern: bool
        """
        super().__init__(**kwargs)
        self.bootstrap_servers = bootstrap_servers
        self.client_rack = client_rack
        self.ssl = ssl
        self.topic_name = topic_name
        self.topic_name_is_pattern = topic_name_is_pattern


class KafkaConnectionPropertiesRequired(KafkaConnectionProperties):
    """KafkaConnectionPropertiesRequired.

    :ivar bootstrap_servers: List of host and port pairs used for establishing the initial
     connection to the Kafka cluster.
    :vartype bootstrap_servers: str
    :ivar client_rack: A rack identifier for this client. This can be any string value which
     indicates where this client is physically located. It corresponds with the broker config
     'broker.rack'.
    :vartype client_rack: str
    :ivar ssl: SSL authentication and encryption settings.
    :vartype ssl: ~polaris.sdk.global_api.models.KafkaConnectionPropertiesSsl
    :ivar topic_name: The topic name or a regular expression that identifies the Kafka topics.
    :vartype topic_name: str
    :ivar topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris looks
     for a single topic with the exact name in ``topicName``. If true, Polaris treats ``topicName``
     as a regular expression to match topic names. Use this option to ingest data from multiple
     topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
     ``topic23`` but not ``topicAB``.
    :vartype topic_name_is_pattern: bool
    """


class CreateKafkaConnectionRequest(
    CreateConnectionRequest,
    KafkaConnectionPropertiesRequired,
    ConnectionSecretsRequiredProperties,
):
    """A request to create a Kafka connection.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
     Required.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
    :ivar bootstrap_servers: List of host and port pairs used for establishing the initial
     connection to the Kafka cluster.
    :vartype bootstrap_servers: str
    :ivar client_rack: A rack identifier for this client. This can be any string value which
     indicates where this client is physically located. It corresponds with the broker config
     'broker.rack'.
    :vartype client_rack: str
    :ivar ssl: SSL authentication and encryption settings.
    :vartype ssl: ~polaris.sdk.global_api.models.KafkaConnectionPropertiesSsl
    :ivar topic_name: The topic name or a regular expression that identifies the Kafka topics.
    :vartype topic_name: str
    :ivar topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris looks
     for a single topic with the exact name in ``topicName``. If true, Polaris treats ``topicName``
     as a regular expression to match topic names. Use this option to ingest data from multiple
     topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
     ``topic23`` but not ``topicAB``.
    :vartype topic_name_is_pattern: bool
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "secrets": {"required": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsRequiredPayload"},
        "bootstrap_servers": {"key": "bootstrapServers", "type": "str"},
        "client_rack": {"key": "clientRack", "type": "str"},
        "ssl": {"key": "ssl", "type": "KafkaConnectionPropertiesSsl"},
        "topic_name": {"key": "topicName", "type": "str"},
        "topic_name_is_pattern": {"key": "topicNameIsPattern", "type": "bool"},
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        secrets: "_models.ConnectionSecretsRequiredPayload",
        name: str,
        bootstrap_servers: Optional[str] = None,
        client_rack: Optional[str] = None,
        ssl: Optional["_models.KafkaConnectionPropertiesSsl"] = None,
        topic_name: Optional[str] = None,
        topic_name_is_pattern: bool = False,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
         Required.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
        :keyword bootstrap_servers: List of host and port pairs used for establishing the initial
         connection to the Kafka cluster.
        :paramtype bootstrap_servers: str
        :keyword client_rack: A rack identifier for this client. This can be any string value which
         indicates where this client is physically located. It corresponds with the broker config
         'broker.rack'.
        :paramtype client_rack: str
        :keyword ssl: SSL authentication and encryption settings.
        :paramtype ssl: ~polaris.sdk.global_api.models.KafkaConnectionPropertiesSsl
        :keyword topic_name: The topic name or a regular expression that identifies the Kafka topics.
        :paramtype topic_name: str
        :keyword topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris
         looks for a single topic with the exact name in ``topicName``. If true, Polaris treats
         ``topicName`` as a regular expression to match topic names. Use this option to ingest data from
         multiple topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
         ``topic23`` but not ``topicAB``.
        :paramtype topic_name_is_pattern: bool
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            name=name,
            description=description,
            bootstrap_servers=bootstrap_servers,
            client_rack=client_rack,
            ssl=ssl,
            topic_name=topic_name,
            topic_name_is_pattern=topic_name_is_pattern,
            secrets=secrets,
            **kwargs
        )
        self.secrets = secrets
        self.bootstrap_servers = bootstrap_servers
        self.client_rack = client_rack
        self.ssl = ssl
        self.topic_name = topic_name
        self.topic_name_is_pattern = topic_name_is_pattern
        self.type: str = "kafka"
        self.name = name
        self.description = description


class KinesisConnectionProperties(_serialization.Model):
    """Properties specific to a Kinesis connection.

    :ivar aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
    :vartype aws_assumed_role_arn: str
    :ivar aws_endpoint: The URL of the entry point for the AWS Kinesis connection.
    :vartype aws_endpoint: str
    :ivar stream: The Kinesis stream to read.
    :vartype stream: str
    """

    _attribute_map = {
        "aws_assumed_role_arn": {"key": "awsAssumedRoleArn", "type": "str"},
        "aws_endpoint": {"key": "awsEndpoint", "type": "str"},
        "stream": {"key": "stream", "type": "str"},
    }

    def __init__(
        self,
        *,
        aws_assumed_role_arn: Optional[str] = None,
        aws_endpoint: Optional[str] = None,
        stream: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
        :paramtype aws_assumed_role_arn: str
        :keyword aws_endpoint: The URL of the entry point for the AWS Kinesis connection.
        :paramtype aws_endpoint: str
        :keyword stream: The Kinesis stream to read.
        :paramtype stream: str
        """
        super().__init__(**kwargs)
        self.aws_assumed_role_arn = aws_assumed_role_arn
        self.aws_endpoint = aws_endpoint
        self.stream = stream


class KinesisConnectionPropertiesRequired(KinesisConnectionProperties):
    """KinesisConnectionPropertiesRequired.

    :ivar aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
    :vartype aws_assumed_role_arn: str
    :ivar aws_endpoint: The URL of the entry point for the AWS Kinesis connection.
    :vartype aws_endpoint: str
    :ivar stream: The Kinesis stream to read.
    :vartype stream: str
    """


class CreateKinesisConnectionRequest(
    CreateConnectionRequest, KinesisConnectionPropertiesRequired
):
    """A request to create a Kinesis connection.

    All required parameters must be populated in order to send to server.

    :ivar aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
    :vartype aws_assumed_role_arn: str
    :ivar aws_endpoint: The URL of the entry point for the AWS Kinesis connection.
    :vartype aws_endpoint: str
    :ivar stream: The Kinesis stream to read.
    :vartype stream: str
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "type": {"required": True},
    }

    _attribute_map = {
        "aws_assumed_role_arn": {"key": "awsAssumedRoleArn", "type": "str"},
        "aws_endpoint": {"key": "awsEndpoint", "type": "str"},
        "stream": {"key": "stream", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        aws_assumed_role_arn: Optional[str] = None,
        aws_endpoint: Optional[str] = None,
        stream: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
        :paramtype aws_assumed_role_arn: str
        :keyword aws_endpoint: The URL of the entry point for the AWS Kinesis connection.
        :paramtype aws_endpoint: str
        :keyword stream: The Kinesis stream to read.
        :paramtype stream: str
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            name=name,
            description=description,
            aws_assumed_role_arn=aws_assumed_role_arn,
            aws_endpoint=aws_endpoint,
            stream=stream,
            **kwargs
        )
        self.aws_assumed_role_arn = aws_assumed_role_arn
        self.aws_endpoint = aws_endpoint
        self.stream = stream
        self.type: str = "kinesis"
        self.name = name
        self.description = description


class CreateLookupRequest(_serialization.Model):
    """A request to create a lookup.

    All required parameters must be populated in order to send to server.

    :ivar name: Unique name of the lookup. Required.
    :vartype name: str
    :ivar source: The source of a lookup.
     The following lookup type is supported:


     * ``table``\\ : A lookup source that references a table. The table
       must be partitioned by ALL granularity and contain a single segment. Required.
    :vartype source: ~polaris.sdk.global_api.models.LookupSourcePayload
    """

    _validation = {
        "name": {"required": True},
        "source": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "source": {"key": "source", "type": "LookupSourcePayload"},
    }

    def __init__(
        self, *, name: str, source: "_models.LookupSourcePayload", **kwargs: Any
    ) -> None:
        """
        :keyword name: Unique name of the lookup. Required.
        :paramtype name: str
        :keyword source: The source of a lookup.
         The following lookup type is supported:


         * ``table``\\ : A lookup source that references a table. The table
           must be partitioned by ALL granularity and contain a single segment. Required.
        :paramtype source: ~polaris.sdk.global_api.models.LookupSourcePayload
        """
        super().__init__(**kwargs)
        self.name = name
        self.source = source


class PushStreamingConnectionProperties(_serialization.Model):
    """Properties specific to a push streaming connection.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar endpoint_url:
    :vartype endpoint_url: str
    """

    _validation = {
        "endpoint_url": {"readonly": True},
    }

    _attribute_map = {
        "endpoint_url": {"key": "endpointUrl", "type": "str"},
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.endpoint_url = None


class CreatePushStreamingConnectionRequest(
    CreateConnectionRequest, PushStreamingConnectionProperties
):
    """A request to create a push streaming connection.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar endpoint_url:
    :vartype endpoint_url: str
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "endpoint_url": {"readonly": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "type": {"required": True},
    }

    _attribute_map = {
        "endpoint_url": {"key": "endpointUrl", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self, *, name: str, description: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(name=name, description=description, **kwargs)
        self.endpoint_url = None
        self.type: str = "push_streaming"
        self.name = name
        self.description = description


class CreateRestoreDataJobRequest(CreateJobRequest):
    """A data restore job targeting an interval of data in a table.

    All required parameters must be populated in order to send to server.

    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar interval: A single time interval in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_ describing the range of data from
     the table to restore. Required.
    :vartype interval: str
    :ivar versions: List of segment versions in the specified interval to restore or delete.
    :vartype versions: list[str]
    """

    _validation = {
        "type": {"required": True},
        "target": {"required": True},
        "interval": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "interval": {"key": "interval", "type": "str"},
        "versions": {"key": "versions", "type": "[str]"},
    }

    def __init__(
        self,
        *,
        target: "_models.JobTargetV2",
        interval: str,
        versions: Optional[List[str]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        :keyword interval: A single time interval in `ISO 8601 format
         <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_ describing the range of data from
         the table to restore. Required.
        :paramtype interval: str
        :keyword versions: List of segment versions in the specified interval to restore or delete.
        :paramtype versions: list[str]
        """
        super().__init__(**kwargs)
        self.type: str = "restore_data"
        self.target = target
        self.interval = interval
        self.versions = versions


class S3ConnectionProperties(_serialization.Model):
    """Properties specific to a S3 connection.

    :ivar aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
    :vartype aws_assumed_role_arn: str
    :ivar aws_endpoint: The URL of the entry point for the Amazon S3 bucket.
    :vartype aws_endpoint: str
    :ivar bucket: The name of the bucket containing the desired object.
    :vartype bucket: str
    :ivar prefix: Prefix to restrict the connection to specific keys.
    :vartype prefix: str
    """

    _attribute_map = {
        "aws_assumed_role_arn": {"key": "awsAssumedRoleArn", "type": "str"},
        "aws_endpoint": {"key": "awsEndpoint", "type": "str"},
        "bucket": {"key": "bucket", "type": "str"},
        "prefix": {"key": "prefix", "type": "str"},
    }

    def __init__(
        self,
        *,
        aws_assumed_role_arn: Optional[str] = None,
        aws_endpoint: Optional[str] = None,
        bucket: Optional[str] = None,
        prefix: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
        :paramtype aws_assumed_role_arn: str
        :keyword aws_endpoint: The URL of the entry point for the Amazon S3 bucket.
        :paramtype aws_endpoint: str
        :keyword bucket: The name of the bucket containing the desired object.
        :paramtype bucket: str
        :keyword prefix: Prefix to restrict the connection to specific keys.
        :paramtype prefix: str
        """
        super().__init__(**kwargs)
        self.aws_assumed_role_arn = aws_assumed_role_arn
        self.aws_endpoint = aws_endpoint
        self.bucket = bucket
        self.prefix = prefix


class S3ConnectionPropertiesRequired(S3ConnectionProperties):
    """S3ConnectionPropertiesRequired.

    :ivar aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
    :vartype aws_assumed_role_arn: str
    :ivar aws_endpoint: The URL of the entry point for the Amazon S3 bucket.
    :vartype aws_endpoint: str
    :ivar bucket: The name of the bucket containing the desired object.
    :vartype bucket: str
    :ivar prefix: Prefix to restrict the connection to specific keys.
    :vartype prefix: str
    """


class CreateS3ConnectionRequest(
    CreateConnectionRequest,
    S3ConnectionPropertiesRequired,
    ConnectionSecretsOptionalProperties,
):
    """A request to create an S3 bucket connection.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
    :ivar aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
    :vartype aws_assumed_role_arn: str
    :ivar aws_endpoint: The URL of the entry point for the Amazon S3 bucket.
    :vartype aws_endpoint: str
    :ivar bucket: The name of the bucket containing the desired object.
    :vartype bucket: str
    :ivar prefix: Prefix to restrict the connection to specific keys.
    :vartype prefix: str
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsOptionalPayload"},
        "aws_assumed_role_arn": {"key": "awsAssumedRoleArn", "type": "str"},
        "aws_endpoint": {"key": "awsEndpoint", "type": "str"},
        "bucket": {"key": "bucket", "type": "str"},
        "prefix": {"key": "prefix", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        secrets: Optional["_models.ConnectionSecretsOptionalPayload"] = None,
        aws_assumed_role_arn: Optional[str] = None,
        aws_endpoint: Optional[str] = None,
        bucket: Optional[str] = None,
        prefix: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
        :keyword aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
        :paramtype aws_assumed_role_arn: str
        :keyword aws_endpoint: The URL of the entry point for the Amazon S3 bucket.
        :paramtype aws_endpoint: str
        :keyword bucket: The name of the bucket containing the desired object.
        :paramtype bucket: str
        :keyword prefix: Prefix to restrict the connection to specific keys.
        :paramtype prefix: str
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            name=name,
            description=description,
            aws_assumed_role_arn=aws_assumed_role_arn,
            aws_endpoint=aws_endpoint,
            bucket=bucket,
            prefix=prefix,
            secrets=secrets,
            **kwargs
        )
        self.secrets = secrets
        self.aws_assumed_role_arn = aws_assumed_role_arn
        self.aws_endpoint = aws_endpoint
        self.bucket = bucket
        self.prefix = prefix
        self.type: str = "s3"
        self.name = name
        self.description = description


class CreateSqlJobRequest(CreateJobRequest):
    """A SQL-based ingestion job. If you ingest into a table that's used as a lookup source, the job
    must set the partitioning granularity to ``ALL``\\ , and the query must be a replace statement
    with overwrite time range ``ALL``. If the job produces more data than fits in a single segment,
    Polaris fails the job with the error ``TooManySegmentsInTimeChunkFault``.

    All required parameters must be populated in order to send to server.

    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar query: The SQL query. Required.
    :vartype query: str
    :ivar context: Context parameters used to specify various query configuration parameters. For
     more information, see `SQL ingestion reference
     <https://docs.imply.io/ui/saas/help/sql-ingestion-reference.html>`_.
    :vartype context: dict[str, any]
    :ivar create_table_if_not_exists: Whether the job should create the table if it doesn't already
     exist. For more information, see `Introduction to tables
     <https://docs.imply.io/ui/saas/help/tables.html>`_.
    :vartype create_table_if_not_exists: bool
    :ivar parameters: Array of type and value pairs for dynamic parameters in parameterized SQL
     queries. For more information, see `Submit parameterized SQL ingestion
     <https://docs.imply.io/ui/saas/help/api-sql-ingestion.html>`_.
    :vartype parameters: list[~polaris.sdk.global_api.models.SqlParameter]
    """

    _validation = {
        "type": {"required": True},
        "query": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "query": {"key": "query", "type": "str"},
        "context": {"key": "context", "type": "{object}"},
        "create_table_if_not_exists": {"key": "createTableIfNotExists", "type": "bool"},
        "parameters": {"key": "parameters", "type": "[SqlParameter]"},
    }

    def __init__(
        self,
        *,
        query: str,
        context: Optional[Dict[str, Any]] = None,
        create_table_if_not_exists: bool = False,
        parameters: List["_models.SqlParameter"] = [],
        **kwargs: Any
    ) -> None:
        """
        :keyword query: The SQL query. Required.
        :paramtype query: str
        :keyword context: Context parameters used to specify various query configuration parameters.
         For more information, see `SQL ingestion reference
         <https://docs.imply.io/ui/saas/help/sql-ingestion-reference.html>`_.
        :paramtype context: dict[str, any]
        :keyword create_table_if_not_exists: Whether the job should create the table if it doesn't
         already exist. For more information, see `Introduction to tables
         <https://docs.imply.io/ui/saas/help/tables.html>`_.
        :paramtype create_table_if_not_exists: bool
        :keyword parameters: Array of type and value pairs for dynamic parameters in parameterized SQL
         queries. For more information, see `Submit parameterized SQL ingestion
         <https://docs.imply.io/ui/saas/help/api-sql-ingestion.html>`_.
        :paramtype parameters: list[~polaris.sdk.global_api.models.SqlParameter]
        """
        super().__init__(**kwargs)
        self.type: str = "sql"
        self.query = query
        self.context = context
        self.create_table_if_not_exists = create_table_if_not_exists
        self.parameters = parameters


class CreateStreamingJobRequest(CreateJobRequest):
    """A streaming ingestion job. The only source type allowed for this job is ``connection``.

    All required parameters must be populated in order to send to server.

    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar source: Source input of the job. Required.
    :vartype source: ~polaris.sdk.global_api.models.JobSourceV2
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar clustering_columns: Optional columns to use for clustering. If specified, will take
     precedence over clustering columns defined
     on a table. Polaris sorts columns within a partition based on their order in this array.

     For jobs targeting aggregate tables, only dimensions (not measures) are supported for
     clustering.

     For more information, see `Clustering
     <https://docs.imply.io/ui/saas/help/partitioning.html>`_.
    :vartype clustering_columns: list[str]
    :ivar create_table_if_not_exists: Whether the job should create the table if it doesn't already
     exist. For more information, see `Introduction to tables
     <https://docs.imply.io/ui/saas/help/tables.html>`_.
    :vartype create_table_if_not_exists: bool
    :ivar dimension_exclusions: The names of dimensions to exclude from ingestion. This list is
     only used if the target table is
     ``flexible``\\ , otherwise it is ignored.
    :vartype dimension_exclusions: list[str]
    :ivar early_message_rejection_period: An ISO 8601 duration such as ``P1D``\\ , indicating how
     far in the future data will be accepted. If both a filter expression and early message
     rejection period are specified, only rows that meet both criteria are accepted. The default in
     Polaris is ``P2000D``\\ , indicating messages with a primary timestamp (\\ ``__time``\\ ) more
     than 2000 days in the future will be skipped.
    :vartype early_message_rejection_period: str
    :ivar enable_upserts: Creates a streaming job to perform dimension upserts. A dimension upsert
     job updates rows that already exist in the table, otherwise inserts new rows. When
     ``enableUpserts`` is true, you must also set ``upsertKeyColumns`` and ``upsertVersionColumn``.
    :vartype enable_upserts: bool
    :ivar filter_expression: SQL expression to use for filtering the source data. For more
     information, see `Filter data to ingest
     <https://docs.imply.io/ui/saas/help//ingest-with-filters.html>`_.
    :vartype filter_expression: str
    :ivar late_message_rejection_period: An ISO 8601 duration such as ``P1D``\\ , indicating how
     far in the past data will be accepted. If both a filter expression and late message rejection
     period are specified, only rows that meet both criteria are accepted. The default in Polaris is
     ``P30D``\\ , indicating messages with a primary timestamp (\\ ``__time``\\ ) older than 30 days
     will be skipped.
    :vartype late_message_rejection_period: str
    :ivar mappings: Relationship between the input fields and the output columns of a table's
     schema.
     Define the Polaris column name in ``columnName``\\ , and specify how the column is defined
     with respect to the input fields in ``expression``. ``expression`` must be a valid SQL
     expression.

     For batch ingestion jobs, you must include a mapping for each field. Polaris ignores
     unmapped input fields. Streaming ingestion jobs may apply schema auto-discovery for
     Polaris to discover input fields and map them directly to table dimensions.
     Always specify a mapping for ``__time`` and when you want to transform an input field.

     For more information, see
     `Map and transform data with input expressions
     <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_
     and `Schema auto-discovery on ingestion jobs
     <https://docs.imply.io/ui/saas/help/job-auto-discovery.html>`_.
    :vartype mappings: list[~polaris.sdk.global_api.models.InputToTableSchemaMapping]
    :ivar max_parse_exceptions: Configuration parameter that specifies the maximum number of parse
     exceptions that a task can tolerate before failing.
    :vartype max_parse_exceptions: int
    :ivar partitioned_by: Optional `time partitioning
     <https://docs.imply.io/ui/saas/help/partitioning.html>`_. If specified,
     takes precedence over the time partitioning defined on the target table.
     If unspecified, defaults to the time partitioning of the table.

     When ingesting into a lookup table, you can only set ``all`` partitioning. Known values are:
     "second", "minute", "five_minute", "ten_minute", "fifteen_minute", "thirty_minute", "hour",
     "six_hour", "eight_hour", "day", "month", "quarter", "year", and "all".
    :vartype partitioned_by: str or ~polaris.sdk.global_api.models.PartitioningGranularity
    :ivar read_from_point: Sets the point to start reading from in a stream:


     * ``earliest`` tells Polaris to read data from the earliest available point in the stream. Use
     this if there is already data in the stream that you wish to ingest. Note that Polaris will
     only ingest data whose timestamp is within the last 30 days. If you have older data you wish to
     ingest, we recommend exporting it to a file and batch ingesting it.
     * ``latest`` tells Polaris to read data from the latest point available in the stream. Polaris
     will only ingest data published to the stream after the job is created (provided the data's
     timestamp is within the last 30 days). Known values are: "earliest" and "latest".
    :vartype read_from_point: str or ~polaris.sdk.global_api.models.StreamingReadFromPoint
    :ivar replace_running: Set to true to allow the create job request to replace the existing
     streaming job on the target table, if there is one. A table can only be targeted by one
     streaming job at a time. When this is false (the default), a request to create another
     streaming job will be rejected with an error. You may set this to true even if there is no
     running streaming job.
    :vartype replace_running: bool
    :ivar upsert_key_columns: An array of one or more dimension columns to uniquely identify rows
     for dimension upserts. Multiple dimensions are treated as a compound key. Requires
     ``enableUpserts`` set to true.
    :vartype upsert_key_columns: list[str]
    :ivar upsert_version_column: Dimension column to identify row versions. If multiple rows
     contain the same values for ``upsertKeyColumns``\\ , Polaris takes the row with the highest
     version. The default version column is ``__time``. Requires ``enableUpserts`` set to true.
    :vartype upsert_version_column: str
    :ivar use_schema_discovery: Set to true to allow for data to be discovered and written to the
     target table during ingestion. Only applies when ``schemaMode`` on the table is ``flexible``.
    :vartype use_schema_discovery: bool
    """

    _validation = {
        "type": {"required": True},
        "source": {"required": True},
        "target": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "source": {"key": "source", "type": "JobSourceV2"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "clustering_columns": {"key": "clusteringColumns", "type": "[str]"},
        "create_table_if_not_exists": {"key": "createTableIfNotExists", "type": "bool"},
        "dimension_exclusions": {"key": "dimensionExclusions", "type": "[str]"},
        "early_message_rejection_period": {
            "key": "earlyMessageRejectionPeriod",
            "type": "str",
        },
        "enable_upserts": {"key": "enableUpserts", "type": "bool"},
        "filter_expression": {"key": "filterExpression", "type": "str"},
        "late_message_rejection_period": {
            "key": "lateMessageRejectionPeriod",
            "type": "str",
        },
        "mappings": {"key": "mappings", "type": "[InputToTableSchemaMapping]"},
        "max_parse_exceptions": {"key": "maxParseExceptions", "type": "int"},
        "partitioned_by": {"key": "partitionedBy", "type": "str"},
        "read_from_point": {"key": "readFromPoint", "type": "str"},
        "replace_running": {"key": "replaceRunning", "type": "bool"},
        "upsert_key_columns": {"key": "upsertKeyColumns", "type": "[str]"},
        "upsert_version_column": {"key": "upsertVersionColumn", "type": "str"},
        "use_schema_discovery": {"key": "useSchemaDiscovery", "type": "bool"},
    }

    def __init__(
        self,
        *,
        source: "_models.JobSourceV2",
        target: "_models.JobTargetV2",
        clustering_columns: Optional[List[str]] = None,
        create_table_if_not_exists: bool = False,
        dimension_exclusions: List[str] = [],
        early_message_rejection_period: str = "P2000D",
        enable_upserts: bool = False,
        filter_expression: Optional[str] = None,
        late_message_rejection_period: str = "P30D",
        mappings: List["_models.InputToTableSchemaMapping"] = [],
        max_parse_exceptions: int = 2147483647,
        partitioned_by: Optional[Union[str, "_models.PartitioningGranularity"]] = None,
        read_from_point: Union[str, "_models.StreamingReadFromPoint"] = "latest",
        replace_running: bool = False,
        upsert_key_columns: Optional[List[str]] = None,
        upsert_version_column: Optional[str] = None,
        use_schema_discovery: bool = False,
        **kwargs: Any
    ) -> None:
        """
        :keyword source: Source input of the job. Required.
        :paramtype source: ~polaris.sdk.global_api.models.JobSourceV2
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        :keyword clustering_columns: Optional columns to use for clustering. If specified, will take
         precedence over clustering columns defined
         on a table. Polaris sorts columns within a partition based on their order in this array.

         For jobs targeting aggregate tables, only dimensions (not measures) are supported for
         clustering.

         For more information, see `Clustering
         <https://docs.imply.io/ui/saas/help/partitioning.html>`_.
        :paramtype clustering_columns: list[str]
        :keyword create_table_if_not_exists: Whether the job should create the table if it doesn't
         already exist. For more information, see `Introduction to tables
         <https://docs.imply.io/ui/saas/help/tables.html>`_.
        :paramtype create_table_if_not_exists: bool
        :keyword dimension_exclusions: The names of dimensions to exclude from ingestion. This list is
         only used if the target table is
         ``flexible``\\ , otherwise it is ignored.
        :paramtype dimension_exclusions: list[str]
        :keyword early_message_rejection_period: An ISO 8601 duration such as ``P1D``\\ , indicating
         how far in the future data will be accepted. If both a filter expression and early message
         rejection period are specified, only rows that meet both criteria are accepted. The default in
         Polaris is ``P2000D``\\ , indicating messages with a primary timestamp (\\ ``__time``\\ ) more
         than 2000 days in the future will be skipped.
        :paramtype early_message_rejection_period: str
        :keyword enable_upserts: Creates a streaming job to perform dimension upserts. A dimension
         upsert job updates rows that already exist in the table, otherwise inserts new rows. When
         ``enableUpserts`` is true, you must also set ``upsertKeyColumns`` and ``upsertVersionColumn``.
        :paramtype enable_upserts: bool
        :keyword filter_expression: SQL expression to use for filtering the source data. For more
         information, see `Filter data to ingest
         <https://docs.imply.io/ui/saas/help//ingest-with-filters.html>`_.
        :paramtype filter_expression: str
        :keyword late_message_rejection_period: An ISO 8601 duration such as ``P1D``\\ , indicating how
         far in the past data will be accepted. If both a filter expression and late message rejection
         period are specified, only rows that meet both criteria are accepted. The default in Polaris is
         ``P30D``\\ , indicating messages with a primary timestamp (\\ ``__time``\\ ) older than 30 days
         will be skipped.
        :paramtype late_message_rejection_period: str
        :keyword mappings: Relationship between the input fields and the output columns of a table's
         schema.
         Define the Polaris column name in ``columnName``\\ , and specify how the column is defined
         with respect to the input fields in ``expression``. ``expression`` must be a valid SQL
         expression.

         For batch ingestion jobs, you must include a mapping for each field. Polaris ignores
         unmapped input fields. Streaming ingestion jobs may apply schema auto-discovery for
         Polaris to discover input fields and map them directly to table dimensions.
         Always specify a mapping for ``__time`` and when you want to transform an input field.

         For more information, see
         `Map and transform data with input expressions
         <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_
         and `Schema auto-discovery on ingestion jobs
         <https://docs.imply.io/ui/saas/help/job-auto-discovery.html>`_.
        :paramtype mappings: list[~polaris.sdk.global_api.models.InputToTableSchemaMapping]
        :keyword max_parse_exceptions: Configuration parameter that specifies the maximum number of
         parse exceptions that a task can tolerate before failing.
        :paramtype max_parse_exceptions: int
        :keyword partitioned_by: Optional `time partitioning
         <https://docs.imply.io/ui/saas/help/partitioning.html>`_. If specified,
         takes precedence over the time partitioning defined on the target table.
         If unspecified, defaults to the time partitioning of the table.

         When ingesting into a lookup table, you can only set ``all`` partitioning. Known values are:
         "second", "minute", "five_minute", "ten_minute", "fifteen_minute", "thirty_minute", "hour",
         "six_hour", "eight_hour", "day", "month", "quarter", "year", and "all".
        :paramtype partitioned_by: str or ~polaris.sdk.global_api.models.PartitioningGranularity
        :keyword read_from_point: Sets the point to start reading from in a stream:


         * ``earliest`` tells Polaris to read data from the earliest available point in the stream. Use
         this if there is already data in the stream that you wish to ingest. Note that Polaris will
         only ingest data whose timestamp is within the last 30 days. If you have older data you wish to
         ingest, we recommend exporting it to a file and batch ingesting it.
         * ``latest`` tells Polaris to read data from the latest point available in the stream. Polaris
         will only ingest data published to the stream after the job is created (provided the data's
         timestamp is within the last 30 days). Known values are: "earliest" and "latest".
        :paramtype read_from_point: str or ~polaris.sdk.global_api.models.StreamingReadFromPoint
        :keyword replace_running: Set to true to allow the create job request to replace the existing
         streaming job on the target table, if there is one. A table can only be targeted by one
         streaming job at a time. When this is false (the default), a request to create another
         streaming job will be rejected with an error. You may set this to true even if there is no
         running streaming job.
        :paramtype replace_running: bool
        :keyword upsert_key_columns: An array of one or more dimension columns to uniquely identify
         rows for dimension upserts. Multiple dimensions are treated as a compound key. Requires
         ``enableUpserts`` set to true.
        :paramtype upsert_key_columns: list[str]
        :keyword upsert_version_column: Dimension column to identify row versions. If multiple rows
         contain the same values for ``upsertKeyColumns``\\ , Polaris takes the row with the highest
         version. The default version column is ``__time``. Requires ``enableUpserts`` set to true.
        :paramtype upsert_version_column: str
        :keyword use_schema_discovery: Set to true to allow for data to be discovered and written to
         the target table during ingestion. Only applies when ``schemaMode`` on the table is
         ``flexible``.
        :paramtype use_schema_discovery: bool
        """
        super().__init__(**kwargs)
        self.type: str = "streaming"
        self.source = source
        self.target = target
        self.clustering_columns = clustering_columns
        self.create_table_if_not_exists = create_table_if_not_exists
        self.dimension_exclusions = dimension_exclusions
        self.early_message_rejection_period = early_message_rejection_period
        self.enable_upserts = enable_upserts
        self.filter_expression = filter_expression
        self.late_message_rejection_period = late_message_rejection_period
        self.mappings = mappings
        self.max_parse_exceptions = max_parse_exceptions
        self.partitioned_by = partitioned_by
        self.read_from_point = read_from_point
        self.replace_running = replace_running
        self.upsert_key_columns = upsert_key_columns
        self.upsert_version_column = upsert_version_column
        self.use_schema_discovery = use_schema_discovery


class CsvFormatSettings(DataFormatSettings):
    """CsvFormatSettings.

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    :ivar columns: If provided, a list of the names to use for the columns. Use this setting with
     files that don't contain a header row with column names. Another use case is when you want to
     ignore the header rows in the files using ``skipHeaderRows`` and supply your own column names.
     For streaming ingestion jobs, ``columns`` is required and must be non-empty.
    :vartype columns: list[str]
    :ivar delimiter: The delimiter between values. Defaults to ``,`` for comma-separated values.
     Set to ``\\t`` or a literal tab character for tab-separated values.
    :vartype delimiter: str
    :ivar list_delimiter: A custom delimiter for multi-value dimensions. Defaults to ``\\u0001``.
    :vartype list_delimiter: str
    :ivar skip_header_rows: The number of initial rows to skip. Use ``skipHeaderRows`` if your data
     has multiple header rows and
     you only want to read the last row, or you want to supply your own column names. For streaming
     ingestion jobs, Polaris does not support skipping header rows and raises an error if
     ``skipHeaderRows`` is
     set.

     Interacts with the ``columns`` setting. If ``columns`` is not set or is empty, then Polaris
     reads the file as follows:


     * Skip ``skipHeaderRows`` rows
     * Read header from the next row, row number ``skipHeaderRows + 1``
     * Read data starting on row ``skipHeaderRows + 2``

     If ``columns`` is set, then Polaris reads the file as follows:


     * Skip ``skipHeaderRows`` rows
     * Read data starting on row ``skipHeaderRows + 1``

     With the default setting of ``skipHeaderRows`` set to zero, the following applies:


     * If ``columns`` is unset, then the first row is read as the header, and the data begins on
     the second row.
     * If ``columns`` is set, then no header row is read, and the data begins on the first row of
     the file.
    :vartype skip_header_rows: int
    """

    _validation = {
        "format": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
        "columns": {"key": "columns", "type": "[str]"},
        "delimiter": {"key": "delimiter", "type": "str"},
        "list_delimiter": {"key": "listDelimiter", "type": "str"},
        "skip_header_rows": {"key": "skipHeaderRows", "type": "int"},
    }

    def __init__(
        self,
        *,
        columns: List[str] = [],
        delimiter: Optional[str] = None,
        list_delimiter: Optional[str] = None,
        skip_header_rows: int = 0,
        **kwargs: Any
    ) -> None:
        """
        :keyword columns: If provided, a list of the names to use for the columns. Use this setting
         with files that don't contain a header row with column names. Another use case is when you want
         to ignore the header rows in the files using ``skipHeaderRows`` and supply your own column
         names. For streaming ingestion jobs, ``columns`` is required and must be non-empty.
        :paramtype columns: list[str]
        :keyword delimiter: The delimiter between values. Defaults to ``,`` for comma-separated values.
         Set to ``\\t`` or a literal tab character for tab-separated values.
        :paramtype delimiter: str
        :keyword list_delimiter: A custom delimiter for multi-value dimensions. Defaults to
         ``\\u0001``.
        :paramtype list_delimiter: str
        :keyword skip_header_rows: The number of initial rows to skip. Use ``skipHeaderRows`` if your
         data has multiple header rows and
         you only want to read the last row, or you want to supply your own column names. For streaming
         ingestion jobs, Polaris does not support skipping header rows and raises an error if
         ``skipHeaderRows`` is
         set.

         Interacts with the ``columns`` setting. If ``columns`` is not set or is empty, then Polaris
         reads the file as follows:


         * Skip ``skipHeaderRows`` rows
         * Read header from the next row, row number ``skipHeaderRows + 1``
         * Read data starting on row ``skipHeaderRows + 2``

         If ``columns`` is set, then Polaris reads the file as follows:


         * Skip ``skipHeaderRows`` rows
         * Read data starting on row ``skipHeaderRows + 1``

         With the default setting of ``skipHeaderRows`` set to zero, the following applies:


         * If ``columns`` is unset, then the first row is read as the header, and the data begins on
         the second row.
         * If ``columns`` is set, then no header row is read, and the data begins on the first row of
         the file.
        :paramtype skip_header_rows: int
        """
        super().__init__(**kwargs)
        self.format: str = "csv"
        self.columns = columns
        self.delimiter = delimiter
        self.list_delimiter = list_delimiter
        self.skip_header_rows = skip_header_rows


class Theme(_serialization.Model):
    """Color theme for an organization and visualizations.

    :ivar app_palette: Color palette for the Polaris UI.
    :vartype app_palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar vis_palette: Color palette for visualizations.
    :vartype vis_palette: ~polaris.sdk.global_api.models.VisualizationColorPalette
    """

    _attribute_map = {
        "app_palette": {"key": "appPalette", "type": "AppColorPalette"},
        "vis_palette": {"key": "visPalette", "type": "VisualizationColorPalette"},
    }

    def __init__(
        self,
        *,
        app_palette: Optional["_models.AppColorPalette"] = None,
        vis_palette: Optional["_models.VisualizationColorPalette"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword app_palette: Color palette for the Polaris UI.
        :paramtype app_palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword vis_palette: Color palette for visualizations.
        :paramtype vis_palette: ~polaris.sdk.global_api.models.VisualizationColorPalette
        """
        super().__init__(**kwargs)
        self.app_palette = app_palette
        self.vis_palette = vis_palette


class Customization(Theme, ApplicationName):
    """All customizations applied to an organization.

    :ivar app_name: Application name.
    :vartype app_name: str
    :ivar app_palette: Color palette for the Polaris UI.
    :vartype app_palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar vis_palette: Color palette for visualizations.
    :vartype vis_palette: ~polaris.sdk.global_api.models.VisualizationColorPalette
    :ivar logos: Application logos.
    :vartype logos: ~polaris.sdk.global_api.models.LogosResponse
    """

    _attribute_map = {
        "app_name": {"key": "appName", "type": "str"},
        "app_palette": {"key": "appPalette", "type": "AppColorPalette"},
        "vis_palette": {"key": "visPalette", "type": "VisualizationColorPalette"},
        "logos": {"key": "logos", "type": "LogosResponse"},
    }

    def __init__(
        self,
        *,
        app_name: Optional[str] = None,
        app_palette: Optional["_models.AppColorPalette"] = None,
        vis_palette: Optional["_models.VisualizationColorPalette"] = None,
        logos: Optional["_models.LogosResponse"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword app_name: Application name.
        :paramtype app_name: str
        :keyword app_palette: Color palette for the Polaris UI.
        :paramtype app_palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword vis_palette: Color palette for visualizations.
        :paramtype vis_palette: ~polaris.sdk.global_api.models.VisualizationColorPalette
        :keyword logos: Application logos.
        :paramtype logos: ~polaris.sdk.global_api.models.LogosResponse
        """
        super().__init__(
            app_palette=app_palette,
            vis_palette=vis_palette,
            app_name=app_name,
            **kwargs
        )
        self.app_name = app_name
        self.logos = logos
        self.app_palette = app_palette
        self.vis_palette = vis_palette


class CustomizationResponse(Customization, ModificationRecord):
    """All customizations applied to an organization.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar last_modified_by: The user who last modified the customizations.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.User
    :ivar last_update_timestamp: Date and time of the last update in ISO 8601 format.
    :vartype last_update_timestamp: ~datetime.datetime
    :ivar app_name: Application name.
    :vartype app_name: str
    :ivar app_palette: Color palette for the Polaris UI.
    :vartype app_palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar vis_palette: Color palette for visualizations.
    :vartype vis_palette: ~polaris.sdk.global_api.models.VisualizationColorPalette
    :ivar logos: Application logos.
    :vartype logos: ~polaris.sdk.global_api.models.LogosResponse
    """

    _validation = {
        "last_modified_by": {"readonly": True},
    }

    _attribute_map = {
        "last_modified_by": {"key": "lastModifiedBy", "type": "User"},
        "last_update_timestamp": {"key": "lastUpdateTimestamp", "type": "iso-8601"},
        "app_name": {"key": "appName", "type": "str"},
        "app_palette": {"key": "appPalette", "type": "AppColorPalette"},
        "vis_palette": {"key": "visPalette", "type": "VisualizationColorPalette"},
        "logos": {"key": "logos", "type": "LogosResponse"},
    }

    def __init__(
        self,
        *,
        last_update_timestamp: Optional[datetime.datetime] = None,
        app_name: Optional[str] = None,
        app_palette: Optional["_models.AppColorPalette"] = None,
        vis_palette: Optional["_models.VisualizationColorPalette"] = None,
        logos: Optional["_models.LogosResponse"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword last_update_timestamp: Date and time of the last update in ISO 8601 format.
        :paramtype last_update_timestamp: ~datetime.datetime
        :keyword app_name: Application name.
        :paramtype app_name: str
        :keyword app_palette: Color palette for the Polaris UI.
        :paramtype app_palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword vis_palette: Color palette for visualizations.
        :paramtype vis_palette: ~polaris.sdk.global_api.models.VisualizationColorPalette
        :keyword logos: Application logos.
        :paramtype logos: ~polaris.sdk.global_api.models.LogosResponse
        """
        super().__init__(
            app_name=app_name,
            app_palette=app_palette,
            vis_palette=vis_palette,
            logos=logos,
            last_update_timestamp=last_update_timestamp,
            **kwargs
        )
        self.last_modified_by = None
        self.last_update_timestamp = last_update_timestamp
        self.app_name = app_name
        self.app_palette = app_palette
        self.vis_palette = vis_palette
        self.logos = logos


class DashboardPayload(_serialization.Model):
    """Dashboard properties.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar type: Dashboard type - always "dashboard2". Known values are: "classic" and "dashboard2".
    :vartype type: str or ~polaris.sdk.global_api.models.DashboardType
    :ivar title: Dashboard title to display in the Polaris UI.
    :vartype title: str
    :ivar description: Dashboard description.
    :vartype description: str
    :ivar palette: Color palette for the Polaris UI. Use the 6-character hex format for all colors.
    :vartype palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar read_access: Access control list for read access to the dashboard.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar modify_access: Access control list for modifying the dashboard.
    :vartype modify_access: ~polaris.sdk.global_api.models.AccessList
    :ivar pages: Array of dashboard pages.
    :vartype pages: list[~polaris.sdk.global_api.models.DashboardPayloadPagesItem]
    :ivar default_filters: Default filters to apply to the dashboard.
    :vartype default_filters: list[~polaris.sdk.global_api.models.DashboardFilter]
    :ivar enforce_time_filter: Ensure that every query is filtered on the primary time dimension.
    :vartype enforce_time_filter: bool
    :ivar filter_tile: Enable visibility of global filters. Known values are: "show" and "hide".
    :vartype filter_tile: str or ~polaris.sdk.global_api.models.ShowHide
    :ivar pages_tile: Enable visibility of page selector. Known values are: "show" and "hide".
    :vartype pages_tile: str or ~polaris.sdk.global_api.models.ShowHide
    :ivar pages_color_summary: Show status indicator according to tile formatting. Only applicable
     if ``pagesTile`` is set to ``show``. Known values are: "show" and "hide".
    :vartype pages_color_summary: str or ~polaris.sdk.global_api.models.ShowHide
    :ivar has_global_compare: Enable global comparisons.
    :vartype has_global_compare: bool
    :ivar default_compare: Default comparison to apply to the dashboard.
    :vartype default_compare: ~polaris.sdk.global_api.models.DashboardCompare
    :ivar has_global_measures: Enable global measures.
    :vartype has_global_measures: bool
    :ivar default_measures: IDs of default measures to apply to the dashboard.
    :vartype default_measures: list[str]
    :ivar filter_query_default_duration: Default time period used for filter queries, expressed as
     an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype filter_query_default_duration: ~datetime.timedelta
    :ivar default_refresh_rate: Default refresh rate for the dashboard, expressed as an `ISO 8601
     Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_refresh_rate: ~datetime.timedelta
    :ivar min_auto_refresh_rate: The rate under which this dashboard won't refresh,  expressed as
     an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_auto_refresh_rate: ~datetime.timedelta
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "palette": {"key": "palette", "type": "AppColorPalette"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "modify_access": {"key": "modifyAccess", "type": "AccessList"},
        "pages": {"key": "pages", "type": "[DashboardPayloadPagesItem]"},
        "default_filters": {"key": "defaultFilters", "type": "[DashboardFilter]"},
        "enforce_time_filter": {"key": "enforceTimeFilter", "type": "bool"},
        "filter_tile": {"key": "filterTile", "type": "str"},
        "pages_tile": {"key": "pagesTile", "type": "str"},
        "pages_color_summary": {"key": "pagesColorSummary", "type": "str"},
        "has_global_compare": {"key": "hasGlobalCompare", "type": "bool"},
        "default_compare": {"key": "defaultCompare", "type": "DashboardCompare"},
        "has_global_measures": {"key": "hasGlobalMeasures", "type": "bool"},
        "default_measures": {"key": "defaultMeasures", "type": "[str]"},
        "filter_query_default_duration": {
            "key": "filterQueryDefaultDuration",
            "type": "duration",
        },
        "default_refresh_rate": {"key": "defaultRefreshRate", "type": "duration"},
        "min_auto_refresh_rate": {"key": "minAutoRefreshRate", "type": "duration"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        type: Union[str, "_models.DashboardType"] = "dashboard2",
        title: Optional[str] = None,
        description: Optional[str] = None,
        palette: Optional["_models.AppColorPalette"] = None,
        read_access: Optional["_models.AccessList"] = None,
        modify_access: Optional["_models.AccessList"] = None,
        pages: Optional[List["_models.DashboardPayloadPagesItem"]] = None,
        default_filters: Optional[List["_models.DashboardFilter"]] = None,
        enforce_time_filter: bool = False,
        filter_tile: Optional[Union[str, "_models.ShowHide"]] = None,
        pages_tile: Optional[Union[str, "_models.ShowHide"]] = None,
        pages_color_summary: Optional[Union[str, "_models.ShowHide"]] = None,
        has_global_compare: bool = False,
        default_compare: Optional["_models.DashboardCompare"] = None,
        has_global_measures: bool = False,
        default_measures: Optional[List[str]] = None,
        filter_query_default_duration: datetime.timedelta = "P1D",
        default_refresh_rate: Optional[datetime.timedelta] = None,
        min_auto_refresh_rate: Optional[datetime.timedelta] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword type: Dashboard type - always "dashboard2". Known values are: "classic" and
         "dashboard2".
        :paramtype type: str or ~polaris.sdk.global_api.models.DashboardType
        :keyword title: Dashboard title to display in the Polaris UI.
        :paramtype title: str
        :keyword description: Dashboard description.
        :paramtype description: str
        :keyword palette: Color palette for the Polaris UI. Use the 6-character hex format for all
         colors.
        :paramtype palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword read_access: Access control list for read access to the dashboard.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword modify_access: Access control list for modifying the dashboard.
        :paramtype modify_access: ~polaris.sdk.global_api.models.AccessList
        :keyword pages: Array of dashboard pages.
        :paramtype pages: list[~polaris.sdk.global_api.models.DashboardPayloadPagesItem]
        :keyword default_filters: Default filters to apply to the dashboard.
        :paramtype default_filters: list[~polaris.sdk.global_api.models.DashboardFilter]
        :keyword enforce_time_filter: Ensure that every query is filtered on the primary time
         dimension.
        :paramtype enforce_time_filter: bool
        :keyword filter_tile: Enable visibility of global filters. Known values are: "show" and "hide".
        :paramtype filter_tile: str or ~polaris.sdk.global_api.models.ShowHide
        :keyword pages_tile: Enable visibility of page selector. Known values are: "show" and "hide".
        :paramtype pages_tile: str or ~polaris.sdk.global_api.models.ShowHide
        :keyword pages_color_summary: Show status indicator according to tile formatting. Only
         applicable if ``pagesTile`` is set to ``show``. Known values are: "show" and "hide".
        :paramtype pages_color_summary: str or ~polaris.sdk.global_api.models.ShowHide
        :keyword has_global_compare: Enable global comparisons.
        :paramtype has_global_compare: bool
        :keyword default_compare: Default comparison to apply to the dashboard.
        :paramtype default_compare: ~polaris.sdk.global_api.models.DashboardCompare
        :keyword has_global_measures: Enable global measures.
        :paramtype has_global_measures: bool
        :keyword default_measures: IDs of default measures to apply to the dashboard.
        :paramtype default_measures: list[str]
        :keyword filter_query_default_duration: Default time period used for filter queries, expressed
         as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype filter_query_default_duration: ~datetime.timedelta
        :keyword default_refresh_rate: Default refresh rate for the dashboard, expressed as an `ISO
         8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype default_refresh_rate: ~datetime.timedelta
        :keyword min_auto_refresh_rate: The rate under which this dashboard won't refresh,  expressed
         as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_auto_refresh_rate: ~datetime.timedelta
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.palette = palette
        self.read_access = read_access
        self.modify_access = modify_access
        self.pages = pages
        self.default_filters = default_filters
        self.enforce_time_filter = enforce_time_filter
        self.filter_tile = filter_tile
        self.pages_tile = pages_tile
        self.pages_color_summary = pages_color_summary
        self.has_global_compare = has_global_compare
        self.default_compare = default_compare
        self.has_global_measures = has_global_measures
        self.default_measures = default_measures
        self.filter_query_default_duration = filter_query_default_duration
        self.default_refresh_rate = default_refresh_rate
        self.min_auto_refresh_rate = min_auto_refresh_rate


class DashboardBody(DashboardPayload):
    """DashboardBody.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar type: Dashboard type - always "dashboard2". Known values are: "classic" and "dashboard2".
    :vartype type: str or ~polaris.sdk.global_api.models.DashboardType
    :ivar title: Dashboard title to display in the Polaris UI.
    :vartype title: str
    :ivar description: Dashboard description.
    :vartype description: str
    :ivar palette: Color palette for the Polaris UI. Use the 6-character hex format for all colors.
    :vartype palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar read_access: Access control list for read access to the dashboard.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar modify_access: Access control list for modifying the dashboard.
    :vartype modify_access: ~polaris.sdk.global_api.models.AccessList
    :ivar pages: Array of dashboard pages.
    :vartype pages: list[~polaris.sdk.global_api.models.DashboardPayloadPagesItem]
    :ivar default_filters: Default filters to apply to the dashboard.
    :vartype default_filters: list[~polaris.sdk.global_api.models.DashboardFilter]
    :ivar enforce_time_filter: Ensure that every query is filtered on the primary time dimension.
    :vartype enforce_time_filter: bool
    :ivar filter_tile: Enable visibility of global filters. Known values are: "show" and "hide".
    :vartype filter_tile: str or ~polaris.sdk.global_api.models.ShowHide
    :ivar pages_tile: Enable visibility of page selector. Known values are: "show" and "hide".
    :vartype pages_tile: str or ~polaris.sdk.global_api.models.ShowHide
    :ivar pages_color_summary: Show status indicator according to tile formatting. Only applicable
     if ``pagesTile`` is set to ``show``. Known values are: "show" and "hide".
    :vartype pages_color_summary: str or ~polaris.sdk.global_api.models.ShowHide
    :ivar has_global_compare: Enable global comparisons.
    :vartype has_global_compare: bool
    :ivar default_compare: Default comparison to apply to the dashboard.
    :vartype default_compare: ~polaris.sdk.global_api.models.DashboardCompare
    :ivar has_global_measures: Enable global measures.
    :vartype has_global_measures: bool
    :ivar default_measures: IDs of default measures to apply to the dashboard.
    :vartype default_measures: list[str]
    :ivar filter_query_default_duration: Default time period used for filter queries, expressed as
     an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype filter_query_default_duration: ~datetime.timedelta
    :ivar default_refresh_rate: Default refresh rate for the dashboard, expressed as an `ISO 8601
     Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_refresh_rate: ~datetime.timedelta
    :ivar min_auto_refresh_rate: The rate under which this dashboard won't refresh,  expressed as
     an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_auto_refresh_rate: ~datetime.timedelta
    """


class DashboardCompare(_serialization.Model):
    """Comparison that can be applied to a dashboard."""


class DashboardDataCubeListResponse(_serialization.Model):
    """Array of data cubes.

    All required parameters must be populated in order to send to server.

    :ivar values: Array of data cubes. Required.
    :vartype values: list[~polaris.sdk.global_api.models.DashboardDataCubeListResponseValuesItem]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {
            "key": "values",
            "type": "[DashboardDataCubeListResponseValuesItem]",
        },
    }

    def __init__(
        self,
        *,
        values: List["_models.DashboardDataCubeListResponseValuesItem"],
        **kwargs: Any
    ) -> None:
        """
        :keyword values: Array of data cubes. Required.
        :paramtype values: list[~polaris.sdk.global_api.models.DashboardDataCubeListResponseValuesItem]
        """
        super().__init__(**kwargs)
        self.values = values


class DataCubePayload(_serialization.Model):
    """A data cube.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar title: Data cube title.
    :vartype title: str
    :ivar description: Data cube description.
    :vartype description: str
    :ivar query_mode: Data cube query mode. Known values are: "sql" and "plywood".
    :vartype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
    :ivar source: Data cube source.
    :vartype source: ~polaris.sdk.global_api.models.DataCubeSource
    :ivar palette: Color palette for the Polaris UI. Use the 6-character hex format for all colors.
    :vartype palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar min_auto_refresh_rate: Minimum auto refresh rate for the data cube, expressed as an `ISO
     8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_auto_refresh_rate: ~datetime.timedelta
    :ivar latest_time_filter_granularity: When using a relative time filter, Polaris uses this
     level of granularity to align the
     filter boundaries when querying the underlying table, expressed as an `ISO 8601 Duration
     <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
     For an aggregate table, set to the same granularity used during ingestion or leave unset for
     Polaris to infer
     an appropriate value from the data. For a detail table, leave unset.
    :vartype latest_time_filter_granularity: ~datetime.timedelta
    :ivar subset_formula: Row level filter to apply to the data cube. This filter is never shown in
     the cube view
     and effectively constrains the data cube to only the events that match this filter.
    :vartype subset_formula: str
    :ivar filter_token: Only allow users with the given filter token to access this data cube.
    :vartype filter_token: str
    :ivar rollup: Whether the associated table has rollup enabled.
    :vartype rollup: bool
    :ivar options: Data cube options.
    :vartype options: ~polaris.sdk.global_api.models.DataCubeOptions
    :ivar read_access: Access control list for read access to the data cube.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar restricted_edit_access: In some cases, you may need to limit a user's ability to edit
     aspects of a data cube;
     for example, to allow a user to modify dimensions but not to change the title or description.
    :vartype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
    :ivar modify_access: Access control list for modifying this data cube.
    :vartype modify_access: ~polaris.sdk.global_api.models.AccessList
    :ivar download_access: Access control list for downloading raw data from this data cube.
    :vartype download_access: ~polaris.sdk.global_api.models.AccessList
    :ivar attributes: Column metadata for the associated data source.
    :vartype attributes: list[~polaris.sdk.global_api.models.Attribute]
    :ivar dimensions: The dimensions of the data cube.
    :vartype dimensions: list[~polaris.sdk.global_api.models.DimensionPayload]
    :ivar measures: Array of data cube measures.
    :vartype measures: list[~polaris.sdk.global_api.models.MeasurePayload]
    :ivar instances: Data cube instances.
    :vartype instances: ~polaris.sdk.global_api.models.DataCubeInstanceList
    :ivar special_time_dimension: Time dimension Polaris uses for all time-related calculations for
     the data cube, including comparisons, filters, alerts, and reports.
     Polarise uses this to check the freshness of data and apply time filters.
    :vartype special_time_dimension: str
    :ivar enforce_time_filter: Ensures that every query is filtered on the primary time dimension.
     You can enable this setting if time unbounded queries are likely to be slow due to the volume
     of data.
    :vartype enforce_time_filter: bool
    :ivar default_filter: Default filter to apply when visualizing the data cube.
    :vartype default_filter: ~polaris.sdk.global_api.models.Filter
    :ivar default_timezone: Time zone to select when a user first opens the data cube, expressed as
     an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype default_timezone: str
    :ivar default_duration: Time period to display when a user first opens the data cube,
     expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_duration: ~datetime.timedelta
    :ivar default_selected_measures: IDs of the measures to show by default in visualizations.
    :vartype default_selected_measures: list[str]
    :ivar default_pinned_dimensions: IDs of the dimensions to pin by default in visualizations.
    :vartype default_pinned_dimensions: list[str]
    :ivar default_refresh_rate: The default refresh rate for the data cube, expressed as an `ISO
     8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_refresh_rate: ~datetime.timedelta
    :ivar default_visualization: Name of the default visualization to use when initially viewing
     the data cube.
    :vartype default_visualization: str
    :ivar default_having_filter: The default HAVING filter for the data cube.
    :vartype default_having_filter: ~polaris.sdk.global_api.models.HavingFilter
    :ivar latest_data_strategy: Determines how Polaris calculates the latest data time for the data
     cube.
     By default, Polaris queries the data source for the latest time stamp on ingested data.
     You can set this property to always use the current time, which may be more appropriate for
     streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
    :vartype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
    :ivar query_caching: Allow caching on queries made to this data cube. Caching can greatly speed
     up exploration but can
     also cause results to be a little out of date especially in realtime rolled up datasets. Known
     values are: "allow" and "disable".
    :vartype query_caching: str or ~polaris.sdk.global_api.models.DataCubePayloadQueryCaching
    :ivar formulae_visibility: Hide or show dimension and measure formulae in info modals. Polaris
     displays formulae are by default. Users
     with appropriate permissions can still see formulae when editing. Known values are: "show" and
     "hide".
    :vartype formulae_visibility: str or ~polaris.sdk.global_api.models.Visibility
    :ivar min_alert_frequency: Minimum allowable frequency for alerts associated with this data
     cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_alert_frequency: ~datetime.timedelta
    :ivar min_alert_time_frame: Minimum allowable time frame for alerts associated with this data
     cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_alert_time_frame: ~datetime.timedelta
    :ivar default_parameters: The default parameters to populate an Explore visualization.
    :vartype default_parameters: str
    :ivar default_facet_splits: Default dimensions to split on.
    :vartype default_facet_splits: list[any]
    :ivar default_facet_compare: Default comparison for the data cube.
    :vartype default_facet_compare: ~polaris.sdk.global_api.models.FacetCompare
    :ivar custom_facet_compares: Customized comparisons for the data cube.
    :vartype custom_facet_compares: list[~polaris.sdk.global_api.models.FacetCompare]
    :ivar require_group_filters: Enable this property to use access filters. When enabled, users
     who aren't assigned an access
     filter can't perform queries.
    :vartype require_group_filters: bool
    :ivar allow_filter_combine: Determines the behaviour when a user is a member of two or more
     user groups with access filters applied.
     If ``true``\\ , Polaris combines the filters with the OR operator.
     If ``false``\\ , the user can't view any data in the data cube.
    :vartype allow_filter_combine: bool
    :ivar group_filters: Defines access filters for a user group.
    :vartype group_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
    :ivar user_filters: Defines access filters for a Polaris API key.
    :vartype user_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "query_mode": {"key": "queryMode", "type": "str"},
        "source": {"key": "source", "type": "DataCubeSource"},
        "palette": {"key": "palette", "type": "AppColorPalette"},
        "min_auto_refresh_rate": {"key": "minAutoRefreshRate", "type": "duration"},
        "latest_time_filter_granularity": {
            "key": "latestTimeFilterGranularity",
            "type": "duration",
        },
        "subset_formula": {"key": "subsetFormula", "type": "str"},
        "filter_token": {"key": "filterToken", "type": "str"},
        "rollup": {"key": "rollup", "type": "bool"},
        "options": {"key": "options", "type": "DataCubeOptions"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "restricted_edit_access": {"key": "restrictedEditAccess", "type": "AccessList"},
        "modify_access": {"key": "modifyAccess", "type": "AccessList"},
        "download_access": {"key": "downloadAccess", "type": "AccessList"},
        "attributes": {"key": "attributes", "type": "[Attribute]"},
        "dimensions": {"key": "dimensions", "type": "[DimensionPayload]"},
        "measures": {"key": "measures", "type": "[MeasurePayload]"},
        "instances": {"key": "instances", "type": "DataCubeInstanceList"},
        "special_time_dimension": {"key": "specialTimeDimension", "type": "str"},
        "enforce_time_filter": {"key": "enforceTimeFilter", "type": "bool"},
        "default_filter": {"key": "defaultFilter", "type": "Filter"},
        "default_timezone": {"key": "defaultTimezone", "type": "str"},
        "default_duration": {"key": "defaultDuration", "type": "duration"},
        "default_selected_measures": {
            "key": "defaultSelectedMeasures",
            "type": "[str]",
        },
        "default_pinned_dimensions": {
            "key": "defaultPinnedDimensions",
            "type": "[str]",
        },
        "default_refresh_rate": {"key": "defaultRefreshRate", "type": "duration"},
        "default_visualization": {"key": "defaultVisualization", "type": "str"},
        "default_having_filter": {"key": "defaultHavingFilter", "type": "HavingFilter"},
        "latest_data_strategy": {"key": "latestDataStrategy", "type": "str"},
        "query_caching": {"key": "queryCaching", "type": "str"},
        "formulae_visibility": {"key": "formulaeVisibility", "type": "str"},
        "min_alert_frequency": {"key": "minAlertFrequency", "type": "duration"},
        "min_alert_time_frame": {"key": "minAlertTimeFrame", "type": "duration"},
        "default_parameters": {"key": "defaultParameters", "type": "str"},
        "default_facet_splits": {"key": "defaultFacetSplits", "type": "[object]"},
        "default_facet_compare": {"key": "defaultFacetCompare", "type": "FacetCompare"},
        "custom_facet_compares": {
            "key": "customFacetCompares",
            "type": "[FacetCompare]",
        },
        "require_group_filters": {"key": "requireGroupFilters", "type": "bool"},
        "allow_filter_combine": {"key": "allowFilterCombine", "type": "bool"},
        "group_filters": {"key": "groupFilters", "type": "{GroupFilter}"},
        "user_filters": {"key": "userFilters", "type": "{GroupFilter}"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        title: Optional[str] = None,
        description: Optional[str] = None,
        query_mode: Optional[Union[str, "_models.QueryMode"]] = None,
        source: Optional["_models.DataCubeSource"] = None,
        palette: Optional["_models.AppColorPalette"] = None,
        min_auto_refresh_rate: Optional[datetime.timedelta] = None,
        latest_time_filter_granularity: Optional[datetime.timedelta] = None,
        subset_formula: Optional[str] = None,
        filter_token: Optional[str] = None,
        rollup: Optional[bool] = None,
        options: Optional["_models.DataCubeOptions"] = None,
        read_access: Optional["_models.AccessList"] = None,
        restricted_edit_access: Optional["_models.AccessList"] = None,
        modify_access: Optional["_models.AccessList"] = None,
        download_access: Optional["_models.AccessList"] = None,
        attributes: Optional[List["_models.Attribute"]] = None,
        dimensions: Optional[List["_models.DimensionPayload"]] = None,
        measures: Optional[List["_models.MeasurePayload"]] = None,
        instances: Optional["_models.DataCubeInstanceList"] = None,
        special_time_dimension: Optional[str] = None,
        enforce_time_filter: Optional[bool] = None,
        default_filter: Optional["_models.Filter"] = None,
        default_timezone: Optional[str] = None,
        default_duration: Optional[datetime.timedelta] = None,
        default_selected_measures: Optional[List[str]] = None,
        default_pinned_dimensions: Optional[List[str]] = None,
        default_refresh_rate: Optional[datetime.timedelta] = None,
        default_visualization: Optional[str] = None,
        default_having_filter: Optional["_models.HavingFilter"] = None,
        latest_data_strategy: Optional[Union[str, "_models.LatestDataStrategy"]] = None,
        query_caching: Optional[
            Union[str, "_models.DataCubePayloadQueryCaching"]
        ] = None,
        formulae_visibility: Optional[Union[str, "_models.Visibility"]] = None,
        min_alert_frequency: Optional[datetime.timedelta] = None,
        min_alert_time_frame: Optional[datetime.timedelta] = None,
        default_parameters: Optional[str] = None,
        default_facet_splits: Optional[List[Any]] = None,
        default_facet_compare: Optional["_models.FacetCompare"] = None,
        custom_facet_compares: Optional[List["_models.FacetCompare"]] = None,
        require_group_filters: Optional[bool] = None,
        allow_filter_combine: Optional[bool] = None,
        group_filters: Optional[Dict[str, "_models.GroupFilter"]] = None,
        user_filters: Optional[Dict[str, "_models.GroupFilter"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword title: Data cube title.
        :paramtype title: str
        :keyword description: Data cube description.
        :paramtype description: str
        :keyword query_mode: Data cube query mode. Known values are: "sql" and "plywood".
        :paramtype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
        :keyword source: Data cube source.
        :paramtype source: ~polaris.sdk.global_api.models.DataCubeSource
        :keyword palette: Color palette for the Polaris UI. Use the 6-character hex format for all
         colors.
        :paramtype palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword min_auto_refresh_rate: Minimum auto refresh rate for the data cube, expressed as an
         `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_auto_refresh_rate: ~datetime.timedelta
        :keyword latest_time_filter_granularity: When using a relative time filter, Polaris uses this
         level of granularity to align the
         filter boundaries when querying the underlying table, expressed as an `ISO 8601 Duration
         <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
         For an aggregate table, set to the same granularity used during ingestion or leave unset for
         Polaris to infer
         an appropriate value from the data. For a detail table, leave unset.
        :paramtype latest_time_filter_granularity: ~datetime.timedelta
        :keyword subset_formula: Row level filter to apply to the data cube. This filter is never shown
         in the cube view
         and effectively constrains the data cube to only the events that match this filter.
        :paramtype subset_formula: str
        :keyword filter_token: Only allow users with the given filter token to access this data cube.
        :paramtype filter_token: str
        :keyword rollup: Whether the associated table has rollup enabled.
        :paramtype rollup: bool
        :keyword options: Data cube options.
        :paramtype options: ~polaris.sdk.global_api.models.DataCubeOptions
        :keyword read_access: Access control list for read access to the data cube.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword restricted_edit_access: In some cases, you may need to limit a user's ability to edit
         aspects of a data cube;
         for example, to allow a user to modify dimensions but not to change the title or description.
        :paramtype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
        :keyword modify_access: Access control list for modifying this data cube.
        :paramtype modify_access: ~polaris.sdk.global_api.models.AccessList
        :keyword download_access: Access control list for downloading raw data from this data cube.
        :paramtype download_access: ~polaris.sdk.global_api.models.AccessList
        :keyword attributes: Column metadata for the associated data source.
        :paramtype attributes: list[~polaris.sdk.global_api.models.Attribute]
        :keyword dimensions: The dimensions of the data cube.
        :paramtype dimensions: list[~polaris.sdk.global_api.models.DimensionPayload]
        :keyword measures: Array of data cube measures.
        :paramtype measures: list[~polaris.sdk.global_api.models.MeasurePayload]
        :keyword instances: Data cube instances.
        :paramtype instances: ~polaris.sdk.global_api.models.DataCubeInstanceList
        :keyword special_time_dimension: Time dimension Polaris uses for all time-related calculations
         for the data cube, including comparisons, filters, alerts, and reports.
         Polarise uses this to check the freshness of data and apply time filters.
        :paramtype special_time_dimension: str
        :keyword enforce_time_filter: Ensures that every query is filtered on the primary time
         dimension.
         You can enable this setting if time unbounded queries are likely to be slow due to the volume
         of data.
        :paramtype enforce_time_filter: bool
        :keyword default_filter: Default filter to apply when visualizing the data cube.
        :paramtype default_filter: ~polaris.sdk.global_api.models.Filter
        :keyword default_timezone: Time zone to select when a user first opens the data cube, expressed
         as an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype default_timezone: str
        :keyword default_duration: Time period to display when a user first opens the data cube,
         expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype default_duration: ~datetime.timedelta
        :keyword default_selected_measures: IDs of the measures to show by default in visualizations.
        :paramtype default_selected_measures: list[str]
        :keyword default_pinned_dimensions: IDs of the dimensions to pin by default in visualizations.
        :paramtype default_pinned_dimensions: list[str]
        :keyword default_refresh_rate: The default refresh rate for the data cube, expressed as an `ISO
         8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype default_refresh_rate: ~datetime.timedelta
        :keyword default_visualization: Name of the default visualization to use when initially viewing
         the data cube.
        :paramtype default_visualization: str
        :keyword default_having_filter: The default HAVING filter for the data cube.
        :paramtype default_having_filter: ~polaris.sdk.global_api.models.HavingFilter
        :keyword latest_data_strategy: Determines how Polaris calculates the latest data time for the
         data cube.
         By default, Polaris queries the data source for the latest time stamp on ingested data.
         You can set this property to always use the current time, which may be more appropriate for
         streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
        :paramtype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
        :keyword query_caching: Allow caching on queries made to this data cube. Caching can greatly
         speed up exploration but can
         also cause results to be a little out of date especially in realtime rolled up datasets. Known
         values are: "allow" and "disable".
        :paramtype query_caching: str or ~polaris.sdk.global_api.models.DataCubePayloadQueryCaching
        :keyword formulae_visibility: Hide or show dimension and measure formulae in info modals.
         Polaris displays formulae are by default. Users
         with appropriate permissions can still see formulae when editing. Known values are: "show" and
         "hide".
        :paramtype formulae_visibility: str or ~polaris.sdk.global_api.models.Visibility
        :keyword min_alert_frequency: Minimum allowable frequency for alerts associated with this data
         cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_alert_frequency: ~datetime.timedelta
        :keyword min_alert_time_frame: Minimum allowable time frame for alerts associated with this
         data cube, expressed as an `ISO 8601 Duration
         <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_alert_time_frame: ~datetime.timedelta
        :keyword default_parameters: The default parameters to populate an Explore visualization.
        :paramtype default_parameters: str
        :keyword default_facet_splits: Default dimensions to split on.
        :paramtype default_facet_splits: list[any]
        :keyword default_facet_compare: Default comparison for the data cube.
        :paramtype default_facet_compare: ~polaris.sdk.global_api.models.FacetCompare
        :keyword custom_facet_compares: Customized comparisons for the data cube.
        :paramtype custom_facet_compares: list[~polaris.sdk.global_api.models.FacetCompare]
        :keyword require_group_filters: Enable this property to use access filters. When enabled, users
         who aren't assigned an access
         filter can't perform queries.
        :paramtype require_group_filters: bool
        :keyword allow_filter_combine: Determines the behaviour when a user is a member of two or more
         user groups with access filters applied.
         If ``true``\\ , Polaris combines the filters with the OR operator.
         If ``false``\\ , the user can't view any data in the data cube.
        :paramtype allow_filter_combine: bool
        :keyword group_filters: Defines access filters for a user group.
        :paramtype group_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
        :keyword user_filters: Defines access filters for a Polaris API key.
        :paramtype user_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.title = title
        self.description = description
        self.query_mode = query_mode
        self.source = source
        self.palette = palette
        self.min_auto_refresh_rate = min_auto_refresh_rate
        self.latest_time_filter_granularity = latest_time_filter_granularity
        self.subset_formula = subset_formula
        self.filter_token = filter_token
        self.rollup = rollup
        self.options = options
        self.read_access = read_access
        self.restricted_edit_access = restricted_edit_access
        self.modify_access = modify_access
        self.download_access = download_access
        self.attributes = attributes
        self.dimensions = dimensions
        self.measures = measures
        self.instances = instances
        self.special_time_dimension = special_time_dimension
        self.enforce_time_filter = enforce_time_filter
        self.default_filter = default_filter
        self.default_timezone = default_timezone
        self.default_duration = default_duration
        self.default_selected_measures = default_selected_measures
        self.default_pinned_dimensions = default_pinned_dimensions
        self.default_refresh_rate = default_refresh_rate
        self.default_visualization = default_visualization
        self.default_having_filter = default_having_filter
        self.latest_data_strategy = latest_data_strategy
        self.query_caching = query_caching
        self.formulae_visibility = formulae_visibility
        self.min_alert_frequency = min_alert_frequency
        self.min_alert_time_frame = min_alert_time_frame
        self.default_parameters = default_parameters
        self.default_facet_splits = default_facet_splits
        self.default_facet_compare = default_facet_compare
        self.custom_facet_compares = custom_facet_compares
        self.require_group_filters = require_group_filters
        self.allow_filter_combine = allow_filter_combine
        self.group_filters = group_filters
        self.user_filters = user_filters


class DashboardDataCubeListResponseValuesItem(DataCubePayload, AuditRecord):
    """DashboardDataCubeListResponseValuesItem.

    All required parameters must be populated in order to send to server.

    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar title: Data cube title.
    :vartype title: str
    :ivar description: Data cube description.
    :vartype description: str
    :ivar query_mode: Data cube query mode. Known values are: "sql" and "plywood".
    :vartype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
    :ivar source: Data cube source.
    :vartype source: ~polaris.sdk.global_api.models.DataCubeSource
    :ivar palette: Color palette for the Polaris UI. Use the 6-character hex format for all colors.
    :vartype palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar min_auto_refresh_rate: Minimum auto refresh rate for the data cube, expressed as an `ISO
     8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_auto_refresh_rate: ~datetime.timedelta
    :ivar latest_time_filter_granularity: When using a relative time filter, Polaris uses this
     level of granularity to align the
     filter boundaries when querying the underlying table, expressed as an `ISO 8601 Duration
     <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
     For an aggregate table, set to the same granularity used during ingestion or leave unset for
     Polaris to infer
     an appropriate value from the data. For a detail table, leave unset.
    :vartype latest_time_filter_granularity: ~datetime.timedelta
    :ivar subset_formula: Row level filter to apply to the data cube. This filter is never shown in
     the cube view
     and effectively constrains the data cube to only the events that match this filter.
    :vartype subset_formula: str
    :ivar filter_token: Only allow users with the given filter token to access this data cube.
    :vartype filter_token: str
    :ivar rollup: Whether the associated table has rollup enabled.
    :vartype rollup: bool
    :ivar options: Data cube options.
    :vartype options: ~polaris.sdk.global_api.models.DataCubeOptions
    :ivar read_access: Access control list for read access to the data cube.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar restricted_edit_access: In some cases, you may need to limit a user's ability to edit
     aspects of a data cube;
     for example, to allow a user to modify dimensions but not to change the title or description.
    :vartype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
    :ivar modify_access: Access control list for modifying this data cube.
    :vartype modify_access: ~polaris.sdk.global_api.models.AccessList
    :ivar download_access: Access control list for downloading raw data from this data cube.
    :vartype download_access: ~polaris.sdk.global_api.models.AccessList
    :ivar attributes: Column metadata for the associated data source.
    :vartype attributes: list[~polaris.sdk.global_api.models.Attribute]
    :ivar dimensions: The dimensions of the data cube.
    :vartype dimensions: list[~polaris.sdk.global_api.models.DimensionPayload]
    :ivar measures: Array of data cube measures.
    :vartype measures: list[~polaris.sdk.global_api.models.MeasurePayload]
    :ivar instances: Data cube instances.
    :vartype instances: ~polaris.sdk.global_api.models.DataCubeInstanceList
    :ivar special_time_dimension: Time dimension Polaris uses for all time-related calculations for
     the data cube, including comparisons, filters, alerts, and reports.
     Polarise uses this to check the freshness of data and apply time filters.
    :vartype special_time_dimension: str
    :ivar enforce_time_filter: Ensures that every query is filtered on the primary time dimension.
     You can enable this setting if time unbounded queries are likely to be slow due to the volume
     of data.
    :vartype enforce_time_filter: bool
    :ivar default_filter: Default filter to apply when visualizing the data cube.
    :vartype default_filter: ~polaris.sdk.global_api.models.Filter
    :ivar default_timezone: Time zone to select when a user first opens the data cube, expressed as
     an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype default_timezone: str
    :ivar default_duration: Time period to display when a user first opens the data cube,
     expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_duration: ~datetime.timedelta
    :ivar default_selected_measures: IDs of the measures to show by default in visualizations.
    :vartype default_selected_measures: list[str]
    :ivar default_pinned_dimensions: IDs of the dimensions to pin by default in visualizations.
    :vartype default_pinned_dimensions: list[str]
    :ivar default_refresh_rate: The default refresh rate for the data cube, expressed as an `ISO
     8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_refresh_rate: ~datetime.timedelta
    :ivar default_visualization: Name of the default visualization to use when initially viewing
     the data cube.
    :vartype default_visualization: str
    :ivar default_having_filter: The default HAVING filter for the data cube.
    :vartype default_having_filter: ~polaris.sdk.global_api.models.HavingFilter
    :ivar latest_data_strategy: Determines how Polaris calculates the latest data time for the data
     cube.
     By default, Polaris queries the data source for the latest time stamp on ingested data.
     You can set this property to always use the current time, which may be more appropriate for
     streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
    :vartype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
    :ivar query_caching: Allow caching on queries made to this data cube. Caching can greatly speed
     up exploration but can
     also cause results to be a little out of date especially in realtime rolled up datasets. Known
     values are: "allow" and "disable".
    :vartype query_caching: str or ~polaris.sdk.global_api.models.DataCubePayloadQueryCaching
    :ivar formulae_visibility: Hide or show dimension and measure formulae in info modals. Polaris
     displays formulae are by default. Users
     with appropriate permissions can still see formulae when editing. Known values are: "show" and
     "hide".
    :vartype formulae_visibility: str or ~polaris.sdk.global_api.models.Visibility
    :ivar min_alert_frequency: Minimum allowable frequency for alerts associated with this data
     cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_alert_frequency: ~datetime.timedelta
    :ivar min_alert_time_frame: Minimum allowable time frame for alerts associated with this data
     cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_alert_time_frame: ~datetime.timedelta
    :ivar default_parameters: The default parameters to populate an Explore visualization.
    :vartype default_parameters: str
    :ivar default_facet_splits: Default dimensions to split on.
    :vartype default_facet_splits: list[any]
    :ivar default_facet_compare: Default comparison for the data cube.
    :vartype default_facet_compare: ~polaris.sdk.global_api.models.FacetCompare
    :ivar custom_facet_compares: Customized comparisons for the data cube.
    :vartype custom_facet_compares: list[~polaris.sdk.global_api.models.FacetCompare]
    :ivar require_group_filters: Enable this property to use access filters. When enabled, users
     who aren't assigned an access
     filter can't perform queries.
    :vartype require_group_filters: bool
    :ivar allow_filter_combine: Determines the behaviour when a user is a member of two or more
     user groups with access filters applied.
     If ``true``\\ , Polaris combines the filters with the OR operator.
     If ``false``\\ , the user can't view any data in the data cube.
    :vartype allow_filter_combine: bool
    :ivar group_filters: Defines access filters for a user group.
    :vartype group_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
    :ivar user_filters: Defines access filters for a Polaris API key.
    :vartype user_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
    """

    _validation = {
        "created_at": {"required": True},
        "updated_at": {"required": True},
        "id": {"max_length": 255, "min_length": 1},
    }

    _attribute_map = {
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "query_mode": {"key": "queryMode", "type": "str"},
        "source": {"key": "source", "type": "DataCubeSource"},
        "palette": {"key": "palette", "type": "AppColorPalette"},
        "min_auto_refresh_rate": {"key": "minAutoRefreshRate", "type": "duration"},
        "latest_time_filter_granularity": {
            "key": "latestTimeFilterGranularity",
            "type": "duration",
        },
        "subset_formula": {"key": "subsetFormula", "type": "str"},
        "filter_token": {"key": "filterToken", "type": "str"},
        "rollup": {"key": "rollup", "type": "bool"},
        "options": {"key": "options", "type": "DataCubeOptions"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "restricted_edit_access": {"key": "restrictedEditAccess", "type": "AccessList"},
        "modify_access": {"key": "modifyAccess", "type": "AccessList"},
        "download_access": {"key": "downloadAccess", "type": "AccessList"},
        "attributes": {"key": "attributes", "type": "[Attribute]"},
        "dimensions": {"key": "dimensions", "type": "[DimensionPayload]"},
        "measures": {"key": "measures", "type": "[MeasurePayload]"},
        "instances": {"key": "instances", "type": "DataCubeInstanceList"},
        "special_time_dimension": {"key": "specialTimeDimension", "type": "str"},
        "enforce_time_filter": {"key": "enforceTimeFilter", "type": "bool"},
        "default_filter": {"key": "defaultFilter", "type": "Filter"},
        "default_timezone": {"key": "defaultTimezone", "type": "str"},
        "default_duration": {"key": "defaultDuration", "type": "duration"},
        "default_selected_measures": {
            "key": "defaultSelectedMeasures",
            "type": "[str]",
        },
        "default_pinned_dimensions": {
            "key": "defaultPinnedDimensions",
            "type": "[str]",
        },
        "default_refresh_rate": {"key": "defaultRefreshRate", "type": "duration"},
        "default_visualization": {"key": "defaultVisualization", "type": "str"},
        "default_having_filter": {"key": "defaultHavingFilter", "type": "HavingFilter"},
        "latest_data_strategy": {"key": "latestDataStrategy", "type": "str"},
        "query_caching": {"key": "queryCaching", "type": "str"},
        "formulae_visibility": {"key": "formulaeVisibility", "type": "str"},
        "min_alert_frequency": {"key": "minAlertFrequency", "type": "duration"},
        "min_alert_time_frame": {"key": "minAlertTimeFrame", "type": "duration"},
        "default_parameters": {"key": "defaultParameters", "type": "str"},
        "default_facet_splits": {"key": "defaultFacetSplits", "type": "[object]"},
        "default_facet_compare": {"key": "defaultFacetCompare", "type": "FacetCompare"},
        "custom_facet_compares": {
            "key": "customFacetCompares",
            "type": "[FacetCompare]",
        },
        "require_group_filters": {"key": "requireGroupFilters", "type": "bool"},
        "allow_filter_combine": {"key": "allowFilterCombine", "type": "bool"},
        "group_filters": {"key": "groupFilters", "type": "{GroupFilter}"},
        "user_filters": {"key": "userFilters", "type": "{GroupFilter}"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        title: Optional[str] = None,
        description: Optional[str] = None,
        query_mode: Optional[Union[str, "_models.QueryMode"]] = None,
        source: Optional["_models.DataCubeSource"] = None,
        palette: Optional["_models.AppColorPalette"] = None,
        min_auto_refresh_rate: Optional[datetime.timedelta] = None,
        latest_time_filter_granularity: Optional[datetime.timedelta] = None,
        subset_formula: Optional[str] = None,
        filter_token: Optional[str] = None,
        rollup: Optional[bool] = None,
        options: Optional["_models.DataCubeOptions"] = None,
        read_access: Optional["_models.AccessList"] = None,
        restricted_edit_access: Optional["_models.AccessList"] = None,
        modify_access: Optional["_models.AccessList"] = None,
        download_access: Optional["_models.AccessList"] = None,
        attributes: Optional[List["_models.Attribute"]] = None,
        dimensions: Optional[List["_models.DimensionPayload"]] = None,
        measures: Optional[List["_models.MeasurePayload"]] = None,
        instances: Optional["_models.DataCubeInstanceList"] = None,
        special_time_dimension: Optional[str] = None,
        enforce_time_filter: Optional[bool] = None,
        default_filter: Optional["_models.Filter"] = None,
        default_timezone: Optional[str] = None,
        default_duration: Optional[datetime.timedelta] = None,
        default_selected_measures: Optional[List[str]] = None,
        default_pinned_dimensions: Optional[List[str]] = None,
        default_refresh_rate: Optional[datetime.timedelta] = None,
        default_visualization: Optional[str] = None,
        default_having_filter: Optional["_models.HavingFilter"] = None,
        latest_data_strategy: Optional[Union[str, "_models.LatestDataStrategy"]] = None,
        query_caching: Optional[
            Union[str, "_models.DataCubePayloadQueryCaching"]
        ] = None,
        formulae_visibility: Optional[Union[str, "_models.Visibility"]] = None,
        min_alert_frequency: Optional[datetime.timedelta] = None,
        min_alert_time_frame: Optional[datetime.timedelta] = None,
        default_parameters: Optional[str] = None,
        default_facet_splits: Optional[List[Any]] = None,
        default_facet_compare: Optional["_models.FacetCompare"] = None,
        custom_facet_compares: Optional[List["_models.FacetCompare"]] = None,
        require_group_filters: Optional[bool] = None,
        allow_filter_combine: Optional[bool] = None,
        group_filters: Optional[Dict[str, "_models.GroupFilter"]] = None,
        user_filters: Optional[Dict[str, "_models.GroupFilter"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword title: Data cube title.
        :paramtype title: str
        :keyword description: Data cube description.
        :paramtype description: str
        :keyword query_mode: Data cube query mode. Known values are: "sql" and "plywood".
        :paramtype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
        :keyword source: Data cube source.
        :paramtype source: ~polaris.sdk.global_api.models.DataCubeSource
        :keyword palette: Color palette for the Polaris UI. Use the 6-character hex format for all
         colors.
        :paramtype palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword min_auto_refresh_rate: Minimum auto refresh rate for the data cube, expressed as an
         `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_auto_refresh_rate: ~datetime.timedelta
        :keyword latest_time_filter_granularity: When using a relative time filter, Polaris uses this
         level of granularity to align the
         filter boundaries when querying the underlying table, expressed as an `ISO 8601 Duration
         <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
         For an aggregate table, set to the same granularity used during ingestion or leave unset for
         Polaris to infer
         an appropriate value from the data. For a detail table, leave unset.
        :paramtype latest_time_filter_granularity: ~datetime.timedelta
        :keyword subset_formula: Row level filter to apply to the data cube. This filter is never shown
         in the cube view
         and effectively constrains the data cube to only the events that match this filter.
        :paramtype subset_formula: str
        :keyword filter_token: Only allow users with the given filter token to access this data cube.
        :paramtype filter_token: str
        :keyword rollup: Whether the associated table has rollup enabled.
        :paramtype rollup: bool
        :keyword options: Data cube options.
        :paramtype options: ~polaris.sdk.global_api.models.DataCubeOptions
        :keyword read_access: Access control list for read access to the data cube.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword restricted_edit_access: In some cases, you may need to limit a user's ability to edit
         aspects of a data cube;
         for example, to allow a user to modify dimensions but not to change the title or description.
        :paramtype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
        :keyword modify_access: Access control list for modifying this data cube.
        :paramtype modify_access: ~polaris.sdk.global_api.models.AccessList
        :keyword download_access: Access control list for downloading raw data from this data cube.
        :paramtype download_access: ~polaris.sdk.global_api.models.AccessList
        :keyword attributes: Column metadata for the associated data source.
        :paramtype attributes: list[~polaris.sdk.global_api.models.Attribute]
        :keyword dimensions: The dimensions of the data cube.
        :paramtype dimensions: list[~polaris.sdk.global_api.models.DimensionPayload]
        :keyword measures: Array of data cube measures.
        :paramtype measures: list[~polaris.sdk.global_api.models.MeasurePayload]
        :keyword instances: Data cube instances.
        :paramtype instances: ~polaris.sdk.global_api.models.DataCubeInstanceList
        :keyword special_time_dimension: Time dimension Polaris uses for all time-related calculations
         for the data cube, including comparisons, filters, alerts, and reports.
         Polarise uses this to check the freshness of data and apply time filters.
        :paramtype special_time_dimension: str
        :keyword enforce_time_filter: Ensures that every query is filtered on the primary time
         dimension.
         You can enable this setting if time unbounded queries are likely to be slow due to the volume
         of data.
        :paramtype enforce_time_filter: bool
        :keyword default_filter: Default filter to apply when visualizing the data cube.
        :paramtype default_filter: ~polaris.sdk.global_api.models.Filter
        :keyword default_timezone: Time zone to select when a user first opens the data cube, expressed
         as an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype default_timezone: str
        :keyword default_duration: Time period to display when a user first opens the data cube,
         expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype default_duration: ~datetime.timedelta
        :keyword default_selected_measures: IDs of the measures to show by default in visualizations.
        :paramtype default_selected_measures: list[str]
        :keyword default_pinned_dimensions: IDs of the dimensions to pin by default in visualizations.
        :paramtype default_pinned_dimensions: list[str]
        :keyword default_refresh_rate: The default refresh rate for the data cube, expressed as an `ISO
         8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype default_refresh_rate: ~datetime.timedelta
        :keyword default_visualization: Name of the default visualization to use when initially viewing
         the data cube.
        :paramtype default_visualization: str
        :keyword default_having_filter: The default HAVING filter for the data cube.
        :paramtype default_having_filter: ~polaris.sdk.global_api.models.HavingFilter
        :keyword latest_data_strategy: Determines how Polaris calculates the latest data time for the
         data cube.
         By default, Polaris queries the data source for the latest time stamp on ingested data.
         You can set this property to always use the current time, which may be more appropriate for
         streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
        :paramtype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
        :keyword query_caching: Allow caching on queries made to this data cube. Caching can greatly
         speed up exploration but can
         also cause results to be a little out of date especially in realtime rolled up datasets. Known
         values are: "allow" and "disable".
        :paramtype query_caching: str or ~polaris.sdk.global_api.models.DataCubePayloadQueryCaching
        :keyword formulae_visibility: Hide or show dimension and measure formulae in info modals.
         Polaris displays formulae are by default. Users
         with appropriate permissions can still see formulae when editing. Known values are: "show" and
         "hide".
        :paramtype formulae_visibility: str or ~polaris.sdk.global_api.models.Visibility
        :keyword min_alert_frequency: Minimum allowable frequency for alerts associated with this data
         cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_alert_frequency: ~datetime.timedelta
        :keyword min_alert_time_frame: Minimum allowable time frame for alerts associated with this
         data cube, expressed as an `ISO 8601 Duration
         <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_alert_time_frame: ~datetime.timedelta
        :keyword default_parameters: The default parameters to populate an Explore visualization.
        :paramtype default_parameters: str
        :keyword default_facet_splits: Default dimensions to split on.
        :paramtype default_facet_splits: list[any]
        :keyword default_facet_compare: Default comparison for the data cube.
        :paramtype default_facet_compare: ~polaris.sdk.global_api.models.FacetCompare
        :keyword custom_facet_compares: Customized comparisons for the data cube.
        :paramtype custom_facet_compares: list[~polaris.sdk.global_api.models.FacetCompare]
        :keyword require_group_filters: Enable this property to use access filters. When enabled, users
         who aren't assigned an access
         filter can't perform queries.
        :paramtype require_group_filters: bool
        :keyword allow_filter_combine: Determines the behaviour when a user is a member of two or more
         user groups with access filters applied.
         If ``true``\\ , Polaris combines the filters with the OR operator.
         If ``false``\\ , the user can't view any data in the data cube.
        :paramtype allow_filter_combine: bool
        :keyword group_filters: Defines access filters for a user group.
        :paramtype group_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
        :keyword user_filters: Defines access filters for a Polaris API key.
        :paramtype user_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
        """
        super().__init__(
            additional_properties=additional_properties,
            id=id,
            title=title,
            description=description,
            query_mode=query_mode,
            source=source,
            palette=palette,
            min_auto_refresh_rate=min_auto_refresh_rate,
            latest_time_filter_granularity=latest_time_filter_granularity,
            subset_formula=subset_formula,
            filter_token=filter_token,
            rollup=rollup,
            options=options,
            read_access=read_access,
            restricted_edit_access=restricted_edit_access,
            modify_access=modify_access,
            download_access=download_access,
            attributes=attributes,
            dimensions=dimensions,
            measures=measures,
            instances=instances,
            special_time_dimension=special_time_dimension,
            enforce_time_filter=enforce_time_filter,
            default_filter=default_filter,
            default_timezone=default_timezone,
            default_duration=default_duration,
            default_selected_measures=default_selected_measures,
            default_pinned_dimensions=default_pinned_dimensions,
            default_refresh_rate=default_refresh_rate,
            default_visualization=default_visualization,
            default_having_filter=default_having_filter,
            latest_data_strategy=latest_data_strategy,
            query_caching=query_caching,
            formulae_visibility=formulae_visibility,
            min_alert_frequency=min_alert_frequency,
            min_alert_time_frame=min_alert_time_frame,
            default_parameters=default_parameters,
            default_facet_splits=default_facet_splits,
            default_facet_compare=default_facet_compare,
            custom_facet_compares=custom_facet_compares,
            require_group_filters=require_group_filters,
            allow_filter_combine=allow_filter_combine,
            group_filters=group_filters,
            user_filters=user_filters,
            created_at=created_at,
            created_by=created_by,
            updated_at=updated_at,
            updated_by=updated_by,
            **kwargs
        )
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by
        self.additional_properties = additional_properties
        self.id = id
        self.title = title
        self.description = description
        self.query_mode = query_mode
        self.source = source
        self.palette = palette
        self.min_auto_refresh_rate = min_auto_refresh_rate
        self.latest_time_filter_granularity = latest_time_filter_granularity
        self.subset_formula = subset_formula
        self.filter_token = filter_token
        self.rollup = rollup
        self.options = options
        self.read_access = read_access
        self.restricted_edit_access = restricted_edit_access
        self.modify_access = modify_access
        self.download_access = download_access
        self.attributes = attributes
        self.dimensions = dimensions
        self.measures = measures
        self.instances = instances
        self.special_time_dimension = special_time_dimension
        self.enforce_time_filter = enforce_time_filter
        self.default_filter = default_filter
        self.default_timezone = default_timezone
        self.default_duration = default_duration
        self.default_selected_measures = default_selected_measures
        self.default_pinned_dimensions = default_pinned_dimensions
        self.default_refresh_rate = default_refresh_rate
        self.default_visualization = default_visualization
        self.default_having_filter = default_having_filter
        self.latest_data_strategy = latest_data_strategy
        self.query_caching = query_caching
        self.formulae_visibility = formulae_visibility
        self.min_alert_frequency = min_alert_frequency
        self.min_alert_time_frame = min_alert_time_frame
        self.default_parameters = default_parameters
        self.default_facet_splits = default_facet_splits
        self.default_facet_compare = default_facet_compare
        self.custom_facet_compares = custom_facet_compares
        self.require_group_filters = require_group_filters
        self.allow_filter_combine = allow_filter_combine
        self.group_filters = group_filters
        self.user_filters = user_filters


class DashboardDescription(_serialization.Model):
    """Object containing the properties of the dashboard to embed.

    All required parameters must be populated in order to send to server.

    :ivar dashboard: Dashboard ID. Required.
    :vartype dashboard: str
    :ivar filter_clauses: Filter to apply to a query.
    :vartype filter_clauses: ~polaris.sdk.global_api.models.Filter
    """

    _validation = {
        "dashboard": {"required": True},
    }

    _attribute_map = {
        "dashboard": {"key": "dashboard", "type": "str"},
        "filter_clauses": {"key": "filterClauses", "type": "Filter"},
    }

    def __init__(
        self,
        *,
        dashboard: str,
        filter_clauses: Optional["_models.Filter"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword dashboard: Dashboard ID. Required.
        :paramtype dashboard: str
        :keyword filter_clauses: Filter to apply to a query.
        :paramtype filter_clauses: ~polaris.sdk.global_api.models.Filter
        """
        super().__init__(**kwargs)
        self.dashboard = dashboard
        self.filter_clauses = filter_clauses


class DashboardFilter(_serialization.Model):
    """A default filter to apply to a dashboard.

    All required parameters must be populated in order to send to server.

    :ivar id: Asset ID. Required.
    :vartype id: str
    :ivar dimension: ID of the dimension to filter on. Polaris filters any tile whose associated
     data cube
     has a matching dimension. Required.
    :vartype dimension: str
    :ivar is_separate: Filter is always visible in the Dashboard filter bar.
    :vartype is_separate: bool
    :ivar is_mandatory: Filter must have a selection.
    :vartype is_mandatory: bool
    :ivar has_default_values: Filter defines default values if the user doesn't make a selection.
    :vartype has_default_values: bool
    :ivar default_values: Filter clause to apply to a query.
    :vartype default_values: ~polaris.sdk.global_api.models.FilterClause
    """

    _validation = {
        "id": {"required": True, "max_length": 255, "min_length": 1},
        "dimension": {"required": True, "max_length": 255, "min_length": 1},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "str"},
        "dimension": {"key": "dimension", "type": "str"},
        "is_separate": {"key": "isSeparate", "type": "bool"},
        "is_mandatory": {"key": "isMandatory", "type": "bool"},
        "has_default_values": {"key": "hasDefaultValues", "type": "bool"},
        "default_values": {"key": "defaultValues", "type": "FilterClause"},
    }

    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        dimension: str,
        is_separate: bool = True,
        is_mandatory: bool = False,
        has_default_values: bool = False,
        default_values: Optional["_models.FilterClause"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword id: Asset ID. Required.
        :paramtype id: str
        :keyword dimension: ID of the dimension to filter on. Polaris filters any tile whose associated
         data cube
         has a matching dimension. Required.
        :paramtype dimension: str
        :keyword is_separate: Filter is always visible in the Dashboard filter bar.
        :paramtype is_separate: bool
        :keyword is_mandatory: Filter must have a selection.
        :paramtype is_mandatory: bool
        :keyword has_default_values: Filter defines default values if the user doesn't make a
         selection.
        :paramtype has_default_values: bool
        :keyword default_values: Filter clause to apply to a query.
        :paramtype default_values: ~polaris.sdk.global_api.models.FilterClause
        """
        super().__init__(**kwargs)
        self.id = id
        self.dimension = dimension
        self.is_separate = is_separate
        self.is_mandatory = is_mandatory
        self.has_default_values = has_default_values
        self.default_values = default_values


class DashboardListResponse(_serialization.Model):
    """Array of dashboards.

    All required parameters must be populated in order to send to server.

    :ivar values: Array of dashboards. Required.
    :vartype values: list[~polaris.sdk.global_api.models.DashboardListResponseValuesItem]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[DashboardListResponseValuesItem]"},
    }

    def __init__(
        self, *, values: List["_models.DashboardListResponseValuesItem"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Array of dashboards. Required.
        :paramtype values: list[~polaris.sdk.global_api.models.DashboardListResponseValuesItem]
        """
        super().__init__(**kwargs)
        self.values = values


class DashboardSummaryPayload(_serialization.Model):
    """Dashboard summary.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID. Required.
    :vartype id: str
    :ivar type: Dashboard type - always "dashboard2". Known values are: "classic" and "dashboard2".
    :vartype type: str or ~polaris.sdk.global_api.models.DashboardType
    :ivar title: Dashboard title to display in the Polaris UI. Required.
    :vartype title: str
    :ivar description: Dashboard description.
    :vartype description: str
    :ivar summaries: Summarized information about the dashboard pages, tiles, and their associated
     data cubes. Required.
    :vartype summaries: list[str]
    :ivar page_count: Number of pages in the dashboard. Required.
    :vartype page_count: int
    :ivar tile_count: Number of tiles across all pages in the dashboard. Required.
    :vartype tile_count: int
    :ivar default_filter_count: Number of default filters defined on the dashboard. Required.
    :vartype default_filter_count: int
    :ivar data_cube_ids: IDs of the data cubes used by the dashboard. Required.
    :vartype data_cube_ids: list[str]
    :ivar palette: Color palette for the Polaris UI. Use the 6-character hex format for all colors.
    :vartype palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar read_access: List of users with read access to the dashboard.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar modify_access: List of users who can modify the dashboard.
    :vartype modify_access: ~polaris.sdk.global_api.models.AccessList
    """

    _validation = {
        "id": {"required": True, "max_length": 255, "min_length": 1},
        "type": {"required": True},
        "title": {"required": True},
        "summaries": {"required": True},
        "page_count": {"required": True},
        "tile_count": {"required": True},
        "default_filter_count": {"required": True},
        "data_cube_ids": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "summaries": {"key": "summaries", "type": "[str]"},
        "page_count": {"key": "pageCount", "type": "int"},
        "tile_count": {"key": "tileCount", "type": "int"},
        "default_filter_count": {"key": "defaultFilterCount", "type": "int"},
        "data_cube_ids": {"key": "dataCubeIds", "type": "[str]"},
        "palette": {"key": "palette", "type": "AppColorPalette"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "modify_access": {"key": "modifyAccess", "type": "AccessList"},
    }

    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        type: Union[str, "_models.DashboardType"] = "dashboard2",
        title: str,
        summaries: List[str],
        page_count: int,
        tile_count: int,
        default_filter_count: int,
        data_cube_ids: List[str],
        additional_properties: Optional[Dict[str, Any]] = None,
        description: Optional[str] = None,
        palette: Optional["_models.AppColorPalette"] = None,
        read_access: Optional["_models.AccessList"] = None,
        modify_access: Optional["_models.AccessList"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID. Required.
        :paramtype id: str
        :keyword type: Dashboard type - always "dashboard2". Known values are: "classic" and
         "dashboard2".
        :paramtype type: str or ~polaris.sdk.global_api.models.DashboardType
        :keyword title: Dashboard title to display in the Polaris UI. Required.
        :paramtype title: str
        :keyword description: Dashboard description.
        :paramtype description: str
        :keyword summaries: Summarized information about the dashboard pages, tiles, and their
         associated data cubes. Required.
        :paramtype summaries: list[str]
        :keyword page_count: Number of pages in the dashboard. Required.
        :paramtype page_count: int
        :keyword tile_count: Number of tiles across all pages in the dashboard. Required.
        :paramtype tile_count: int
        :keyword default_filter_count: Number of default filters defined on the dashboard. Required.
        :paramtype default_filter_count: int
        :keyword data_cube_ids: IDs of the data cubes used by the dashboard. Required.
        :paramtype data_cube_ids: list[str]
        :keyword palette: Color palette for the Polaris UI. Use the 6-character hex format for all
         colors.
        :paramtype palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword read_access: List of users with read access to the dashboard.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword modify_access: List of users who can modify the dashboard.
        :paramtype modify_access: ~polaris.sdk.global_api.models.AccessList
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.summaries = summaries
        self.page_count = page_count
        self.tile_count = tile_count
        self.default_filter_count = default_filter_count
        self.data_cube_ids = data_cube_ids
        self.palette = palette
        self.read_access = read_access
        self.modify_access = modify_access


class DashboardListResponseValuesItem(AuditRecord, DashboardSummaryPayload):
    """DashboardListResponseValuesItem.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID. Required.
    :vartype id: str
    :ivar type: Dashboard type - always "dashboard2". Known values are: "classic" and "dashboard2".
    :vartype type: str or ~polaris.sdk.global_api.models.DashboardType
    :ivar title: Dashboard title to display in the Polaris UI. Required.
    :vartype title: str
    :ivar description: Dashboard description.
    :vartype description: str
    :ivar summaries: Summarized information about the dashboard pages, tiles, and their associated
     data cubes. Required.
    :vartype summaries: list[str]
    :ivar page_count: Number of pages in the dashboard. Required.
    :vartype page_count: int
    :ivar tile_count: Number of tiles across all pages in the dashboard. Required.
    :vartype tile_count: int
    :ivar default_filter_count: Number of default filters defined on the dashboard. Required.
    :vartype default_filter_count: int
    :ivar data_cube_ids: IDs of the data cubes used by the dashboard. Required.
    :vartype data_cube_ids: list[str]
    :ivar palette: Color palette for the Polaris UI. Use the 6-character hex format for all colors.
    :vartype palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar read_access: List of users with read access to the dashboard.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar modify_access: List of users who can modify the dashboard.
    :vartype modify_access: ~polaris.sdk.global_api.models.AccessList
    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    """

    _validation = {
        "id": {"required": True, "max_length": 255, "min_length": 1},
        "type": {"required": True},
        "title": {"required": True},
        "summaries": {"required": True},
        "page_count": {"required": True},
        "tile_count": {"required": True},
        "default_filter_count": {"required": True},
        "data_cube_ids": {"required": True},
        "created_at": {"required": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "summaries": {"key": "summaries", "type": "[str]"},
        "page_count": {"key": "pageCount", "type": "int"},
        "tile_count": {"key": "tileCount", "type": "int"},
        "default_filter_count": {"key": "defaultFilterCount", "type": "int"},
        "data_cube_ids": {"key": "dataCubeIds", "type": "[str]"},
        "palette": {"key": "palette", "type": "AppColorPalette"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "modify_access": {"key": "modifyAccess", "type": "AccessList"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        type: Union[str, "_models.DashboardType"] = "dashboard2",
        title: str,
        summaries: List[str],
        page_count: int,
        tile_count: int,
        default_filter_count: int,
        data_cube_ids: List[str],
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        additional_properties: Optional[Dict[str, Any]] = None,
        description: Optional[str] = None,
        palette: Optional["_models.AppColorPalette"] = None,
        read_access: Optional["_models.AccessList"] = None,
        modify_access: Optional["_models.AccessList"] = None,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID. Required.
        :paramtype id: str
        :keyword type: Dashboard type - always "dashboard2". Known values are: "classic" and
         "dashboard2".
        :paramtype type: str or ~polaris.sdk.global_api.models.DashboardType
        :keyword title: Dashboard title to display in the Polaris UI. Required.
        :paramtype title: str
        :keyword description: Dashboard description.
        :paramtype description: str
        :keyword summaries: Summarized information about the dashboard pages, tiles, and their
         associated data cubes. Required.
        :paramtype summaries: list[str]
        :keyword page_count: Number of pages in the dashboard. Required.
        :paramtype page_count: int
        :keyword tile_count: Number of tiles across all pages in the dashboard. Required.
        :paramtype tile_count: int
        :keyword default_filter_count: Number of default filters defined on the dashboard. Required.
        :paramtype default_filter_count: int
        :keyword data_cube_ids: IDs of the data cubes used by the dashboard. Required.
        :paramtype data_cube_ids: list[str]
        :keyword palette: Color palette for the Polaris UI. Use the 6-character hex format for all
         colors.
        :paramtype palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword read_access: List of users with read access to the dashboard.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword modify_access: List of users who can modify the dashboard.
        :paramtype modify_access: ~polaris.sdk.global_api.models.AccessList
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        """
        super().__init__(
            created_at=created_at,
            created_by=created_by,
            updated_at=updated_at,
            updated_by=updated_by,
            additional_properties=additional_properties,
            id=id,
            type=type,
            title=title,
            description=description,
            summaries=summaries,
            page_count=page_count,
            tile_count=tile_count,
            default_filter_count=default_filter_count,
            data_cube_ids=data_cube_ids,
            palette=palette,
            read_access=read_access,
            modify_access=modify_access,
            **kwargs
        )
        self.additional_properties = additional_properties
        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.summaries = summaries
        self.page_count = page_count
        self.tile_count = tile_count
        self.default_filter_count = default_filter_count
        self.data_cube_ids = data_cube_ids
        self.palette = palette
        self.read_access = read_access
        self.modify_access = modify_access
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by


class PagePayload(_serialization.Model):
    """Page of tiles within a dashboard.

    :ivar id: Asset ID.
    :vartype id: str
    :ivar label: Page label to display in the Polaris UI.
    :vartype label: str
    :ivar tiles: Dashboard page tiles.
    :vartype tiles: list[~polaris.sdk.global_api.models.PagePayloadTilesItem]
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "tiles": {"key": "tiles", "type": "[PagePayloadTilesItem]"},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        label: Optional[str] = None,
        tiles: Optional[List["_models.PagePayloadTilesItem"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword label: Page label to display in the Polaris UI.
        :paramtype label: str
        :keyword tiles: Dashboard page tiles.
        :paramtype tiles: list[~polaris.sdk.global_api.models.PagePayloadTilesItem]
        """
        super().__init__(**kwargs)
        self.id = id
        self.label = label
        self.tiles = tiles


class DashboardPayloadPagesItem(PagePayload):
    """DashboardPayloadPagesItem.

    :ivar id: Asset ID.
    :vartype id: str
    :ivar label: Page label to display in the Polaris UI.
    :vartype label: str
    :ivar tiles: Dashboard page tiles.
    :vartype tiles: list[~polaris.sdk.global_api.models.PagePayloadTilesItem]
    """


class DashboardResponse(AuditRecord, DashboardPayload):
    """DashboardResponse.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar type: Dashboard type - always "dashboard2". Known values are: "classic" and "dashboard2".
    :vartype type: str or ~polaris.sdk.global_api.models.DashboardType
    :ivar title: Dashboard title to display in the Polaris UI.
    :vartype title: str
    :ivar description: Dashboard description.
    :vartype description: str
    :ivar palette: Color palette for the Polaris UI. Use the 6-character hex format for all colors.
    :vartype palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar read_access: Access control list for read access to the dashboard.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar modify_access: Access control list for modifying the dashboard.
    :vartype modify_access: ~polaris.sdk.global_api.models.AccessList
    :ivar pages: Array of dashboard pages.
    :vartype pages: list[~polaris.sdk.global_api.models.DashboardPayloadPagesItem]
    :ivar default_filters: Default filters to apply to the dashboard.
    :vartype default_filters: list[~polaris.sdk.global_api.models.DashboardFilter]
    :ivar enforce_time_filter: Ensure that every query is filtered on the primary time dimension.
    :vartype enforce_time_filter: bool
    :ivar filter_tile: Enable visibility of global filters. Known values are: "show" and "hide".
    :vartype filter_tile: str or ~polaris.sdk.global_api.models.ShowHide
    :ivar pages_tile: Enable visibility of page selector. Known values are: "show" and "hide".
    :vartype pages_tile: str or ~polaris.sdk.global_api.models.ShowHide
    :ivar pages_color_summary: Show status indicator according to tile formatting. Only applicable
     if ``pagesTile`` is set to ``show``. Known values are: "show" and "hide".
    :vartype pages_color_summary: str or ~polaris.sdk.global_api.models.ShowHide
    :ivar has_global_compare: Enable global comparisons.
    :vartype has_global_compare: bool
    :ivar default_compare: Default comparison to apply to the dashboard.
    :vartype default_compare: ~polaris.sdk.global_api.models.DashboardCompare
    :ivar has_global_measures: Enable global measures.
    :vartype has_global_measures: bool
    :ivar default_measures: IDs of default measures to apply to the dashboard.
    :vartype default_measures: list[str]
    :ivar filter_query_default_duration: Default time period used for filter queries, expressed as
     an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype filter_query_default_duration: ~datetime.timedelta
    :ivar default_refresh_rate: Default refresh rate for the dashboard, expressed as an `ISO 8601
     Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_refresh_rate: ~datetime.timedelta
    :ivar min_auto_refresh_rate: The rate under which this dashboard won't refresh,  expressed as
     an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_auto_refresh_rate: ~datetime.timedelta
    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
        "created_at": {"required": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "palette": {"key": "palette", "type": "AppColorPalette"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "modify_access": {"key": "modifyAccess", "type": "AccessList"},
        "pages": {"key": "pages", "type": "[DashboardPayloadPagesItem]"},
        "default_filters": {"key": "defaultFilters", "type": "[DashboardFilter]"},
        "enforce_time_filter": {"key": "enforceTimeFilter", "type": "bool"},
        "filter_tile": {"key": "filterTile", "type": "str"},
        "pages_tile": {"key": "pagesTile", "type": "str"},
        "pages_color_summary": {"key": "pagesColorSummary", "type": "str"},
        "has_global_compare": {"key": "hasGlobalCompare", "type": "bool"},
        "default_compare": {"key": "defaultCompare", "type": "DashboardCompare"},
        "has_global_measures": {"key": "hasGlobalMeasures", "type": "bool"},
        "default_measures": {"key": "defaultMeasures", "type": "[str]"},
        "filter_query_default_duration": {
            "key": "filterQueryDefaultDuration",
            "type": "duration",
        },
        "default_refresh_rate": {"key": "defaultRefreshRate", "type": "duration"},
        "min_auto_refresh_rate": {"key": "minAutoRefreshRate", "type": "duration"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        type: Union[str, "_models.DashboardType"] = "dashboard2",
        title: Optional[str] = None,
        description: Optional[str] = None,
        palette: Optional["_models.AppColorPalette"] = None,
        read_access: Optional["_models.AccessList"] = None,
        modify_access: Optional["_models.AccessList"] = None,
        pages: Optional[List["_models.DashboardPayloadPagesItem"]] = None,
        default_filters: Optional[List["_models.DashboardFilter"]] = None,
        enforce_time_filter: bool = False,
        filter_tile: Optional[Union[str, "_models.ShowHide"]] = None,
        pages_tile: Optional[Union[str, "_models.ShowHide"]] = None,
        pages_color_summary: Optional[Union[str, "_models.ShowHide"]] = None,
        has_global_compare: bool = False,
        default_compare: Optional["_models.DashboardCompare"] = None,
        has_global_measures: bool = False,
        default_measures: Optional[List[str]] = None,
        filter_query_default_duration: datetime.timedelta = "P1D",
        default_refresh_rate: Optional[datetime.timedelta] = None,
        min_auto_refresh_rate: Optional[datetime.timedelta] = None,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword type: Dashboard type - always "dashboard2". Known values are: "classic" and
         "dashboard2".
        :paramtype type: str or ~polaris.sdk.global_api.models.DashboardType
        :keyword title: Dashboard title to display in the Polaris UI.
        :paramtype title: str
        :keyword description: Dashboard description.
        :paramtype description: str
        :keyword palette: Color palette for the Polaris UI. Use the 6-character hex format for all
         colors.
        :paramtype palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword read_access: Access control list for read access to the dashboard.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword modify_access: Access control list for modifying the dashboard.
        :paramtype modify_access: ~polaris.sdk.global_api.models.AccessList
        :keyword pages: Array of dashboard pages.
        :paramtype pages: list[~polaris.sdk.global_api.models.DashboardPayloadPagesItem]
        :keyword default_filters: Default filters to apply to the dashboard.
        :paramtype default_filters: list[~polaris.sdk.global_api.models.DashboardFilter]
        :keyword enforce_time_filter: Ensure that every query is filtered on the primary time
         dimension.
        :paramtype enforce_time_filter: bool
        :keyword filter_tile: Enable visibility of global filters. Known values are: "show" and "hide".
        :paramtype filter_tile: str or ~polaris.sdk.global_api.models.ShowHide
        :keyword pages_tile: Enable visibility of page selector. Known values are: "show" and "hide".
        :paramtype pages_tile: str or ~polaris.sdk.global_api.models.ShowHide
        :keyword pages_color_summary: Show status indicator according to tile formatting. Only
         applicable if ``pagesTile`` is set to ``show``. Known values are: "show" and "hide".
        :paramtype pages_color_summary: str or ~polaris.sdk.global_api.models.ShowHide
        :keyword has_global_compare: Enable global comparisons.
        :paramtype has_global_compare: bool
        :keyword default_compare: Default comparison to apply to the dashboard.
        :paramtype default_compare: ~polaris.sdk.global_api.models.DashboardCompare
        :keyword has_global_measures: Enable global measures.
        :paramtype has_global_measures: bool
        :keyword default_measures: IDs of default measures to apply to the dashboard.
        :paramtype default_measures: list[str]
        :keyword filter_query_default_duration: Default time period used for filter queries, expressed
         as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype filter_query_default_duration: ~datetime.timedelta
        :keyword default_refresh_rate: Default refresh rate for the dashboard, expressed as an `ISO
         8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype default_refresh_rate: ~datetime.timedelta
        :keyword min_auto_refresh_rate: The rate under which this dashboard won't refresh,  expressed
         as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_auto_refresh_rate: ~datetime.timedelta
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        """
        super().__init__(
            created_at=created_at,
            created_by=created_by,
            updated_at=updated_at,
            updated_by=updated_by,
            additional_properties=additional_properties,
            id=id,
            type=type,
            title=title,
            description=description,
            palette=palette,
            read_access=read_access,
            modify_access=modify_access,
            pages=pages,
            default_filters=default_filters,
            enforce_time_filter=enforce_time_filter,
            filter_tile=filter_tile,
            pages_tile=pages_tile,
            pages_color_summary=pages_color_summary,
            has_global_compare=has_global_compare,
            default_compare=default_compare,
            has_global_measures=has_global_measures,
            default_measures=default_measures,
            filter_query_default_duration=filter_query_default_duration,
            default_refresh_rate=default_refresh_rate,
            min_auto_refresh_rate=min_auto_refresh_rate,
            **kwargs
        )
        self.additional_properties = additional_properties
        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.palette = palette
        self.read_access = read_access
        self.modify_access = modify_access
        self.pages = pages
        self.default_filters = default_filters
        self.enforce_time_filter = enforce_time_filter
        self.filter_tile = filter_tile
        self.pages_tile = pages_tile
        self.pages_color_summary = pages_color_summary
        self.has_global_compare = has_global_compare
        self.default_compare = default_compare
        self.has_global_measures = has_global_measures
        self.default_measures = default_measures
        self.filter_query_default_duration = filter_query_default_duration
        self.default_refresh_rate = default_refresh_rate
        self.min_auto_refresh_rate = min_auto_refresh_rate
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by


class DataCubeBody(DataCubePayload):
    """DataCubeBody.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar title: Data cube title.
    :vartype title: str
    :ivar description: Data cube description.
    :vartype description: str
    :ivar query_mode: Data cube query mode. Known values are: "sql" and "plywood".
    :vartype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
    :ivar source: Data cube source.
    :vartype source: ~polaris.sdk.global_api.models.DataCubeSource
    :ivar palette: Color palette for the Polaris UI. Use the 6-character hex format for all colors.
    :vartype palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar min_auto_refresh_rate: Minimum auto refresh rate for the data cube, expressed as an `ISO
     8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_auto_refresh_rate: ~datetime.timedelta
    :ivar latest_time_filter_granularity: When using a relative time filter, Polaris uses this
     level of granularity to align the
     filter boundaries when querying the underlying table, expressed as an `ISO 8601 Duration
     <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
     For an aggregate table, set to the same granularity used during ingestion or leave unset for
     Polaris to infer
     an appropriate value from the data. For a detail table, leave unset.
    :vartype latest_time_filter_granularity: ~datetime.timedelta
    :ivar subset_formula: Row level filter to apply to the data cube. This filter is never shown in
     the cube view
     and effectively constrains the data cube to only the events that match this filter.
    :vartype subset_formula: str
    :ivar filter_token: Only allow users with the given filter token to access this data cube.
    :vartype filter_token: str
    :ivar rollup: Whether the associated table has rollup enabled.
    :vartype rollup: bool
    :ivar options: Data cube options.
    :vartype options: ~polaris.sdk.global_api.models.DataCubeOptions
    :ivar read_access: Access control list for read access to the data cube.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar restricted_edit_access: In some cases, you may need to limit a user's ability to edit
     aspects of a data cube;
     for example, to allow a user to modify dimensions but not to change the title or description.
    :vartype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
    :ivar modify_access: Access control list for modifying this data cube.
    :vartype modify_access: ~polaris.sdk.global_api.models.AccessList
    :ivar download_access: Access control list for downloading raw data from this data cube.
    :vartype download_access: ~polaris.sdk.global_api.models.AccessList
    :ivar attributes: Column metadata for the associated data source.
    :vartype attributes: list[~polaris.sdk.global_api.models.Attribute]
    :ivar dimensions: The dimensions of the data cube.
    :vartype dimensions: list[~polaris.sdk.global_api.models.DimensionPayload]
    :ivar measures: Array of data cube measures.
    :vartype measures: list[~polaris.sdk.global_api.models.MeasurePayload]
    :ivar instances: Data cube instances.
    :vartype instances: ~polaris.sdk.global_api.models.DataCubeInstanceList
    :ivar special_time_dimension: Time dimension Polaris uses for all time-related calculations for
     the data cube, including comparisons, filters, alerts, and reports.
     Polarise uses this to check the freshness of data and apply time filters.
    :vartype special_time_dimension: str
    :ivar enforce_time_filter: Ensures that every query is filtered on the primary time dimension.
     You can enable this setting if time unbounded queries are likely to be slow due to the volume
     of data.
    :vartype enforce_time_filter: bool
    :ivar default_filter: Default filter to apply when visualizing the data cube.
    :vartype default_filter: ~polaris.sdk.global_api.models.Filter
    :ivar default_timezone: Time zone to select when a user first opens the data cube, expressed as
     an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype default_timezone: str
    :ivar default_duration: Time period to display when a user first opens the data cube,
     expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_duration: ~datetime.timedelta
    :ivar default_selected_measures: IDs of the measures to show by default in visualizations.
    :vartype default_selected_measures: list[str]
    :ivar default_pinned_dimensions: IDs of the dimensions to pin by default in visualizations.
    :vartype default_pinned_dimensions: list[str]
    :ivar default_refresh_rate: The default refresh rate for the data cube, expressed as an `ISO
     8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_refresh_rate: ~datetime.timedelta
    :ivar default_visualization: Name of the default visualization to use when initially viewing
     the data cube.
    :vartype default_visualization: str
    :ivar default_having_filter: The default HAVING filter for the data cube.
    :vartype default_having_filter: ~polaris.sdk.global_api.models.HavingFilter
    :ivar latest_data_strategy: Determines how Polaris calculates the latest data time for the data
     cube.
     By default, Polaris queries the data source for the latest time stamp on ingested data.
     You can set this property to always use the current time, which may be more appropriate for
     streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
    :vartype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
    :ivar query_caching: Allow caching on queries made to this data cube. Caching can greatly speed
     up exploration but can
     also cause results to be a little out of date especially in realtime rolled up datasets. Known
     values are: "allow" and "disable".
    :vartype query_caching: str or ~polaris.sdk.global_api.models.DataCubePayloadQueryCaching
    :ivar formulae_visibility: Hide or show dimension and measure formulae in info modals. Polaris
     displays formulae are by default. Users
     with appropriate permissions can still see formulae when editing. Known values are: "show" and
     "hide".
    :vartype formulae_visibility: str or ~polaris.sdk.global_api.models.Visibility
    :ivar min_alert_frequency: Minimum allowable frequency for alerts associated with this data
     cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_alert_frequency: ~datetime.timedelta
    :ivar min_alert_time_frame: Minimum allowable time frame for alerts associated with this data
     cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_alert_time_frame: ~datetime.timedelta
    :ivar default_parameters: The default parameters to populate an Explore visualization.
    :vartype default_parameters: str
    :ivar default_facet_splits: Default dimensions to split on.
    :vartype default_facet_splits: list[any]
    :ivar default_facet_compare: Default comparison for the data cube.
    :vartype default_facet_compare: ~polaris.sdk.global_api.models.FacetCompare
    :ivar custom_facet_compares: Customized comparisons for the data cube.
    :vartype custom_facet_compares: list[~polaris.sdk.global_api.models.FacetCompare]
    :ivar require_group_filters: Enable this property to use access filters. When enabled, users
     who aren't assigned an access
     filter can't perform queries.
    :vartype require_group_filters: bool
    :ivar allow_filter_combine: Determines the behaviour when a user is a member of two or more
     user groups with access filters applied.
     If ``true``\\ , Polaris combines the filters with the OR operator.
     If ``false``\\ , the user can't view any data in the data cube.
    :vartype allow_filter_combine: bool
    :ivar group_filters: Defines access filters for a user group.
    :vartype group_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
    :ivar user_filters: Defines access filters for a Polaris API key.
    :vartype user_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
    """


class DataCubeDescription(_serialization.Model):
    """Object describing the data cube to embed."""


class DataCubeInstance(_serialization.Model):
    """Named instance of the data cube for the related dimension formula.

    All required parameters must be populated in order to send to server.

    :ivar title: Instance title. Required.
    :vartype title: str
    :ivar value: Instance value. Required.
    :vartype value: str
    """

    _validation = {
        "title": {"required": True},
        "value": {"required": True},
    }

    _attribute_map = {
        "title": {"key": "title", "type": "str"},
        "value": {"key": "value", "type": "str"},
    }

    def __init__(self, *, title: str, value: str, **kwargs: Any) -> None:
        """
        :keyword title: Instance title. Required.
        :paramtype title: str
        :keyword value: Instance value. Required.
        :paramtype value: str
        """
        super().__init__(**kwargs)
        self.title = title
        self.value = value


class DataCubeInstanceList(_serialization.Model):
    """Data cube instances.

    All required parameters must be populated in order to send to server.

    :ivar dimension_formula: Formula for the dimension that defines the instances. Required.
    :vartype dimension_formula: str
    :ivar values: All instances values. Required.
    :vartype values: list[any]
    """

    _validation = {
        "dimension_formula": {"required": True},
        "values": {"required": True},
    }

    _attribute_map = {
        "dimension_formula": {"key": "dimensionFormula", "type": "str"},
        "values": {"key": "values", "type": "[object]"},
    }

    def __init__(
        self, *, dimension_formula: str, values: List[Any], **kwargs: Any
    ) -> None:
        """
        :keyword dimension_formula: Formula for the dimension that defines the instances. Required.
        :paramtype dimension_formula: str
        :keyword values: All instances values. Required.
        :paramtype values: list[any]
        """
        super().__init__(**kwargs)
        self.dimension_formula = dimension_formula
        self.values = values


class DataCubeListResponse(_serialization.Model):
    """A list of data cube details.

    All required parameters must be populated in order to send to server.

    :ivar values: Array of data cube details. Required.
    :vartype values: list[~polaris.sdk.global_api.models.DataCubeListResponseValuesItem]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[DataCubeListResponseValuesItem]"},
    }

    def __init__(
        self, *, values: List["_models.DataCubeListResponseValuesItem"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Array of data cube details. Required.
        :paramtype values: list[~polaris.sdk.global_api.models.DataCubeListResponseValuesItem]
        """
        super().__init__(**kwargs)
        self.values = values


class DataCubeSummaryPayload(_serialization.Model):
    """A data cube summary.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID. Required.
    :vartype id: str
    :ivar title: Data cube title to display in the Polaris UI. Required.
    :vartype title: str
    :ivar description: Data cube description.
    :vartype description: str
    :ivar query_mode: Data cube query mode. Required. Known values are: "sql" and "plywood".
    :vartype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
    :ivar source: Data cube source. Required.
    :vartype source: str
    :ivar source_type: Data cube source type. Required. Known values are: "direct" and "query".
    :vartype source_type: str or ~polaris.sdk.global_api.models.DataCubeSourceType
    :ivar source_value: Table name or query for the data cube source.
    :vartype source_value: str
    :ivar palette: Color palette for the Polaris UI. Use the 6-character hex format for all colors.
    :vartype palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar rollup: Whether the source table has rollup enabled.
    :vartype rollup: bool
    :ivar read_access: Access control list for read access to the data cube.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar restricted_edit_access: In some cases, you may need to limit a user's ability to edit
     aspects of a data cube.
     For example, to allow a user to modify dimensions but not to the data cube title or
     description.
    :vartype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
    :ivar modify_access: Access control list for modifying the data cube.
    :vartype modify_access: ~polaris.sdk.global_api.models.AccessList
    :ivar download_access: Access control list for downloading raw data from the data cube.
    :vartype download_access: ~polaris.sdk.global_api.models.AccessList
    :ivar dimension_count: Number of dimensions in the data cube.
    :vartype dimension_count: int
    :ivar measure_count: Number of measures in the data cube.
    :vartype measure_count: int
    :ivar latest_data_strategy: Determines how Polaris calculates the latest data time for the data
     cube.
     By default, Polaris queries the data source for the latest time stamp on ingested data.
     You can set this property to always use the current time, which may be more appropriate for
     streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
    :vartype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
    :ivar fixed_max_time: Latest data time for the data cubes with "predefined" latest data
     strategy.
    :vartype fixed_max_time: ~datetime.datetime
    :ivar special_time_dimension: Time dimension that corresponds to when the data point was added.
     Polaris uses this to check the freshness of data and apply time filters.
    :vartype special_time_dimension: str
    :ivar default_refresh_rate: Default refresh rate for the data cube, expressed as an `ISO 8601
     Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_refresh_rate: ~datetime.timedelta
    :ivar default_timezone: Timezone to apply when the user first opens the data cube, expressed as
     an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype default_timezone: str
    """

    _validation = {
        "id": {"required": True, "max_length": 255, "min_length": 1},
        "title": {"required": True},
        "query_mode": {"required": True},
        "source": {"required": True},
        "source_type": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "query_mode": {"key": "queryMode", "type": "str"},
        "source": {"key": "source", "type": "str"},
        "source_type": {"key": "sourceType", "type": "str"},
        "source_value": {"key": "sourceValue", "type": "str"},
        "palette": {"key": "palette", "type": "AppColorPalette"},
        "rollup": {"key": "rollup", "type": "bool"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "restricted_edit_access": {"key": "restrictedEditAccess", "type": "AccessList"},
        "modify_access": {"key": "modifyAccess", "type": "AccessList"},
        "download_access": {"key": "downloadAccess", "type": "AccessList"},
        "dimension_count": {"key": "dimensionCount", "type": "int"},
        "measure_count": {"key": "measureCount", "type": "int"},
        "latest_data_strategy": {"key": "latestDataStrategy", "type": "str"},
        "fixed_max_time": {"key": "fixedMaxTime", "type": "iso-8601"},
        "special_time_dimension": {"key": "specialTimeDimension", "type": "str"},
        "default_refresh_rate": {"key": "defaultRefreshRate", "type": "duration"},
        "default_timezone": {"key": "defaultTimezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        title: str,
        query_mode: Union[str, "_models.QueryMode"],
        source: str,
        source_type: Union[str, "_models.DataCubeSourceType"],
        additional_properties: Optional[Dict[str, Any]] = None,
        description: Optional[str] = None,
        source_value: Optional[str] = None,
        palette: Optional["_models.AppColorPalette"] = None,
        rollup: Optional[bool] = None,
        read_access: Optional["_models.AccessList"] = None,
        restricted_edit_access: Optional["_models.AccessList"] = None,
        modify_access: Optional["_models.AccessList"] = None,
        download_access: Optional["_models.AccessList"] = None,
        dimension_count: Optional[int] = None,
        measure_count: Optional[int] = None,
        latest_data_strategy: Optional[Union[str, "_models.LatestDataStrategy"]] = None,
        fixed_max_time: Optional[datetime.datetime] = None,
        special_time_dimension: Optional[str] = None,
        default_refresh_rate: Optional[datetime.timedelta] = None,
        default_timezone: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID. Required.
        :paramtype id: str
        :keyword title: Data cube title to display in the Polaris UI. Required.
        :paramtype title: str
        :keyword description: Data cube description.
        :paramtype description: str
        :keyword query_mode: Data cube query mode. Required. Known values are: "sql" and "plywood".
        :paramtype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
        :keyword source: Data cube source. Required.
        :paramtype source: str
        :keyword source_type: Data cube source type. Required. Known values are: "direct" and "query".
        :paramtype source_type: str or ~polaris.sdk.global_api.models.DataCubeSourceType
        :keyword source_value: Table name or query for the data cube source.
        :paramtype source_value: str
        :keyword palette: Color palette for the Polaris UI. Use the 6-character hex format for all
         colors.
        :paramtype palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword rollup: Whether the source table has rollup enabled.
        :paramtype rollup: bool
        :keyword read_access: Access control list for read access to the data cube.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword restricted_edit_access: In some cases, you may need to limit a user's ability to edit
         aspects of a data cube.
         For example, to allow a user to modify dimensions but not to the data cube title or
         description.
        :paramtype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
        :keyword modify_access: Access control list for modifying the data cube.
        :paramtype modify_access: ~polaris.sdk.global_api.models.AccessList
        :keyword download_access: Access control list for downloading raw data from the data cube.
        :paramtype download_access: ~polaris.sdk.global_api.models.AccessList
        :keyword dimension_count: Number of dimensions in the data cube.
        :paramtype dimension_count: int
        :keyword measure_count: Number of measures in the data cube.
        :paramtype measure_count: int
        :keyword latest_data_strategy: Determines how Polaris calculates the latest data time for the
         data cube.
         By default, Polaris queries the data source for the latest time stamp on ingested data.
         You can set this property to always use the current time, which may be more appropriate for
         streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
        :paramtype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
        :keyword fixed_max_time: Latest data time for the data cubes with "predefined" latest data
         strategy.
        :paramtype fixed_max_time: ~datetime.datetime
        :keyword special_time_dimension: Time dimension that corresponds to when the data point was
         added.
         Polaris uses this to check the freshness of data and apply time filters.
        :paramtype special_time_dimension: str
        :keyword default_refresh_rate: Default refresh rate for the data cube, expressed as an `ISO
         8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype default_refresh_rate: ~datetime.timedelta
        :keyword default_timezone: Timezone to apply when the user first opens the data cube, expressed
         as an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype default_timezone: str
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.title = title
        self.description = description
        self.query_mode = query_mode
        self.source = source
        self.source_type = source_type
        self.source_value = source_value
        self.palette = palette
        self.rollup = rollup
        self.read_access = read_access
        self.restricted_edit_access = restricted_edit_access
        self.modify_access = modify_access
        self.download_access = download_access
        self.dimension_count = dimension_count
        self.measure_count = measure_count
        self.latest_data_strategy = latest_data_strategy
        self.fixed_max_time = fixed_max_time
        self.special_time_dimension = special_time_dimension
        self.default_refresh_rate = default_refresh_rate
        self.default_timezone = default_timezone


class DataCubeListResponseValuesItem(AuditRecord, DataCubeSummaryPayload):
    """DataCubeListResponseValuesItem.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID. Required.
    :vartype id: str
    :ivar title: Data cube title to display in the Polaris UI. Required.
    :vartype title: str
    :ivar description: Data cube description.
    :vartype description: str
    :ivar query_mode: Data cube query mode. Required. Known values are: "sql" and "plywood".
    :vartype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
    :ivar source: Data cube source. Required.
    :vartype source: str
    :ivar source_type: Data cube source type. Required. Known values are: "direct" and "query".
    :vartype source_type: str or ~polaris.sdk.global_api.models.DataCubeSourceType
    :ivar source_value: Table name or query for the data cube source.
    :vartype source_value: str
    :ivar palette: Color palette for the Polaris UI. Use the 6-character hex format for all colors.
    :vartype palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar rollup: Whether the source table has rollup enabled.
    :vartype rollup: bool
    :ivar read_access: Access control list for read access to the data cube.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar restricted_edit_access: In some cases, you may need to limit a user's ability to edit
     aspects of a data cube.
     For example, to allow a user to modify dimensions but not to the data cube title or
     description.
    :vartype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
    :ivar modify_access: Access control list for modifying the data cube.
    :vartype modify_access: ~polaris.sdk.global_api.models.AccessList
    :ivar download_access: Access control list for downloading raw data from the data cube.
    :vartype download_access: ~polaris.sdk.global_api.models.AccessList
    :ivar dimension_count: Number of dimensions in the data cube.
    :vartype dimension_count: int
    :ivar measure_count: Number of measures in the data cube.
    :vartype measure_count: int
    :ivar latest_data_strategy: Determines how Polaris calculates the latest data time for the data
     cube.
     By default, Polaris queries the data source for the latest time stamp on ingested data.
     You can set this property to always use the current time, which may be more appropriate for
     streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
    :vartype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
    :ivar fixed_max_time: Latest data time for the data cubes with "predefined" latest data
     strategy.
    :vartype fixed_max_time: ~datetime.datetime
    :ivar special_time_dimension: Time dimension that corresponds to when the data point was added.
     Polaris uses this to check the freshness of data and apply time filters.
    :vartype special_time_dimension: str
    :ivar default_refresh_rate: Default refresh rate for the data cube, expressed as an `ISO 8601
     Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_refresh_rate: ~datetime.timedelta
    :ivar default_timezone: Timezone to apply when the user first opens the data cube, expressed as
     an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype default_timezone: str
    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    """

    _validation = {
        "id": {"required": True, "max_length": 255, "min_length": 1},
        "title": {"required": True},
        "query_mode": {"required": True},
        "source": {"required": True},
        "source_type": {"required": True},
        "created_at": {"required": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "query_mode": {"key": "queryMode", "type": "str"},
        "source": {"key": "source", "type": "str"},
        "source_type": {"key": "sourceType", "type": "str"},
        "source_value": {"key": "sourceValue", "type": "str"},
        "palette": {"key": "palette", "type": "AppColorPalette"},
        "rollup": {"key": "rollup", "type": "bool"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "restricted_edit_access": {"key": "restrictedEditAccess", "type": "AccessList"},
        "modify_access": {"key": "modifyAccess", "type": "AccessList"},
        "download_access": {"key": "downloadAccess", "type": "AccessList"},
        "dimension_count": {"key": "dimensionCount", "type": "int"},
        "measure_count": {"key": "measureCount", "type": "int"},
        "latest_data_strategy": {"key": "latestDataStrategy", "type": "str"},
        "fixed_max_time": {"key": "fixedMaxTime", "type": "iso-8601"},
        "special_time_dimension": {"key": "specialTimeDimension", "type": "str"},
        "default_refresh_rate": {"key": "defaultRefreshRate", "type": "duration"},
        "default_timezone": {"key": "defaultTimezone", "type": "str"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        title: str,
        query_mode: Union[str, "_models.QueryMode"],
        source: str,
        source_type: Union[str, "_models.DataCubeSourceType"],
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        additional_properties: Optional[Dict[str, Any]] = None,
        description: Optional[str] = None,
        source_value: Optional[str] = None,
        palette: Optional["_models.AppColorPalette"] = None,
        rollup: Optional[bool] = None,
        read_access: Optional["_models.AccessList"] = None,
        restricted_edit_access: Optional["_models.AccessList"] = None,
        modify_access: Optional["_models.AccessList"] = None,
        download_access: Optional["_models.AccessList"] = None,
        dimension_count: Optional[int] = None,
        measure_count: Optional[int] = None,
        latest_data_strategy: Optional[Union[str, "_models.LatestDataStrategy"]] = None,
        fixed_max_time: Optional[datetime.datetime] = None,
        special_time_dimension: Optional[str] = None,
        default_refresh_rate: Optional[datetime.timedelta] = None,
        default_timezone: Optional[str] = None,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID. Required.
        :paramtype id: str
        :keyword title: Data cube title to display in the Polaris UI. Required.
        :paramtype title: str
        :keyword description: Data cube description.
        :paramtype description: str
        :keyword query_mode: Data cube query mode. Required. Known values are: "sql" and "plywood".
        :paramtype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
        :keyword source: Data cube source. Required.
        :paramtype source: str
        :keyword source_type: Data cube source type. Required. Known values are: "direct" and "query".
        :paramtype source_type: str or ~polaris.sdk.global_api.models.DataCubeSourceType
        :keyword source_value: Table name or query for the data cube source.
        :paramtype source_value: str
        :keyword palette: Color palette for the Polaris UI. Use the 6-character hex format for all
         colors.
        :paramtype palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword rollup: Whether the source table has rollup enabled.
        :paramtype rollup: bool
        :keyword read_access: Access control list for read access to the data cube.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword restricted_edit_access: In some cases, you may need to limit a user's ability to edit
         aspects of a data cube.
         For example, to allow a user to modify dimensions but not to the data cube title or
         description.
        :paramtype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
        :keyword modify_access: Access control list for modifying the data cube.
        :paramtype modify_access: ~polaris.sdk.global_api.models.AccessList
        :keyword download_access: Access control list for downloading raw data from the data cube.
        :paramtype download_access: ~polaris.sdk.global_api.models.AccessList
        :keyword dimension_count: Number of dimensions in the data cube.
        :paramtype dimension_count: int
        :keyword measure_count: Number of measures in the data cube.
        :paramtype measure_count: int
        :keyword latest_data_strategy: Determines how Polaris calculates the latest data time for the
         data cube.
         By default, Polaris queries the data source for the latest time stamp on ingested data.
         You can set this property to always use the current time, which may be more appropriate for
         streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
        :paramtype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
        :keyword fixed_max_time: Latest data time for the data cubes with "predefined" latest data
         strategy.
        :paramtype fixed_max_time: ~datetime.datetime
        :keyword special_time_dimension: Time dimension that corresponds to when the data point was
         added.
         Polaris uses this to check the freshness of data and apply time filters.
        :paramtype special_time_dimension: str
        :keyword default_refresh_rate: Default refresh rate for the data cube, expressed as an `ISO
         8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype default_refresh_rate: ~datetime.timedelta
        :keyword default_timezone: Timezone to apply when the user first opens the data cube, expressed
         as an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype default_timezone: str
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        """
        super().__init__(
            created_at=created_at,
            created_by=created_by,
            updated_at=updated_at,
            updated_by=updated_by,
            additional_properties=additional_properties,
            id=id,
            title=title,
            description=description,
            query_mode=query_mode,
            source=source,
            source_type=source_type,
            source_value=source_value,
            palette=palette,
            rollup=rollup,
            read_access=read_access,
            restricted_edit_access=restricted_edit_access,
            modify_access=modify_access,
            download_access=download_access,
            dimension_count=dimension_count,
            measure_count=measure_count,
            latest_data_strategy=latest_data_strategy,
            fixed_max_time=fixed_max_time,
            special_time_dimension=special_time_dimension,
            default_refresh_rate=default_refresh_rate,
            default_timezone=default_timezone,
            **kwargs
        )
        self.additional_properties = additional_properties
        self.id = id
        self.title = title
        self.description = description
        self.query_mode = query_mode
        self.source = source
        self.source_type = source_type
        self.source_value = source_value
        self.palette = palette
        self.rollup = rollup
        self.read_access = read_access
        self.restricted_edit_access = restricted_edit_access
        self.modify_access = modify_access
        self.download_access = download_access
        self.dimension_count = dimension_count
        self.measure_count = measure_count
        self.latest_data_strategy = latest_data_strategy
        self.fixed_max_time = fixed_max_time
        self.special_time_dimension = special_time_dimension
        self.default_refresh_rate = default_refresh_rate
        self.default_timezone = default_timezone
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by


class DataCubeOptions(_serialization.Model):
    """Data cube options.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar fixed_max_time: Specifies a fixed time value for the data cube to use as the latest "max
     time" instead of querying for
     it or using the current time. Use this property in conjunction with the "predefined" latest
     data strategy.
    :vartype fixed_max_time: ~datetime.datetime
    :ivar timeout_override: Optional number of milliseconds to override the default 40-second query
     timeout.
     Setting this value higher than 660,000 (11 minutes) overrides the default value for the client
     timeout, which is 660,000.
    :vartype timeout_override: float
    :ivar time_series_max_entries: Maximum number of entries allowed in a time series
     visualization.
     Overrides the default value of 500,000.
    :vartype time_series_max_entries: float
    :ivar exact_results_only: Disables approximate aggregators and forces Polaris to prioritize
     GroupBy queries over TopN queries.
    :vartype exact_results_only: bool
    :ivar custom_transforms: Map any Druid extraction function to a dimension. Extraction function
     definitions should be keyed on dimension names.
    :vartype custom_transforms: dict[str, any]
    :ivar pii_mask: Defines a threshold below which Polaris considers data to be Personally
     Identifiable Information (PII) and hides it.
     See the `piiMask <https://docs.imply.io/latest/managing-data-cubes#piimask>`_ example.
    :vartype pii_mask: ~polaris.sdk.global_api.models.DataCubeOptionsPiiMask
    :ivar restricted_mode_properties: Defines a restricted edit mode for access control to grant
     users limited edit rights for a data cube.
     See the `restrictedModeProperties
     <https://docs.imply.io/latest/managing-data-cubes#restrictedmodeproperties>`_ example.
    :vartype restricted_mode_properties: list[str]
    :ivar latest_presets: Array of preset objects to override the LATEST DATA presets in the time
     filter menu.
    :vartype latest_presets: list[~polaris.sdk.global_api.models.TimeFilterPreset]
    :ivar current_presets: Array of preset objects to override the CURRENT presets in the time
     filter menu.
    :vartype current_presets: list[~polaris.sdk.global_api.models.TimeFilterPreset]
    :ivar previous_presets: Array of preset objects to override the PREVIOUS presets in the time
     filter menu.
    :vartype previous_presets: list[~polaris.sdk.global_api.models.TimeFilterPreset]
    :ivar split_limits: Array of numbers to override the default options of [5, 10, 25, 50, 100]
     shown in the limit dropdown of the split menu.
    :vartype split_limits: list[float]
    :ivar ignore_dimension_in_explain: List of dimension IDs to ignore when computing an
     explanation.
    :vartype ignore_dimension_in_explain: list[str]
    :ivar rank_expression: Measure expression Polaris uses to order dimension values in the
     dimension filter menu. Defaults to ``count``.
    :vartype rank_expression: str
    :ivar druid_context: An object to pass in as the query context.
    :vartype druid_context: dict[str, any]
    :ivar priority: Number to pass as 'priority' into the query context.
    :vartype priority: int
    :ivar max_download_limit: Limit (in number of rows) for data cube downloads.
    :vartype max_download_limit: int
    :ivar large_download_interval: Limit (as a time interval) for data cube downloads.
    :vartype large_download_interval: ~datetime.timedelta
    :ivar suppress_overall_by_default: Hides the "overall" element of a visualization by default.
    :vartype suppress_overall_by_default: bool
    :ivar boost_prefix_rank: Boosts dimension values where matches occur at the beginning of the
     string over values with matches found in other positions in the dimension filter menu.
    :vartype boost_prefix_rank: bool
    :ivar boost_selected_measures: When the data cube view is in multi-measure selection mode,
     boosts selected measures to the top of the measures list in the measure picker menu.
    :vartype boost_selected_measures: bool
    :ivar gray_out_trivial: Renders trivial dimensions in gray in the dimensions panel. A
     continuous dimension is trivial if it has a maximum value equal to its minimum value. A
     discrete dimension is trivial if it has less than two values.
    :vartype gray_out_trivial: bool
    :ivar always_show_compare_control: Removes the ability to toggle `time compare
     <https://docs.imply.io/latest/time-compare>`_.
    :vartype always_show_compare_control: bool
    :ivar disable_preview: Disables the preview of values in the dimension and measure modals.
    :vartype disable_preview: bool
    :ivar show_explain_badge: Shows a badge with the standard deviation for the sample values used
     for the `explanation <https://docs.imply.io/latest/explain>`_.
    :vartype show_explain_badge: bool
    """

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "fixed_max_time": {"key": "fixedMaxTime", "type": "iso-8601"},
        "timeout_override": {"key": "timeoutOverride", "type": "float"},
        "time_series_max_entries": {"key": "timeSeriesMaxEntries", "type": "float"},
        "exact_results_only": {"key": "exactResultsOnly", "type": "bool"},
        "custom_transforms": {"key": "customTransforms", "type": "{object}"},
        "pii_mask": {"key": "piiMask", "type": "DataCubeOptionsPiiMask"},
        "restricted_mode_properties": {
            "key": "restrictedModeProperties",
            "type": "[str]",
        },
        "latest_presets": {"key": "latestPresets", "type": "[TimeFilterPreset]"},
        "current_presets": {"key": "currentPresets", "type": "[TimeFilterPreset]"},
        "previous_presets": {"key": "previousPresets", "type": "[TimeFilterPreset]"},
        "split_limits": {"key": "splitLimits", "type": "[float]"},
        "ignore_dimension_in_explain": {
            "key": "ignoreDimensionInExplain",
            "type": "[str]",
        },
        "rank_expression": {"key": "rankExpression", "type": "str"},
        "druid_context": {"key": "druidContext", "type": "{object}"},
        "priority": {"key": "priority", "type": "int"},
        "max_download_limit": {"key": "maxDownloadLimit", "type": "int"},
        "large_download_interval": {"key": "largeDownloadInterval", "type": "duration"},
        "suppress_overall_by_default": {
            "key": "suppressOverallByDefault",
            "type": "bool",
        },
        "boost_prefix_rank": {"key": "boostPrefixRank", "type": "bool"},
        "boost_selected_measures": {"key": "boostSelectedMeasures", "type": "bool"},
        "gray_out_trivial": {"key": "grayOutTrivial", "type": "bool"},
        "always_show_compare_control": {
            "key": "alwaysShowCompareControl",
            "type": "bool",
        },
        "disable_preview": {"key": "disablePreview", "type": "bool"},
        "show_explain_badge": {"key": "showExplainBadge", "type": "bool"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        fixed_max_time: Optional[datetime.datetime] = None,
        timeout_override: Optional[float] = None,
        time_series_max_entries: Optional[float] = None,
        exact_results_only: Optional[bool] = None,
        custom_transforms: Optional[Dict[str, Any]] = None,
        pii_mask: Optional["_models.DataCubeOptionsPiiMask"] = None,
        restricted_mode_properties: Optional[List[str]] = None,
        latest_presets: Optional[List["_models.TimeFilterPreset"]] = None,
        current_presets: Optional[List["_models.TimeFilterPreset"]] = None,
        previous_presets: Optional[List["_models.TimeFilterPreset"]] = None,
        split_limits: Optional[List[float]] = None,
        ignore_dimension_in_explain: Optional[List[str]] = None,
        rank_expression: Optional[str] = None,
        druid_context: Optional[Dict[str, Any]] = None,
        priority: Optional[int] = None,
        max_download_limit: Optional[int] = None,
        large_download_interval: Optional[datetime.timedelta] = None,
        suppress_overall_by_default: Optional[bool] = None,
        boost_prefix_rank: Optional[bool] = None,
        boost_selected_measures: Optional[bool] = None,
        gray_out_trivial: Optional[bool] = None,
        always_show_compare_control: Optional[bool] = None,
        disable_preview: Optional[bool] = None,
        show_explain_badge: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword fixed_max_time: Specifies a fixed time value for the data cube to use as the latest
         "max time" instead of querying for
         it or using the current time. Use this property in conjunction with the "predefined" latest
         data strategy.
        :paramtype fixed_max_time: ~datetime.datetime
        :keyword timeout_override: Optional number of milliseconds to override the default 40-second
         query timeout.
         Setting this value higher than 660,000 (11 minutes) overrides the default value for the client
         timeout, which is 660,000.
        :paramtype timeout_override: float
        :keyword time_series_max_entries: Maximum number of entries allowed in a time series
         visualization.
         Overrides the default value of 500,000.
        :paramtype time_series_max_entries: float
        :keyword exact_results_only: Disables approximate aggregators and forces Polaris to prioritize
         GroupBy queries over TopN queries.
        :paramtype exact_results_only: bool
        :keyword custom_transforms: Map any Druid extraction function to a dimension. Extraction
         function definitions should be keyed on dimension names.
        :paramtype custom_transforms: dict[str, any]
        :keyword pii_mask: Defines a threshold below which Polaris considers data to be Personally
         Identifiable Information (PII) and hides it.
         See the `piiMask <https://docs.imply.io/latest/managing-data-cubes#piimask>`_ example.
        :paramtype pii_mask: ~polaris.sdk.global_api.models.DataCubeOptionsPiiMask
        :keyword restricted_mode_properties: Defines a restricted edit mode for access control to grant
         users limited edit rights for a data cube.
         See the `restrictedModeProperties
         <https://docs.imply.io/latest/managing-data-cubes#restrictedmodeproperties>`_ example.
        :paramtype restricted_mode_properties: list[str]
        :keyword latest_presets: Array of preset objects to override the LATEST DATA presets in the
         time filter menu.
        :paramtype latest_presets: list[~polaris.sdk.global_api.models.TimeFilterPreset]
        :keyword current_presets: Array of preset objects to override the CURRENT presets in the time
         filter menu.
        :paramtype current_presets: list[~polaris.sdk.global_api.models.TimeFilterPreset]
        :keyword previous_presets: Array of preset objects to override the PREVIOUS presets in the time
         filter menu.
        :paramtype previous_presets: list[~polaris.sdk.global_api.models.TimeFilterPreset]
        :keyword split_limits: Array of numbers to override the default options of [5, 10, 25, 50, 100]
         shown in the limit dropdown of the split menu.
        :paramtype split_limits: list[float]
        :keyword ignore_dimension_in_explain: List of dimension IDs to ignore when computing an
         explanation.
        :paramtype ignore_dimension_in_explain: list[str]
        :keyword rank_expression: Measure expression Polaris uses to order dimension values in the
         dimension filter menu. Defaults to ``count``.
        :paramtype rank_expression: str
        :keyword druid_context: An object to pass in as the query context.
        :paramtype druid_context: dict[str, any]
        :keyword priority: Number to pass as 'priority' into the query context.
        :paramtype priority: int
        :keyword max_download_limit: Limit (in number of rows) for data cube downloads.
        :paramtype max_download_limit: int
        :keyword large_download_interval: Limit (as a time interval) for data cube downloads.
        :paramtype large_download_interval: ~datetime.timedelta
        :keyword suppress_overall_by_default: Hides the "overall" element of a visualization by
         default.
        :paramtype suppress_overall_by_default: bool
        :keyword boost_prefix_rank: Boosts dimension values where matches occur at the beginning of the
         string over values with matches found in other positions in the dimension filter menu.
        :paramtype boost_prefix_rank: bool
        :keyword boost_selected_measures: When the data cube view is in multi-measure selection mode,
         boosts selected measures to the top of the measures list in the measure picker menu.
        :paramtype boost_selected_measures: bool
        :keyword gray_out_trivial: Renders trivial dimensions in gray in the dimensions panel. A
         continuous dimension is trivial if it has a maximum value equal to its minimum value. A
         discrete dimension is trivial if it has less than two values.
        :paramtype gray_out_trivial: bool
        :keyword always_show_compare_control: Removes the ability to toggle `time compare
         <https://docs.imply.io/latest/time-compare>`_.
        :paramtype always_show_compare_control: bool
        :keyword disable_preview: Disables the preview of values in the dimension and measure modals.
        :paramtype disable_preview: bool
        :keyword show_explain_badge: Shows a badge with the standard deviation for the sample values
         used for the `explanation <https://docs.imply.io/latest/explain>`_.
        :paramtype show_explain_badge: bool
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.fixed_max_time = fixed_max_time
        self.timeout_override = timeout_override
        self.time_series_max_entries = time_series_max_entries
        self.exact_results_only = exact_results_only
        self.custom_transforms = custom_transforms
        self.pii_mask = pii_mask
        self.restricted_mode_properties = restricted_mode_properties
        self.latest_presets = latest_presets
        self.current_presets = current_presets
        self.previous_presets = previous_presets
        self.split_limits = split_limits
        self.ignore_dimension_in_explain = ignore_dimension_in_explain
        self.rank_expression = rank_expression
        self.druid_context = druid_context
        self.priority = priority
        self.max_download_limit = max_download_limit
        self.large_download_interval = large_download_interval
        self.suppress_overall_by_default = suppress_overall_by_default
        self.boost_prefix_rank = boost_prefix_rank
        self.boost_selected_measures = boost_selected_measures
        self.gray_out_trivial = gray_out_trivial
        self.always_show_compare_control = always_show_compare_control
        self.disable_preview = disable_preview
        self.show_explain_badge = show_explain_badge


class DataCubeOptionsPiiMask(_serialization.Model):
    """Defines a threshold below which Polaris considers data to be Personally Identifiable
    Information (PII) and hides it.
    See the `piiMask <https://docs.imply.io/latest/managing-data-cubes#piimask>`_ example.

    All required parameters must be populated in order to send to server.

    :ivar aggregate: Required.
    :vartype aggregate: str
    :ivar threshold: Required.
    :vartype threshold: float
    :ivar hide_aggregates:
    :vartype hide_aggregates: bool
    :ivar mask_text:
    :vartype mask_text: str
    :ivar other_text:
    :vartype other_text: str
    """

    _validation = {
        "aggregate": {"required": True},
        "threshold": {"required": True},
    }

    _attribute_map = {
        "aggregate": {"key": "aggregate", "type": "str"},
        "threshold": {"key": "threshold", "type": "float"},
        "hide_aggregates": {"key": "hideAggregates", "type": "bool"},
        "mask_text": {"key": "maskText", "type": "str"},
        "other_text": {"key": "otherText", "type": "str"},
    }

    def __init__(
        self,
        *,
        aggregate: str,
        threshold: float,
        hide_aggregates: Optional[bool] = None,
        mask_text: Optional[str] = None,
        other_text: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword aggregate: Required.
        :paramtype aggregate: str
        :keyword threshold: Required.
        :paramtype threshold: float
        :keyword hide_aggregates:
        :paramtype hide_aggregates: bool
        :keyword mask_text:
        :paramtype mask_text: str
        :keyword other_text:
        :paramtype other_text: str
        """
        super().__init__(**kwargs)
        self.aggregate = aggregate
        self.threshold = threshold
        self.hide_aggregates = hide_aggregates
        self.mask_text = mask_text
        self.other_text = other_text


class DataCubeResponse(AuditRecord, DataCubePayload):
    """DataCubeResponse.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar title: Data cube title.
    :vartype title: str
    :ivar description: Data cube description.
    :vartype description: str
    :ivar query_mode: Data cube query mode. Known values are: "sql" and "plywood".
    :vartype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
    :ivar source: Data cube source.
    :vartype source: ~polaris.sdk.global_api.models.DataCubeSource
    :ivar palette: Color palette for the Polaris UI. Use the 6-character hex format for all colors.
    :vartype palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar min_auto_refresh_rate: Minimum auto refresh rate for the data cube, expressed as an `ISO
     8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_auto_refresh_rate: ~datetime.timedelta
    :ivar latest_time_filter_granularity: When using a relative time filter, Polaris uses this
     level of granularity to align the
     filter boundaries when querying the underlying table, expressed as an `ISO 8601 Duration
     <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
     For an aggregate table, set to the same granularity used during ingestion or leave unset for
     Polaris to infer
     an appropriate value from the data. For a detail table, leave unset.
    :vartype latest_time_filter_granularity: ~datetime.timedelta
    :ivar subset_formula: Row level filter to apply to the data cube. This filter is never shown in
     the cube view
     and effectively constrains the data cube to only the events that match this filter.
    :vartype subset_formula: str
    :ivar filter_token: Only allow users with the given filter token to access this data cube.
    :vartype filter_token: str
    :ivar rollup: Whether the associated table has rollup enabled.
    :vartype rollup: bool
    :ivar options: Data cube options.
    :vartype options: ~polaris.sdk.global_api.models.DataCubeOptions
    :ivar read_access: Access control list for read access to the data cube.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar restricted_edit_access: In some cases, you may need to limit a user's ability to edit
     aspects of a data cube;
     for example, to allow a user to modify dimensions but not to change the title or description.
    :vartype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
    :ivar modify_access: Access control list for modifying this data cube.
    :vartype modify_access: ~polaris.sdk.global_api.models.AccessList
    :ivar download_access: Access control list for downloading raw data from this data cube.
    :vartype download_access: ~polaris.sdk.global_api.models.AccessList
    :ivar attributes: Column metadata for the associated data source.
    :vartype attributes: list[~polaris.sdk.global_api.models.Attribute]
    :ivar dimensions: The dimensions of the data cube.
    :vartype dimensions: list[~polaris.sdk.global_api.models.DimensionPayload]
    :ivar measures: Array of data cube measures.
    :vartype measures: list[~polaris.sdk.global_api.models.MeasurePayload]
    :ivar instances: Data cube instances.
    :vartype instances: ~polaris.sdk.global_api.models.DataCubeInstanceList
    :ivar special_time_dimension: Time dimension Polaris uses for all time-related calculations for
     the data cube, including comparisons, filters, alerts, and reports.
     Polarise uses this to check the freshness of data and apply time filters.
    :vartype special_time_dimension: str
    :ivar enforce_time_filter: Ensures that every query is filtered on the primary time dimension.
     You can enable this setting if time unbounded queries are likely to be slow due to the volume
     of data.
    :vartype enforce_time_filter: bool
    :ivar default_filter: Default filter to apply when visualizing the data cube.
    :vartype default_filter: ~polaris.sdk.global_api.models.Filter
    :ivar default_timezone: Time zone to select when a user first opens the data cube, expressed as
     an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype default_timezone: str
    :ivar default_duration: Time period to display when a user first opens the data cube,
     expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_duration: ~datetime.timedelta
    :ivar default_selected_measures: IDs of the measures to show by default in visualizations.
    :vartype default_selected_measures: list[str]
    :ivar default_pinned_dimensions: IDs of the dimensions to pin by default in visualizations.
    :vartype default_pinned_dimensions: list[str]
    :ivar default_refresh_rate: The default refresh rate for the data cube, expressed as an `ISO
     8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_refresh_rate: ~datetime.timedelta
    :ivar default_visualization: Name of the default visualization to use when initially viewing
     the data cube.
    :vartype default_visualization: str
    :ivar default_having_filter: The default HAVING filter for the data cube.
    :vartype default_having_filter: ~polaris.sdk.global_api.models.HavingFilter
    :ivar latest_data_strategy: Determines how Polaris calculates the latest data time for the data
     cube.
     By default, Polaris queries the data source for the latest time stamp on ingested data.
     You can set this property to always use the current time, which may be more appropriate for
     streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
    :vartype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
    :ivar query_caching: Allow caching on queries made to this data cube. Caching can greatly speed
     up exploration but can
     also cause results to be a little out of date especially in realtime rolled up datasets. Known
     values are: "allow" and "disable".
    :vartype query_caching: str or ~polaris.sdk.global_api.models.DataCubePayloadQueryCaching
    :ivar formulae_visibility: Hide or show dimension and measure formulae in info modals. Polaris
     displays formulae are by default. Users
     with appropriate permissions can still see formulae when editing. Known values are: "show" and
     "hide".
    :vartype formulae_visibility: str or ~polaris.sdk.global_api.models.Visibility
    :ivar min_alert_frequency: Minimum allowable frequency for alerts associated with this data
     cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_alert_frequency: ~datetime.timedelta
    :ivar min_alert_time_frame: Minimum allowable time frame for alerts associated with this data
     cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_alert_time_frame: ~datetime.timedelta
    :ivar default_parameters: The default parameters to populate an Explore visualization.
    :vartype default_parameters: str
    :ivar default_facet_splits: Default dimensions to split on.
    :vartype default_facet_splits: list[any]
    :ivar default_facet_compare: Default comparison for the data cube.
    :vartype default_facet_compare: ~polaris.sdk.global_api.models.FacetCompare
    :ivar custom_facet_compares: Customized comparisons for the data cube.
    :vartype custom_facet_compares: list[~polaris.sdk.global_api.models.FacetCompare]
    :ivar require_group_filters: Enable this property to use access filters. When enabled, users
     who aren't assigned an access
     filter can't perform queries.
    :vartype require_group_filters: bool
    :ivar allow_filter_combine: Determines the behaviour when a user is a member of two or more
     user groups with access filters applied.
     If ``true``\\ , Polaris combines the filters with the OR operator.
     If ``false``\\ , the user can't view any data in the data cube.
    :vartype allow_filter_combine: bool
    :ivar group_filters: Defines access filters for a user group.
    :vartype group_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
    :ivar user_filters: Defines access filters for a Polaris API key.
    :vartype user_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
        "created_at": {"required": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "query_mode": {"key": "queryMode", "type": "str"},
        "source": {"key": "source", "type": "DataCubeSource"},
        "palette": {"key": "palette", "type": "AppColorPalette"},
        "min_auto_refresh_rate": {"key": "minAutoRefreshRate", "type": "duration"},
        "latest_time_filter_granularity": {
            "key": "latestTimeFilterGranularity",
            "type": "duration",
        },
        "subset_formula": {"key": "subsetFormula", "type": "str"},
        "filter_token": {"key": "filterToken", "type": "str"},
        "rollup": {"key": "rollup", "type": "bool"},
        "options": {"key": "options", "type": "DataCubeOptions"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "restricted_edit_access": {"key": "restrictedEditAccess", "type": "AccessList"},
        "modify_access": {"key": "modifyAccess", "type": "AccessList"},
        "download_access": {"key": "downloadAccess", "type": "AccessList"},
        "attributes": {"key": "attributes", "type": "[Attribute]"},
        "dimensions": {"key": "dimensions", "type": "[DimensionPayload]"},
        "measures": {"key": "measures", "type": "[MeasurePayload]"},
        "instances": {"key": "instances", "type": "DataCubeInstanceList"},
        "special_time_dimension": {"key": "specialTimeDimension", "type": "str"},
        "enforce_time_filter": {"key": "enforceTimeFilter", "type": "bool"},
        "default_filter": {"key": "defaultFilter", "type": "Filter"},
        "default_timezone": {"key": "defaultTimezone", "type": "str"},
        "default_duration": {"key": "defaultDuration", "type": "duration"},
        "default_selected_measures": {
            "key": "defaultSelectedMeasures",
            "type": "[str]",
        },
        "default_pinned_dimensions": {
            "key": "defaultPinnedDimensions",
            "type": "[str]",
        },
        "default_refresh_rate": {"key": "defaultRefreshRate", "type": "duration"},
        "default_visualization": {"key": "defaultVisualization", "type": "str"},
        "default_having_filter": {"key": "defaultHavingFilter", "type": "HavingFilter"},
        "latest_data_strategy": {"key": "latestDataStrategy", "type": "str"},
        "query_caching": {"key": "queryCaching", "type": "str"},
        "formulae_visibility": {"key": "formulaeVisibility", "type": "str"},
        "min_alert_frequency": {"key": "minAlertFrequency", "type": "duration"},
        "min_alert_time_frame": {"key": "minAlertTimeFrame", "type": "duration"},
        "default_parameters": {"key": "defaultParameters", "type": "str"},
        "default_facet_splits": {"key": "defaultFacetSplits", "type": "[object]"},
        "default_facet_compare": {"key": "defaultFacetCompare", "type": "FacetCompare"},
        "custom_facet_compares": {
            "key": "customFacetCompares",
            "type": "[FacetCompare]",
        },
        "require_group_filters": {"key": "requireGroupFilters", "type": "bool"},
        "allow_filter_combine": {"key": "allowFilterCombine", "type": "bool"},
        "group_filters": {"key": "groupFilters", "type": "{GroupFilter}"},
        "user_filters": {"key": "userFilters", "type": "{GroupFilter}"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        title: Optional[str] = None,
        description: Optional[str] = None,
        query_mode: Optional[Union[str, "_models.QueryMode"]] = None,
        source: Optional["_models.DataCubeSource"] = None,
        palette: Optional["_models.AppColorPalette"] = None,
        min_auto_refresh_rate: Optional[datetime.timedelta] = None,
        latest_time_filter_granularity: Optional[datetime.timedelta] = None,
        subset_formula: Optional[str] = None,
        filter_token: Optional[str] = None,
        rollup: Optional[bool] = None,
        options: Optional["_models.DataCubeOptions"] = None,
        read_access: Optional["_models.AccessList"] = None,
        restricted_edit_access: Optional["_models.AccessList"] = None,
        modify_access: Optional["_models.AccessList"] = None,
        download_access: Optional["_models.AccessList"] = None,
        attributes: Optional[List["_models.Attribute"]] = None,
        dimensions: Optional[List["_models.DimensionPayload"]] = None,
        measures: Optional[List["_models.MeasurePayload"]] = None,
        instances: Optional["_models.DataCubeInstanceList"] = None,
        special_time_dimension: Optional[str] = None,
        enforce_time_filter: Optional[bool] = None,
        default_filter: Optional["_models.Filter"] = None,
        default_timezone: Optional[str] = None,
        default_duration: Optional[datetime.timedelta] = None,
        default_selected_measures: Optional[List[str]] = None,
        default_pinned_dimensions: Optional[List[str]] = None,
        default_refresh_rate: Optional[datetime.timedelta] = None,
        default_visualization: Optional[str] = None,
        default_having_filter: Optional["_models.HavingFilter"] = None,
        latest_data_strategy: Optional[Union[str, "_models.LatestDataStrategy"]] = None,
        query_caching: Optional[
            Union[str, "_models.DataCubePayloadQueryCaching"]
        ] = None,
        formulae_visibility: Optional[Union[str, "_models.Visibility"]] = None,
        min_alert_frequency: Optional[datetime.timedelta] = None,
        min_alert_time_frame: Optional[datetime.timedelta] = None,
        default_parameters: Optional[str] = None,
        default_facet_splits: Optional[List[Any]] = None,
        default_facet_compare: Optional["_models.FacetCompare"] = None,
        custom_facet_compares: Optional[List["_models.FacetCompare"]] = None,
        require_group_filters: Optional[bool] = None,
        allow_filter_combine: Optional[bool] = None,
        group_filters: Optional[Dict[str, "_models.GroupFilter"]] = None,
        user_filters: Optional[Dict[str, "_models.GroupFilter"]] = None,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword title: Data cube title.
        :paramtype title: str
        :keyword description: Data cube description.
        :paramtype description: str
        :keyword query_mode: Data cube query mode. Known values are: "sql" and "plywood".
        :paramtype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
        :keyword source: Data cube source.
        :paramtype source: ~polaris.sdk.global_api.models.DataCubeSource
        :keyword palette: Color palette for the Polaris UI. Use the 6-character hex format for all
         colors.
        :paramtype palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword min_auto_refresh_rate: Minimum auto refresh rate for the data cube, expressed as an
         `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_auto_refresh_rate: ~datetime.timedelta
        :keyword latest_time_filter_granularity: When using a relative time filter, Polaris uses this
         level of granularity to align the
         filter boundaries when querying the underlying table, expressed as an `ISO 8601 Duration
         <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
         For an aggregate table, set to the same granularity used during ingestion or leave unset for
         Polaris to infer
         an appropriate value from the data. For a detail table, leave unset.
        :paramtype latest_time_filter_granularity: ~datetime.timedelta
        :keyword subset_formula: Row level filter to apply to the data cube. This filter is never shown
         in the cube view
         and effectively constrains the data cube to only the events that match this filter.
        :paramtype subset_formula: str
        :keyword filter_token: Only allow users with the given filter token to access this data cube.
        :paramtype filter_token: str
        :keyword rollup: Whether the associated table has rollup enabled.
        :paramtype rollup: bool
        :keyword options: Data cube options.
        :paramtype options: ~polaris.sdk.global_api.models.DataCubeOptions
        :keyword read_access: Access control list for read access to the data cube.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword restricted_edit_access: In some cases, you may need to limit a user's ability to edit
         aspects of a data cube;
         for example, to allow a user to modify dimensions but not to change the title or description.
        :paramtype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
        :keyword modify_access: Access control list for modifying this data cube.
        :paramtype modify_access: ~polaris.sdk.global_api.models.AccessList
        :keyword download_access: Access control list for downloading raw data from this data cube.
        :paramtype download_access: ~polaris.sdk.global_api.models.AccessList
        :keyword attributes: Column metadata for the associated data source.
        :paramtype attributes: list[~polaris.sdk.global_api.models.Attribute]
        :keyword dimensions: The dimensions of the data cube.
        :paramtype dimensions: list[~polaris.sdk.global_api.models.DimensionPayload]
        :keyword measures: Array of data cube measures.
        :paramtype measures: list[~polaris.sdk.global_api.models.MeasurePayload]
        :keyword instances: Data cube instances.
        :paramtype instances: ~polaris.sdk.global_api.models.DataCubeInstanceList
        :keyword special_time_dimension: Time dimension Polaris uses for all time-related calculations
         for the data cube, including comparisons, filters, alerts, and reports.
         Polarise uses this to check the freshness of data and apply time filters.
        :paramtype special_time_dimension: str
        :keyword enforce_time_filter: Ensures that every query is filtered on the primary time
         dimension.
         You can enable this setting if time unbounded queries are likely to be slow due to the volume
         of data.
        :paramtype enforce_time_filter: bool
        :keyword default_filter: Default filter to apply when visualizing the data cube.
        :paramtype default_filter: ~polaris.sdk.global_api.models.Filter
        :keyword default_timezone: Time zone to select when a user first opens the data cube, expressed
         as an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype default_timezone: str
        :keyword default_duration: Time period to display when a user first opens the data cube,
         expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype default_duration: ~datetime.timedelta
        :keyword default_selected_measures: IDs of the measures to show by default in visualizations.
        :paramtype default_selected_measures: list[str]
        :keyword default_pinned_dimensions: IDs of the dimensions to pin by default in visualizations.
        :paramtype default_pinned_dimensions: list[str]
        :keyword default_refresh_rate: The default refresh rate for the data cube, expressed as an `ISO
         8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype default_refresh_rate: ~datetime.timedelta
        :keyword default_visualization: Name of the default visualization to use when initially viewing
         the data cube.
        :paramtype default_visualization: str
        :keyword default_having_filter: The default HAVING filter for the data cube.
        :paramtype default_having_filter: ~polaris.sdk.global_api.models.HavingFilter
        :keyword latest_data_strategy: Determines how Polaris calculates the latest data time for the
         data cube.
         By default, Polaris queries the data source for the latest time stamp on ingested data.
         You can set this property to always use the current time, which may be more appropriate for
         streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
        :paramtype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
        :keyword query_caching: Allow caching on queries made to this data cube. Caching can greatly
         speed up exploration but can
         also cause results to be a little out of date especially in realtime rolled up datasets. Known
         values are: "allow" and "disable".
        :paramtype query_caching: str or ~polaris.sdk.global_api.models.DataCubePayloadQueryCaching
        :keyword formulae_visibility: Hide or show dimension and measure formulae in info modals.
         Polaris displays formulae are by default. Users
         with appropriate permissions can still see formulae when editing. Known values are: "show" and
         "hide".
        :paramtype formulae_visibility: str or ~polaris.sdk.global_api.models.Visibility
        :keyword min_alert_frequency: Minimum allowable frequency for alerts associated with this data
         cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_alert_frequency: ~datetime.timedelta
        :keyword min_alert_time_frame: Minimum allowable time frame for alerts associated with this
         data cube, expressed as an `ISO 8601 Duration
         <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_alert_time_frame: ~datetime.timedelta
        :keyword default_parameters: The default parameters to populate an Explore visualization.
        :paramtype default_parameters: str
        :keyword default_facet_splits: Default dimensions to split on.
        :paramtype default_facet_splits: list[any]
        :keyword default_facet_compare: Default comparison for the data cube.
        :paramtype default_facet_compare: ~polaris.sdk.global_api.models.FacetCompare
        :keyword custom_facet_compares: Customized comparisons for the data cube.
        :paramtype custom_facet_compares: list[~polaris.sdk.global_api.models.FacetCompare]
        :keyword require_group_filters: Enable this property to use access filters. When enabled, users
         who aren't assigned an access
         filter can't perform queries.
        :paramtype require_group_filters: bool
        :keyword allow_filter_combine: Determines the behaviour when a user is a member of two or more
         user groups with access filters applied.
         If ``true``\\ , Polaris combines the filters with the OR operator.
         If ``false``\\ , the user can't view any data in the data cube.
        :paramtype allow_filter_combine: bool
        :keyword group_filters: Defines access filters for a user group.
        :paramtype group_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
        :keyword user_filters: Defines access filters for a Polaris API key.
        :paramtype user_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        """
        super().__init__(
            created_at=created_at,
            created_by=created_by,
            updated_at=updated_at,
            updated_by=updated_by,
            additional_properties=additional_properties,
            id=id,
            title=title,
            description=description,
            query_mode=query_mode,
            source=source,
            palette=palette,
            min_auto_refresh_rate=min_auto_refresh_rate,
            latest_time_filter_granularity=latest_time_filter_granularity,
            subset_formula=subset_formula,
            filter_token=filter_token,
            rollup=rollup,
            options=options,
            read_access=read_access,
            restricted_edit_access=restricted_edit_access,
            modify_access=modify_access,
            download_access=download_access,
            attributes=attributes,
            dimensions=dimensions,
            measures=measures,
            instances=instances,
            special_time_dimension=special_time_dimension,
            enforce_time_filter=enforce_time_filter,
            default_filter=default_filter,
            default_timezone=default_timezone,
            default_duration=default_duration,
            default_selected_measures=default_selected_measures,
            default_pinned_dimensions=default_pinned_dimensions,
            default_refresh_rate=default_refresh_rate,
            default_visualization=default_visualization,
            default_having_filter=default_having_filter,
            latest_data_strategy=latest_data_strategy,
            query_caching=query_caching,
            formulae_visibility=formulae_visibility,
            min_alert_frequency=min_alert_frequency,
            min_alert_time_frame=min_alert_time_frame,
            default_parameters=default_parameters,
            default_facet_splits=default_facet_splits,
            default_facet_compare=default_facet_compare,
            custom_facet_compares=custom_facet_compares,
            require_group_filters=require_group_filters,
            allow_filter_combine=allow_filter_combine,
            group_filters=group_filters,
            user_filters=user_filters,
            **kwargs
        )
        self.additional_properties = additional_properties
        self.id = id
        self.title = title
        self.description = description
        self.query_mode = query_mode
        self.source = source
        self.palette = palette
        self.min_auto_refresh_rate = min_auto_refresh_rate
        self.latest_time_filter_granularity = latest_time_filter_granularity
        self.subset_formula = subset_formula
        self.filter_token = filter_token
        self.rollup = rollup
        self.options = options
        self.read_access = read_access
        self.restricted_edit_access = restricted_edit_access
        self.modify_access = modify_access
        self.download_access = download_access
        self.attributes = attributes
        self.dimensions = dimensions
        self.measures = measures
        self.instances = instances
        self.special_time_dimension = special_time_dimension
        self.enforce_time_filter = enforce_time_filter
        self.default_filter = default_filter
        self.default_timezone = default_timezone
        self.default_duration = default_duration
        self.default_selected_measures = default_selected_measures
        self.default_pinned_dimensions = default_pinned_dimensions
        self.default_refresh_rate = default_refresh_rate
        self.default_visualization = default_visualization
        self.default_having_filter = default_having_filter
        self.latest_data_strategy = latest_data_strategy
        self.query_caching = query_caching
        self.formulae_visibility = formulae_visibility
        self.min_alert_frequency = min_alert_frequency
        self.min_alert_time_frame = min_alert_time_frame
        self.default_parameters = default_parameters
        self.default_facet_splits = default_facet_splits
        self.default_facet_compare = default_facet_compare
        self.custom_facet_compares = custom_facet_compares
        self.require_group_filters = require_group_filters
        self.allow_filter_combine = allow_filter_combine
        self.group_filters = group_filters
        self.user_filters = user_filters
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by


class DataCubeSource(_serialization.Model):
    """Data cube source.

    All required parameters must be populated in order to send to server.

    :ivar type: Data cube source type. Known values are: "direct" and "query".
    :vartype type: str or ~polaris.sdk.global_api.models.DataCubeSourceType
    :ivar value: Source value. Required.
    :vartype value: str
    :ivar connection_name: ID of the connection associated with this data source. In Polaris, this
     is always ``druid``. Required.
    :vartype connection_name: str
    """

    _validation = {
        "value": {"required": True},
        "connection_name": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "value": {"key": "value", "type": "str"},
        "connection_name": {"key": "connectionName", "type": "str"},
    }

    def __init__(
        self,
        *,
        value: str,
        connection_name: str,
        type: Optional[Union[str, "_models.DataCubeSourceType"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Data cube source type. Known values are: "direct" and "query".
        :paramtype type: str or ~polaris.sdk.global_api.models.DataCubeSourceType
        :keyword value: Source value. Required.
        :paramtype value: str
        :keyword connection_name: ID of the connection associated with this data source. In Polaris,
         this is always ``druid``. Required.
        :paramtype connection_name: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.value = value
        self.connection_name = connection_name


class DatCubeResponse(AuditRecord, DataCubePayload):
    """DatCubeResponse.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar title: Data cube title.
    :vartype title: str
    :ivar description: Data cube description.
    :vartype description: str
    :ivar query_mode: Data cube query mode. Known values are: "sql" and "plywood".
    :vartype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
    :ivar source: Data cube source.
    :vartype source: ~polaris.sdk.global_api.models.DataCubeSource
    :ivar palette: Color palette for the Polaris UI. Use the 6-character hex format for all colors.
    :vartype palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar min_auto_refresh_rate: Minimum auto refresh rate for the data cube, expressed as an `ISO
     8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_auto_refresh_rate: ~datetime.timedelta
    :ivar latest_time_filter_granularity: When using a relative time filter, Polaris uses this
     level of granularity to align the
     filter boundaries when querying the underlying table, expressed as an `ISO 8601 Duration
     <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
     For an aggregate table, set to the same granularity used during ingestion or leave unset for
     Polaris to infer
     an appropriate value from the data. For a detail table, leave unset.
    :vartype latest_time_filter_granularity: ~datetime.timedelta
    :ivar subset_formula: Row level filter to apply to the data cube. This filter is never shown in
     the cube view
     and effectively constrains the data cube to only the events that match this filter.
    :vartype subset_formula: str
    :ivar filter_token: Only allow users with the given filter token to access this data cube.
    :vartype filter_token: str
    :ivar rollup: Whether the associated table has rollup enabled.
    :vartype rollup: bool
    :ivar options: Data cube options.
    :vartype options: ~polaris.sdk.global_api.models.DataCubeOptions
    :ivar read_access: Access control list for read access to the data cube.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar restricted_edit_access: In some cases, you may need to limit a user's ability to edit
     aspects of a data cube;
     for example, to allow a user to modify dimensions but not to change the title or description.
    :vartype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
    :ivar modify_access: Access control list for modifying this data cube.
    :vartype modify_access: ~polaris.sdk.global_api.models.AccessList
    :ivar download_access: Access control list for downloading raw data from this data cube.
    :vartype download_access: ~polaris.sdk.global_api.models.AccessList
    :ivar attributes: Column metadata for the associated data source.
    :vartype attributes: list[~polaris.sdk.global_api.models.Attribute]
    :ivar dimensions: The dimensions of the data cube.
    :vartype dimensions: list[~polaris.sdk.global_api.models.DimensionPayload]
    :ivar measures: Array of data cube measures.
    :vartype measures: list[~polaris.sdk.global_api.models.MeasurePayload]
    :ivar instances: Data cube instances.
    :vartype instances: ~polaris.sdk.global_api.models.DataCubeInstanceList
    :ivar special_time_dimension: Time dimension Polaris uses for all time-related calculations for
     the data cube, including comparisons, filters, alerts, and reports.
     Polarise uses this to check the freshness of data and apply time filters.
    :vartype special_time_dimension: str
    :ivar enforce_time_filter: Ensures that every query is filtered on the primary time dimension.
     You can enable this setting if time unbounded queries are likely to be slow due to the volume
     of data.
    :vartype enforce_time_filter: bool
    :ivar default_filter: Default filter to apply when visualizing the data cube.
    :vartype default_filter: ~polaris.sdk.global_api.models.Filter
    :ivar default_timezone: Time zone to select when a user first opens the data cube, expressed as
     an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype default_timezone: str
    :ivar default_duration: Time period to display when a user first opens the data cube,
     expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_duration: ~datetime.timedelta
    :ivar default_selected_measures: IDs of the measures to show by default in visualizations.
    :vartype default_selected_measures: list[str]
    :ivar default_pinned_dimensions: IDs of the dimensions to pin by default in visualizations.
    :vartype default_pinned_dimensions: list[str]
    :ivar default_refresh_rate: The default refresh rate for the data cube, expressed as an `ISO
     8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype default_refresh_rate: ~datetime.timedelta
    :ivar default_visualization: Name of the default visualization to use when initially viewing
     the data cube.
    :vartype default_visualization: str
    :ivar default_having_filter: The default HAVING filter for the data cube.
    :vartype default_having_filter: ~polaris.sdk.global_api.models.HavingFilter
    :ivar latest_data_strategy: Determines how Polaris calculates the latest data time for the data
     cube.
     By default, Polaris queries the data source for the latest time stamp on ingested data.
     You can set this property to always use the current time, which may be more appropriate for
     streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
    :vartype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
    :ivar query_caching: Allow caching on queries made to this data cube. Caching can greatly speed
     up exploration but can
     also cause results to be a little out of date especially in realtime rolled up datasets. Known
     values are: "allow" and "disable".
    :vartype query_caching: str or ~polaris.sdk.global_api.models.DataCubePayloadQueryCaching
    :ivar formulae_visibility: Hide or show dimension and measure formulae in info modals. Polaris
     displays formulae are by default. Users
     with appropriate permissions can still see formulae when editing. Known values are: "show" and
     "hide".
    :vartype formulae_visibility: str or ~polaris.sdk.global_api.models.Visibility
    :ivar min_alert_frequency: Minimum allowable frequency for alerts associated with this data
     cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_alert_frequency: ~datetime.timedelta
    :ivar min_alert_time_frame: Minimum allowable time frame for alerts associated with this data
     cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
    :vartype min_alert_time_frame: ~datetime.timedelta
    :ivar default_parameters: The default parameters to populate an Explore visualization.
    :vartype default_parameters: str
    :ivar default_facet_splits: Default dimensions to split on.
    :vartype default_facet_splits: list[any]
    :ivar default_facet_compare: Default comparison for the data cube.
    :vartype default_facet_compare: ~polaris.sdk.global_api.models.FacetCompare
    :ivar custom_facet_compares: Customized comparisons for the data cube.
    :vartype custom_facet_compares: list[~polaris.sdk.global_api.models.FacetCompare]
    :ivar require_group_filters: Enable this property to use access filters. When enabled, users
     who aren't assigned an access
     filter can't perform queries.
    :vartype require_group_filters: bool
    :ivar allow_filter_combine: Determines the behaviour when a user is a member of two or more
     user groups with access filters applied.
     If ``true``\\ , Polaris combines the filters with the OR operator.
     If ``false``\\ , the user can't view any data in the data cube.
    :vartype allow_filter_combine: bool
    :ivar group_filters: Defines access filters for a user group.
    :vartype group_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
    :ivar user_filters: Defines access filters for a Polaris API key.
    :vartype user_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
        "created_at": {"required": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "query_mode": {"key": "queryMode", "type": "str"},
        "source": {"key": "source", "type": "DataCubeSource"},
        "palette": {"key": "palette", "type": "AppColorPalette"},
        "min_auto_refresh_rate": {"key": "minAutoRefreshRate", "type": "duration"},
        "latest_time_filter_granularity": {
            "key": "latestTimeFilterGranularity",
            "type": "duration",
        },
        "subset_formula": {"key": "subsetFormula", "type": "str"},
        "filter_token": {"key": "filterToken", "type": "str"},
        "rollup": {"key": "rollup", "type": "bool"},
        "options": {"key": "options", "type": "DataCubeOptions"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "restricted_edit_access": {"key": "restrictedEditAccess", "type": "AccessList"},
        "modify_access": {"key": "modifyAccess", "type": "AccessList"},
        "download_access": {"key": "downloadAccess", "type": "AccessList"},
        "attributes": {"key": "attributes", "type": "[Attribute]"},
        "dimensions": {"key": "dimensions", "type": "[DimensionPayload]"},
        "measures": {"key": "measures", "type": "[MeasurePayload]"},
        "instances": {"key": "instances", "type": "DataCubeInstanceList"},
        "special_time_dimension": {"key": "specialTimeDimension", "type": "str"},
        "enforce_time_filter": {"key": "enforceTimeFilter", "type": "bool"},
        "default_filter": {"key": "defaultFilter", "type": "Filter"},
        "default_timezone": {"key": "defaultTimezone", "type": "str"},
        "default_duration": {"key": "defaultDuration", "type": "duration"},
        "default_selected_measures": {
            "key": "defaultSelectedMeasures",
            "type": "[str]",
        },
        "default_pinned_dimensions": {
            "key": "defaultPinnedDimensions",
            "type": "[str]",
        },
        "default_refresh_rate": {"key": "defaultRefreshRate", "type": "duration"},
        "default_visualization": {"key": "defaultVisualization", "type": "str"},
        "default_having_filter": {"key": "defaultHavingFilter", "type": "HavingFilter"},
        "latest_data_strategy": {"key": "latestDataStrategy", "type": "str"},
        "query_caching": {"key": "queryCaching", "type": "str"},
        "formulae_visibility": {"key": "formulaeVisibility", "type": "str"},
        "min_alert_frequency": {"key": "minAlertFrequency", "type": "duration"},
        "min_alert_time_frame": {"key": "minAlertTimeFrame", "type": "duration"},
        "default_parameters": {"key": "defaultParameters", "type": "str"},
        "default_facet_splits": {"key": "defaultFacetSplits", "type": "[object]"},
        "default_facet_compare": {"key": "defaultFacetCompare", "type": "FacetCompare"},
        "custom_facet_compares": {
            "key": "customFacetCompares",
            "type": "[FacetCompare]",
        },
        "require_group_filters": {"key": "requireGroupFilters", "type": "bool"},
        "allow_filter_combine": {"key": "allowFilterCombine", "type": "bool"},
        "group_filters": {"key": "groupFilters", "type": "{GroupFilter}"},
        "user_filters": {"key": "userFilters", "type": "{GroupFilter}"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        title: Optional[str] = None,
        description: Optional[str] = None,
        query_mode: Optional[Union[str, "_models.QueryMode"]] = None,
        source: Optional["_models.DataCubeSource"] = None,
        palette: Optional["_models.AppColorPalette"] = None,
        min_auto_refresh_rate: Optional[datetime.timedelta] = None,
        latest_time_filter_granularity: Optional[datetime.timedelta] = None,
        subset_formula: Optional[str] = None,
        filter_token: Optional[str] = None,
        rollup: Optional[bool] = None,
        options: Optional["_models.DataCubeOptions"] = None,
        read_access: Optional["_models.AccessList"] = None,
        restricted_edit_access: Optional["_models.AccessList"] = None,
        modify_access: Optional["_models.AccessList"] = None,
        download_access: Optional["_models.AccessList"] = None,
        attributes: Optional[List["_models.Attribute"]] = None,
        dimensions: Optional[List["_models.DimensionPayload"]] = None,
        measures: Optional[List["_models.MeasurePayload"]] = None,
        instances: Optional["_models.DataCubeInstanceList"] = None,
        special_time_dimension: Optional[str] = None,
        enforce_time_filter: Optional[bool] = None,
        default_filter: Optional["_models.Filter"] = None,
        default_timezone: Optional[str] = None,
        default_duration: Optional[datetime.timedelta] = None,
        default_selected_measures: Optional[List[str]] = None,
        default_pinned_dimensions: Optional[List[str]] = None,
        default_refresh_rate: Optional[datetime.timedelta] = None,
        default_visualization: Optional[str] = None,
        default_having_filter: Optional["_models.HavingFilter"] = None,
        latest_data_strategy: Optional[Union[str, "_models.LatestDataStrategy"]] = None,
        query_caching: Optional[
            Union[str, "_models.DataCubePayloadQueryCaching"]
        ] = None,
        formulae_visibility: Optional[Union[str, "_models.Visibility"]] = None,
        min_alert_frequency: Optional[datetime.timedelta] = None,
        min_alert_time_frame: Optional[datetime.timedelta] = None,
        default_parameters: Optional[str] = None,
        default_facet_splits: Optional[List[Any]] = None,
        default_facet_compare: Optional["_models.FacetCompare"] = None,
        custom_facet_compares: Optional[List["_models.FacetCompare"]] = None,
        require_group_filters: Optional[bool] = None,
        allow_filter_combine: Optional[bool] = None,
        group_filters: Optional[Dict[str, "_models.GroupFilter"]] = None,
        user_filters: Optional[Dict[str, "_models.GroupFilter"]] = None,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword title: Data cube title.
        :paramtype title: str
        :keyword description: Data cube description.
        :paramtype description: str
        :keyword query_mode: Data cube query mode. Known values are: "sql" and "plywood".
        :paramtype query_mode: str or ~polaris.sdk.global_api.models.QueryMode
        :keyword source: Data cube source.
        :paramtype source: ~polaris.sdk.global_api.models.DataCubeSource
        :keyword palette: Color palette for the Polaris UI. Use the 6-character hex format for all
         colors.
        :paramtype palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword min_auto_refresh_rate: Minimum auto refresh rate for the data cube, expressed as an
         `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_auto_refresh_rate: ~datetime.timedelta
        :keyword latest_time_filter_granularity: When using a relative time filter, Polaris uses this
         level of granularity to align the
         filter boundaries when querying the underlying table, expressed as an `ISO 8601 Duration
         <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
         For an aggregate table, set to the same granularity used during ingestion or leave unset for
         Polaris to infer
         an appropriate value from the data. For a detail table, leave unset.
        :paramtype latest_time_filter_granularity: ~datetime.timedelta
        :keyword subset_formula: Row level filter to apply to the data cube. This filter is never shown
         in the cube view
         and effectively constrains the data cube to only the events that match this filter.
        :paramtype subset_formula: str
        :keyword filter_token: Only allow users with the given filter token to access this data cube.
        :paramtype filter_token: str
        :keyword rollup: Whether the associated table has rollup enabled.
        :paramtype rollup: bool
        :keyword options: Data cube options.
        :paramtype options: ~polaris.sdk.global_api.models.DataCubeOptions
        :keyword read_access: Access control list for read access to the data cube.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword restricted_edit_access: In some cases, you may need to limit a user's ability to edit
         aspects of a data cube;
         for example, to allow a user to modify dimensions but not to change the title or description.
        :paramtype restricted_edit_access: ~polaris.sdk.global_api.models.AccessList
        :keyword modify_access: Access control list for modifying this data cube.
        :paramtype modify_access: ~polaris.sdk.global_api.models.AccessList
        :keyword download_access: Access control list for downloading raw data from this data cube.
        :paramtype download_access: ~polaris.sdk.global_api.models.AccessList
        :keyword attributes: Column metadata for the associated data source.
        :paramtype attributes: list[~polaris.sdk.global_api.models.Attribute]
        :keyword dimensions: The dimensions of the data cube.
        :paramtype dimensions: list[~polaris.sdk.global_api.models.DimensionPayload]
        :keyword measures: Array of data cube measures.
        :paramtype measures: list[~polaris.sdk.global_api.models.MeasurePayload]
        :keyword instances: Data cube instances.
        :paramtype instances: ~polaris.sdk.global_api.models.DataCubeInstanceList
        :keyword special_time_dimension: Time dimension Polaris uses for all time-related calculations
         for the data cube, including comparisons, filters, alerts, and reports.
         Polarise uses this to check the freshness of data and apply time filters.
        :paramtype special_time_dimension: str
        :keyword enforce_time_filter: Ensures that every query is filtered on the primary time
         dimension.
         You can enable this setting if time unbounded queries are likely to be slow due to the volume
         of data.
        :paramtype enforce_time_filter: bool
        :keyword default_filter: Default filter to apply when visualizing the data cube.
        :paramtype default_filter: ~polaris.sdk.global_api.models.Filter
        :keyword default_timezone: Time zone to select when a user first opens the data cube, expressed
         as an `Olsen Timezone <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype default_timezone: str
        :keyword default_duration: Time period to display when a user first opens the data cube,
         expressed as an `ISO 8601 duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype default_duration: ~datetime.timedelta
        :keyword default_selected_measures: IDs of the measures to show by default in visualizations.
        :paramtype default_selected_measures: list[str]
        :keyword default_pinned_dimensions: IDs of the dimensions to pin by default in visualizations.
        :paramtype default_pinned_dimensions: list[str]
        :keyword default_refresh_rate: The default refresh rate for the data cube, expressed as an `ISO
         8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype default_refresh_rate: ~datetime.timedelta
        :keyword default_visualization: Name of the default visualization to use when initially viewing
         the data cube.
        :paramtype default_visualization: str
        :keyword default_having_filter: The default HAVING filter for the data cube.
        :paramtype default_having_filter: ~polaris.sdk.global_api.models.HavingFilter
        :keyword latest_data_strategy: Determines how Polaris calculates the latest data time for the
         data cube.
         By default, Polaris queries the data source for the latest time stamp on ingested data.
         You can set this property to always use the current time, which may be more appropriate for
         streaming data. Known values are: "query", "query-floored-P1D", and "predefined".
        :paramtype latest_data_strategy: str or ~polaris.sdk.global_api.models.LatestDataStrategy
        :keyword query_caching: Allow caching on queries made to this data cube. Caching can greatly
         speed up exploration but can
         also cause results to be a little out of date especially in realtime rolled up datasets. Known
         values are: "allow" and "disable".
        :paramtype query_caching: str or ~polaris.sdk.global_api.models.DataCubePayloadQueryCaching
        :keyword formulae_visibility: Hide or show dimension and measure formulae in info modals.
         Polaris displays formulae are by default. Users
         with appropriate permissions can still see formulae when editing. Known values are: "show" and
         "hide".
        :paramtype formulae_visibility: str or ~polaris.sdk.global_api.models.Visibility
        :keyword min_alert_frequency: Minimum allowable frequency for alerts associated with this data
         cube, expressed as an `ISO 8601 Duration <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_alert_frequency: ~datetime.timedelta
        :keyword min_alert_time_frame: Minimum allowable time frame for alerts associated with this
         data cube, expressed as an `ISO 8601 Duration
         <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
        :paramtype min_alert_time_frame: ~datetime.timedelta
        :keyword default_parameters: The default parameters to populate an Explore visualization.
        :paramtype default_parameters: str
        :keyword default_facet_splits: Default dimensions to split on.
        :paramtype default_facet_splits: list[any]
        :keyword default_facet_compare: Default comparison for the data cube.
        :paramtype default_facet_compare: ~polaris.sdk.global_api.models.FacetCompare
        :keyword custom_facet_compares: Customized comparisons for the data cube.
        :paramtype custom_facet_compares: list[~polaris.sdk.global_api.models.FacetCompare]
        :keyword require_group_filters: Enable this property to use access filters. When enabled, users
         who aren't assigned an access
         filter can't perform queries.
        :paramtype require_group_filters: bool
        :keyword allow_filter_combine: Determines the behaviour when a user is a member of two or more
         user groups with access filters applied.
         If ``true``\\ , Polaris combines the filters with the OR operator.
         If ``false``\\ , the user can't view any data in the data cube.
        :paramtype allow_filter_combine: bool
        :keyword group_filters: Defines access filters for a user group.
        :paramtype group_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
        :keyword user_filters: Defines access filters for a Polaris API key.
        :paramtype user_filters: dict[str, ~polaris.sdk.global_api.models.GroupFilter]
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        """
        super().__init__(
            created_at=created_at,
            created_by=created_by,
            updated_at=updated_at,
            updated_by=updated_by,
            additional_properties=additional_properties,
            id=id,
            title=title,
            description=description,
            query_mode=query_mode,
            source=source,
            palette=palette,
            min_auto_refresh_rate=min_auto_refresh_rate,
            latest_time_filter_granularity=latest_time_filter_granularity,
            subset_formula=subset_formula,
            filter_token=filter_token,
            rollup=rollup,
            options=options,
            read_access=read_access,
            restricted_edit_access=restricted_edit_access,
            modify_access=modify_access,
            download_access=download_access,
            attributes=attributes,
            dimensions=dimensions,
            measures=measures,
            instances=instances,
            special_time_dimension=special_time_dimension,
            enforce_time_filter=enforce_time_filter,
            default_filter=default_filter,
            default_timezone=default_timezone,
            default_duration=default_duration,
            default_selected_measures=default_selected_measures,
            default_pinned_dimensions=default_pinned_dimensions,
            default_refresh_rate=default_refresh_rate,
            default_visualization=default_visualization,
            default_having_filter=default_having_filter,
            latest_data_strategy=latest_data_strategy,
            query_caching=query_caching,
            formulae_visibility=formulae_visibility,
            min_alert_frequency=min_alert_frequency,
            min_alert_time_frame=min_alert_time_frame,
            default_parameters=default_parameters,
            default_facet_splits=default_facet_splits,
            default_facet_compare=default_facet_compare,
            custom_facet_compares=custom_facet_compares,
            require_group_filters=require_group_filters,
            allow_filter_combine=allow_filter_combine,
            group_filters=group_filters,
            user_filters=user_filters,
            **kwargs
        )
        self.additional_properties = additional_properties
        self.id = id
        self.title = title
        self.description = description
        self.query_mode = query_mode
        self.source = source
        self.palette = palette
        self.min_auto_refresh_rate = min_auto_refresh_rate
        self.latest_time_filter_granularity = latest_time_filter_granularity
        self.subset_formula = subset_formula
        self.filter_token = filter_token
        self.rollup = rollup
        self.options = options
        self.read_access = read_access
        self.restricted_edit_access = restricted_edit_access
        self.modify_access = modify_access
        self.download_access = download_access
        self.attributes = attributes
        self.dimensions = dimensions
        self.measures = measures
        self.instances = instances
        self.special_time_dimension = special_time_dimension
        self.enforce_time_filter = enforce_time_filter
        self.default_filter = default_filter
        self.default_timezone = default_timezone
        self.default_duration = default_duration
        self.default_selected_measures = default_selected_measures
        self.default_pinned_dimensions = default_pinned_dimensions
        self.default_refresh_rate = default_refresh_rate
        self.default_visualization = default_visualization
        self.default_having_filter = default_having_filter
        self.latest_data_strategy = latest_data_strategy
        self.query_caching = query_caching
        self.formulae_visibility = formulae_visibility
        self.min_alert_frequency = min_alert_frequency
        self.min_alert_time_frame = min_alert_time_frame
        self.default_parameters = default_parameters
        self.default_facet_splits = default_facet_splits
        self.default_facet_compare = default_facet_compare
        self.custom_facet_compares = custom_facet_compares
        self.require_group_filters = require_group_filters
        self.allow_filter_combine = allow_filter_combine
        self.group_filters = group_filters
        self.user_filters = user_filters
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by


class DeleteDataJobResponse(JobResponse):
    """A delete data job response.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: Required. Known values are: "pending", "running", "completed", "idle",
     "canceled", "failed", "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobResponseExecutionStatus
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar spec: An abstract request to create a job. Required.
    :vartype spec: ~polaris.sdk.global_api.models.CreateJobRequest
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    :ivar delete_all: Set to true to delete all data for this table. The table itself is not
     dropped.
    :vartype delete_all: bool
    :ivar versions: List of segment versions in the specified interval to restore or delete.
    :vartype versions: list[str]
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True, "readonly": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "spec": {"required": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "spec": {"key": "spec", "type": "CreateJobRequest"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
        "delete_all": {"key": "deleteAll", "type": "bool"},
        "versions": {"key": "versions", "type": "[str]"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        spec: "_models.CreateJobRequest",
        target: "_models.JobTargetV2",
        delete_all: bool = False,
        versions: Optional[List[str]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword spec: An abstract request to create a job. Required.
        :paramtype spec: ~polaris.sdk.global_api.models.CreateJobRequest
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        :keyword delete_all: Set to true to delete all data for this table. The table itself is not
         dropped.
        :paramtype delete_all: bool
        :keyword versions: List of segment versions in the specified interval to restore or delete.
        :paramtype versions: list[str]
        """
        super().__init__(
            desired_execution_status=desired_execution_status,
            spec=spec,
            target=target,
            **kwargs
        )
        self.type: str = "delete_data"
        self.delete_all = delete_all
        self.versions = versions


class DeleteDataJobSummaryResponse(JobSummaryResponse):
    """A data deletion job, targeting either an interval of data in a table or, if ``deleteAll`` is
    set, all data in the table.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: The execution status of the job.


     * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
     awaiting resources.
     * ``running``   - The job is currently in progress.
     * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
     warnings or errors.
     * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
     to ingest.
     * ``canceled``  - The job was canceled by the user.
     * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
     the failure.
     * ``suspended`` - The job is suspended by the user.
     * ``unknown``   - The execution status of the job is not known. This state typically occurs
     when a downstream error prevents retrieval of the job execution status. If a job persists in
     this state for an extended period of time (more than a few minutes), please contact Imply.
     Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
     "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        execution_status: Union[str, "_models.JobExecutionStatusV2"],
        target: "_models.JobTargetV2",
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword execution_status: The execution status of the job.


         * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
         awaiting resources.
         * ``running``   - The job is currently in progress.
         * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
         warnings or errors.
         * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
         to ingest.
         * ``canceled``  - The job was canceled by the user.
         * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
         the failure.
         * ``suspended`` - The job is suspended by the user.
         * ``unknown``   - The execution status of the job is not known. This state typically occurs
         when a downstream error prevents retrieval of the job execution status. If a job persists in
         this state for an extended period of time (more than a few minutes), please contact Imply.
         Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
         "suspended", and "unknown".
        :paramtype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        """
        super().__init__(
            desired_execution_status=desired_execution_status,
            execution_status=execution_status,
            target=target,
            **kwargs
        )
        self.type: str = "delete_data"


class Delivery(_serialization.Model):
    """Delivery configuration for a report.

    All required parameters must be populated in order to send to server.

    :ivar frequency_type: A ``fixed`` frequency was chosen from a predefined list in the Polaris
     UI. A ``custom`` frequency was entered manually. Known values are: "fixed" and "custom".
    :vartype frequency_type: str or ~polaris.sdk.global_api.models.DeliveryFrequencyType
    :ivar frequency: Delivery interval, expressed as an `ISO 8601 duration
     <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_. Required.
    :vartype frequency: ~datetime.timedelta
    :ivar day_type: For frequencies that span one month or more, you can choose whether to deliver
     the report on a
     numbered day of the month (\\ ``of-month``\\ ) or on the first specified weekday of the month
     (\\ ``of-week``\\ ).
     Examples:


     * `dayType`: `of-month` and `day`: ``15`` delivers the report on the 15th day of the month.
     * `dayType`: `of-week` and `day`: 1` delivers the report on the first Monday of the month.
     Known values are: "of-month" and "of-week".
    :vartype day_type: str or ~polaris.sdk.global_api.models.DeliveryDayType
    :ivar day: Numbered day of the interval specified in ``dayType``. For frequencies of one day or
     less, this property is not relevant. When ``dayType`` is set to ``of-month``\\ , set this
     property to a number between ``1`` and ``31``. When ``dayType``
     is to set ``of-week``\\ , set this property to a number between ``1`` and ``7`` (where 1 is
     Monday and 7 is Sunday). Required.
    :vartype day: float
    :ivar time: Hour of the day to deliver the report. Set this property to a number between ``0``
     and ``23`` (where 0 is midnight and 23 is 11pm).
    :vartype time: float
    """

    _validation = {
        "frequency": {"required": True},
        "day": {"required": True, "maximum": 31, "minimum": 1},
        "time": {"maximum": 23, "minimum": 0},
    }

    _attribute_map = {
        "frequency_type": {"key": "frequencyType", "type": "str"},
        "frequency": {"key": "frequency", "type": "duration"},
        "day_type": {"key": "dayType", "type": "str"},
        "day": {"key": "day", "type": "float"},
        "time": {"key": "time", "type": "float"},
    }

    def __init__(
        self,
        *,
        frequency: datetime.timedelta,
        day: float,
        frequency_type: Union[str, "_models.DeliveryFrequencyType"] = "fixed",
        day_type: Optional[Union[str, "_models.DeliveryDayType"]] = None,
        time: Optional[float] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword frequency_type: A ``fixed`` frequency was chosen from a predefined list in the Polaris
         UI. A ``custom`` frequency was entered manually. Known values are: "fixed" and "custom".
        :paramtype frequency_type: str or ~polaris.sdk.global_api.models.DeliveryFrequencyType
        :keyword frequency: Delivery interval, expressed as an `ISO 8601 duration
         <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_. Required.
        :paramtype frequency: ~datetime.timedelta
        :keyword day_type: For frequencies that span one month or more, you can choose whether to
         deliver the report on a
         numbered day of the month (\\ ``of-month``\\ ) or on the first specified weekday of the month
         (\\ ``of-week``\\ ).
         Examples:


         * `dayType`: `of-month` and `day`: ``15`` delivers the report on the 15th day of the month.
         * `dayType`: `of-week` and `day`: 1` delivers the report on the first Monday of the month.
         Known values are: "of-month" and "of-week".
        :paramtype day_type: str or ~polaris.sdk.global_api.models.DeliveryDayType
        :keyword day: Numbered day of the interval specified in ``dayType``. For frequencies of one day
         or
         less, this property is not relevant. When ``dayType`` is set to ``of-month``\\ , set this
         property to a number between ``1`` and ``31``. When ``dayType``
         is to set ``of-week``\\ , set this property to a number between ``1`` and ``7`` (where 1 is
         Monday and 7 is Sunday). Required.
        :paramtype day: float
        :keyword time: Hour of the day to deliver the report. Set this property to a number between
         ``0`` and ``23`` (where 0 is midnight and 23 is 11pm).
        :paramtype time: float
        """
        super().__init__(**kwargs)
        self.frequency_type = frequency_type
        self.frequency = frequency
        self.day_type = day_type
        self.day = day
        self.time = time


class DetailTableColumn(_serialization.Model):
    """A column of a ``detail`` type table.

    All required parameters must be populated in order to send to server.

    :ivar name: The name of the table column. Required.
    :vartype name: str
    :ivar data_type: The expected data type of the column. Reserve the ``timestamp`` data type for
     the primary timestamp column ``__time``. Required. Known values are: "bigint", "complex<json>",
     "double", "float", "geo", "HLLSketch", "ipAddress", "ipPrefix", "json", "long",
     "longStringPair", "doubleArray", "floatArray", "longArray", "stringArray",
     "quantilesDoublesSketch", "string", "thetaSketch", "ingest_timeseries", "timestamp", "varchar",
     and "variance".
    :vartype data_type: str or ~polaris.sdk.global_api.models.TableColumnDataType
    """

    _validation = {
        "name": {"required": True},
        "data_type": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "data_type": {"key": "dataType", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        data_type: Union[str, "_models.TableColumnDataType"],
        **kwargs: Any
    ) -> None:
        """
        :keyword name: The name of the table column. Required.
        :paramtype name: str
        :keyword data_type: The expected data type of the column. Reserve the ``timestamp`` data type
         for the primary timestamp column ``__time``. Required. Known values are: "bigint",
         "complex<json>", "double", "float", "geo", "HLLSketch", "ipAddress", "ipPrefix", "json",
         "long", "longStringPair", "doubleArray", "floatArray", "longArray", "stringArray",
         "quantilesDoublesSketch", "string", "thetaSketch", "ingest_timeseries", "timestamp", "varchar",
         and "variance".
        :paramtype data_type: str or ~polaris.sdk.global_api.models.TableColumnDataType
        """
        super().__init__(**kwargs)
        self.name = name
        self.data_type = data_type


class DetailTablePayload(TablePayload):
    """A detail table is a standard table where each row of input data is stored as a row in the
    table.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar name: The unique, immutable name of the table. Required.
    :vartype name: str
    :ivar type: Visualization type. Required. Known values are: "table", "detail", and "aggregate".
    :vartype type: str or ~polaris.sdk.global_api.models.TableType
    :ivar version: The version number of the table. Newly created tables are always initialized at
     version 0. Do not provide the version number when creating a table. When updating a table,
     provide the current table version number. If the version number in the request is not the
     current version, Polaris raises a ``409 Conflict`` error. In that case, retrieve the latest
     version and retry the request to avoid concurrently conflicting changes. Required.
    :vartype version: int
    :ivar availability: The availability status of the table:


     * ``available``   - All data in table is available for querying.
     * ``deleting``    - The table is being deleted.
     * ``unavailable`` - Not all data in the table is available for querying. Known values are:
     "available", "deleting", and "unavailable".
    :vartype availability: str or ~polaris.sdk.global_api.models.TableAvailability
    :ivar clustering_columns: Table columns to use for clustering. Polaris sorts table columns
     within the partition based
     on their order in this array.

     For aggregate tables, only dimensions (not measures) are supported for clustering.
     If a nonexistent column is specified, Polaris raises a ``400 Bad Request``
     error.

     For more information, see `Clustering
     <https://docs.imply.io/ui/saas/help/partitioning.html>`_.
    :vartype clustering_columns: list[str]
    :ivar created_by_user: The user who created the initial object.
    :vartype created_by_user: ~polaris.sdk.global_api.models.CreatedByUserResponse
    :ivar created_on_timestamp: The date and time this object was created in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype created_on_timestamp: ~datetime.datetime
    :ivar description: The table's description, limited to 1000 characters.
    :vartype description: str
    :ivar id: A generated, permanently unique ID for this table.
    :vartype id: str
    :ivar modified_by_user: The user who modified the object last.
    :vartype modified_by_user: ~polaris.sdk.global_api.models.ModifiedByUserResponse
    :ivar modified_on_timestamp: The date and time this table was last modified in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype modified_on_timestamp: ~datetime.datetime
    :ivar partitioning_granularity: The `time partitioning
     <https://docs.imply.io/ui/saas/help/partitioning.html>`_ of the table. The ``all`` granularity
     groups all data into a single bucket. The ``week`` granularity is deprecated. You can't create
     a new table with the time partitioning set to ``week``. A table sourced by a lookup can only
     use all partitioning. You can’t change this setting on a table that’s actively used by a
     lookup. Known values are: "second", "minute", "five_minute", "ten_minute", "fifteen_minute",
     "thirty_minute", "hour", "six_hour", "eight_hour", "day", "week", "month", "quarter", "year",
     and "all".
    :vartype partitioning_granularity: str or
     ~polaris.sdk.global_api.models.TablePartitioningGranularity
    :ivar queryable_schema: The queryable schema of the table. May include undeclared columns (in
     flexible tables only) or declared columns (in strict or flexible tables).
    :vartype queryable_schema: list[~polaris.sdk.global_api.models.DruidTableColumn]
    :ivar storage_policy: Policy specifying the time range of data to retain or precache.


     * The ``retain`` storage policy determines how long to keep data after which it is deleted.
     * The ``cached`` storage policy determines how long to keep data precached.
       Outside of the ``cached`` policy time range, data isn't precached and only resides in lower
     cost deep storage.

     By default, Polaris retains all data and precaches all data.
     You can’t set a custom storage policy for a table that’s actively used by a lookup.
     For more information, see
     `Data lifecycle management
     <https://docs.imply.io/ui/saas/help/data-lifecycle-management.html>`_.
    :vartype storage_policy: ~polaris.sdk.global_api.models.TableStoragePolicy
    :ivar schema_mode: The table's schema enforcement mode. For more information, see `Introduction
     to tables <https://docs.imply.io/ui/saas/help/tables.html>`_. Known values are: "flexible" and
     "strict".
    :vartype schema_mode: str or ~polaris.sdk.global_api.models.TableSchemaMode
    :ivar segment_compacted_bytes: Total compacted bytes of the table.
    :vartype segment_compacted_bytes: int
    :ivar segment_count: The number of segments in the table.
    :vartype segment_count: int
    :ivar segment_total_bytes: Total bytes of the table.
    :vartype segment_total_bytes: int
    :ivar precached_data_size_bytes: The total size of the table in bytes.
    :vartype precached_data_size_bytes: int
    :ivar total_data_size_bytes: The total size of the table in bytes.
    :vartype total_data_size_bytes: int
    :ivar total_rows: The total number of rows stored in the table.
    :vartype total_rows: int
    :ivar schema: The schema of the table. The order of the columns determines the order of the
     columns in the Polaris UI and in ``SELECT *`` SQL queries.
    :vartype schema: list[~polaris.sdk.global_api.models.DetailTableColumn]
    """

    _validation = {
        "name": {"required": True, "max_length": 255, "min_length": 1},
        "type": {"required": True},
        "version": {"required": True},
        "availability": {"readonly": True},
        "created_by_user": {"readonly": True},
        "created_on_timestamp": {"readonly": True},
        "id": {"readonly": True},
        "modified_by_user": {"readonly": True},
        "modified_on_timestamp": {"readonly": True},
        "queryable_schema": {"readonly": True},
        "segment_compacted_bytes": {"readonly": True},
        "segment_count": {"readonly": True},
        "segment_total_bytes": {"readonly": True},
        "precached_data_size_bytes": {"readonly": True},
        "total_data_size_bytes": {"readonly": True},
        "total_rows": {"readonly": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "version": {"key": "version", "type": "int"},
        "availability": {"key": "availability", "type": "str"},
        "clustering_columns": {"key": "clusteringColumns", "type": "[str]"},
        "created_by_user": {"key": "createdByUser", "type": "CreatedByUserResponse"},
        "created_on_timestamp": {"key": "createdOnTimestamp", "type": "iso-8601"},
        "description": {"key": "description", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "modified_by_user": {"key": "modifiedByUser", "type": "ModifiedByUserResponse"},
        "modified_on_timestamp": {"key": "modifiedOnTimestamp", "type": "iso-8601"},
        "partitioning_granularity": {"key": "partitioningGranularity", "type": "str"},
        "queryable_schema": {"key": "queryableSchema", "type": "[DruidTableColumn]"},
        "storage_policy": {"key": "storagePolicy", "type": "TableStoragePolicy"},
        "schema_mode": {"key": "schemaMode", "type": "str"},
        "segment_compacted_bytes": {"key": "segmentCompactedBytes", "type": "int"},
        "segment_count": {"key": "segmentCount", "type": "int"},
        "segment_total_bytes": {"key": "segmentTotalBytes", "type": "int"},
        "precached_data_size_bytes": {"key": "precachedDataSizeBytes", "type": "int"},
        "total_data_size_bytes": {"key": "totalDataSizeBytes", "type": "int"},
        "total_rows": {"key": "totalRows", "type": "int"},
        "schema": {"key": "schema", "type": "[DetailTableColumn]"},
    }

    def __init__(
        self,
        *,
        name: str,
        version: int = 0,
        clustering_columns: Optional[List[str]] = None,
        description: Optional[str] = None,
        partitioning_granularity: Union[
            str, "_models.TablePartitioningGranularity"
        ] = "day",
        storage_policy: Optional["_models.TableStoragePolicy"] = None,
        schema_mode: Optional[Union[str, "_models.TableSchemaMode"]] = None,
        schema: List["_models.DetailTableColumn"] = [],
        **kwargs: Any
    ) -> None:
        """
        :keyword name: The unique, immutable name of the table. Required.
        :paramtype name: str
        :keyword version: The version number of the table. Newly created tables are always initialized
         at version 0. Do not provide the version number when creating a table. When updating a table,
         provide the current table version number. If the version number in the request is not the
         current version, Polaris raises a ``409 Conflict`` error. In that case, retrieve the latest
         version and retry the request to avoid concurrently conflicting changes. Required.
        :paramtype version: int
        :keyword clustering_columns: Table columns to use for clustering. Polaris sorts table columns
         within the partition based
         on their order in this array.

         For aggregate tables, only dimensions (not measures) are supported for clustering.
         If a nonexistent column is specified, Polaris raises a ``400 Bad Request``
         error.

         For more information, see `Clustering
         <https://docs.imply.io/ui/saas/help/partitioning.html>`_.
        :paramtype clustering_columns: list[str]
        :keyword description: The table's description, limited to 1000 characters.
        :paramtype description: str
        :keyword partitioning_granularity: The `time partitioning
         <https://docs.imply.io/ui/saas/help/partitioning.html>`_ of the table. The ``all`` granularity
         groups all data into a single bucket. The ``week`` granularity is deprecated. You can't create
         a new table with the time partitioning set to ``week``. A table sourced by a lookup can only
         use all partitioning. You can’t change this setting on a table that’s actively used by a
         lookup. Known values are: "second", "minute", "five_minute", "ten_minute", "fifteen_minute",
         "thirty_minute", "hour", "six_hour", "eight_hour", "day", "week", "month", "quarter", "year",
         and "all".
        :paramtype partitioning_granularity: str or
         ~polaris.sdk.global_api.models.TablePartitioningGranularity
        :keyword storage_policy: Policy specifying the time range of data to retain or precache.


         * The ``retain`` storage policy determines how long to keep data after which it is deleted.
         * The ``cached`` storage policy determines how long to keep data precached.
           Outside of the ``cached`` policy time range, data isn't precached and only resides in lower
         cost deep storage.

         By default, Polaris retains all data and precaches all data.
         You can’t set a custom storage policy for a table that’s actively used by a lookup.
         For more information, see
         `Data lifecycle management
         <https://docs.imply.io/ui/saas/help/data-lifecycle-management.html>`_.
        :paramtype storage_policy: ~polaris.sdk.global_api.models.TableStoragePolicy
        :keyword schema_mode: The table's schema enforcement mode. For more information, see
         `Introduction to tables <https://docs.imply.io/ui/saas/help/tables.html>`_. Known values are:
         "flexible" and "strict".
        :paramtype schema_mode: str or ~polaris.sdk.global_api.models.TableSchemaMode
        :keyword schema: The schema of the table. The order of the columns determines the order of the
         columns in the Polaris UI and in ``SELECT *`` SQL queries.
        :paramtype schema: list[~polaris.sdk.global_api.models.DetailTableColumn]
        """
        super().__init__(
            name=name,
            version=version,
            clustering_columns=clustering_columns,
            description=description,
            partitioning_granularity=partitioning_granularity,
            storage_policy=storage_policy,
            schema_mode=schema_mode,
            **kwargs
        )
        self.type: str = "detail"
        self.schema = schema


class Digest(_serialization.Model):
    """The hash of the file's content as computed by the specified algorithm.

    All required parameters must be populated in order to send to server.

    :ivar algo: The algorithm used to hash the file's content. Required. "md5"
    :vartype algo: str or ~polaris.sdk.global_api.models.DigestAlgo
    :ivar hash: The hash of the file's content generated with the given ``algo``. Required.
    :vartype hash: str
    """

    _validation = {
        "algo": {"required": True},
        "hash": {"required": True},
    }

    _attribute_map = {
        "algo": {"key": "algo", "type": "str"},
        "hash": {"key": "hash", "type": "str"},
    }

    def __init__(
        self, *, algo: Union[str, "_models.DigestAlgo"], hash: str, **kwargs: Any
    ) -> None:
        """
        :keyword algo: The algorithm used to hash the file's content. Required. "md5"
        :paramtype algo: str or ~polaris.sdk.global_api.models.DigestAlgo
        :keyword hash: The hash of the file's content generated with the given ``algo``. Required.
        :paramtype hash: str
        """
        super().__init__(**kwargs)
        self.algo = algo
        self.hash = hash


class Dimension(_serialization.Model):
    """Dimension.

    All required parameters must be populated in order to send to server.

    :ivar name: Required.
    :vartype name: str
    :ivar sort_by_measure: ID of the measure to sort by.
    :vartype sort_by_measure: str
    :ivar sort_ascending: Sets the sort direction to ascending.
    :vartype sort_ascending: bool
    :ivar limit: Limit on the number of results.
    :vartype limit: float
    :ivar overall: Displays an "Overall" row showing the sum total of the chosen measure. Known
     values are: "auto", "hide", and "show".
    :vartype overall: str or ~polaris.sdk.global_api.models.DimensionOverall
    :ivar others: Displays an "Other" row showing sum total of the measure for all the dimension
     values that were cut off by the limit. Known values are: "auto", "hide", and "show".
    :vartype others: str or ~polaris.sdk.global_api.models.DimensionOthers
    """

    _validation = {
        "name": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "sort_by_measure": {"key": "sortByMeasure", "type": "str"},
        "sort_ascending": {"key": "sortAscending", "type": "bool"},
        "limit": {"key": "limit", "type": "float"},
        "overall": {"key": "overall", "type": "str"},
        "others": {"key": "others", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        sort_by_measure: Optional[str] = None,
        sort_ascending: Optional[bool] = None,
        limit: Optional[float] = None,
        overall: Optional[Union[str, "_models.DimensionOverall"]] = None,
        others: Optional[Union[str, "_models.DimensionOthers"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Required.
        :paramtype name: str
        :keyword sort_by_measure: ID of the measure to sort by.
        :paramtype sort_by_measure: str
        :keyword sort_ascending: Sets the sort direction to ascending.
        :paramtype sort_ascending: bool
        :keyword limit: Limit on the number of results.
        :paramtype limit: float
        :keyword overall: Displays an "Overall" row showing the sum total of the chosen measure. Known
         values are: "auto", "hide", and "show".
        :paramtype overall: str or ~polaris.sdk.global_api.models.DimensionOverall
        :keyword others: Displays an "Other" row showing sum total of the measure for all the dimension
         values that were cut off by the limit. Known values are: "auto", "hide", and "show".
        :paramtype others: str or ~polaris.sdk.global_api.models.DimensionOthers
        """
        super().__init__(**kwargs)
        self.name = name
        self.sort_by_measure = sort_by_measure
        self.sort_ascending = sort_ascending
        self.limit = limit
        self.overall = overall
        self.others = others


class DimensionListResponse(_serialization.Model):
    """A list of data cube dimensions.

    All required parameters must be populated in order to send to server.

    :ivar values: Array of data cube dimensions. Required.
    :vartype values: list[~polaris.sdk.global_api.models.DimensionListResponseValuesItem]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[DimensionListResponseValuesItem]"},
    }

    def __init__(
        self, *, values: List["_models.DimensionListResponseValuesItem"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Array of data cube dimensions. Required.
        :paramtype values: list[~polaris.sdk.global_api.models.DimensionListResponseValuesItem]
        """
        super().__init__(**kwargs)
        self.values = values


class DimensionPayload(_serialization.Model):
    """Dimensions correspond to data columns in the data source. In a data cube, you can show and
    filter data using dimensions.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar title: Dimension title.
    :vartype title: str
    :ivar description: Dimension description.
    :vartype description: str
    :ivar group: Dimensions with the same value for this property are grouped together in the
     dimensions panel.
    :vartype group: str
    :ivar formula: SQL expression for the dimension. Refer to the associated Polaris table by its
     alias "t".
    :vartype formula: str
    :ivar type: Specific data type for a dimension. For IP Prefix dimensions, use the ``IP`` data
     type
     and set ``ipPrefix``\\ : ``true`` on the dimension. Known values are: "TIME", "STRING",
     "SET/STRING", "NUMBER", "BOOLEAN", "IP", and "TIME_SERIES".
    :vartype type: str or ~polaris.sdk.global_api.models.DimensionType
    :ivar geo: Indicates that this is a geographic dimension. You must also provide a valid
     ``geoEncoding`` and
     set the dimension ``type``.
    :vartype geo: bool
    :ivar geo_encoding: The geo encoding type for a dimension. Geo dimensions require specific data
     types to be set
     depending on the geo encoding type. For ``lat-coordinate`` or ``lng-coordinate`` dimensions,
         set the type to ``number``. For all other geo encodings, set the type to ``string``. Known
     values are: "ISO 3166-1 Alpha-2", "ISO 3166-1 Alpha-3", "ISO 3166-2", "UN M49", "Geohash",
     "lng-coordinate", and "lat-coordinate".
    :vartype geo_encoding: str or ~polaris.sdk.global_api.models.GeoEncodingType
    :ivar ip_prefix: Store the dimension as a complex data type representing an IP prefix. Requires
     the ``IP`` dimension
     type.
    :vartype ip_prefix: bool
    :ivar format: Date/time format to use for TIME dimensions. See `MomentJS docs
     <https://momentjs.com/docs/?/displaying/format/#/displaying/>`_
     for more information.
    :vartype format: str
    :ivar url: URL transformation for string dimensions. Polaris interpolates the provided string
     and
     replaces ``%s`` with the dimension value.
    :vartype url: str
    :ivar granularities: Preset bucketing granularities for time and numeric dimensions.
    :vartype granularities: list[any]
    :ivar bucketing_strategy: The bucketing strategy for a dimension. Known values are:
     "defaultBucket", "defaultNoBucket", "neverBucket", and "alwaysBucket".
    :vartype bucketing_strategy: str or ~polaris.sdk.global_api.models.BucketingStrategy
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "group": {"key": "group", "type": "str"},
        "formula": {"key": "formula", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "geo": {"key": "geo", "type": "bool"},
        "geo_encoding": {"key": "geoEncoding", "type": "str"},
        "ip_prefix": {"key": "ipPrefix", "type": "bool"},
        "format": {"key": "format", "type": "str"},
        "url": {"key": "url", "type": "str"},
        "granularities": {"key": "granularities", "type": "[object]"},
        "bucketing_strategy": {"key": "bucketingStrategy", "type": "str"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        title: Optional[str] = None,
        description: Optional[str] = None,
        group: Optional[str] = None,
        formula: Optional[str] = None,
        type: Optional[Union[str, "_models.DimensionType"]] = None,
        geo: Optional[bool] = None,
        geo_encoding: Optional[Union[str, "_models.GeoEncodingType"]] = None,
        ip_prefix: Optional[bool] = None,
        format: Optional[str] = None,
        url: Optional[str] = None,
        granularities: Optional[List[Any]] = None,
        bucketing_strategy: Optional[Union[str, "_models.BucketingStrategy"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword title: Dimension title.
        :paramtype title: str
        :keyword description: Dimension description.
        :paramtype description: str
        :keyword group: Dimensions with the same value for this property are grouped together in the
         dimensions panel.
        :paramtype group: str
        :keyword formula: SQL expression for the dimension. Refer to the associated Polaris table by
         its alias "t".
        :paramtype formula: str
        :keyword type: Specific data type for a dimension. For IP Prefix dimensions, use the ``IP``
         data type
         and set ``ipPrefix``\\ : ``true`` on the dimension. Known values are: "TIME", "STRING",
         "SET/STRING", "NUMBER", "BOOLEAN", "IP", and "TIME_SERIES".
        :paramtype type: str or ~polaris.sdk.global_api.models.DimensionType
        :keyword geo: Indicates that this is a geographic dimension. You must also provide a valid
         ``geoEncoding`` and
         set the dimension ``type``.
        :paramtype geo: bool
        :keyword geo_encoding: The geo encoding type for a dimension. Geo dimensions require specific
         data types to be set
         depending on the geo encoding type. For ``lat-coordinate`` or ``lng-coordinate`` dimensions,
             set the type to ``number``. For all other geo encodings, set the type to ``string``. Known
         values are: "ISO 3166-1 Alpha-2", "ISO 3166-1 Alpha-3", "ISO 3166-2", "UN M49", "Geohash",
         "lng-coordinate", and "lat-coordinate".
        :paramtype geo_encoding: str or ~polaris.sdk.global_api.models.GeoEncodingType
        :keyword ip_prefix: Store the dimension as a complex data type representing an IP prefix.
         Requires the ``IP`` dimension
         type.
        :paramtype ip_prefix: bool
        :keyword format: Date/time format to use for TIME dimensions. See `MomentJS docs
         <https://momentjs.com/docs/?/displaying/format/#/displaying/>`_
         for more information.
        :paramtype format: str
        :keyword url: URL transformation for string dimensions. Polaris interpolates the provided
         string and
         replaces ``%s`` with the dimension value.
        :paramtype url: str
        :keyword granularities: Preset bucketing granularities for time and numeric dimensions.
        :paramtype granularities: list[any]
        :keyword bucketing_strategy: The bucketing strategy for a dimension. Known values are:
         "defaultBucket", "defaultNoBucket", "neverBucket", and "alwaysBucket".
        :paramtype bucketing_strategy: str or ~polaris.sdk.global_api.models.BucketingStrategy
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.title = title
        self.description = description
        self.group = group
        self.formula = formula
        self.type = type
        self.geo = geo
        self.geo_encoding = geo_encoding
        self.ip_prefix = ip_prefix
        self.format = format
        self.url = url
        self.granularities = granularities
        self.bucketing_strategy = bucketing_strategy


class DimensionListResponseValuesItem(DimensionPayload):
    """DimensionListResponseValuesItem.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar title: Dimension title.
    :vartype title: str
    :ivar description: Dimension description.
    :vartype description: str
    :ivar group: Dimensions with the same value for this property are grouped together in the
     dimensions panel.
    :vartype group: str
    :ivar formula: SQL expression for the dimension. Refer to the associated Polaris table by its
     alias "t".
    :vartype formula: str
    :ivar type: Specific data type for a dimension. For IP Prefix dimensions, use the ``IP`` data
     type
     and set ``ipPrefix``\\ : ``true`` on the dimension. Known values are: "TIME", "STRING",
     "SET/STRING", "NUMBER", "BOOLEAN", "IP", and "TIME_SERIES".
    :vartype type: str or ~polaris.sdk.global_api.models.DimensionType
    :ivar geo: Indicates that this is a geographic dimension. You must also provide a valid
     ``geoEncoding`` and
     set the dimension ``type``.
    :vartype geo: bool
    :ivar geo_encoding: The geo encoding type for a dimension. Geo dimensions require specific data
     types to be set
     depending on the geo encoding type. For ``lat-coordinate`` or ``lng-coordinate`` dimensions,
         set the type to ``number``. For all other geo encodings, set the type to ``string``. Known
     values are: "ISO 3166-1 Alpha-2", "ISO 3166-1 Alpha-3", "ISO 3166-2", "UN M49", "Geohash",
     "lng-coordinate", and "lat-coordinate".
    :vartype geo_encoding: str or ~polaris.sdk.global_api.models.GeoEncodingType
    :ivar ip_prefix: Store the dimension as a complex data type representing an IP prefix. Requires
     the ``IP`` dimension
     type.
    :vartype ip_prefix: bool
    :ivar format: Date/time format to use for TIME dimensions. See `MomentJS docs
     <https://momentjs.com/docs/?/displaying/format/#/displaying/>`_
     for more information.
    :vartype format: str
    :ivar url: URL transformation for string dimensions. Polaris interpolates the provided string
     and
     replaces ``%s`` with the dimension value.
    :vartype url: str
    :ivar granularities: Preset bucketing granularities for time and numeric dimensions.
    :vartype granularities: list[any]
    :ivar bucketing_strategy: The bucketing strategy for a dimension. Known values are:
     "defaultBucket", "defaultNoBucket", "neverBucket", and "alwaysBucket".
    :vartype bucketing_strategy: str or ~polaris.sdk.global_api.models.BucketingStrategy
    """


class DimensionResponse(DimensionPayload):
    """DimensionResponse.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar title: Dimension title.
    :vartype title: str
    :ivar description: Dimension description.
    :vartype description: str
    :ivar group: Dimensions with the same value for this property are grouped together in the
     dimensions panel.
    :vartype group: str
    :ivar formula: SQL expression for the dimension. Refer to the associated Polaris table by its
     alias "t".
    :vartype formula: str
    :ivar type: Specific data type for a dimension. For IP Prefix dimensions, use the ``IP`` data
     type
     and set ``ipPrefix``\\ : ``true`` on the dimension. Known values are: "TIME", "STRING",
     "SET/STRING", "NUMBER", "BOOLEAN", "IP", and "TIME_SERIES".
    :vartype type: str or ~polaris.sdk.global_api.models.DimensionType
    :ivar geo: Indicates that this is a geographic dimension. You must also provide a valid
     ``geoEncoding`` and
     set the dimension ``type``.
    :vartype geo: bool
    :ivar geo_encoding: The geo encoding type for a dimension. Geo dimensions require specific data
     types to be set
     depending on the geo encoding type. For ``lat-coordinate`` or ``lng-coordinate`` dimensions,
         set the type to ``number``. For all other geo encodings, set the type to ``string``. Known
     values are: "ISO 3166-1 Alpha-2", "ISO 3166-1 Alpha-3", "ISO 3166-2", "UN M49", "Geohash",
     "lng-coordinate", and "lat-coordinate".
    :vartype geo_encoding: str or ~polaris.sdk.global_api.models.GeoEncodingType
    :ivar ip_prefix: Store the dimension as a complex data type representing an IP prefix. Requires
     the ``IP`` dimension
     type.
    :vartype ip_prefix: bool
    :ivar format: Date/time format to use for TIME dimensions. See `MomentJS docs
     <https://momentjs.com/docs/?/displaying/format/#/displaying/>`_
     for more information.
    :vartype format: str
    :ivar url: URL transformation for string dimensions. Polaris interpolates the provided string
     and
     replaces ``%s`` with the dimension value.
    :vartype url: str
    :ivar granularities: Preset bucketing granularities for time and numeric dimensions.
    :vartype granularities: list[any]
    :ivar bucketing_strategy: The bucketing strategy for a dimension. Known values are:
     "defaultBucket", "defaultNoBucket", "neverBucket", and "alwaysBucket".
    :vartype bucketing_strategy: str or ~polaris.sdk.global_api.models.BucketingStrategy
    """


class DivergingColorPalette(_serialization.Model):
    """Color palette to apply to Heatmap visualizations only.

    :ivar baseline_color: A single color to apply to zero values in Heatmap visualizations (=0).
    :vartype baseline_color: str
    :ivar range_start_color: A single color to apply to the positive data range in Heatmap
     visualizations (>0).
    :vartype range_start_color: str
    :ivar range_end_color: A single color to apply to for the negative data range in Heatmap
     visualizations (<0).
    :vartype range_end_color: str
    """

    _validation = {
        "baseline_color": {"pattern": r"^#[\da-fA-F]{6}$"},
        "range_start_color": {"pattern": r"^#[\da-fA-F]{6}$"},
        "range_end_color": {"pattern": r"^#[\da-fA-F]{6}$"},
    }

    _attribute_map = {
        "baseline_color": {"key": "baselineColor", "type": "str"},
        "range_start_color": {"key": "rangeStartColor", "type": "str"},
        "range_end_color": {"key": "rangeEndColor", "type": "str"},
    }

    def __init__(
        self,
        *,
        baseline_color: Optional[str] = None,
        range_start_color: Optional[str] = None,
        range_end_color: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword baseline_color: A single color to apply to zero values in Heatmap visualizations (=0).
        :paramtype baseline_color: str
        :keyword range_start_color: A single color to apply to the positive data range in Heatmap
         visualizations (>0).
        :paramtype range_start_color: str
        :keyword range_end_color: A single color to apply to for the negative data range in Heatmap
         visualizations (<0).
        :paramtype range_end_color: str
        """
        super().__init__(**kwargs)
        self.baseline_color = baseline_color
        self.range_start_color = range_start_color
        self.range_end_color = range_end_color


class DropTableJobResponse(JobResponse):
    """A drop table job response.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: Required. Known values are: "pending", "running", "completed", "idle",
     "canceled", "failed", "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobResponseExecutionStatus
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar spec: An abstract request to create a job. Required.
    :vartype spec: ~polaris.sdk.global_api.models.CreateJobRequest
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True, "readonly": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "spec": {"required": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "spec": {"key": "spec", "type": "CreateJobRequest"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        spec: "_models.CreateJobRequest",
        target: "_models.JobTargetV2",
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword spec: An abstract request to create a job. Required.
        :paramtype spec: ~polaris.sdk.global_api.models.CreateJobRequest
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        """
        super().__init__(
            desired_execution_status=desired_execution_status,
            spec=spec,
            target=target,
            **kwargs
        )
        self.type: str = "drop_table"


class DropTableJobSummaryResponse(JobSummaryResponse):
    """Drops a table and deletes of all its data. The table will not exist after this job completes.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: The execution status of the job.


     * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
     awaiting resources.
     * ``running``   - The job is currently in progress.
     * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
     warnings or errors.
     * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
     to ingest.
     * ``canceled``  - The job was canceled by the user.
     * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
     the failure.
     * ``suspended`` - The job is suspended by the user.
     * ``unknown``   - The execution status of the job is not known. This state typically occurs
     when a downstream error prevents retrieval of the job execution status. If a job persists in
     this state for an extended period of time (more than a few minutes), please contact Imply.
     Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
     "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        execution_status: Union[str, "_models.JobExecutionStatusV2"],
        target: "_models.JobTargetV2",
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword execution_status: The execution status of the job.


         * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
         awaiting resources.
         * ``running``   - The job is currently in progress.
         * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
         warnings or errors.
         * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
         to ingest.
         * ``canceled``  - The job was canceled by the user.
         * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
         the failure.
         * ``suspended`` - The job is suspended by the user.
         * ``unknown``   - The execution status of the job is not known. This state typically occurs
         when a downstream error prevents retrieval of the job execution status. If a job persists in
         this state for an extended period of time (more than a few minutes), please contact Imply.
         Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
         "suspended", and "unknown".
        :paramtype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        """
        super().__init__(
            desired_execution_status=desired_execution_status,
            execution_status=execution_status,
            target=target,
            **kwargs
        )
        self.type: str = "drop_table"


class DruidTableColumn(_serialization.Model):
    """A column of a queryable schema in Druid.

    All required parameters must be populated in order to send to server.

    :ivar data_type: The expected data type of the column. Reserve the ``timestamp`` data type for
     the primary timestamp column ``__time``. Required. Known values are: "bigint", "complex<json>",
     "double", "float", "geo", "HLLSketch", "ipAddress", "ipPrefix", "json", "long",
     "longStringPair", "doubleArray", "floatArray", "longArray", "stringArray",
     "quantilesDoublesSketch", "string", "thetaSketch", "ingest_timeseries", "timestamp", "varchar",
     and "variance".
    :vartype data_type: str or ~polaris.sdk.global_api.models.TableColumnDataType
    :ivar is_discovered: Whether Polaris automatically discovered the column during ingestion. If
     true, this column is an undeclared column. Required.
    :vartype is_discovered: bool
    :ivar name: The name of the table column. Required.
    :vartype name: str
    """

    _validation = {
        "data_type": {"required": True},
        "is_discovered": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "data_type": {"key": "dataType", "type": "str"},
        "is_discovered": {"key": "isDiscovered", "type": "bool"},
        "name": {"key": "name", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_type: Union[str, "_models.TableColumnDataType"],
        is_discovered: bool,
        name: str,
        **kwargs: Any
    ) -> None:
        """
        :keyword data_type: The expected data type of the column. Reserve the ``timestamp`` data type
         for the primary timestamp column ``__time``. Required. Known values are: "bigint",
         "complex<json>", "double", "float", "geo", "HLLSketch", "ipAddress", "ipPrefix", "json",
         "long", "longStringPair", "doubleArray", "floatArray", "longArray", "stringArray",
         "quantilesDoublesSketch", "string", "thetaSketch", "ingest_timeseries", "timestamp", "varchar",
         and "variance".
        :paramtype data_type: str or ~polaris.sdk.global_api.models.TableColumnDataType
        :keyword is_discovered: Whether Polaris automatically discovered the column during ingestion.
         If true, this column is an undeclared column. Required.
        :paramtype is_discovered: bool
        :keyword name: The name of the table column. Required.
        :paramtype name: str
        """
        super().__init__(**kwargs)
        self.data_type = data_type
        self.is_discovered = is_discovered
        self.name = name


class EmbeddedBubbleChartVisualization(_serialization.Model):
    """EmbeddedBubbleChartVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "bubble-chart"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedBubbleChartVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar bubbles: Dimensions to be shown by the bubbles. Required.
    :vartype bubbles: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 2},
        "bubbles": {"required": True, "max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "bubbles": {"key": "bubbles", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        bubbles: List[Any],
        type: Optional[
            Union[str, "_models.EmbeddedBubbleChartVisualizationType"]
        ] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "bubble-chart"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedBubbleChartVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword bubbles: Dimensions to be shown by the bubbles. Required.
        :paramtype bubbles: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.bubbles = bubbles
        self.timezone = timezone


class EmbeddedGeoMarksVisualization(_serialization.Model):
    """EmbeddedGeoMarksVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "geo-marks"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedGeoMarksVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar markers: Dimensions to be shown by the markers. Required.
    :vartype markers: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "markers": {"required": True, "max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "markers": {"key": "markers", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        markers: List[Any],
        type: Optional[Union[str, "_models.EmbeddedGeoMarksVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "geo-marks"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedGeoMarksVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword markers: Dimensions to be shown by the markers. Required.
        :paramtype markers: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.markers = markers
        self.timezone = timezone


class EmbeddedGeoShadeVisualization(_serialization.Model):
    """EmbeddedGeoShadeVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "geo-shade"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedGeoShadeVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar markers: Dimensions to be shown by the markers. Required.
    :vartype markers: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "markers": {"required": True, "max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "markers": {"key": "markers", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        markers: List[Any],
        type: Optional[Union[str, "_models.EmbeddedGeoShadeVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "geo-shade"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedGeoShadeVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword markers: Dimensions to be shown by the markers. Required.
        :paramtype markers: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.markers = markers
        self.timezone = timezone


class EmbeddedHeatMapVisualization(_serialization.Model):
    """EmbeddedHeatMapVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "heatmap"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedHeatMapVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar rows: Dimensions to be displayed in the rows. Required.
    :vartype rows: list[any]
    :ivar columns: Dimensions to be displayed in the columns.
    :vartype columns: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "rows": {"required": True, "max_items": 1, "min_items": 1},
        "columns": {"max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "rows": {"key": "rows", "type": "[object]"},
        "columns": {"key": "columns", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        rows: List[Any],
        type: Optional[Union[str, "_models.EmbeddedHeatMapVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        columns: Optional[List[Any]] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "heatmap"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedHeatMapVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword rows: Dimensions to be displayed in the rows. Required.
        :paramtype rows: list[any]
        :keyword columns: Dimensions to be displayed in the columns.
        :paramtype columns: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.rows = rows
        self.columns = columns
        self.timezone = timezone


class EmbeddedHorizontalBarsVisualization(_serialization.Model):
    """EmbeddedHorizontalBarsVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "horizontal-bars"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedHorizontalBarsVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar bars: Dimensions to be shown by the bars. Required.
    :vartype bars: list[any]
    :ivar stack: Dimensions to be shown by the stack.
    :vartype stack: list[any]
    :ivar multiples: Dimensions to be shown by the multiples.
    :vartype multiples: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "bars": {"required": True, "max_items": 1, "min_items": 1},
        "stack": {"max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "bars": {"key": "bars", "type": "[object]"},
        "stack": {"key": "stack", "type": "[object]"},
        "multiples": {"key": "multiples", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        bars: List[Any],
        type: Optional[
            Union[str, "_models.EmbeddedHorizontalBarsVisualizationType"]
        ] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        stack: Optional[List[Any]] = None,
        multiples: Optional[List[Any]] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "horizontal-bars"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedHorizontalBarsVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword bars: Dimensions to be shown by the bars. Required.
        :paramtype bars: list[any]
        :keyword stack: Dimensions to be shown by the stack.
        :paramtype stack: list[any]
        :keyword multiples: Dimensions to be shown by the multiples.
        :paramtype multiples: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.bars = bars
        self.stack = stack
        self.multiples = multiples
        self.timezone = timezone


class EmbeddedLineChartVisualization(_serialization.Model):
    """EmbeddedLineChartVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Visualization type. "line-chart"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedLineChartVisualizationType
    :ivar data_cube: Data cube ID. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to apply to the visualization. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar line: Dimensions to show in line. Required.
    :vartype line: list[any]
    :ivar layer: Dimensions to show in layers.
    :vartype layer: list[any]
    :ivar multiples: Dimensions to show in multiples.
    :vartype multiples: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "line": {"required": True, "max_items": 1, "min_items": 0},
        "layer": {"max_items": 1, "min_items": 0},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "line": {"key": "line", "type": "[object]"},
        "layer": {"key": "layer", "type": "[object]"},
        "multiples": {"key": "multiples", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        line: List[Any],
        type: Optional[Union[str, "_models.EmbeddedLineChartVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        layer: Optional[List[Any]] = None,
        multiples: Optional[List[Any]] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Visualization type. "line-chart"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedLineChartVisualizationType
        :keyword data_cube: Data cube ID. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to apply to the visualization. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword line: Dimensions to show in line. Required.
        :paramtype line: list[any]
        :keyword layer: Dimensions to show in layers.
        :paramtype layer: list[any]
        :keyword multiples: Dimensions to show in multiples.
        :paramtype multiples: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.line = line
        self.layer = layer
        self.multiples = multiples
        self.timezone = timezone


class EmbeddedPathTreeVisualization(_serialization.Model):
    """EmbeddedPathTreeVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "path-tree"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedPathTreeVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar group: Dimensions to be shown by the group. Required.
    :vartype group: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "group": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "group": {"key": "group", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        group: List[Any],
        type: Optional[Union[str, "_models.EmbeddedPathTreeVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "path-tree"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedPathTreeVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword group: Dimensions to be shown by the group. Required.
        :paramtype group: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.group = group
        self.timezone = timezone


class EmbeddedPieChartVisualization(_serialization.Model):
    """EmbeddedPieChartVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "pie-chart"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedPieChartVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar layout: Dimensions to be shown by the layout. Required.
    :vartype layout: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "layout": {"required": True, "max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "layout": {"key": "layout", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        layout: List[Any],
        type: Optional[Union[str, "_models.EmbeddedPieChartVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "pie-chart"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedPieChartVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword layout: Dimensions to be shown by the layout. Required.
        :paramtype layout: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.layout = layout
        self.timezone = timezone


class EmbeddedRawVisualization(_serialization.Model):
    """EmbeddedRawVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "raw"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedRawVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        type: Optional[Union[str, "_models.EmbeddedRawVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "raw"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedRawVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.timezone = timezone


class EmbeddedSankeyVisualization(_serialization.Model):
    """EmbeddedSankeyVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "sankey"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedSankeyVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar left: Dimensions to be shown on the left. Required.
    :vartype left: list[any]
    :ivar right: Dimensions to be shown on the right. Required.
    :vartype right: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "left": {"required": True, "max_items": 1, "min_items": 1},
        "right": {"required": True, "max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "left": {"key": "left", "type": "[object]"},
        "right": {"key": "right", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        left: List[Any],
        right: List[Any],
        type: Optional[Union[str, "_models.EmbeddedSankeyVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "sankey"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedSankeyVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword left: Dimensions to be shown on the left. Required.
        :paramtype left: list[any]
        :keyword right: Dimensions to be shown on the right. Required.
        :paramtype right: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.left = left
        self.right = right
        self.timezone = timezone


class EmbeddedSparkLineVisualization(_serialization.Model):
    """EmbeddedSparkLineVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "spark-line"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedSparkLineVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar line: Dimensions to be shown by the line. Required.
    :vartype line: list[any]
    :ivar rows: Dimensions to be displayed in the rows.
    :vartype rows: list[any]
    :ivar columns: Dimensions to be displayed in the columns.
    :vartype columns: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "line": {"required": True, "max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "line": {"key": "line", "type": "[object]"},
        "rows": {"key": "rows", "type": "[object]"},
        "columns": {"key": "columns", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        line: List[Any],
        type: Optional[Union[str, "_models.EmbeddedSparkLineVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        rows: Optional[List[Any]] = None,
        columns: Optional[List[Any]] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "spark-line"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedSparkLineVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword line: Dimensions to be shown by the line. Required.
        :paramtype line: list[any]
        :keyword rows: Dimensions to be displayed in the rows.
        :paramtype rows: list[any]
        :keyword columns: Dimensions to be displayed in the columns.
        :paramtype columns: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.line = line
        self.rows = rows
        self.columns = columns
        self.timezone = timezone


class EmbeddedSpotMatrixVisualization(_serialization.Model):
    """EmbeddedSpotMatrixVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "spot-matrix"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedSpotMatrixVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar rows: Dimensions to be displayed in the rows. Required.
    :vartype rows: list[any]
    :ivar columns: Dimensions to be displayed in the columns.
    :vartype columns: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "rows": {"required": True, "max_items": 1, "min_items": 1},
        "columns": {"max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "rows": {"key": "rows", "type": "[object]"},
        "columns": {"key": "columns", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        rows: List[Any],
        type: Optional[
            Union[str, "_models.EmbeddedSpotMatrixVisualizationType"]
        ] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        columns: Optional[List[Any]] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "spot-matrix"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedSpotMatrixVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword rows: Dimensions to be displayed in the rows. Required.
        :paramtype rows: list[any]
        :keyword columns: Dimensions to be displayed in the columns.
        :paramtype columns: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.rows = rows
        self.columns = columns
        self.timezone = timezone


class EmbeddedStackAreaChartVisualization(_serialization.Model):
    """EmbeddedStackAreaChartVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "stack-area-chart"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedStackAreaChartVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar line: Dimensions to be shown by the line. Required.
    :vartype line: list[any]
    :ivar stack: Dimensions to be shown by the stack.
    :vartype stack: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "line": {"required": True, "max_items": 1, "min_items": 1},
        "stack": {"max_items": 1, "min_items": 0},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "line": {"key": "line", "type": "[object]"},
        "stack": {"key": "stack", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        line: List[Any],
        type: Optional[
            Union[str, "_models.EmbeddedStackAreaChartVisualizationType"]
        ] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        stack: Optional[List[Any]] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "stack-area-chart"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedStackAreaChartVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword line: Dimensions to be shown by the line. Required.
        :paramtype line: list[any]
        :keyword stack: Dimensions to be shown by the stack.
        :paramtype stack: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.line = line
        self.stack = stack
        self.timezone = timezone


class EmbeddedSunburstVisualization(_serialization.Model):
    """EmbeddedSunburstVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "sunburst"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedSunburstVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar layout: Dimensions to be shown by the layout. Required.
    :vartype layout: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "layout": {"required": True, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "layout": {"key": "layout", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        layout: List[Any],
        type: Optional[Union[str, "_models.EmbeddedSunburstVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "sunburst"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedSunburstVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword layout: Dimensions to be shown by the layout. Required.
        :paramtype layout: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.layout = layout
        self.timezone = timezone


class EmbeddedTableVisualization(_serialization.Model):
    """EmbeddedTableVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Visualization type. "table"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedTableVisualizationType
    :ivar data_cube: Data cube ID. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to apply to the visualization. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar rows: Dimensions to display in rows. Required.
    :vartype rows: list[any]
    :ivar columns: Dimensions to display in columns.
    :vartype columns: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "rows": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "rows": {"key": "rows", "type": "[object]"},
        "columns": {"key": "columns", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        rows: List[Any],
        type: Optional[Union[str, "_models.EmbeddedTableVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        columns: Optional[List[Any]] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Visualization type. "table"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedTableVisualizationType
        :keyword data_cube: Data cube ID. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to apply to the visualization. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword rows: Dimensions to display in rows. Required.
        :paramtype rows: list[any]
        :keyword columns: Dimensions to display in columns.
        :paramtype columns: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.rows = rows
        self.columns = columns
        self.timezone = timezone


class EmbeddedTotalsVisualization(_serialization.Model):
    """EmbeddedTotalsVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "totals"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedTotalsVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        type: Optional[Union[str, "_models.EmbeddedTotalsVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "totals"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedTotalsVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.timezone = timezone


class EmbeddedTreeMapVisualization(_serialization.Model):
    """EmbeddedTreeMapVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "treemap"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedTreeMapVisualizationType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar layout: Dimensions to be shown by the layout. Required.
    :vartype layout: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "layout": {"required": True, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "layout": {"key": "layout", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        layout: List[Any],
        type: Optional[Union[str, "_models.EmbeddedTreeMapVisualizationType"]] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "treemap"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedTreeMapVisualizationType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword layout: Dimensions to be shown by the layout. Required.
        :paramtype layout: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.layout = layout
        self.timezone = timezone


class EmbeddedVerticalBarsVisualization(_serialization.Model):
    """EmbeddedVerticalBarsVisualization.

    All required parameters must be populated in order to send to server.

    :ivar type: Visualization type. "vertical-bars"
    :vartype type: str or ~polaris.sdk.global_api.models.EmbeddedVerticalBarsVisualizationType
    :ivar data_cube: Data cube ID. Required.
    :vartype data_cube: str
    :ivar filter: Array of filters to apply to the visualization.
    :vartype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison: Comparison for data cubes.
    :vartype comparison: ~polaris.sdk.global_api.models.FacetCompare
    :ivar bars: Dimensions to be shown by the bars. Required.
    :vartype bars: list[any]
    :ivar stack: Dimensions to be shown by the stack.
    :vartype stack: list[any]
    :ivar multiples: Dimensions to be shown by the multiples.
    :vartype multiples: list[any]
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "bars": {"required": True, "max_items": 1, "min_items": 1},
        "stack": {"max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "[EmbeddingFilterItem]"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "FacetCompare"},
        "bars": {"key": "bars", "type": "[object]"},
        "stack": {"key": "stack", "type": "[object]"},
        "multiples": {"key": "multiples", "type": "[object]"},
        "timezone": {"key": "timezone", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        bars: List[Any],
        type: Optional[
            Union[str, "_models.EmbeddedVerticalBarsVisualizationType"]
        ] = None,
        filter: Optional[
            List["_models.EmbeddingFilterItem"]
        ] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.FacetCompare"] = None,
        stack: Optional[List[Any]] = None,
        multiples: Optional[List[Any]] = None,
        timezone: str = "Etc/UTC",
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Visualization type. "vertical-bars"
        :paramtype type: str or ~polaris.sdk.global_api.models.EmbeddedVerticalBarsVisualizationType
        :keyword data_cube: Data cube ID. Required.
        :paramtype data_cube: str
        :keyword filter: Array of filters to apply to the visualization.
        :paramtype filter: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison: Comparison for data cubes.
        :paramtype comparison: ~polaris.sdk.global_api.models.FacetCompare
        :keyword bars: Dimensions to be shown by the bars. Required.
        :paramtype bars: list[any]
        :keyword stack: Dimensions to be shown by the stack.
        :paramtype stack: list[any]
        :keyword multiples: Dimensions to be shown by the multiples.
        :paramtype multiples: list[any]
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.bars = bars
        self.stack = stack
        self.multiples = multiples
        self.timezone = timezone


class EmbeddingBarChart(_serialization.Model):
    """EmbeddingBarChart.

    All required parameters must be populated in order to send to server.

    :ivar module_name: Required. "bar_chart"
    :vartype module_name: str or ~polaris.sdk.global_api.models.EmbeddingBarChartModuleName
    :ivar x_axis_split: ID of the dimension to show on the x-axis. Required.
    :vartype x_axis_split: any
    :ivar metrics: IDs of the measures to show as values. Required.
    :vartype metrics: list[str]
    :ivar stack: ID of the dimension to apply as a stack.
    :vartype stack: any
    :ivar chart_title: Title to display above the chart.
    :vartype chart_title: str
    :ivar group_stacks: Show stacked series as grouped instead of stacked.
    :vartype group_stacks: bool
    :ivar show_label_on_top_of_bars: Display the value on each bar.
    :vartype show_label_on_top_of_bars: bool
    :ivar legend_position: Specify the position of the legend. If undefined the legend displays in
     the top position. Known values are: "top", "bottom", "left", "right", and "none".
    :vartype legend_position: str or ~polaris.sdk.global_api.models.EmbeddingBarChartLegendPosition
    :ivar x_axis_customization: X-axis customizations.
    :vartype x_axis_customization:
     ~polaris.sdk.global_api.models.EmbeddingBarChartXAxisCustomization
    :ivar y_axis_customizations: Y-axis customizations.
    :vartype y_axis_customizations:
     list[~polaris.sdk.global_api.models.EmbeddingBarChartYAxisCustomizationsItem]
    :ivar grid_configuration: Spacing around the visualization.
    :vartype grid_configuration: ~polaris.sdk.global_api.models.EmbeddingBarChartGridConfiguration
    :ivar compare: ISO 8601 format duration to use for a relative time comparison.
    :vartype compare: str
    """

    _validation = {
        "module_name": {"required": True},
        "x_axis_split": {"required": True},
        "metrics": {"required": True},
    }

    _attribute_map = {
        "module_name": {"key": "moduleName", "type": "str"},
        "x_axis_split": {"key": "xAxisSplit", "type": "object"},
        "metrics": {"key": "metrics", "type": "[str]"},
        "stack": {"key": "stack", "type": "object"},
        "chart_title": {"key": "chartTitle", "type": "str"},
        "group_stacks": {"key": "groupStacks", "type": "bool"},
        "show_label_on_top_of_bars": {"key": "showLabelOnTopOfBars", "type": "bool"},
        "legend_position": {"key": "legendPosition", "type": "str"},
        "x_axis_customization": {
            "key": "xAxisCustomization",
            "type": "EmbeddingBarChartXAxisCustomization",
        },
        "y_axis_customizations": {
            "key": "yAxisCustomizations",
            "type": "[EmbeddingBarChartYAxisCustomizationsItem]",
        },
        "grid_configuration": {
            "key": "gridConfiguration",
            "type": "EmbeddingBarChartGridConfiguration",
        },
        "compare": {"key": "compare", "type": "str"},
    }

    def __init__(
        self,
        *,
        module_name: Union[str, "_models.EmbeddingBarChartModuleName"],
        x_axis_split: Any,
        metrics: List[str],
        stack: Optional[Any] = None,
        chart_title: Optional[str] = None,
        group_stacks: Optional[bool] = None,
        show_label_on_top_of_bars: Optional[bool] = None,
        legend_position: Optional[
            Union[str, "_models.EmbeddingBarChartLegendPosition"]
        ] = None,
        x_axis_customization: Optional[
            "_models.EmbeddingBarChartXAxisCustomization"
        ] = None,
        y_axis_customizations: Optional[
            List["_models.EmbeddingBarChartYAxisCustomizationsItem"]
        ] = None,
        grid_configuration: Optional[
            "_models.EmbeddingBarChartGridConfiguration"
        ] = None,
        compare: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword module_name: Required. "bar_chart"
        :paramtype module_name: str or ~polaris.sdk.global_api.models.EmbeddingBarChartModuleName
        :keyword x_axis_split: ID of the dimension to show on the x-axis. Required.
        :paramtype x_axis_split: any
        :keyword metrics: IDs of the measures to show as values. Required.
        :paramtype metrics: list[str]
        :keyword stack: ID of the dimension to apply as a stack.
        :paramtype stack: any
        :keyword chart_title: Title to display above the chart.
        :paramtype chart_title: str
        :keyword group_stacks: Show stacked series as grouped instead of stacked.
        :paramtype group_stacks: bool
        :keyword show_label_on_top_of_bars: Display the value on each bar.
        :paramtype show_label_on_top_of_bars: bool
        :keyword legend_position: Specify the position of the legend. If undefined the legend displays
         in the top position. Known values are: "top", "bottom", "left", "right", and "none".
        :paramtype legend_position: str or
         ~polaris.sdk.global_api.models.EmbeddingBarChartLegendPosition
        :keyword x_axis_customization: X-axis customizations.
        :paramtype x_axis_customization:
         ~polaris.sdk.global_api.models.EmbeddingBarChartXAxisCustomization
        :keyword y_axis_customizations: Y-axis customizations.
        :paramtype y_axis_customizations:
         list[~polaris.sdk.global_api.models.EmbeddingBarChartYAxisCustomizationsItem]
        :keyword grid_configuration: Spacing around the visualization.
        :paramtype grid_configuration:
         ~polaris.sdk.global_api.models.EmbeddingBarChartGridConfiguration
        :keyword compare: ISO 8601 format duration to use for a relative time comparison.
        :paramtype compare: str
        """
        super().__init__(**kwargs)
        self.module_name = module_name
        self.x_axis_split = x_axis_split
        self.metrics = metrics
        self.stack = stack
        self.chart_title = chart_title
        self.group_stacks = group_stacks
        self.show_label_on_top_of_bars = show_label_on_top_of_bars
        self.legend_position = legend_position
        self.x_axis_customization = x_axis_customization
        self.y_axis_customizations = y_axis_customizations
        self.grid_configuration = grid_configuration
        self.compare = compare


class EmbeddingBarChartGridConfiguration(_serialization.Model):
    """Spacing around the visualization.

    :ivar top: Padding on top of the chart in pixels.
    :vartype top: float
    :ivar right: Padding to the right of the chart in pixels.
    :vartype right: float
    :ivar bottom: Padding underneath the chart in pixels.
    :vartype bottom: float
    :ivar left: Padding to the left of the chart in pixels.
    :vartype left: float
    """

    _attribute_map = {
        "top": {"key": "top", "type": "float"},
        "right": {"key": "right", "type": "float"},
        "bottom": {"key": "bottom", "type": "float"},
        "left": {"key": "left", "type": "float"},
    }

    def __init__(
        self,
        *,
        top: Optional[float] = None,
        right: Optional[float] = None,
        bottom: Optional[float] = None,
        left: Optional[float] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword top: Padding on top of the chart in pixels.
        :paramtype top: float
        :keyword right: Padding to the right of the chart in pixels.
        :paramtype right: float
        :keyword bottom: Padding underneath the chart in pixels.
        :paramtype bottom: float
        :keyword left: Padding to the left of the chart in pixels.
        :paramtype left: float
        """
        super().__init__(**kwargs)
        self.top = top
        self.right = right
        self.bottom = bottom
        self.left = left


class EmbeddingBarChartXAxisCustomization(_serialization.Model):
    """X-axis customizations.

    :ivar label_orientation: Orientation of the x-axis labels. Known values are: "horizontal",
     "auto", and "angled".
    :vartype label_orientation: str or
     ~polaris.sdk.global_api.models.EmbeddingBarChartXAxisCustomizationLabelOrientation
    :ivar title: Custom x-axis label.
    :vartype title: str
    """

    _attribute_map = {
        "label_orientation": {"key": "labelOrientation", "type": "str"},
        "title": {"key": "title", "type": "str"},
    }

    def __init__(
        self,
        *,
        label_orientation: Optional[
            Union[str, "_models.EmbeddingBarChartXAxisCustomizationLabelOrientation"]
        ] = None,
        title: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword label_orientation: Orientation of the x-axis labels. Known values are: "horizontal",
         "auto", and "angled".
        :paramtype label_orientation: str or
         ~polaris.sdk.global_api.models.EmbeddingBarChartXAxisCustomizationLabelOrientation
        :keyword title: Custom x-axis label.
        :paramtype title: str
        """
        super().__init__(**kwargs)
        self.label_orientation = label_orientation
        self.title = title


class EmbeddingBarChartYAxisCustomizationsItem(_serialization.Model):
    """EmbeddingBarChartYAxisCustomizationsItem.

    :ivar digits_after_decimal: Metric value precision.
    :vartype digits_after_decimal: float
    :ivar format: Numeric formatting and abbreviation type. Known values are: "raw", "si",
     "dollar", "dollar-raw", "byte", "byte-decimal", "byte-iec", "bit-per-second",
     "bit-per-second-decimal", "bit-per-second-iec", "percent", "percent-raw", "millisecond",
     "microsecond", "nanosecond", "milliwatt", "seconds-as-time", "duration", "duration-ago", and
     "time-format".
    :vartype format: str or ~polaris.sdk.global_api.models.AbbreviationType
    :ivar title: Custom y-axis label.
    :vartype title: str
    :ivar max: Maximum value to display on the y-axis.
    :vartype max: float
    :ivar min: Minimum value to display on the y-axis.
    :vartype min: float
    """

    _attribute_map = {
        "digits_after_decimal": {"key": "digitsAfterDecimal", "type": "float"},
        "format": {"key": "format", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "max": {"key": "max", "type": "float"},
        "min": {"key": "min", "type": "float"},
    }

    def __init__(
        self,
        *,
        digits_after_decimal: Optional[float] = None,
        format: Optional[Union[str, "_models.AbbreviationType"]] = None,
        title: Optional[str] = None,
        max: Optional[float] = None,  # pylint: disable=redefined-builtin
        min: Optional[float] = None,  # pylint: disable=redefined-builtin
        **kwargs: Any
    ) -> None:
        """
        :keyword digits_after_decimal: Metric value precision.
        :paramtype digits_after_decimal: float
        :keyword format: Numeric formatting and abbreviation type. Known values are: "raw", "si",
         "dollar", "dollar-raw", "byte", "byte-decimal", "byte-iec", "bit-per-second",
         "bit-per-second-decimal", "bit-per-second-iec", "percent", "percent-raw", "millisecond",
         "microsecond", "nanosecond", "milliwatt", "seconds-as-time", "duration", "duration-ago", and
         "time-format".
        :paramtype format: str or ~polaris.sdk.global_api.models.AbbreviationType
        :keyword title: Custom y-axis label.
        :paramtype title: str
        :keyword max: Maximum value to display on the y-axis.
        :paramtype max: float
        :keyword min: Minimum value to display on the y-axis.
        :paramtype min: float
        """
        super().__init__(**kwargs)
        self.digits_after_decimal = digits_after_decimal
        self.format = format
        self.title = title
        self.max = max
        self.min = min


class EmbeddingBooleanFilter(_serialization.Model):
    """A filter applied to a boolean dimension.

    :ivar filter_type: "boolean"
    :vartype filter_type: str or ~polaris.sdk.global_api.models.EmbeddingBooleanFilterType
    :ivar dimension:
    :vartype dimension: str
    :ivar value:
    :vartype value: bool
    """

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "dimension": {"key": "dimension", "type": "str"},
        "value": {"key": "value", "type": "bool"},
    }

    def __init__(
        self,
        *,
        filter_type: Optional[Union[str, "_models.EmbeddingBooleanFilterType"]] = None,
        dimension: Optional[str] = None,
        value: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword filter_type: "boolean"
        :paramtype filter_type: str or ~polaris.sdk.global_api.models.EmbeddingBooleanFilterType
        :keyword dimension:
        :paramtype dimension: str
        :keyword value:
        :paramtype value: bool
        """
        super().__init__(**kwargs)
        self.filter_type = filter_type
        self.dimension = dimension
        self.value = value


class EmbeddingDashboardDescription(_serialization.Model):
    """Object containing the properties of the dashboard to embed.

    All required parameters must be populated in order to send to server.

    :ivar dashboard: Dashboard ID. Required.
    :vartype dashboard: str
    :ivar filter_clauses: Array of filters to apply to the visualization.
    :vartype filter_clauses: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
    """

    _validation = {
        "dashboard": {"required": True},
    }

    _attribute_map = {
        "dashboard": {"key": "dashboard", "type": "str"},
        "filter_clauses": {"key": "filterClauses", "type": "[EmbeddingFilterItem]"},
    }

    def __init__(
        self,
        *,
        dashboard: str,
        filter_clauses: Optional[List["_models.EmbeddingFilterItem"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword dashboard: Dashboard ID. Required.
        :paramtype dashboard: str
        :keyword filter_clauses: Array of filters to apply to the visualization.
        :paramtype filter_clauses: list[~polaris.sdk.global_api.models.EmbeddingFilterItem]
        """
        super().__init__(**kwargs)
        self.dashboard = dashboard
        self.filter_clauses = filter_clauses


class EmbeddingDataCubeDescription(_serialization.Model):
    """Object describing the data cube to embed."""


class EmbeddingDimension(_serialization.Model):
    """EmbeddingDimension.

    All required parameters must be populated in order to send to server.

    :ivar name: Required.
    :vartype name: str
    :ivar sort_by_measure: ID of the measure to sort by.
    :vartype sort_by_measure: str
    :ivar sort_ascending: Sets the sort direction to assending.
    :vartype sort_ascending: bool
    :ivar limit: Limit on the number of results.
    :vartype limit: float
    :ivar overall: Displays an "Overall" row showing the sum total of the chosen measure. Known
     values are: "auto", "hide", and "show".
    :vartype overall: str or ~polaris.sdk.global_api.models.EmbeddingDimensionOverall
    :ivar others: Displays an "Other" row showing sum total of the measure for all the dimension
     values that were cut off by the limit. Known values are: "auto", "hide", and "show".
    :vartype others: str or ~polaris.sdk.global_api.models.EmbeddingDimensionOthers
    """

    _validation = {
        "name": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "sort_by_measure": {"key": "sortByMeasure", "type": "str"},
        "sort_ascending": {"key": "sortAscending", "type": "bool"},
        "limit": {"key": "limit", "type": "float"},
        "overall": {"key": "overall", "type": "str"},
        "others": {"key": "others", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        sort_by_measure: Optional[str] = None,
        sort_ascending: Optional[bool] = None,
        limit: Optional[float] = None,
        overall: Optional[Union[str, "_models.EmbeddingDimensionOverall"]] = None,
        others: Optional[Union[str, "_models.EmbeddingDimensionOthers"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Required.
        :paramtype name: str
        :keyword sort_by_measure: ID of the measure to sort by.
        :paramtype sort_by_measure: str
        :keyword sort_ascending: Sets the sort direction to assending.
        :paramtype sort_ascending: bool
        :keyword limit: Limit on the number of results.
        :paramtype limit: float
        :keyword overall: Displays an "Overall" row showing the sum total of the chosen measure. Known
         values are: "auto", "hide", and "show".
        :paramtype overall: str or ~polaris.sdk.global_api.models.EmbeddingDimensionOverall
        :keyword others: Displays an "Other" row showing sum total of the measure for all the dimension
         values that were cut off by the limit. Known values are: "auto", "hide", and "show".
        :paramtype others: str or ~polaris.sdk.global_api.models.EmbeddingDimensionOthers
        """
        super().__init__(**kwargs)
        self.name = name
        self.sort_by_measure = sort_by_measure
        self.sort_ascending = sort_ascending
        self.limit = limit
        self.overall = overall
        self.others = others


class EmbeddingExploreView(_serialization.Model):
    """An `explore visualization
    <https://docs.imply.io/polaris/visualizations/#explore-visualizations>`_ for the embedding
    link.

    All required parameters must be populated in order to send to server.

    :ivar data_cube: Identifies the associated data cube. Required.
    :vartype data_cube: str
    :ivar where: SQL WHERE expression to apply. Required.
    :vartype where: str
    :ivar having: SQL HAVING expression to apply.
    :vartype having: str
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    :ivar instance: Optional instance ID to use for the visualization.
    :vartype instance: str
    :ivar parameters: Configuration parameters for the explore visualizations. Required.
    :vartype parameters: ~polaris.sdk.global_api.models.EmbeddingExploreViewParameters
    """

    _validation = {
        "data_cube": {"required": True, "max_length": 255, "min_length": 1},
        "where": {"required": True},
        "parameters": {"required": True},
    }

    _attribute_map = {
        "data_cube": {"key": "dataCube", "type": "str"},
        "where": {"key": "where", "type": "str"},
        "having": {"key": "having", "type": "str"},
        "timezone": {"key": "timezone", "type": "str"},
        "instance": {"key": "instance", "type": "str"},
        "parameters": {"key": "parameters", "type": "EmbeddingExploreViewParameters"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        where: str,
        parameters: "_models.EmbeddingExploreViewParameters",
        having: Optional[str] = None,
        timezone: Optional[str] = None,
        instance: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword data_cube: Identifies the associated data cube. Required.
        :paramtype data_cube: str
        :keyword where: SQL WHERE expression to apply. Required.
        :paramtype where: str
        :keyword having: SQL HAVING expression to apply.
        :paramtype having: str
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        :keyword instance: Optional instance ID to use for the visualization.
        :paramtype instance: str
        :keyword parameters: Configuration parameters for the explore visualizations. Required.
        :paramtype parameters: ~polaris.sdk.global_api.models.EmbeddingExploreViewParameters
        """
        super().__init__(**kwargs)
        self.data_cube = data_cube
        self.where = where
        self.having = having
        self.timezone = timezone
        self.instance = instance
        self.parameters = parameters


class EmbeddingExploreViewParameters(_serialization.Model):
    """Configuration parameters for the explore visualizations."""


class EmbeddingFilterItem(_serialization.Model):
    """EmbeddingFilterItem."""


class EmbeddingFlatTableParameters(_serialization.Model):
    """EmbeddingFlatTableParameters.

    All required parameters must be populated in order to send to server.

    :ivar compares: ISO 8601 format duration to use for a relative time comparison.
    :vartype compares: list[str]
    :ivar dim_out_zeros: Order the results in descending order.
    :vartype dim_out_zeros: bool
    :ivar display_year: Whether to display the year in time values. Known values are: "auto",
     "always", and "never".
    :vartype display_year: str or
     ~polaris.sdk.global_api.models.EmbeddingFlatTableParametersDisplayYear
    :ivar max_rows: Maximum number of rows in the table.
    :vartype max_rows: float
    :ivar metrics: IDs of measures to show as metrics. Required.
    :vartype metrics: list[str]
    :ivar module_name: Visualization type. Required. "flat_table"
    :vartype module_name: str or
     ~polaris.sdk.global_api.models.EmbeddingFlatTableParametersModuleName
    :ivar multiple_value_mode: How to display data for columns with multiple values. Known values
     are: "None", "latest", "latestNonNull", and "count".
    :vartype multiple_value_mode: str or
     ~polaris.sdk.global_api.models.EmbeddingFlatTableParametersMultipleValueMode
    :ivar order_by_desc: Order the results in descending order.
    :vartype order_by_desc: bool
    :ivar order_by_index: Column index to order the results by.
    :vartype order_by_index: float
    :ivar pivot_column: ID of the dimension for which to display row values as columns.
    :vartype pivot_column: any
    :ivar show_columns: IDs of dimensions to display as columns but omit from Group By.
    :vartype show_columns: list[str]
    :ivar show_delta: If a comparison is set display the difference as its own column.
    :vartype show_delta: bool
    :ivar split_columns: IDs of dimensions to add to Group By.
    :vartype split_columns: list[any]
    :ivar sticky_columns: Pins Group By columns to the left.
    :vartype sticky_columns: bool
    """

    _validation = {
        "metrics": {"required": True},
        "module_name": {"required": True},
    }

    _attribute_map = {
        "compares": {"key": "compares", "type": "[str]"},
        "dim_out_zeros": {"key": "dimOutZeros", "type": "bool"},
        "display_year": {"key": "displayYear", "type": "str"},
        "max_rows": {"key": "maxRows", "type": "float"},
        "metrics": {"key": "metrics", "type": "[str]"},
        "module_name": {"key": "moduleName", "type": "str"},
        "multiple_value_mode": {"key": "multipleValueMode", "type": "str"},
        "order_by_desc": {"key": "orderByDesc", "type": "bool"},
        "order_by_index": {"key": "orderByIndex", "type": "float"},
        "pivot_column": {"key": "pivotColumn", "type": "object"},
        "show_columns": {"key": "showColumns", "type": "[str]"},
        "show_delta": {"key": "showDelta", "type": "bool"},
        "split_columns": {"key": "splitColumns", "type": "[object]"},
        "sticky_columns": {"key": "stickyColumns", "type": "bool"},
    }

    def __init__(
        self,
        *,
        metrics: List[str],
        module_name: Union[str, "_models.EmbeddingFlatTableParametersModuleName"],
        compares: Optional[List[str]] = None,
        dim_out_zeros: Optional[bool] = None,
        display_year: Optional[
            Union[str, "_models.EmbeddingFlatTableParametersDisplayYear"]
        ] = None,
        max_rows: Optional[float] = None,
        multiple_value_mode: Optional[
            Union[str, "_models.EmbeddingFlatTableParametersMultipleValueMode"]
        ] = None,
        order_by_desc: Optional[bool] = None,
        order_by_index: Optional[float] = None,
        pivot_column: Optional[Any] = None,
        show_columns: Optional[List[str]] = None,
        show_delta: Optional[bool] = None,
        split_columns: Optional[List[Any]] = None,
        sticky_columns: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword compares: ISO 8601 format duration to use for a relative time comparison.
        :paramtype compares: list[str]
        :keyword dim_out_zeros: Order the results in descending order.
        :paramtype dim_out_zeros: bool
        :keyword display_year: Whether to display the year in time values. Known values are: "auto",
         "always", and "never".
        :paramtype display_year: str or
         ~polaris.sdk.global_api.models.EmbeddingFlatTableParametersDisplayYear
        :keyword max_rows: Maximum number of rows in the table.
        :paramtype max_rows: float
        :keyword metrics: IDs of measures to show as metrics. Required.
        :paramtype metrics: list[str]
        :keyword module_name: Visualization type. Required. "flat_table"
        :paramtype module_name: str or
         ~polaris.sdk.global_api.models.EmbeddingFlatTableParametersModuleName
        :keyword multiple_value_mode: How to display data for columns with multiple values. Known
         values are: "None", "latest", "latestNonNull", and "count".
        :paramtype multiple_value_mode: str or
         ~polaris.sdk.global_api.models.EmbeddingFlatTableParametersMultipleValueMode
        :keyword order_by_desc: Order the results in descending order.
        :paramtype order_by_desc: bool
        :keyword order_by_index: Column index to order the results by.
        :paramtype order_by_index: float
        :keyword pivot_column: ID of the dimension for which to display row values as columns.
        :paramtype pivot_column: any
        :keyword show_columns: IDs of dimensions to display as columns but omit from Group By.
        :paramtype show_columns: list[str]
        :keyword show_delta: If a comparison is set display the difference as its own column.
        :paramtype show_delta: bool
        :keyword split_columns: IDs of dimensions to add to Group By.
        :paramtype split_columns: list[any]
        :keyword sticky_columns: Pins Group By columns to the left.
        :paramtype sticky_columns: bool
        """
        super().__init__(**kwargs)
        self.compares = compares
        self.dim_out_zeros = dim_out_zeros
        self.display_year = display_year
        self.max_rows = max_rows
        self.metrics = metrics
        self.module_name = module_name
        self.multiple_value_mode = multiple_value_mode
        self.order_by_desc = order_by_desc
        self.order_by_index = order_by_index
        self.pivot_column = pivot_column
        self.show_columns = show_columns
        self.show_delta = show_delta
        self.split_columns = split_columns
        self.sticky_columns = sticky_columns


class EmbeddingGaugeParameters(_serialization.Model):
    """EmbeddingGaugeParameters.

    All required parameters must be populated in order to send to server.

    :ivar color_label: Colors the label to match the color range.
    :vartype color_label: bool
    :ivar custom_label: Custom label to replace the measure name. Requires ``showCustomLabel`` to
     be set to ``true``.
    :vartype custom_label: str
    :ivar max: Maximum value to show on the gauge.
    :vartype max: float
    :ivar metric: Measure ID to show as metric. Required.
    :vartype metric: str
    :ivar min: Minimum value to show on the gauge.
    :vartype min: float
    :ivar module_name: Required. "gauge"
    :vartype module_name: str or ~polaris.sdk.global_api.models.EmbeddingGaugeParametersModuleName
    :ivar ranges: Color to show for a specific range on the gauge.
    :vartype ranges: list[~polaris.sdk.global_api.models.ExploreColorRange]
    :ivar show_as_percentage: Show the gauge value as a percent.
    :vartype show_as_percentage: bool
    :ivar show_custom_label: Show the custom label.
    :vartype show_custom_label: bool
    :ivar show_legend: Display a legend for the color ranges.
    :vartype show_legend: bool
    """

    _validation = {
        "metric": {"required": True},
        "module_name": {"required": True},
    }

    _attribute_map = {
        "color_label": {"key": "colorLabel", "type": "bool"},
        "custom_label": {"key": "customLabel", "type": "str"},
        "max": {"key": "max", "type": "float"},
        "metric": {"key": "metric", "type": "str"},
        "min": {"key": "min", "type": "float"},
        "module_name": {"key": "moduleName", "type": "str"},
        "ranges": {"key": "ranges", "type": "[ExploreColorRange]"},
        "show_as_percentage": {"key": "showAsPercentage", "type": "bool"},
        "show_custom_label": {"key": "showCustomLabel", "type": "bool"},
        "show_legend": {"key": "showLegend", "type": "bool"},
    }

    def __init__(
        self,
        *,
        metric: str,
        module_name: Union[str, "_models.EmbeddingGaugeParametersModuleName"],
        color_label: Optional[bool] = None,
        custom_label: Optional[str] = None,
        max: Optional[float] = None,  # pylint: disable=redefined-builtin
        min: Optional[float] = None,  # pylint: disable=redefined-builtin
        ranges: Optional[List["_models.ExploreColorRange"]] = None,
        show_as_percentage: Optional[bool] = None,
        show_custom_label: Optional[bool] = None,
        show_legend: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword color_label: Colors the label to match the color range.
        :paramtype color_label: bool
        :keyword custom_label: Custom label to replace the measure name. Requires ``showCustomLabel``
         to be set to ``true``.
        :paramtype custom_label: str
        :keyword max: Maximum value to show on the gauge.
        :paramtype max: float
        :keyword metric: Measure ID to show as metric. Required.
        :paramtype metric: str
        :keyword min: Minimum value to show on the gauge.
        :paramtype min: float
        :keyword module_name: Required. "gauge"
        :paramtype module_name: str or
         ~polaris.sdk.global_api.models.EmbeddingGaugeParametersModuleName
        :keyword ranges: Color to show for a specific range on the gauge.
        :paramtype ranges: list[~polaris.sdk.global_api.models.ExploreColorRange]
        :keyword show_as_percentage: Show the gauge value as a percent.
        :paramtype show_as_percentage: bool
        :keyword show_custom_label: Show the custom label.
        :paramtype show_custom_label: bool
        :keyword show_legend: Display a legend for the color ranges.
        :paramtype show_legend: bool
        """
        super().__init__(**kwargs)
        self.color_label = color_label
        self.custom_label = custom_label
        self.max = max
        self.metric = metric
        self.min = min
        self.module_name = module_name
        self.ranges = ranges
        self.show_as_percentage = show_as_percentage
        self.show_custom_label = show_custom_label
        self.show_legend = show_legend


class EmbeddingLineChartParameters(_serialization.Model):
    """EmbeddingLineChartParameters.

    All required parameters must be populated in order to send to server.

    :ivar chart_title: Custom chart title.
    :vartype chart_title: str
    :ivar color: Array of hex colors to use for each line on the chart.
    :vartype color: list[str]
    :ivar compare: ISO 8601 format duration to use for a relative time comparison.
    :vartype compare: str
    :ivar group_by: ID of dimension to add to multiples.
    :vartype group_by: any
    :ivar interpolate: How to fill missing data points. Known values are: "none", "zero",
     "previous", and "interpolate".
    :vartype interpolate: str or
     ~polaris.sdk.global_api.models.EmbeddingLineChartParametersInterpolate
    :ivar line_style: Line style to use in the chart. Known values are: "smooth", "line", and
     "step".
    :vartype line_style: str or
     ~polaris.sdk.global_api.models.EmbeddingLineChartParametersLineStyle
    :ivar metrics: IDs of measures to show as metrics. Required.
    :vartype metrics: list[str]
    :ivar module_name: Required. "line_chart"
    :vartype module_name: str or
     ~polaris.sdk.global_api.models.EmbeddingLineChartParametersModuleName
    :ivar points: Show or hide the point markers. Known values are: "hide" and "show".
    :vartype points: str or ~polaris.sdk.global_api.models.EmbeddingLineChartParametersPoints
    :ivar x_axis: ID of the dimension to show on the x-axis. Dimension must be of type TIME.
     Required.
    :vartype x_axis: any
    :ivar x_axis_customization: X-axis customizations.
    :vartype x_axis_customization:
     ~polaris.sdk.global_api.models.EmbeddingLineChartParametersXAxisCustomization
    :ivar y_axis_customizations: Y-axis customizations.
    :vartype y_axis_customizations:
     list[~polaris.sdk.global_api.models.EmbeddingLineChartParametersYAxisCustomizationsItem]
    """

    _validation = {
        "metrics": {"required": True},
        "module_name": {"required": True},
        "x_axis": {"required": True},
    }

    _attribute_map = {
        "chart_title": {"key": "chartTitle", "type": "str"},
        "color": {"key": "color", "type": "[str]"},
        "compare": {"key": "compare", "type": "str"},
        "group_by": {"key": "groupBy", "type": "object"},
        "interpolate": {"key": "interpolate", "type": "str"},
        "line_style": {"key": "lineStyle", "type": "str"},
        "metrics": {"key": "metrics", "type": "[str]"},
        "module_name": {"key": "moduleName", "type": "str"},
        "points": {"key": "points", "type": "str"},
        "x_axis": {"key": "xAxis", "type": "object"},
        "x_axis_customization": {
            "key": "xAxisCustomization",
            "type": "EmbeddingLineChartParametersXAxisCustomization",
        },
        "y_axis_customizations": {
            "key": "yAxisCustomizations",
            "type": "[EmbeddingLineChartParametersYAxisCustomizationsItem]",
        },
    }

    def __init__(
        self,
        *,
        metrics: List[str],
        module_name: Union[str, "_models.EmbeddingLineChartParametersModuleName"],
        x_axis: Any,
        chart_title: Optional[str] = None,
        color: Optional[List[str]] = None,
        compare: Optional[str] = None,
        group_by: Optional[Any] = None,
        interpolate: Optional[
            Union[str, "_models.EmbeddingLineChartParametersInterpolate"]
        ] = None,
        line_style: Optional[
            Union[str, "_models.EmbeddingLineChartParametersLineStyle"]
        ] = None,
        points: Optional[
            Union[str, "_models.EmbeddingLineChartParametersPoints"]
        ] = None,
        x_axis_customization: Optional[
            "_models.EmbeddingLineChartParametersXAxisCustomization"
        ] = None,
        y_axis_customizations: Optional[
            List["_models.EmbeddingLineChartParametersYAxisCustomizationsItem"]
        ] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword chart_title: Custom chart title.
        :paramtype chart_title: str
        :keyword color: Array of hex colors to use for each line on the chart.
        :paramtype color: list[str]
        :keyword compare: ISO 8601 format duration to use for a relative time comparison.
        :paramtype compare: str
        :keyword group_by: ID of dimension to add to multiples.
        :paramtype group_by: any
        :keyword interpolate: How to fill missing data points. Known values are: "none", "zero",
         "previous", and "interpolate".
        :paramtype interpolate: str or
         ~polaris.sdk.global_api.models.EmbeddingLineChartParametersInterpolate
        :keyword line_style: Line style to use in the chart. Known values are: "smooth", "line", and
         "step".
        :paramtype line_style: str or
         ~polaris.sdk.global_api.models.EmbeddingLineChartParametersLineStyle
        :keyword metrics: IDs of measures to show as metrics. Required.
        :paramtype metrics: list[str]
        :keyword module_name: Required. "line_chart"
        :paramtype module_name: str or
         ~polaris.sdk.global_api.models.EmbeddingLineChartParametersModuleName
        :keyword points: Show or hide the point markers. Known values are: "hide" and "show".
        :paramtype points: str or ~polaris.sdk.global_api.models.EmbeddingLineChartParametersPoints
        :keyword x_axis: ID of the dimension to show on the x-axis. Dimension must be of type TIME.
         Required.
        :paramtype x_axis: any
        :keyword x_axis_customization: X-axis customizations.
        :paramtype x_axis_customization:
         ~polaris.sdk.global_api.models.EmbeddingLineChartParametersXAxisCustomization
        :keyword y_axis_customizations: Y-axis customizations.
        :paramtype y_axis_customizations:
         list[~polaris.sdk.global_api.models.EmbeddingLineChartParametersYAxisCustomizationsItem]
        """
        super().__init__(**kwargs)
        self.chart_title = chart_title
        self.color = color
        self.compare = compare
        self.group_by = group_by
        self.interpolate = interpolate
        self.line_style = line_style
        self.metrics = metrics
        self.module_name = module_name
        self.points = points
        self.x_axis = x_axis
        self.x_axis_customization = x_axis_customization
        self.y_axis_customizations = y_axis_customizations


class EmbeddingLineChartParametersXAxisCustomization(
    _serialization.Model
):  # pylint: disable=name-too-long
    """X-axis customizations.

    :ivar label_orientation: Orientation of the x-axis labels. Known values are: "horizontal",
     "auto", and "angled".
    :vartype label_orientation: str or
     ~polaris.sdk.global_api.models.EmbeddingLineChartParametersXAxisCustomizationLabelOrientation
    :ivar title: Custom x-axis label.
    :vartype title: str
    """

    _attribute_map = {
        "label_orientation": {"key": "labelOrientation", "type": "str"},
        "title": {"key": "title", "type": "str"},
    }

    def __init__(
        self,
        *,
        label_orientation: Optional[
            Union[
                str,
                "_models.EmbeddingLineChartParametersXAxisCustomizationLabelOrientation",
            ]
        ] = None,
        title: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword label_orientation: Orientation of the x-axis labels. Known values are: "horizontal",
         "auto", and "angled".
        :paramtype label_orientation: str or
         ~polaris.sdk.global_api.models.EmbeddingLineChartParametersXAxisCustomizationLabelOrientation
        :keyword title: Custom x-axis label.
        :paramtype title: str
        """
        super().__init__(**kwargs)
        self.label_orientation = label_orientation
        self.title = title


class EmbeddingLineChartParametersYAxisCustomizationsItem(
    _serialization.Model
):  # pylint: disable=name-too-long
    """EmbeddingLineChartParametersYAxisCustomizationsItem.

    :ivar digits_after_decimal: Metric value precision.
    :vartype digits_after_decimal: float
    :ivar format: Numeric formatting and abbreviation type. Known values are: "raw", "si",
     "dollar", "dollar-raw", "byte", "byte-decimal", "byte-iec", "bit-per-second",
     "bit-per-second-decimal", "bit-per-second-iec", "percent", "percent-raw", "millisecond",
     "microsecond", "nanosecond", "milliwatt", "seconds-as-time", "duration", "duration-ago", and
     "time-format".
    :vartype format: str or ~polaris.sdk.global_api.models.AbbreviationType
    :ivar title: Custom y-axis label.
    :vartype title: str
    """

    _attribute_map = {
        "digits_after_decimal": {"key": "digitsAfterDecimal", "type": "float"},
        "format": {"key": "format", "type": "str"},
        "title": {"key": "title", "type": "str"},
    }

    def __init__(
        self,
        *,
        digits_after_decimal: Optional[float] = None,
        format: Optional[Union[str, "_models.AbbreviationType"]] = None,
        title: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword digits_after_decimal: Metric value precision.
        :paramtype digits_after_decimal: float
        :keyword format: Numeric formatting and abbreviation type. Known values are: "raw", "si",
         "dollar", "dollar-raw", "byte", "byte-decimal", "byte-iec", "bit-per-second",
         "bit-per-second-decimal", "bit-per-second-iec", "percent", "percent-raw", "millisecond",
         "microsecond", "nanosecond", "milliwatt", "seconds-as-time", "duration", "duration-ago", and
         "time-format".
        :paramtype format: str or ~polaris.sdk.global_api.models.AbbreviationType
        :keyword title: Custom y-axis label.
        :paramtype title: str
        """
        super().__init__(**kwargs)
        self.digits_after_decimal = digits_after_decimal
        self.format = format
        self.title = title


class EmbeddingLinkListResponse(_serialization.Model):
    """List of embedding link details.

    All required parameters must be populated in order to send to server.

    :ivar values: Array of embedding link details. Required.
    :vartype values: list[~polaris.sdk.global_api.models.EmbeddingLinkListResponseValuesItem]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[EmbeddingLinkListResponseValuesItem]"},
    }

    def __init__(
        self,
        *,
        values: List["_models.EmbeddingLinkListResponseValuesItem"],
        **kwargs: Any
    ) -> None:
        """
        :keyword values: Array of embedding link details. Required.
        :paramtype values: list[~polaris.sdk.global_api.models.EmbeddingLinkListResponseValuesItem]
        """
        super().__init__(**kwargs)
        self.values = values


class EmbeddingLinkRequestPayload(_serialization.Model):
    """Embedding link request properties.

    All required parameters must be populated in order to send to server.

    :ivar name: Name of the embedding link. Required.
    :vartype name: str
    :ivar description: Description of the embedding link.
    :vartype description: str
    :ivar view_description: Object containing the properties of the embedded view.
    :vartype view_description:
     ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadViewDescription
    :ivar explore_view: An `explore visualization
     <https://docs.imply.io/polaris/visualizations/#explore-visualizations>`_ for the embedding
     link.
    :vartype explore_view: ~polaris.sdk.global_api.models.EmbeddingExploreView
    :ivar layout: Show or hide the controls surrounding the visualization. Required. Known values
     are: "entire-view" and "visualization-only".
    :vartype layout: str or ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadLayout
    :ivar required_filter: SQL condition to apply to the underlying data. See `Create an access
     filter <https://docs.imply.io/polaris/embed-visualizations/#create-an-access-filter>`_ for more
     information.
    :vartype required_filter: str
    :ivar restricted: If set to true, a signature validated with the generated private key is
     required to access the link.
    :vartype restricted: bool
    :ivar ttl: Period of time in milliseconds for which the link is valid, after a user first
     accesses it. Applies to restricted links only. Defaults to 1 hour.
    :vartype ttl: float
    :ivar non_filterable_dimensions: Dimensions to exclude from the filter bar of the embedded
     visualization.
    :vartype non_filterable_dimensions: list[str]
    :ivar non_showable_dimensions: Dimensions to exclude from the show bar of the embedded
     visualization.
    :vartype non_showable_dimensions: list[str]
    :ivar non_showable_measures: Measures to exclude from the show bar of the embedded
     visualization.
    :vartype non_showable_measures: list[str]
    :ivar download_limit: Sets the maximum number of rows a user can download.
    :vartype download_limit: float
    :ivar enable_downloads: Enables downloading data from the embedding link. Users can download
     the number of rows specified in the ``downloadLimit`` property.
    :vartype enable_downloads: bool
    :ivar enable_async_downloads: Enables async downloads for the embedding link. Requires
     ``enableDownloads`` to be set to ``true``.
    :vartype enable_async_downloads: bool
    :ivar hide_fixed_time_filter: Set to ``true`` to hide the fixed time filter from the time
     filter UI in the embedded visualization. When ``false`` or omitted, the fixed time filter will
     be displayed.
    :vartype hide_fixed_time_filter: bool
    """

    _validation = {
        "name": {"required": True},
        "layout": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "view_description": {
            "key": "viewDescription",
            "type": "EmbeddingLinkRequestPayloadViewDescription",
        },
        "explore_view": {"key": "exploreView", "type": "EmbeddingExploreView"},
        "layout": {"key": "layout", "type": "str"},
        "required_filter": {"key": "requiredFilter", "type": "str"},
        "restricted": {"key": "restricted", "type": "bool"},
        "ttl": {"key": "ttl", "type": "float"},
        "non_filterable_dimensions": {
            "key": "nonFilterableDimensions",
            "type": "[str]",
        },
        "non_showable_dimensions": {"key": "nonShowableDimensions", "type": "[str]"},
        "non_showable_measures": {"key": "nonShowableMeasures", "type": "[str]"},
        "download_limit": {"key": "downloadLimit", "type": "float"},
        "enable_downloads": {"key": "enableDownloads", "type": "bool"},
        "enable_async_downloads": {"key": "enableAsyncDownloads", "type": "bool"},
        "hide_fixed_time_filter": {"key": "hideFixedTimeFilter", "type": "bool"},
    }

    def __init__(
        self,
        *,
        name: str,
        layout: Union[str, "_models.EmbeddingLinkRequestPayloadLayout"],
        description: Optional[str] = None,
        view_description: Optional[
            "_models.EmbeddingLinkRequestPayloadViewDescription"
        ] = None,
        explore_view: Optional["_models.EmbeddingExploreView"] = None,
        required_filter: Optional[str] = None,
        restricted: Optional[bool] = None,
        ttl: Optional[float] = None,
        non_filterable_dimensions: Optional[List[str]] = None,
        non_showable_dimensions: Optional[List[str]] = None,
        non_showable_measures: Optional[List[str]] = None,
        download_limit: Optional[float] = None,
        enable_downloads: Optional[bool] = None,
        enable_async_downloads: Optional[bool] = None,
        hide_fixed_time_filter: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the embedding link. Required.
        :paramtype name: str
        :keyword description: Description of the embedding link.
        :paramtype description: str
        :keyword view_description: Object containing the properties of the embedded view.
        :paramtype view_description:
         ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadViewDescription
        :keyword explore_view: An `explore visualization
         <https://docs.imply.io/polaris/visualizations/#explore-visualizations>`_ for the embedding
         link.
        :paramtype explore_view: ~polaris.sdk.global_api.models.EmbeddingExploreView
        :keyword layout: Show or hide the controls surrounding the visualization. Required. Known
         values are: "entire-view" and "visualization-only".
        :paramtype layout: str or ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadLayout
        :keyword required_filter: SQL condition to apply to the underlying data. See `Create an access
         filter <https://docs.imply.io/polaris/embed-visualizations/#create-an-access-filter>`_ for more
         information.
        :paramtype required_filter: str
        :keyword restricted: If set to true, a signature validated with the generated private key is
         required to access the link.
        :paramtype restricted: bool
        :keyword ttl: Period of time in milliseconds for which the link is valid, after a user first
         accesses it. Applies to restricted links only. Defaults to 1 hour.
        :paramtype ttl: float
        :keyword non_filterable_dimensions: Dimensions to exclude from the filter bar of the embedded
         visualization.
        :paramtype non_filterable_dimensions: list[str]
        :keyword non_showable_dimensions: Dimensions to exclude from the show bar of the embedded
         visualization.
        :paramtype non_showable_dimensions: list[str]
        :keyword non_showable_measures: Measures to exclude from the show bar of the embedded
         visualization.
        :paramtype non_showable_measures: list[str]
        :keyword download_limit: Sets the maximum number of rows a user can download.
        :paramtype download_limit: float
        :keyword enable_downloads: Enables downloading data from the embedding link. Users can download
         the number of rows specified in the ``downloadLimit`` property.
        :paramtype enable_downloads: bool
        :keyword enable_async_downloads: Enables async downloads for the embedding link. Requires
         ``enableDownloads`` to be set to ``true``.
        :paramtype enable_async_downloads: bool
        :keyword hide_fixed_time_filter: Set to ``true`` to hide the fixed time filter from the time
         filter UI in the embedded visualization. When ``false`` or omitted, the fixed time filter will
         be displayed.
        :paramtype hide_fixed_time_filter: bool
        """
        super().__init__(**kwargs)
        self.name = name
        self.description = description
        self.view_description = view_description
        self.explore_view = explore_view
        self.layout = layout
        self.required_filter = required_filter
        self.restricted = restricted
        self.ttl = ttl
        self.non_filterable_dimensions = non_filterable_dimensions
        self.non_showable_dimensions = non_showable_dimensions
        self.non_showable_measures = non_showable_measures
        self.download_limit = download_limit
        self.enable_downloads = enable_downloads
        self.enable_async_downloads = enable_async_downloads
        self.hide_fixed_time_filter = hide_fixed_time_filter


class EmbeddingLinkPayload(EmbeddingLinkRequestPayload):
    """Object containing embedding link properties.

    All required parameters must be populated in order to send to server.

    :ivar name: Name of the embedding link. Required.
    :vartype name: str
    :ivar description: Description of the embedding link.
    :vartype description: str
    :ivar view_description: Object containing the properties of the embedded view.
    :vartype view_description:
     ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadViewDescription
    :ivar explore_view: An `explore visualization
     <https://docs.imply.io/polaris/visualizations/#explore-visualizations>`_ for the embedding
     link.
    :vartype explore_view: ~polaris.sdk.global_api.models.EmbeddingExploreView
    :ivar layout: Show or hide the controls surrounding the visualization. Required. Known values
     are: "entire-view" and "visualization-only".
    :vartype layout: str or ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadLayout
    :ivar required_filter: SQL condition to apply to the underlying data. See `Create an access
     filter <https://docs.imply.io/polaris/embed-visualizations/#create-an-access-filter>`_ for more
     information.
    :vartype required_filter: str
    :ivar restricted: If set to true, a signature validated with the generated private key is
     required to access the link.
    :vartype restricted: bool
    :ivar ttl: Period of time in milliseconds for which the link is valid, after a user first
     accesses it. Applies to restricted links only. Defaults to 1 hour.
    :vartype ttl: float
    :ivar non_filterable_dimensions: Dimensions to exclude from the filter bar of the embedded
     visualization.
    :vartype non_filterable_dimensions: list[str]
    :ivar non_showable_dimensions: Dimensions to exclude from the show bar of the embedded
     visualization.
    :vartype non_showable_dimensions: list[str]
    :ivar non_showable_measures: Measures to exclude from the show bar of the embedded
     visualization.
    :vartype non_showable_measures: list[str]
    :ivar download_limit: Sets the maximum number of rows a user can download.
    :vartype download_limit: float
    :ivar enable_downloads: Enables downloading data from the embedding link. Users can download
     the number of rows specified in the ``downloadLimit`` property.
    :vartype enable_downloads: bool
    :ivar enable_async_downloads: Enables async downloads for the embedding link. Requires
     ``enableDownloads`` to be set to ``true``.
    :vartype enable_async_downloads: bool
    :ivar hide_fixed_time_filter: Set to ``true`` to hide the fixed time filter from the time
     filter UI in the embedded visualization. When ``false`` or omitted, the fixed time filter will
     be displayed.
    :vartype hide_fixed_time_filter: bool
    :ivar id: Asset ID. Required.
    :vartype id: str
    :ivar api_created: If true, the embedding link was created via API. If false, the embedding
     link was created via the Polaris UI. Required.
    :vartype api_created: bool
    :ivar embedding_secret: Private key generated for restricted embedding links. Only present in a
     response when the
     restricted link is initially created.
    :vartype embedding_secret: str
    """

    _validation = {
        "name": {"required": True},
        "layout": {"required": True},
        "id": {"required": True, "max_length": 255, "min_length": 1},
        "api_created": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "view_description": {
            "key": "viewDescription",
            "type": "EmbeddingLinkRequestPayloadViewDescription",
        },
        "explore_view": {"key": "exploreView", "type": "EmbeddingExploreView"},
        "layout": {"key": "layout", "type": "str"},
        "required_filter": {"key": "requiredFilter", "type": "str"},
        "restricted": {"key": "restricted", "type": "bool"},
        "ttl": {"key": "ttl", "type": "float"},
        "non_filterable_dimensions": {
            "key": "nonFilterableDimensions",
            "type": "[str]",
        },
        "non_showable_dimensions": {"key": "nonShowableDimensions", "type": "[str]"},
        "non_showable_measures": {"key": "nonShowableMeasures", "type": "[str]"},
        "download_limit": {"key": "downloadLimit", "type": "float"},
        "enable_downloads": {"key": "enableDownloads", "type": "bool"},
        "enable_async_downloads": {"key": "enableAsyncDownloads", "type": "bool"},
        "hide_fixed_time_filter": {"key": "hideFixedTimeFilter", "type": "bool"},
        "id": {"key": "id", "type": "str"},
        "api_created": {"key": "apiCreated", "type": "bool"},
        "embedding_secret": {"key": "embeddingSecret", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        layout: Union[str, "_models.EmbeddingLinkRequestPayloadLayout"],
        id: str,  # pylint: disable=redefined-builtin
        api_created: bool,
        description: Optional[str] = None,
        view_description: Optional[
            "_models.EmbeddingLinkRequestPayloadViewDescription"
        ] = None,
        explore_view: Optional["_models.EmbeddingExploreView"] = None,
        required_filter: Optional[str] = None,
        restricted: Optional[bool] = None,
        ttl: Optional[float] = None,
        non_filterable_dimensions: Optional[List[str]] = None,
        non_showable_dimensions: Optional[List[str]] = None,
        non_showable_measures: Optional[List[str]] = None,
        download_limit: Optional[float] = None,
        enable_downloads: Optional[bool] = None,
        enable_async_downloads: Optional[bool] = None,
        hide_fixed_time_filter: Optional[bool] = None,
        embedding_secret: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the embedding link. Required.
        :paramtype name: str
        :keyword description: Description of the embedding link.
        :paramtype description: str
        :keyword view_description: Object containing the properties of the embedded view.
        :paramtype view_description:
         ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadViewDescription
        :keyword explore_view: An `explore visualization
         <https://docs.imply.io/polaris/visualizations/#explore-visualizations>`_ for the embedding
         link.
        :paramtype explore_view: ~polaris.sdk.global_api.models.EmbeddingExploreView
        :keyword layout: Show or hide the controls surrounding the visualization. Required. Known
         values are: "entire-view" and "visualization-only".
        :paramtype layout: str or ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadLayout
        :keyword required_filter: SQL condition to apply to the underlying data. See `Create an access
         filter <https://docs.imply.io/polaris/embed-visualizations/#create-an-access-filter>`_ for more
         information.
        :paramtype required_filter: str
        :keyword restricted: If set to true, a signature validated with the generated private key is
         required to access the link.
        :paramtype restricted: bool
        :keyword ttl: Period of time in milliseconds for which the link is valid, after a user first
         accesses it. Applies to restricted links only. Defaults to 1 hour.
        :paramtype ttl: float
        :keyword non_filterable_dimensions: Dimensions to exclude from the filter bar of the embedded
         visualization.
        :paramtype non_filterable_dimensions: list[str]
        :keyword non_showable_dimensions: Dimensions to exclude from the show bar of the embedded
         visualization.
        :paramtype non_showable_dimensions: list[str]
        :keyword non_showable_measures: Measures to exclude from the show bar of the embedded
         visualization.
        :paramtype non_showable_measures: list[str]
        :keyword download_limit: Sets the maximum number of rows a user can download.
        :paramtype download_limit: float
        :keyword enable_downloads: Enables downloading data from the embedding link. Users can download
         the number of rows specified in the ``downloadLimit`` property.
        :paramtype enable_downloads: bool
        :keyword enable_async_downloads: Enables async downloads for the embedding link. Requires
         ``enableDownloads`` to be set to ``true``.
        :paramtype enable_async_downloads: bool
        :keyword hide_fixed_time_filter: Set to ``true`` to hide the fixed time filter from the time
         filter UI in the embedded visualization. When ``false`` or omitted, the fixed time filter will
         be displayed.
        :paramtype hide_fixed_time_filter: bool
        :keyword id: Asset ID. Required.
        :paramtype id: str
        :keyword api_created: If true, the embedding link was created via API. If false, the embedding
         link was created via the Polaris UI. Required.
        :paramtype api_created: bool
        :keyword embedding_secret: Private key generated for restricted embedding links. Only present
         in a response when the
         restricted link is initially created.
        :paramtype embedding_secret: str
        """
        super().__init__(
            name=name,
            description=description,
            view_description=view_description,
            explore_view=explore_view,
            layout=layout,
            required_filter=required_filter,
            restricted=restricted,
            ttl=ttl,
            non_filterable_dimensions=non_filterable_dimensions,
            non_showable_dimensions=non_showable_dimensions,
            non_showable_measures=non_showable_measures,
            download_limit=download_limit,
            enable_downloads=enable_downloads,
            enable_async_downloads=enable_async_downloads,
            hide_fixed_time_filter=hide_fixed_time_filter,
            **kwargs
        )
        self.id = id
        self.api_created = api_created
        self.embedding_secret = embedding_secret


class EmbeddingLinkListResponseValuesItem(AuditRecord, EmbeddingLinkPayload):
    """EmbeddingLinkListResponseValuesItem.

    All required parameters must be populated in order to send to server.

    :ivar name: Name of the embedding link. Required.
    :vartype name: str
    :ivar description: Description of the embedding link.
    :vartype description: str
    :ivar view_description: Object containing the properties of the embedded view.
    :vartype view_description:
     ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadViewDescription
    :ivar explore_view: An `explore visualization
     <https://docs.imply.io/polaris/visualizations/#explore-visualizations>`_ for the embedding
     link.
    :vartype explore_view: ~polaris.sdk.global_api.models.EmbeddingExploreView
    :ivar layout: Show or hide the controls surrounding the visualization. Required. Known values
     are: "entire-view" and "visualization-only".
    :vartype layout: str or ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadLayout
    :ivar required_filter: SQL condition to apply to the underlying data. See `Create an access
     filter <https://docs.imply.io/polaris/embed-visualizations/#create-an-access-filter>`_ for more
     information.
    :vartype required_filter: str
    :ivar restricted: If set to true, a signature validated with the generated private key is
     required to access the link.
    :vartype restricted: bool
    :ivar ttl: Period of time in milliseconds for which the link is valid, after a user first
     accesses it. Applies to restricted links only. Defaults to 1 hour.
    :vartype ttl: float
    :ivar non_filterable_dimensions: Dimensions to exclude from the filter bar of the embedded
     visualization.
    :vartype non_filterable_dimensions: list[str]
    :ivar non_showable_dimensions: Dimensions to exclude from the show bar of the embedded
     visualization.
    :vartype non_showable_dimensions: list[str]
    :ivar non_showable_measures: Measures to exclude from the show bar of the embedded
     visualization.
    :vartype non_showable_measures: list[str]
    :ivar download_limit: Sets the maximum number of rows a user can download.
    :vartype download_limit: float
    :ivar enable_downloads: Enables downloading data from the embedding link. Users can download
     the number of rows specified in the ``downloadLimit`` property.
    :vartype enable_downloads: bool
    :ivar enable_async_downloads: Enables async downloads for the embedding link. Requires
     ``enableDownloads`` to be set to ``true``.
    :vartype enable_async_downloads: bool
    :ivar hide_fixed_time_filter: Set to ``true`` to hide the fixed time filter from the time
     filter UI in the embedded visualization. When ``false`` or omitted, the fixed time filter will
     be displayed.
    :vartype hide_fixed_time_filter: bool
    :ivar id: Asset ID. Required.
    :vartype id: str
    :ivar api_created: If true, the embedding link was created via API. If false, the embedding
     link was created via the Polaris UI. Required.
    :vartype api_created: bool
    :ivar embedding_secret: Private key generated for restricted embedding links. Only present in a
     response when the
     restricted link is initially created.
    :vartype embedding_secret: str
    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    """

    _validation = {
        "name": {"required": True},
        "layout": {"required": True},
        "id": {"required": True, "max_length": 255, "min_length": 1},
        "api_created": {"required": True},
        "created_at": {"required": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "view_description": {
            "key": "viewDescription",
            "type": "EmbeddingLinkRequestPayloadViewDescription",
        },
        "explore_view": {"key": "exploreView", "type": "EmbeddingExploreView"},
        "layout": {"key": "layout", "type": "str"},
        "required_filter": {"key": "requiredFilter", "type": "str"},
        "restricted": {"key": "restricted", "type": "bool"},
        "ttl": {"key": "ttl", "type": "float"},
        "non_filterable_dimensions": {
            "key": "nonFilterableDimensions",
            "type": "[str]",
        },
        "non_showable_dimensions": {"key": "nonShowableDimensions", "type": "[str]"},
        "non_showable_measures": {"key": "nonShowableMeasures", "type": "[str]"},
        "download_limit": {"key": "downloadLimit", "type": "float"},
        "enable_downloads": {"key": "enableDownloads", "type": "bool"},
        "enable_async_downloads": {"key": "enableAsyncDownloads", "type": "bool"},
        "hide_fixed_time_filter": {"key": "hideFixedTimeFilter", "type": "bool"},
        "id": {"key": "id", "type": "str"},
        "api_created": {"key": "apiCreated", "type": "bool"},
        "embedding_secret": {"key": "embeddingSecret", "type": "str"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        layout: Union[str, "_models.EmbeddingLinkRequestPayloadLayout"],
        id: str,  # pylint: disable=redefined-builtin
        api_created: bool,
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        description: Optional[str] = None,
        view_description: Optional[
            "_models.EmbeddingLinkRequestPayloadViewDescription"
        ] = None,
        explore_view: Optional["_models.EmbeddingExploreView"] = None,
        required_filter: Optional[str] = None,
        restricted: Optional[bool] = None,
        ttl: Optional[float] = None,
        non_filterable_dimensions: Optional[List[str]] = None,
        non_showable_dimensions: Optional[List[str]] = None,
        non_showable_measures: Optional[List[str]] = None,
        download_limit: Optional[float] = None,
        enable_downloads: Optional[bool] = None,
        enable_async_downloads: Optional[bool] = None,
        hide_fixed_time_filter: Optional[bool] = None,
        embedding_secret: Optional[str] = None,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the embedding link. Required.
        :paramtype name: str
        :keyword description: Description of the embedding link.
        :paramtype description: str
        :keyword view_description: Object containing the properties of the embedded view.
        :paramtype view_description:
         ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadViewDescription
        :keyword explore_view: An `explore visualization
         <https://docs.imply.io/polaris/visualizations/#explore-visualizations>`_ for the embedding
         link.
        :paramtype explore_view: ~polaris.sdk.global_api.models.EmbeddingExploreView
        :keyword layout: Show or hide the controls surrounding the visualization. Required. Known
         values are: "entire-view" and "visualization-only".
        :paramtype layout: str or ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadLayout
        :keyword required_filter: SQL condition to apply to the underlying data. See `Create an access
         filter <https://docs.imply.io/polaris/embed-visualizations/#create-an-access-filter>`_ for more
         information.
        :paramtype required_filter: str
        :keyword restricted: If set to true, a signature validated with the generated private key is
         required to access the link.
        :paramtype restricted: bool
        :keyword ttl: Period of time in milliseconds for which the link is valid, after a user first
         accesses it. Applies to restricted links only. Defaults to 1 hour.
        :paramtype ttl: float
        :keyword non_filterable_dimensions: Dimensions to exclude from the filter bar of the embedded
         visualization.
        :paramtype non_filterable_dimensions: list[str]
        :keyword non_showable_dimensions: Dimensions to exclude from the show bar of the embedded
         visualization.
        :paramtype non_showable_dimensions: list[str]
        :keyword non_showable_measures: Measures to exclude from the show bar of the embedded
         visualization.
        :paramtype non_showable_measures: list[str]
        :keyword download_limit: Sets the maximum number of rows a user can download.
        :paramtype download_limit: float
        :keyword enable_downloads: Enables downloading data from the embedding link. Users can download
         the number of rows specified in the ``downloadLimit`` property.
        :paramtype enable_downloads: bool
        :keyword enable_async_downloads: Enables async downloads for the embedding link. Requires
         ``enableDownloads`` to be set to ``true``.
        :paramtype enable_async_downloads: bool
        :keyword hide_fixed_time_filter: Set to ``true`` to hide the fixed time filter from the time
         filter UI in the embedded visualization. When ``false`` or omitted, the fixed time filter will
         be displayed.
        :paramtype hide_fixed_time_filter: bool
        :keyword id: Asset ID. Required.
        :paramtype id: str
        :keyword api_created: If true, the embedding link was created via API. If false, the embedding
         link was created via the Polaris UI. Required.
        :paramtype api_created: bool
        :keyword embedding_secret: Private key generated for restricted embedding links. Only present
         in a response when the
         restricted link is initially created.
        :paramtype embedding_secret: str
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        """
        super().__init__(
            created_at=created_at,
            created_by=created_by,
            updated_at=updated_at,
            updated_by=updated_by,
            name=name,
            description=description,
            view_description=view_description,
            explore_view=explore_view,
            layout=layout,
            required_filter=required_filter,
            restricted=restricted,
            ttl=ttl,
            non_filterable_dimensions=non_filterable_dimensions,
            non_showable_dimensions=non_showable_dimensions,
            non_showable_measures=non_showable_measures,
            download_limit=download_limit,
            enable_downloads=enable_downloads,
            enable_async_downloads=enable_async_downloads,
            hide_fixed_time_filter=hide_fixed_time_filter,
            id=id,
            api_created=api_created,
            embedding_secret=embedding_secret,
            **kwargs
        )
        self.name = name
        self.description = description
        self.view_description = view_description
        self.explore_view = explore_view
        self.layout = layout
        self.required_filter = required_filter
        self.restricted = restricted
        self.ttl = ttl
        self.non_filterable_dimensions = non_filterable_dimensions
        self.non_showable_dimensions = non_showable_dimensions
        self.non_showable_measures = non_showable_measures
        self.download_limit = download_limit
        self.enable_downloads = enable_downloads
        self.enable_async_downloads = enable_async_downloads
        self.hide_fixed_time_filter = hide_fixed_time_filter
        self.id = id
        self.api_created = api_created
        self.embedding_secret = embedding_secret
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by


class EmbeddingLinkRequestPayloadViewDescription(
    _serialization.Model
):  # pylint: disable=name-too-long
    """Object containing the properties of the embedded view."""


class EmbeddingMeasure(_serialization.Model):
    """EmbeddingMeasure.

    :ivar name: Measure ID.
    :vartype name: str
    :ivar transform: Transform type to apply. Known values are: "none", "percent-of-parent", and
     "percent-of-root".
    :vartype transform: str or ~polaris.sdk.global_api.models.EmbeddingTransform
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "transform": {"key": "transform", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        transform: Optional[Union[str, "_models.EmbeddingTransform"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Measure ID.
        :paramtype name: str
        :keyword transform: Transform type to apply. Known values are: "none", "percent-of-parent", and
         "percent-of-root".
        :paramtype transform: str or ~polaris.sdk.global_api.models.EmbeddingTransform
        """
        super().__init__(**kwargs)
        self.name = name
        self.transform = transform


class EmbeddingMeasureFilter(_serialization.Model):
    """A filter applied to the measure of the visualization.

    All required parameters must be populated in order to send to server.

    :ivar filter_type: Required. "measure"
    :vartype filter_type: str or ~polaris.sdk.global_api.models.EmbeddingMeasureFilterType
    :ivar measure: Anything. Required.
    :vartype measure: any
    :ivar max_op: Required. Known values are: "gte" and "gt".
    :vartype max_op: str or ~polaris.sdk.global_api.models.EmbeddingMeasureFilterMaxOp
    :ivar min_op: Required. Known values are: "lte" and "lt".
    :vartype min_op: str or ~polaris.sdk.global_api.models.EmbeddingMeasureFilterMinOp
    :ivar max_value: Required.
    :vartype max_value: float
    :ivar min_value: Required.
    :vartype min_value: float
    :ivar exclude:
    :vartype exclude: bool
    """

    _validation = {
        "filter_type": {"required": True},
        "measure": {"required": True},
        "max_op": {"required": True},
        "min_op": {"required": True},
        "max_value": {"required": True},
        "min_value": {"required": True},
    }

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "measure": {"key": "measure", "type": "object"},
        "max_op": {"key": "maxOp", "type": "str"},
        "min_op": {"key": "minOp", "type": "str"},
        "max_value": {"key": "maxValue", "type": "float"},
        "min_value": {"key": "minValue", "type": "float"},
        "exclude": {"key": "exclude", "type": "bool"},
    }

    def __init__(
        self,
        *,
        filter_type: Union[str, "_models.EmbeddingMeasureFilterType"],
        measure: Any,
        max_op: Union[str, "_models.EmbeddingMeasureFilterMaxOp"],
        min_op: Union[str, "_models.EmbeddingMeasureFilterMinOp"],
        max_value: float,
        min_value: float,
        exclude: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword filter_type: Required. "measure"
        :paramtype filter_type: str or ~polaris.sdk.global_api.models.EmbeddingMeasureFilterType
        :keyword measure: Anything. Required.
        :paramtype measure: any
        :keyword max_op: Required. Known values are: "gte" and "gt".
        :paramtype max_op: str or ~polaris.sdk.global_api.models.EmbeddingMeasureFilterMaxOp
        :keyword min_op: Required. Known values are: "lte" and "lt".
        :paramtype min_op: str or ~polaris.sdk.global_api.models.EmbeddingMeasureFilterMinOp
        :keyword max_value: Required.
        :paramtype max_value: float
        :keyword min_value: Required.
        :paramtype min_value: float
        :keyword exclude:
        :paramtype exclude: bool
        """
        super().__init__(**kwargs)
        self.filter_type = filter_type
        self.measure = measure
        self.max_op = max_op
        self.min_op = min_op
        self.max_value = max_value
        self.min_value = min_value
        self.exclude = exclude


class EmbeddingNumericFilter(_serialization.Model):
    """A filter applied to a numeric dimension.

    All required parameters must be populated in order to send to server.

    :ivar filter_type: Required. "numeric"
    :vartype filter_type: str or ~polaris.sdk.global_api.models.EmbeddingNumericFilterType
    :ivar dimension: Required.
    :vartype dimension: str
    :ivar value: A numeric interval applied to a numeric filter. Required.
    :vartype value: ~polaris.sdk.global_api.models.EmbeddingNumericFilterInterval
    """

    _validation = {
        "filter_type": {"required": True},
        "dimension": {"required": True},
        "value": {"required": True},
    }

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "dimension": {"key": "dimension", "type": "str"},
        "value": {"key": "value", "type": "EmbeddingNumericFilterInterval"},
    }

    def __init__(
        self,
        *,
        filter_type: Union[str, "_models.EmbeddingNumericFilterType"],
        dimension: str,
        value: "_models.EmbeddingNumericFilterInterval",
        **kwargs: Any
    ) -> None:
        """
        :keyword filter_type: Required. "numeric"
        :paramtype filter_type: str or ~polaris.sdk.global_api.models.EmbeddingNumericFilterType
        :keyword dimension: Required.
        :paramtype dimension: str
        :keyword value: A numeric interval applied to a numeric filter. Required.
        :paramtype value: ~polaris.sdk.global_api.models.EmbeddingNumericFilterInterval
        """
        super().__init__(**kwargs)
        self.filter_type = filter_type
        self.dimension = dimension
        self.value = value


class EmbeddingNumericFilterInterval(_serialization.Model):
    """A numeric interval applied to a numeric filter.

    All required parameters must be populated in order to send to server.

    :ivar start_bound: Required. Known values are: "gt" and "gte".
    :vartype start_bound: str or
     ~polaris.sdk.global_api.models.EmbeddingNumericFilterIntervalStartBound
    :ivar start: Required.
    :vartype start: float
    :ivar end_bound: Required. Known values are: "lte" and "lt".
    :vartype end_bound: str or
     ~polaris.sdk.global_api.models.EmbeddingNumericFilterIntervalEndBound
    :ivar end: Required.
    :vartype end: float
    :ivar exclude:
    :vartype exclude: bool
    """

    _validation = {
        "start_bound": {"required": True},
        "start": {"required": True},
        "end_bound": {"required": True},
        "end": {"required": True},
    }

    _attribute_map = {
        "start_bound": {"key": "startBound", "type": "str"},
        "start": {"key": "start", "type": "float"},
        "end_bound": {"key": "endBound", "type": "str"},
        "end": {"key": "end", "type": "float"},
        "exclude": {"key": "exclude", "type": "bool"},
    }

    def __init__(
        self,
        *,
        start_bound: Union[str, "_models.EmbeddingNumericFilterIntervalStartBound"],
        start: float,
        end_bound: Union[str, "_models.EmbeddingNumericFilterIntervalEndBound"],
        end: float,
        exclude: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword start_bound: Required. Known values are: "gt" and "gte".
        :paramtype start_bound: str or
         ~polaris.sdk.global_api.models.EmbeddingNumericFilterIntervalStartBound
        :keyword start: Required.
        :paramtype start: float
        :keyword end_bound: Required. Known values are: "lte" and "lt".
        :paramtype end_bound: str or
         ~polaris.sdk.global_api.models.EmbeddingNumericFilterIntervalEndBound
        :keyword end: Required.
        :paramtype end: float
        :keyword exclude:
        :paramtype exclude: bool
        """
        super().__init__(**kwargs)
        self.start_bound = start_bound
        self.start = start
        self.end_bound = end_bound
        self.end = end
        self.exclude = exclude


class EmbeddingOverallParameters(_serialization.Model):
    """EmbeddingOverallParameters.

    All required parameters must be populated in order to send to server.

    :ivar compare: ISO 8601 format duration to use for a relative time comparison.
    :vartype compare: str
    :ivar conditional_formatting: Conditional formatting for the visualization.
    :vartype conditional_formatting:
     list[~polaris.sdk.global_api.models.EmbeddingOverallParametersConditionalFormattingItem]
    :ivar metrics: IDs of measures to show as metrics. Required.
    :vartype metrics: list[str]
    :ivar module_name: Required. "overall"
    :vartype module_name: str or
     ~polaris.sdk.global_api.models.EmbeddingOverallParametersModuleName
    :ivar single_metric_title: Custom label to show when displaying a single measure.
    :vartype single_metric_title: str
    :ivar time_split: ID of the dimension to use for the trend line. Dimension must be of type
     TIME.
    :vartype time_split: any
    """

    _validation = {
        "metrics": {"required": True},
        "module_name": {"required": True},
    }

    _attribute_map = {
        "compare": {"key": "compare", "type": "str"},
        "conditional_formatting": {
            "key": "conditionalFormatting",
            "type": "[EmbeddingOverallParametersConditionalFormattingItem]",
        },
        "metrics": {"key": "metrics", "type": "[str]"},
        "module_name": {"key": "moduleName", "type": "str"},
        "single_metric_title": {"key": "singleMetricTitle", "type": "str"},
        "time_split": {"key": "timeSplit", "type": "object"},
    }

    def __init__(
        self,
        *,
        metrics: List[str],
        module_name: Union[str, "_models.EmbeddingOverallParametersModuleName"],
        compare: Optional[str] = None,
        conditional_formatting: Optional[
            List["_models.EmbeddingOverallParametersConditionalFormattingItem"]
        ] = None,
        single_metric_title: Optional[str] = None,
        time_split: Optional[Any] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword compare: ISO 8601 format duration to use for a relative time comparison.
        :paramtype compare: str
        :keyword conditional_formatting: Conditional formatting for the visualization.
        :paramtype conditional_formatting:
         list[~polaris.sdk.global_api.models.EmbeddingOverallParametersConditionalFormattingItem]
        :keyword metrics: IDs of measures to show as metrics. Required.
        :paramtype metrics: list[str]
        :keyword module_name: Required. "overall"
        :paramtype module_name: str or
         ~polaris.sdk.global_api.models.EmbeddingOverallParametersModuleName
        :keyword single_metric_title: Custom label to show when displaying a single measure.
        :paramtype single_metric_title: str
        :keyword time_split: ID of the dimension to use for the trend line. Dimension must be of type
         TIME.
        :paramtype time_split: any
        """
        super().__init__(**kwargs)
        self.compare = compare
        self.conditional_formatting = conditional_formatting
        self.metrics = metrics
        self.module_name = module_name
        self.single_metric_title = single_metric_title
        self.time_split = time_split


class EmbeddingOverallParametersConditionalFormattingItem(
    _serialization.Model
):  # pylint: disable=name-too-long
    """EmbeddingOverallParametersConditionalFormattingItem.

    :ivar intent: Caution level. Known values are: "WARNING", "DANGER", and "OK".
    :vartype intent: str or
     ~polaris.sdk.global_api.models.EmbeddingOverallParametersConditionalFormattingItemIntent
    :ivar left_value: Enter a lower limit.
    :vartype left_value: float
    :ivar right_value: Enter an upper limit.
    :vartype right_value: float
    :ivar type: Condition. Known values are: "smallerThan", "largerThan", "smallerThanOrEqualTo",
     "largerThanOrEqualTo", "between", and "outsideOf".
    :vartype type: str or
     ~polaris.sdk.global_api.models.EmbeddingOverallParametersConditionalFormattingItemType
    """

    _attribute_map = {
        "intent": {"key": "intent", "type": "str"},
        "left_value": {"key": "leftValue", "type": "float"},
        "right_value": {"key": "rightValue", "type": "float"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self,
        *,
        intent: Optional[
            Union[
                str, "_models.EmbeddingOverallParametersConditionalFormattingItemIntent"
            ]
        ] = None,
        left_value: Optional[float] = None,
        right_value: Optional[float] = None,
        type: Optional[
            Union[
                str, "_models.EmbeddingOverallParametersConditionalFormattingItemType"
            ]
        ] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword intent: Caution level. Known values are: "WARNING", "DANGER", and "OK".
        :paramtype intent: str or
         ~polaris.sdk.global_api.models.EmbeddingOverallParametersConditionalFormattingItemIntent
        :keyword left_value: Enter a lower limit.
        :paramtype left_value: float
        :keyword right_value: Enter an upper limit.
        :paramtype right_value: float
        :keyword type: Condition. Known values are: "smallerThan", "largerThan",
         "smallerThanOrEqualTo", "largerThanOrEqualTo", "between", and "outsideOf".
        :paramtype type: str or
         ~polaris.sdk.global_api.models.EmbeddingOverallParametersConditionalFormattingItemType
        """
        super().__init__(**kwargs)
        self.intent = intent
        self.left_value = left_value
        self.right_value = right_value
        self.type = type


class EmbeddingStringFilter(_serialization.Model):
    """A filter applied to a string dimension.

    :ivar filter_type: "string"
    :vartype filter_type: str or ~polaris.sdk.global_api.models.EmbeddingStringFilterType
    :ivar dimension:
    :vartype dimension: str
    :ivar operator: Known values are: "eq", "ne", "contains", and "in".
    :vartype operator: str or ~polaris.sdk.global_api.models.EmbeddingStringFilterOperator
    :ivar value:
    :vartype value: str
    """

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "dimension": {"key": "dimension", "type": "str"},
        "operator": {"key": "operator", "type": "str"},
        "value": {"key": "value", "type": "str"},
    }

    def __init__(
        self,
        *,
        filter_type: Optional[Union[str, "_models.EmbeddingStringFilterType"]] = None,
        dimension: Optional[str] = None,
        operator: Optional[Union[str, "_models.EmbeddingStringFilterOperator"]] = None,
        value: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword filter_type: "string"
        :paramtype filter_type: str or ~polaris.sdk.global_api.models.EmbeddingStringFilterType
        :keyword dimension:
        :paramtype dimension: str
        :keyword operator: Known values are: "eq", "ne", "contains", and "in".
        :paramtype operator: str or ~polaris.sdk.global_api.models.EmbeddingStringFilterOperator
        :keyword value:
        :paramtype value: str
        """
        super().__init__(**kwargs)
        self.filter_type = filter_type
        self.dimension = dimension
        self.operator = operator
        self.value = value


class EmbeddingTimeFilter(_serialization.Model):
    """A filter applied to a time dimension.

    All required parameters must be populated in order to send to server.

    :ivar filter_type: Required. "time"
    :vartype filter_type: str or ~polaris.sdk.global_api.models.EmbeddingTimeFilterType
    :ivar dimension: Required.
    :vartype dimension: str
    :ivar value: A time interval applied to a time filter. Required.
    :vartype value: ~polaris.sdk.global_api.models.EmbeddingTimeFilterInterval
    """

    _validation = {
        "filter_type": {"required": True},
        "dimension": {"required": True},
        "value": {"required": True},
    }

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "dimension": {"key": "dimension", "type": "str"},
        "value": {"key": "value", "type": "EmbeddingTimeFilterInterval"},
    }

    def __init__(
        self,
        *,
        filter_type: Union[str, "_models.EmbeddingTimeFilterType"],
        dimension: str,
        value: "_models.EmbeddingTimeFilterInterval",
        **kwargs: Any
    ) -> None:
        """
        :keyword filter_type: Required. "time"
        :paramtype filter_type: str or ~polaris.sdk.global_api.models.EmbeddingTimeFilterType
        :keyword dimension: Required.
        :paramtype dimension: str
        :keyword value: A time interval applied to a time filter. Required.
        :paramtype value: ~polaris.sdk.global_api.models.EmbeddingTimeFilterInterval
        """
        super().__init__(**kwargs)
        self.filter_type = filter_type
        self.dimension = dimension
        self.value = value


class EmbeddingTimeFilterInterval(_serialization.Model):
    """A time interval applied to a time filter.

    All required parameters must be populated in order to send to server.

    :ivar time_type: Required. Known values are: "fixed", "latest", "previous", and "current".
    :vartype time_type: str or ~polaris.sdk.global_api.models.EmbeddingTimeFilterIntervalTimeType
    :ivar value:
    :vartype value: str
    :ivar start:
    :vartype start: str
    :ivar end:
    :vartype end: str
    """

    _validation = {
        "time_type": {"required": True},
    }

    _attribute_map = {
        "time_type": {"key": "timeType", "type": "str"},
        "value": {"key": "value", "type": "str"},
        "start": {"key": "start", "type": "str"},
        "end": {"key": "end", "type": "str"},
    }

    def __init__(
        self,
        *,
        time_type: Union[str, "_models.EmbeddingTimeFilterIntervalTimeType"],
        value: Optional[str] = None,
        start: Optional[str] = None,
        end: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword time_type: Required. Known values are: "fixed", "latest", "previous", and "current".
        :paramtype time_type: str or ~polaris.sdk.global_api.models.EmbeddingTimeFilterIntervalTimeType
        :keyword value:
        :paramtype value: str
        :keyword start:
        :paramtype start: str
        :keyword end:
        :paramtype end: str
        """
        super().__init__(**kwargs)
        self.time_type = time_type
        self.value = value
        self.start = start
        self.end = end


class EmbeddingTimeSeriesParameters(_serialization.Model):
    """EmbeddingTimeSeriesParameters.

    All required parameters must be populated in order to send to server.

    :ivar group_by: ID of the dimension to use for Group By.
    :vartype group_by: str
    :ivar group_limit: Number of Group By values to show.
    :vartype group_limit: float
    :ivar interpolator: How to fill missing data points. Known values are: "linear", "padding", and
     "backfill".
    :vartype interpolator: str or
     ~polaris.sdk.global_api.models.EmbeddingTimeSeriesParametersInterpolator
    :ivar module_name: Required. "time_series"
    :vartype module_name: str or
     ~polaris.sdk.global_api.models.EmbeddingTimeSeriesParametersModuleName
    :ivar render_type: Type of chart. Known values are: "line" and "bar".
    :vartype render_type: str or
     ~polaris.sdk.global_api.models.EmbeddingTimeSeriesParametersRenderType
    :ivar secondtimeseries_column: ID of the dimension to use as the second data column.
    :vartype secondtimeseries_column: str
    :ivar time_column: ID of the dimension containing the time series objects. Required.
    :vartype time_column: str
    :ivar timeseries_bucket: Bucketing period for the time dimension to use. Known values are:
     "PT1M", "PT5M", "PT1H", and "P1D".
    :vartype timeseries_bucket: str or
     ~polaris.sdk.global_api.models.EmbeddingTimeSeriesParametersTimeseriesBucket
    :ivar timeseries_column: ID of the dimension to use as the data column. Required.
    :vartype timeseries_column: str
    :ivar timeseries_function: Function to transform or augment a time series. Known values are:
     "TIMESERIES", "DELTA_TIMESERIES", "ADD_TIMESERIES", "DIVIDE_TIMESERIES", "MULTIPLY_TIMESERIES",
     and "SUBTRACT_TIMESERIES".
    :vartype timeseries_function: str or
     ~polaris.sdk.global_api.models.EmbeddingTimeSeriesParametersTimeseriesFunction
    :ivar aggregation_method: Specifies the method Polaris uses to aggregate data over time:


     * ``TIME_WEIGHTED_AVERAGE``\\ : Calculates the average value of data points, weighted by the
     time between them.
     * ``DOWNSAMPLED_SUM_TIME_SERIES``\\ : Sums data points within specified intervals, reducing
     the resolution of the data. Known values are: "TIME_WEIGHTED_AVERAGE" and
     "DOWNSAMPLED_SUM_TIME_SERIES".
    :vartype aggregation_method: str or
     ~polaris.sdk.global_api.models.EmbeddingTimeSeriesParametersAggregationMethod
    """

    _validation = {
        "module_name": {"required": True},
        "time_column": {"required": True},
        "timeseries_column": {"required": True},
    }

    _attribute_map = {
        "group_by": {"key": "groupBy", "type": "str"},
        "group_limit": {"key": "groupLimit", "type": "float"},
        "interpolator": {"key": "interpolator", "type": "str"},
        "module_name": {"key": "moduleName", "type": "str"},
        "render_type": {"key": "renderType", "type": "str"},
        "secondtimeseries_column": {"key": "secondtimeseriesColumn", "type": "str"},
        "time_column": {"key": "timeColumn", "type": "str"},
        "timeseries_bucket": {"key": "timeseriesBucket", "type": "str"},
        "timeseries_column": {"key": "timeseriesColumn", "type": "str"},
        "timeseries_function": {"key": "timeseriesFunction", "type": "str"},
        "aggregation_method": {"key": "aggregationMethod", "type": "str"},
    }

    def __init__(
        self,
        *,
        module_name: Union[str, "_models.EmbeddingTimeSeriesParametersModuleName"],
        time_column: str,
        timeseries_column: str,
        group_by: Optional[str] = None,
        group_limit: Optional[float] = None,
        interpolator: Optional[
            Union[str, "_models.EmbeddingTimeSeriesParametersInterpolator"]
        ] = None,
        render_type: Optional[
            Union[str, "_models.EmbeddingTimeSeriesParametersRenderType"]
        ] = None,
        secondtimeseries_column: Optional[str] = None,
        timeseries_bucket: Optional[
            Union[str, "_models.EmbeddingTimeSeriesParametersTimeseriesBucket"]
        ] = None,
        timeseries_function: Optional[
            Union[str, "_models.EmbeddingTimeSeriesParametersTimeseriesFunction"]
        ] = None,
        aggregation_method: Union[
            str, "_models.EmbeddingTimeSeriesParametersAggregationMethod"
        ] = "TIME_WEIGHTED_AVERAGE",
        **kwargs: Any
    ) -> None:
        """
        :keyword group_by: ID of the dimension to use for Group By.
        :paramtype group_by: str
        :keyword group_limit: Number of Group By values to show.
        :paramtype group_limit: float
        :keyword interpolator: How to fill missing data points. Known values are: "linear", "padding",
         and "backfill".
        :paramtype interpolator: str or
         ~polaris.sdk.global_api.models.EmbeddingTimeSeriesParametersInterpolator
        :keyword module_name: Required. "time_series"
        :paramtype module_name: str or
         ~polaris.sdk.global_api.models.EmbeddingTimeSeriesParametersModuleName
        :keyword render_type: Type of chart. Known values are: "line" and "bar".
        :paramtype render_type: str or
         ~polaris.sdk.global_api.models.EmbeddingTimeSeriesParametersRenderType
        :keyword secondtimeseries_column: ID of the dimension to use as the second data column.
        :paramtype secondtimeseries_column: str
        :keyword time_column: ID of the dimension containing the time series objects. Required.
        :paramtype time_column: str
        :keyword timeseries_bucket: Bucketing period for the time dimension to use. Known values are:
         "PT1M", "PT5M", "PT1H", and "P1D".
        :paramtype timeseries_bucket: str or
         ~polaris.sdk.global_api.models.EmbeddingTimeSeriesParametersTimeseriesBucket
        :keyword timeseries_column: ID of the dimension to use as the data column. Required.
        :paramtype timeseries_column: str
        :keyword timeseries_function: Function to transform or augment a time series. Known values are:
         "TIMESERIES", "DELTA_TIMESERIES", "ADD_TIMESERIES", "DIVIDE_TIMESERIES", "MULTIPLY_TIMESERIES",
         and "SUBTRACT_TIMESERIES".
        :paramtype timeseries_function: str or
         ~polaris.sdk.global_api.models.EmbeddingTimeSeriesParametersTimeseriesFunction
        :keyword aggregation_method: Specifies the method Polaris uses to aggregate data over time:


         * ``TIME_WEIGHTED_AVERAGE``\\ : Calculates the average value of data points, weighted by the
         time between them.
         * ``DOWNSAMPLED_SUM_TIME_SERIES``\\ : Sums data points within specified intervals, reducing
         the resolution of the data. Known values are: "TIME_WEIGHTED_AVERAGE" and
         "DOWNSAMPLED_SUM_TIME_SERIES".
        :paramtype aggregation_method: str or
         ~polaris.sdk.global_api.models.EmbeddingTimeSeriesParametersAggregationMethod
        """
        super().__init__(**kwargs)
        self.group_by = group_by
        self.group_limit = group_limit
        self.interpolator = interpolator
        self.module_name = module_name
        self.render_type = render_type
        self.secondtimeseries_column = secondtimeseries_column
        self.time_column = time_column
        self.timeseries_bucket = timeseries_bucket
        self.timeseries_column = timeseries_column
        self.timeseries_function = timeseries_function
        self.aggregation_method = aggregation_method


class EmbedLinkDescription(_serialization.Model):
    """Object containing the properties of the embedding link.

    All required parameters must be populated in order to send to server.

    :ivar name: Name of the embedding link. Required.
    :vartype name: str
    :ivar description: Description of the embedding link.
    :vartype description: str
    :ivar view_description: Object containing the properties of the embedded view. Required.
    :vartype view_description: ~polaris.sdk.global_api.models.EmbedLinkDescriptionViewDescription
    :ivar layout: Show or hide the controls surrounding the visualization. Required. Known values
     are: "entire-view" and "visualization-only".
    :vartype layout: str or ~polaris.sdk.global_api.models.EmbedLinkDescriptionLayout
    :ivar required_filter: A SQL condition to apply to the underlying data. See `Create an access
     filter <https://docs.imply.io/polaris/embed-visualizations/#create-an-access-filter>`_ for more
     information.
    :vartype required_filter: str
    :ivar restricted: If set to true, a signature validated with the generated private key is
     required to access the link.
    :vartype restricted: bool
    :ivar ttl: Period of time in milliseconds for which the link is valid, after a user first
     accesses it. Applies to restricted links only. Defaults to 1 hour.
    :vartype ttl: float
    :ivar non_filterable_dimensions: Dimensions to exclude from the filter bar of the embedded
     visualization.
    :vartype non_filterable_dimensions: list[str]
    :ivar non_showable_dimensions: Dimensions to exclude from the show bar of the embedded
     visualization.
    :vartype non_showable_dimensions: list[str]
    :ivar non_showable_measures: Measures to exclude from the show bar of the embedded
     visualization.
    :vartype non_showable_measures: list[str]
    :ivar download_limit: Sets the maximum number of rows a user can download.
    :vartype download_limit: float
    :ivar enable_downloads: Enables downloading data from the embedding link. Users can download
     the number of rows specified in the ``downloadLimit`` property.
    :vartype enable_downloads: bool
    :ivar enable_async_downloads: Enables async downloads for the embedding link. Requires
     ``enableDownloads`` to be set to ``true``.
    :vartype enable_async_downloads: bool
    :ivar hide_fixed_time_filter: Set to ``true`` to hide the fixed time filter from the time
     filter UI in the embedded visualization. When ``false`` or omitted, the fixed time filter will
     be displayed.
    :vartype hide_fixed_time_filter: bool
    """

    _validation = {
        "name": {"required": True},
        "view_description": {"required": True},
        "layout": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "view_description": {
            "key": "viewDescription",
            "type": "EmbedLinkDescriptionViewDescription",
        },
        "layout": {"key": "layout", "type": "str"},
        "required_filter": {"key": "requiredFilter", "type": "str"},
        "restricted": {"key": "restricted", "type": "bool"},
        "ttl": {"key": "ttl", "type": "float"},
        "non_filterable_dimensions": {
            "key": "nonFilterableDimensions",
            "type": "[str]",
        },
        "non_showable_dimensions": {"key": "nonShowableDimensions", "type": "[str]"},
        "non_showable_measures": {"key": "nonShowableMeasures", "type": "[str]"},
        "download_limit": {"key": "downloadLimit", "type": "float"},
        "enable_downloads": {"key": "enableDownloads", "type": "bool"},
        "enable_async_downloads": {"key": "enableAsyncDownloads", "type": "bool"},
        "hide_fixed_time_filter": {"key": "hideFixedTimeFilter", "type": "bool"},
    }

    def __init__(
        self,
        *,
        name: str,
        view_description: "_models.EmbedLinkDescriptionViewDescription",
        layout: Union[str, "_models.EmbedLinkDescriptionLayout"],
        description: Optional[str] = None,
        required_filter: Optional[str] = None,
        restricted: Optional[bool] = None,
        ttl: Optional[float] = None,
        non_filterable_dimensions: Optional[List[str]] = None,
        non_showable_dimensions: Optional[List[str]] = None,
        non_showable_measures: Optional[List[str]] = None,
        download_limit: Optional[float] = None,
        enable_downloads: Optional[bool] = None,
        enable_async_downloads: Optional[bool] = None,
        hide_fixed_time_filter: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the embedding link. Required.
        :paramtype name: str
        :keyword description: Description of the embedding link.
        :paramtype description: str
        :keyword view_description: Object containing the properties of the embedded view. Required.
        :paramtype view_description: ~polaris.sdk.global_api.models.EmbedLinkDescriptionViewDescription
        :keyword layout: Show or hide the controls surrounding the visualization. Required. Known
         values are: "entire-view" and "visualization-only".
        :paramtype layout: str or ~polaris.sdk.global_api.models.EmbedLinkDescriptionLayout
        :keyword required_filter: A SQL condition to apply to the underlying data. See `Create an
         access filter <https://docs.imply.io/polaris/embed-visualizations/#create-an-access-filter>`_
         for more information.
        :paramtype required_filter: str
        :keyword restricted: If set to true, a signature validated with the generated private key is
         required to access the link.
        :paramtype restricted: bool
        :keyword ttl: Period of time in milliseconds for which the link is valid, after a user first
         accesses it. Applies to restricted links only. Defaults to 1 hour.
        :paramtype ttl: float
        :keyword non_filterable_dimensions: Dimensions to exclude from the filter bar of the embedded
         visualization.
        :paramtype non_filterable_dimensions: list[str]
        :keyword non_showable_dimensions: Dimensions to exclude from the show bar of the embedded
         visualization.
        :paramtype non_showable_dimensions: list[str]
        :keyword non_showable_measures: Measures to exclude from the show bar of the embedded
         visualization.
        :paramtype non_showable_measures: list[str]
        :keyword download_limit: Sets the maximum number of rows a user can download.
        :paramtype download_limit: float
        :keyword enable_downloads: Enables downloading data from the embedding link. Users can download
         the number of rows specified in the ``downloadLimit`` property.
        :paramtype enable_downloads: bool
        :keyword enable_async_downloads: Enables async downloads for the embedding link. Requires
         ``enableDownloads`` to be set to ``true``.
        :paramtype enable_async_downloads: bool
        :keyword hide_fixed_time_filter: Set to ``true`` to hide the fixed time filter from the time
         filter UI in the embedded visualization. When ``false`` or omitted, the fixed time filter will
         be displayed.
        :paramtype hide_fixed_time_filter: bool
        """
        super().__init__(**kwargs)
        self.name = name
        self.description = description
        self.view_description = view_description
        self.layout = layout
        self.required_filter = required_filter
        self.restricted = restricted
        self.ttl = ttl
        self.non_filterable_dimensions = non_filterable_dimensions
        self.non_showable_dimensions = non_showable_dimensions
        self.non_showable_measures = non_showable_measures
        self.download_limit = download_limit
        self.enable_downloads = enable_downloads
        self.enable_async_downloads = enable_async_downloads
        self.hide_fixed_time_filter = hide_fixed_time_filter


class EmbedLinkDescriptionViewDescription(_serialization.Model):
    """Object containing the properties of the embedded view."""


class ErrorResponse(_serialization.Model):
    """An error with a code and message.

    All required parameters must be populated in order to send to server.

    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    :ivar target: Error target.
    :vartype target: str
    :ivar details: Error details.
    :vartype details: list[~polaris.sdk.global_api.models.ErrorResponse]
    :ivar innererror: A detailed, service-specific error.
    :vartype innererror: ~polaris.sdk.global_api.models.InnerError
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "target": {"key": "target", "type": "str"},
        "details": {"key": "details", "type": "[ErrorResponse]"},
        "innererror": {"key": "innererror", "type": "InnerError"},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        target: Optional[str] = None,
        details: Optional[List["_models.ErrorResponse"]] = None,
        innererror: Optional["_models.InnerError"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        :keyword target: Error target.
        :paramtype target: str
        :keyword details: Error details.
        :paramtype details: list[~polaris.sdk.global_api.models.ErrorResponse]
        :keyword innererror: A detailed, service-specific error.
        :paramtype innererror: ~polaris.sdk.global_api.models.InnerError
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details
        self.innererror = innererror


class ErrorResponse11(_serialization.Model):
    """An error with a code and message.

    All required parameters must be populated in order to send to server.

    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    :ivar target: Error target.
    :vartype target: str
    :ivar details: Error details.
    :vartype details: list[~polaris.sdk.global_api.models.ErrorResponse]
    :ivar innererror: A detailed, service-specific error.
    :vartype innererror: ~polaris.sdk.global_api.models.InnerError
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "target": {"key": "target", "type": "str"},
        "details": {"key": "details", "type": "[ErrorResponse]"},
        "innererror": {"key": "innererror", "type": "InnerError"},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        target: Optional[str] = None,
        details: Optional[List["_models.ErrorResponse"]] = None,
        innererror: Optional["_models.InnerError"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        :keyword target: Error target.
        :paramtype target: str
        :keyword details: Error details.
        :paramtype details: list[~polaris.sdk.global_api.models.ErrorResponse]
        :keyword innererror: A detailed, service-specific error.
        :paramtype innererror: ~polaris.sdk.global_api.models.InnerError
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details
        self.innererror = innererror


class ErrorResponse14(_serialization.Model):
    """An error with a code and message.

    All required parameters must be populated in order to send to server.

    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    :ivar target: Error target.
    :vartype target: str
    :ivar details: Error details.
    :vartype details: list[~polaris.sdk.global_api.models.ErrorResponse]
    :ivar innererror: A detailed, service-specific error.
    :vartype innererror: ~polaris.sdk.global_api.models.InnerError
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "target": {"key": "target", "type": "str"},
        "details": {"key": "details", "type": "[ErrorResponse]"},
        "innererror": {"key": "innererror", "type": "InnerError"},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        target: Optional[str] = None,
        details: Optional[List["_models.ErrorResponse"]] = None,
        innererror: Optional["_models.InnerError"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        :keyword target: Error target.
        :paramtype target: str
        :keyword details: Error details.
        :paramtype details: list[~polaris.sdk.global_api.models.ErrorResponse]
        :keyword innererror: A detailed, service-specific error.
        :paramtype innererror: ~polaris.sdk.global_api.models.InnerError
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details
        self.innererror = innererror


class ErrorResponse3(_serialization.Model):
    """An error with a code and message.

    All required parameters must be populated in order to send to server.

    :ivar code: The error code. Required.
    :vartype code: str
    :ivar message: The error message. Required.
    :vartype message: str
    :ivar target: The target of the error.
    :vartype target: str
    :ivar details: The details of the error.
    :vartype details: list[~polaris.sdk.global_api.models.ErrorResponse]
    :ivar innererror: A detailed, service-specific error.
    :vartype innererror: ~polaris.sdk.global_api.models.InnerError
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "target": {"key": "target", "type": "str"},
        "details": {"key": "details", "type": "[ErrorResponse]"},
        "innererror": {"key": "innererror", "type": "InnerError"},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        target: Optional[str] = None,
        details: Optional[List["_models.ErrorResponse"]] = None,
        innererror: Optional["_models.InnerError"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword code: The error code. Required.
        :paramtype code: str
        :keyword message: The error message. Required.
        :paramtype message: str
        :keyword target: The target of the error.
        :paramtype target: str
        :keyword details: The details of the error.
        :paramtype details: list[~polaris.sdk.global_api.models.ErrorResponse]
        :keyword innererror: A detailed, service-specific error.
        :paramtype innererror: ~polaris.sdk.global_api.models.InnerError
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details
        self.innererror = innererror


class ErrorResponse5(_serialization.Model):
    """An error with a code and message.

    All required parameters must be populated in order to send to server.

    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    :ivar target: Error target.
    :vartype target: str
    :ivar details: Error details.
    :vartype details: list[~polaris.sdk.global_api.models.ErrorResponse]
    :ivar innererror: A detailed, service-specific error.
    :vartype innererror: ~polaris.sdk.global_api.models.InnerError
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "target": {"key": "target", "type": "str"},
        "details": {"key": "details", "type": "[ErrorResponse]"},
        "innererror": {"key": "innererror", "type": "InnerError"},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        target: Optional[str] = None,
        details: Optional[List["_models.ErrorResponse"]] = None,
        innererror: Optional["_models.InnerError"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        :keyword target: Error target.
        :paramtype target: str
        :keyword details: Error details.
        :paramtype details: list[~polaris.sdk.global_api.models.ErrorResponse]
        :keyword innererror: A detailed, service-specific error.
        :paramtype innererror: ~polaris.sdk.global_api.models.InnerError
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details
        self.innererror = innererror


class ErrorResponse6(_serialization.Model):
    """An error with a code and message.

    All required parameters must be populated in order to send to server.

    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    :ivar target: Error target.
    :vartype target: str
    :ivar details: Error details.
    :vartype details: list[~polaris.sdk.global_api.models.ErrorResponse]
    :ivar innererror: A detailed, service-specific error.
    :vartype innererror: ~polaris.sdk.global_api.models.InnerError
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "target": {"key": "target", "type": "str"},
        "details": {"key": "details", "type": "[ErrorResponse]"},
        "innererror": {"key": "innererror", "type": "InnerError"},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        target: Optional[str] = None,
        details: Optional[List["_models.ErrorResponse"]] = None,
        innererror: Optional["_models.InnerError"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        :keyword target: Error target.
        :paramtype target: str
        :keyword details: Error details.
        :paramtype details: list[~polaris.sdk.global_api.models.ErrorResponse]
        :keyword innererror: A detailed, service-specific error.
        :paramtype innererror: ~polaris.sdk.global_api.models.InnerError
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details
        self.innererror = innererror


class ErrorResponse8(_serialization.Model):
    """An error with a code and message.

    All required parameters must be populated in order to send to server.

    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    :ivar target: Error target.
    :vartype target: str
    :ivar details: Error details.
    :vartype details: list[~polaris.sdk.global_api.models.ErrorResponse]
    :ivar innererror: A detailed, service-specific error.
    :vartype innererror: ~polaris.sdk.global_api.models.InnerError
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "target": {"key": "target", "type": "str"},
        "details": {"key": "details", "type": "[ErrorResponse]"},
        "innererror": {"key": "innererror", "type": "InnerError"},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        target: Optional[str] = None,
        details: Optional[List["_models.ErrorResponse"]] = None,
        innererror: Optional["_models.InnerError"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        :keyword target: Error target.
        :paramtype target: str
        :keyword details: Error details.
        :paramtype details: list[~polaris.sdk.global_api.models.ErrorResponse]
        :keyword innererror: A detailed, service-specific error.
        :paramtype innererror: ~polaris.sdk.global_api.models.InnerError
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details
        self.innererror = innererror


class ErrorResponse9(_serialization.Model):
    """An error with a code and message.

    All required parameters must be populated in order to send to server.

    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    :ivar target: Error target.
    :vartype target: str
    :ivar details: Error details.
    :vartype details: list[~polaris.sdk.global_api.models.ErrorResponse]
    :ivar innererror: A detailed, service-specific error.
    :vartype innererror: ~polaris.sdk.global_api.models.InnerError
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
        "target": {"key": "target", "type": "str"},
        "details": {"key": "details", "type": "[ErrorResponse]"},
        "innererror": {"key": "innererror", "type": "InnerError"},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        target: Optional[str] = None,
        details: Optional[List["_models.ErrorResponse"]] = None,
        innererror: Optional["_models.InnerError"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        :keyword target: Error target.
        :paramtype target: str
        :keyword details: Error details.
        :paramtype details: list[~polaris.sdk.global_api.models.ErrorResponse]
        :keyword innererror: A detailed, service-specific error.
        :paramtype innererror: ~polaris.sdk.global_api.models.InnerError
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details
        self.innererror = innererror


class ExploreColorRange(_serialization.Model):
    """ExploreColorRange.

    All required parameters must be populated in order to send to server.

    :ivar max_value: Required.
    :vartype max_value: float
    :ivar min_value: Required.
    :vartype min_value: float
    :ivar min_op: Operator for the lower bound of a color range. Required. Known values are:
     "greaterThan" and "greaterThanOrEqual".
    :vartype min_op: str or ~polaris.sdk.global_api.models.ExploreColorRangeMinOp
    :ivar max_op: Operator for the upper bound of a color range. Required. Known values are:
     "lessThan" and "lessThanOrEqual".
    :vartype max_op: str or ~polaris.sdk.global_api.models.ExploreColorRangeMaxOp
    :ivar color: Color represented by a hex code. Required.
    :vartype color: str
    """

    _validation = {
        "max_value": {"required": True},
        "min_value": {"required": True},
        "min_op": {"required": True},
        "max_op": {"required": True},
        "color": {"required": True, "pattern": r"^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$"},
    }

    _attribute_map = {
        "max_value": {"key": "maxValue", "type": "float"},
        "min_value": {"key": "minValue", "type": "float"},
        "min_op": {"key": "minOp", "type": "str"},
        "max_op": {"key": "maxOp", "type": "str"},
        "color": {"key": "color", "type": "str"},
    }

    def __init__(
        self,
        *,
        max_value: float,
        min_value: float,
        min_op: Union[str, "_models.ExploreColorRangeMinOp"],
        max_op: Union[str, "_models.ExploreColorRangeMaxOp"],
        color: str,
        **kwargs: Any
    ) -> None:
        """
        :keyword max_value: Required.
        :paramtype max_value: float
        :keyword min_value: Required.
        :paramtype min_value: float
        :keyword min_op: Operator for the lower bound of a color range. Required. Known values are:
         "greaterThan" and "greaterThanOrEqual".
        :paramtype min_op: str or ~polaris.sdk.global_api.models.ExploreColorRangeMinOp
        :keyword max_op: Operator for the upper bound of a color range. Required. Known values are:
         "lessThan" and "lessThanOrEqual".
        :paramtype max_op: str or ~polaris.sdk.global_api.models.ExploreColorRangeMaxOp
        :keyword color: Color represented by a hex code. Required.
        :paramtype color: str
        """
        super().__init__(**kwargs)
        self.max_value = max_value
        self.min_value = min_value
        self.min_op = min_op
        self.max_op = max_op
        self.color = color


class ExploreEssence(_serialization.Model):
    """State of a visualization in the Explore View.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar parameters: Visual module parameters (metric, split, colors, etc.). Required.
    :vartype parameters: any
    :ivar transfer_groups: Maps a parameter name to a transfer group definition. Required.
    :vartype transfer_groups: any
    :ivar data_cube: Identifies the associated data cube. Required.
    :vartype data_cube: str
    :ivar module_name: Name of the visual module to use. Required. Known values are: "overall",
     "gauge", "flat_table", "time_series", "line_chart", "records_table", and "bar_chart".
    :vartype module_name: str or ~polaris.sdk.global_api.models.ExploreEssenceModuleName
    :ivar where: SQL WHERE expression to apply. Required.
    :vartype where: str
    :ivar having: SQL HAVING expression to apply.
    :vartype having: str
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    :ivar instance: Optional instance ID to use for the visualization.
    :vartype instance: str
    """

    _validation = {
        "parameters": {"required": True},
        "transfer_groups": {"required": True},
        "data_cube": {"required": True, "max_length": 255, "min_length": 1},
        "module_name": {"required": True},
        "where": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "parameters": {"key": "parameters", "type": "object"},
        "transfer_groups": {"key": "transferGroups", "type": "object"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "module_name": {"key": "moduleName", "type": "str"},
        "where": {"key": "where", "type": "str"},
        "having": {"key": "having", "type": "str"},
        "timezone": {"key": "timezone", "type": "str"},
        "instance": {"key": "instance", "type": "str"},
    }

    def __init__(
        self,
        *,
        parameters: Any,
        transfer_groups: Any,
        data_cube: str,
        module_name: Union[str, "_models.ExploreEssenceModuleName"],
        where: str,
        additional_properties: Optional[Dict[str, Any]] = None,
        having: Optional[str] = None,
        timezone: Optional[str] = None,
        instance: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword parameters: Visual module parameters (metric, split, colors, etc.). Required.
        :paramtype parameters: any
        :keyword transfer_groups: Maps a parameter name to a transfer group definition. Required.
        :paramtype transfer_groups: any
        :keyword data_cube: Identifies the associated data cube. Required.
        :paramtype data_cube: str
        :keyword module_name: Name of the visual module to use. Required. Known values are: "overall",
         "gauge", "flat_table", "time_series", "line_chart", "records_table", and "bar_chart".
        :paramtype module_name: str or ~polaris.sdk.global_api.models.ExploreEssenceModuleName
        :keyword where: SQL WHERE expression to apply. Required.
        :paramtype where: str
        :keyword having: SQL HAVING expression to apply.
        :paramtype having: str
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        :keyword instance: Optional instance ID to use for the visualization.
        :paramtype instance: str
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.parameters = parameters
        self.transfer_groups = transfer_groups
        self.data_cube = data_cube
        self.module_name = module_name
        self.where = where
        self.having = having
        self.timezone = timezone
        self.instance = instance


class ExploreSplitCombine(_serialization.Model):
    """ExploreSplitCombine.

    All required parameters must be populated in order to send to server.

    :ivar sort: SQL expression to use for sorting.
    :vartype sort: str
    :ivar sort_direction: Sort direction to use. Known values are: "ASC" and "DESC".
    :vartype sort_direction: str or ~polaris.sdk.global_api.models.ExploreSplitCombineSortDirection
    :ivar limit: Limit to apply to the split.
    :vartype limit: float
    :ivar granularity: Granularity to apply to the split. Expressed as an ISO duration string, for
     example\\ ``PT1H``. See https://en.wikipedia.org/wiki/ISO_8601#Durations) for more info.
    :vartype granularity: ~datetime.timedelta
    :ivar id: Optional ID to be use as a key in the UI. Required.
    :vartype id: str
    """

    _validation = {
        "id": {"required": True},
    }

    _attribute_map = {
        "sort": {"key": "sort", "type": "str"},
        "sort_direction": {"key": "sortDirection", "type": "str"},
        "limit": {"key": "limit", "type": "float"},
        "granularity": {"key": "granularity", "type": "duration"},
        "id": {"key": "id", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        sort: Optional[str] = None,
        sort_direction: Optional[
            Union[str, "_models.ExploreSplitCombineSortDirection"]
        ] = None,
        limit: Optional[float] = None,
        granularity: Optional[datetime.timedelta] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword sort: SQL expression to use for sorting.
        :paramtype sort: str
        :keyword sort_direction: Sort direction to use. Known values are: "ASC" and "DESC".
        :paramtype sort_direction: str or
         ~polaris.sdk.global_api.models.ExploreSplitCombineSortDirection
        :keyword limit: Limit to apply to the split.
        :paramtype limit: float
        :keyword granularity: Granularity to apply to the split. Expressed as an ISO duration string,
         for example\\ ``PT1H``. See https://en.wikipedia.org/wiki/ISO_8601#Durations) for more info.
        :paramtype granularity: ~datetime.timedelta
        :keyword id: Optional ID to be use as a key in the UI. Required.
        :paramtype id: str
        """
        super().__init__(**kwargs)
        self.sort = sort
        self.sort_direction = sort_direction
        self.limit = limit
        self.granularity = granularity
        self.id = id


class FacetCompare(_serialization.Model):
    """Comparison for data cubes.

    All required parameters must be populated in order to send to server.

    :ivar type: Comparison type. Required. Known values are: "time-relative", "time-absolute",
     "unfilter", "filter", and "measure".
    :vartype type: str or ~polaris.sdk.global_api.models.FacetCompareType
    :ivar duration: Time period to compare against, expressed as an `ISO 8601 Duration
     <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
     Only used for time-relative comparisons.
    :vartype duration: ~datetime.timedelta
    :ivar absolute_starting_date: Starting date to compare against, expressed as an `ISO 8601 Date
     <https://en.wikipedia.org/wiki/ISO_8601#Dates>`_.
     Only used for time-absolute comparisons.
    :vartype absolute_starting_date: ~datetime.datetime
    :ivar dimension: ID of the dimension to use for comparison.
    :vartype dimension: str
    :ivar measure: ID of the measure to use for comparison. Only valid for measure comparisons.
    :vartype measure: str
    :ivar filter: Filter to use for comparison. Only valid for "filter" comparisons.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "duration": {"key": "duration", "type": "duration"},
        "absolute_starting_date": {"key": "absoluteStartingDate", "type": "iso-8601"},
        "dimension": {"key": "dimension", "type": "str"},
        "measure": {"key": "measure", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.FacetCompareType"],
        duration: Optional[datetime.timedelta] = None,
        absolute_starting_date: Optional[datetime.datetime] = None,
        dimension: Optional[str] = None,
        measure: Optional[str] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Comparison type. Required. Known values are: "time-relative", "time-absolute",
         "unfilter", "filter", and "measure".
        :paramtype type: str or ~polaris.sdk.global_api.models.FacetCompareType
        :keyword duration: Time period to compare against, expressed as an `ISO 8601 Duration
         <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_.
         Only used for time-relative comparisons.
        :paramtype duration: ~datetime.timedelta
        :keyword absolute_starting_date: Starting date to compare against, expressed as an `ISO 8601
         Date <https://en.wikipedia.org/wiki/ISO_8601#Dates>`_.
         Only used for time-absolute comparisons.
        :paramtype absolute_starting_date: ~datetime.datetime
        :keyword dimension: ID of the dimension to use for comparison.
        :paramtype dimension: str
        :keyword measure: ID of the measure to use for comparison. Only valid for measure comparisons.
        :paramtype measure: str
        :keyword filter: Filter to use for comparison. Only valid for "filter" comparisons.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        """
        super().__init__(**kwargs)
        self.type = type
        self.duration = duration
        self.absolute_starting_date = absolute_starting_date
        self.dimension = dimension
        self.measure = measure
        self.filter = filter


class FacetEssence(_serialization.Model):
    """State of a visualization in the Pivot 2 view.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar data_cube: Identifies the associated data cube. Required.
    :vartype data_cube: str
    :ivar instance: Optional instance ID to use for the visualization.
    :vartype instance: str
    :ivar timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
     <https://en.wikipedia.org/wiki/Tz_database>`_.
    :vartype timezone: str
    :ivar filter: Filter expression to apply. Required.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar axes_splits: Dimension splits to apply.
    :vartype axes_splits: list[any]
    :ivar visualization: Visualization type to use. Known values are: "table", "line-chart",
     "vertical-bars", "horizontal-bars", "heatmap", "spot-matrix", "treemap", "pie-chart",
     "sunburst", "geo-marks", "sparkline", "stack-area-chart", "totals", "records", "path-tree",
     "geo-shade", "bubble-chart", "sankey", "street-map", and "records-table".
    :vartype visualization: str or ~polaris.sdk.global_api.models.FacetVisualizationType
    :ivar visualization_options: Visualization options to apply.
    :vartype visualization_options: dict[str, str]
    :ivar selected_measures: Measures to visualize.
    :vartype selected_measures: list[~polaris.sdk.global_api.models.LiveMeasure]
    :ivar multi_measure_mode: Controls how measures display when multiple measures are selected.
     Known values are: "row", "column", and "cell".
    :vartype multi_measure_mode: str or ~polaris.sdk.global_api.models.MultiMeasureMode
    :ivar compare: Comparison for data cubes.
    :vartype compare: ~polaris.sdk.global_api.models.FacetCompare
    :ivar pinned_dimensions: Array of dimension IDs to pin in the pinboard.
    :vartype pinned_dimensions: list[str]
    """

    _validation = {
        "data_cube": {"required": True, "max_length": 255, "min_length": 1},
        "filter": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "instance": {"key": "instance", "type": "str"},
        "timezone": {"key": "timezone", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "axes_splits": {"key": "axesSplits", "type": "[object]"},
        "visualization": {"key": "visualization", "type": "str"},
        "visualization_options": {"key": "visualizationOptions", "type": "{str}"},
        "selected_measures": {"key": "selectedMeasures", "type": "[LiveMeasure]"},
        "multi_measure_mode": {"key": "multiMeasureMode", "type": "str"},
        "compare": {"key": "compare", "type": "FacetCompare"},
        "pinned_dimensions": {"key": "pinnedDimensions", "type": "[str]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        filter: "_models.Filter",  # pylint: disable=redefined-builtin
        additional_properties: Optional[Dict[str, Any]] = None,
        instance: Optional[str] = None,
        timezone: Optional[str] = None,
        axes_splits: Optional[List[Any]] = None,
        visualization: Optional[Union[str, "_models.FacetVisualizationType"]] = None,
        visualization_options: Optional[Dict[str, str]] = None,
        selected_measures: Optional[List["_models.LiveMeasure"]] = None,
        multi_measure_mode: Optional[Union[str, "_models.MultiMeasureMode"]] = None,
        compare: Optional["_models.FacetCompare"] = None,
        pinned_dimensions: Optional[List[str]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword data_cube: Identifies the associated data cube. Required.
        :paramtype data_cube: str
        :keyword instance: Optional instance ID to use for the visualization.
        :paramtype instance: str
        :keyword timezone: Timezone to use for the visualization, expressed as an `Olsen Timezone
         <https://en.wikipedia.org/wiki/Tz_database>`_.
        :paramtype timezone: str
        :keyword filter: Filter expression to apply. Required.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword axes_splits: Dimension splits to apply.
        :paramtype axes_splits: list[any]
        :keyword visualization: Visualization type to use. Known values are: "table", "line-chart",
         "vertical-bars", "horizontal-bars", "heatmap", "spot-matrix", "treemap", "pie-chart",
         "sunburst", "geo-marks", "sparkline", "stack-area-chart", "totals", "records", "path-tree",
         "geo-shade", "bubble-chart", "sankey", "street-map", and "records-table".
        :paramtype visualization: str or ~polaris.sdk.global_api.models.FacetVisualizationType
        :keyword visualization_options: Visualization options to apply.
        :paramtype visualization_options: dict[str, str]
        :keyword selected_measures: Measures to visualize.
        :paramtype selected_measures: list[~polaris.sdk.global_api.models.LiveMeasure]
        :keyword multi_measure_mode: Controls how measures display when multiple measures are selected.
         Known values are: "row", "column", and "cell".
        :paramtype multi_measure_mode: str or ~polaris.sdk.global_api.models.MultiMeasureMode
        :keyword compare: Comparison for data cubes.
        :paramtype compare: ~polaris.sdk.global_api.models.FacetCompare
        :keyword pinned_dimensions: Array of dimension IDs to pin in the pinboard.
        :paramtype pinned_dimensions: list[str]
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.data_cube = data_cube
        self.instance = instance
        self.timezone = timezone
        self.filter = filter
        self.axes_splits = axes_splits
        self.visualization = visualization
        self.visualization_options = visualization_options
        self.selected_measures = selected_measures
        self.multi_measure_mode = multi_measure_mode
        self.compare = compare
        self.pinned_dimensions = pinned_dimensions


class Favorites(_serialization.Model):
    """Favorites object.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar assets: Required.
    :vartype assets: list[~polaris.sdk.global_api.models.CollectionAsset]
    :ivar created_by: The user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.User
    :ivar created_at: Date and time the collection was created, in ISO 8601 format. Required.
    :vartype created_at: ~datetime.datetime
    :ivar updated_by: The user. Required.
    :vartype updated_by: ~polaris.sdk.global_api.models.User
    :ivar updated_at: Date and time of the last update in ISO 8601 format. Required.
    :vartype updated_at: ~datetime.datetime
    """

    _validation = {
        "assets": {"required": True},
        "created_by": {"required": True, "readonly": True},
        "created_at": {"required": True},
        "updated_by": {"required": True, "readonly": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "assets": {"key": "assets", "type": "[CollectionAsset]"},
        "created_by": {"key": "createdBy", "type": "User"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "User"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        assets: List["_models.CollectionAsset"],
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        **kwargs: Any
    ) -> None:
        """
        :keyword assets: Required.
        :paramtype assets: list[~polaris.sdk.global_api.models.CollectionAsset]
        :keyword created_at: Date and time the collection was created, in ISO 8601 format. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword updated_at: Date and time of the last update in ISO 8601 format. Required.
        :paramtype updated_at: ~datetime.datetime
        """
        super().__init__(**kwargs)
        self.assets = assets
        self.created_by = None
        self.created_at = created_at
        self.updated_by = None
        self.updated_at = updated_at


class FieldNameAndDataType(_serialization.Model):
    """A field name and its associated data type.

    All required parameters must be populated in order to send to server.

    :ivar data_type: Data type of the input field. Required. Known values are: "bigint",
     "complex<json>", "double", "float", "geo", "HLLSketch", "ipAddress", "ipPrefix", "json",
     "long", "longStringPair", "doubleArray", "floatArray", "longArray", "stringArray",
     "quantilesDoublesSketch", "string", "thetaSketch", "ingest_timeseries", "timestamp", "varchar",
     and "variance".
    :vartype data_type: str or ~polaris.sdk.global_api.models.FieldNameAndDataTypeDataType
    :ivar name: Name of the input field. Required.
    :vartype name: str
    """

    _validation = {
        "data_type": {"required": True},
        "name": {"required": True},
    }

    _attribute_map = {
        "data_type": {"key": "dataType", "type": "str"},
        "name": {"key": "name", "type": "str"},
    }

    def __init__(
        self,
        *,
        data_type: Union[str, "_models.FieldNameAndDataTypeDataType"],
        name: str,
        **kwargs: Any
    ) -> None:
        """
        :keyword data_type: Data type of the input field. Required. Known values are: "bigint",
         "complex<json>", "double", "float", "geo", "HLLSketch", "ipAddress", "ipPrefix", "json",
         "long", "longStringPair", "doubleArray", "floatArray", "longArray", "stringArray",
         "quantilesDoublesSketch", "string", "thetaSketch", "ingest_timeseries", "timestamp", "varchar",
         and "variance".
        :paramtype data_type: str or ~polaris.sdk.global_api.models.FieldNameAndDataTypeDataType
        :keyword name: Name of the input field. Required.
        :paramtype name: str
        """
        super().__init__(**kwargs)
        self.data_type = data_type
        self.name = name


class FileListResponse(_serialization.Model):
    """FileListResponse.

    All required parameters must be populated in order to send to server.

    :ivar files: Required.
    :vartype files: list[~polaris.sdk.global_api.models.FileMetadata]
    :ivar links: Holds pagination links for paginated responses.
    :vartype links: ~polaris.sdk.global_api.models.PaginationLinks
    :ivar space: Information about the file repository itself. Required.
    :vartype space: ~polaris.sdk.global_api.models.RepositoryMetadata
    :ivar total_count: The total number of files.
    :vartype total_count: int
    """

    _validation = {
        "files": {"required": True},
        "space": {"required": True},
    }

    _attribute_map = {
        "files": {"key": "files", "type": "[FileMetadata]"},
        "links": {"key": "links", "type": "PaginationLinks"},
        "space": {"key": "space", "type": "RepositoryMetadata"},
        "total_count": {"key": "totalCount", "type": "int"},
    }

    def __init__(
        self,
        *,
        files: List["_models.FileMetadata"],
        space: "_models.RepositoryMetadata",
        links: Optional["_models.PaginationLinks"] = None,
        total_count: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword files: Required.
        :paramtype files: list[~polaris.sdk.global_api.models.FileMetadata]
        :keyword links: Holds pagination links for paginated responses.
        :paramtype links: ~polaris.sdk.global_api.models.PaginationLinks
        :keyword space: Information about the file repository itself. Required.
        :paramtype space: ~polaris.sdk.global_api.models.RepositoryMetadata
        :keyword total_count: The total number of files.
        :paramtype total_count: int
        """
        super().__init__(**kwargs)
        self.files = files
        self.links = links
        self.space = space
        self.total_count = total_count


class FileMetadata(_serialization.Model):
    """FileMetadata.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar compression_format: Compression format:


     * ``bz2`` - bzip2
     * ``gz`` - gzip
     * ``sz`` - `Snappy framing format
     <https://github.com/google/snappy/blob/master/framing_format.txt>`_
     * ``xz`` - XZ Utils (previously LZMA Utils)
     * ``zstd`` - `ZStandard <https://facebook.github.io/zstd/>`_. Required. Known values are:
     "none", "bz2", "gz", "sz", "xz", and "zstd".
    :vartype compression_format: str or ~polaris.sdk.global_api.models.CompressionFormat
    :ivar data_format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype data_format: str or ~polaris.sdk.global_api.models.DataFormat
    :ivar digest: The hash of the file's content as computed by the specified algorithm. Required.
    :vartype digest: ~polaris.sdk.global_api.models.Digest
    :ivar id: A generated, permanently unique ID for this file record. Required.
    :vartype id: str
    :ivar name: The unique name of the file. Required.
    :vartype name: str
    :ivar size_bytes: The file size in bytes. Required.
    :vartype size_bytes: int
    :ivar uploaded_by: A user. Required.
    :vartype uploaded_by: ~polaris.sdk.global_api.models.UserV2
    :ivar uploaded_on_datetime: The date and time this file was originally uploaded in `Internet
     date and time format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_\\ , for
     example, *2017-07-21T17:32:28Z*. Required.
    :vartype uploaded_on_datetime: ~datetime.datetime
    """

    _validation = {
        "compression_format": {"required": True},
        "data_format": {"required": True},
        "digest": {"required": True},
        "id": {"required": True},
        "name": {"required": True},
        "size_bytes": {"required": True},
        "uploaded_by": {"required": True, "readonly": True},
        "uploaded_on_datetime": {"required": True},
    }

    _attribute_map = {
        "compression_format": {"key": "compressionFormat", "type": "str"},
        "data_format": {"key": "dataFormat", "type": "str"},
        "digest": {"key": "digest", "type": "Digest"},
        "id": {"key": "id", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "size_bytes": {"key": "sizeBytes", "type": "int"},
        "uploaded_by": {"key": "uploadedBy", "type": "UserV2"},
        "uploaded_on_datetime": {"key": "uploadedOnDatetime", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        compression_format: Union[str, "_models.CompressionFormat"],
        data_format: Union[str, "_models.DataFormat"],
        digest: "_models.Digest",
        id: str,  # pylint: disable=redefined-builtin
        name: str,
        size_bytes: int,
        uploaded_on_datetime: datetime.datetime,
        **kwargs: Any
    ) -> None:
        """
        :keyword compression_format: Compression format:


         * ``bz2`` - bzip2
         * ``gz`` - gzip
         * ``sz`` - `Snappy framing format
         <https://github.com/google/snappy/blob/master/framing_format.txt>`_
         * ``xz`` - XZ Utils (previously LZMA Utils)
         * ``zstd`` - `ZStandard <https://facebook.github.io/zstd/>`_. Required. Known values are:
         "none", "bz2", "gz", "sz", "xz", and "zstd".
        :paramtype compression_format: str or ~polaris.sdk.global_api.models.CompressionFormat
        :keyword data_format: Data format:


         * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
         * ``avro_stream`` - Avro for stream ingestion
         * ``csv`` - Delimiter-separated data including CSV and TSV
         * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
         <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
         * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
         <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
         * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
         * ``orc`` - ORC format
         * ``parquet`` - Parquet format
         * ``protobuf`` - Protobuf format
         * ``regex`` - Format to parse using a regular expression. Required. Known values are:
         "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
         "protobuf".
        :paramtype data_format: str or ~polaris.sdk.global_api.models.DataFormat
        :keyword digest: The hash of the file's content as computed by the specified algorithm.
         Required.
        :paramtype digest: ~polaris.sdk.global_api.models.Digest
        :keyword id: A generated, permanently unique ID for this file record. Required.
        :paramtype id: str
        :keyword name: The unique name of the file. Required.
        :paramtype name: str
        :keyword size_bytes: The file size in bytes. Required.
        :paramtype size_bytes: int
        :keyword uploaded_on_datetime: The date and time this file was originally uploaded in `Internet
         date and time format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_\\ , for
         example, *2017-07-21T17:32:28Z*. Required.
        :paramtype uploaded_on_datetime: ~datetime.datetime
        """
        super().__init__(**kwargs)
        self.compression_format = compression_format
        self.data_format = data_format
        self.digest = digest
        self.id = id
        self.name = name
        self.size_bytes = size_bytes
        self.uploaded_by = None
        self.uploaded_on_datetime = uploaded_on_datetime


class Filter(_serialization.Model):
    """Filter to apply to a query.

    :ivar clauses: List of filter clauses.
    :vartype clauses: list[~polaris.sdk.global_api.models.FilterClause]
    :ivar measure_filters: List of measure filters.
    :vartype measure_filters: list[~polaris.sdk.global_api.models.MeasureFilter]
    """

    _attribute_map = {
        "clauses": {"key": "clauses", "type": "[FilterClause]"},
        "measure_filters": {"key": "measureFilters", "type": "[MeasureFilter]"},
    }

    def __init__(
        self,
        *,
        clauses: Optional[List["_models.FilterClause"]] = None,
        measure_filters: Optional[List["_models.MeasureFilter"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword clauses: List of filter clauses.
        :paramtype clauses: list[~polaris.sdk.global_api.models.FilterClause]
        :keyword measure_filters: List of measure filters.
        :paramtype measure_filters: list[~polaris.sdk.global_api.models.MeasureFilter]
        """
        super().__init__(**kwargs)
        self.clauses = clauses
        self.measure_filters = measure_filters


class Filter1Item(_serialization.Model):
    """Filter1Item."""


class FilterClause(_serialization.Model):
    """Filter clause to apply to a query.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar dimension: ID of the dimension to which the filter applies. Required.
    :vartype dimension: str
    :ivar action: Action performed by a filter clause. Required. Known values are: "overlap",
     "contains", "match", "intersect", and "ipMatch".
    :vartype action: str or ~polaris.sdk.global_api.models.FilterAction
    :ivar values: A set of values.
    :vartype values: ~polaris.sdk.global_api.models.PlywoodSet
    :ivar search: Search string to match.
    :vartype search: str
    :ivar exclude: Whether the filter is an exclusion filter.
    :vartype exclude: bool
    :ivar mv_filter_only: Whether to use MV_FILTER_ONLY for multi-value dimensions.
    :vartype mv_filter_only: bool
    """

    _validation = {
        "dimension": {"required": True},
        "action": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "dimension": {"key": "dimension", "type": "str"},
        "action": {"key": "action", "type": "str"},
        "values": {"key": "values", "type": "PlywoodSet"},
        "search": {"key": "search", "type": "str"},
        "exclude": {"key": "exclude", "type": "bool"},
        "mv_filter_only": {"key": "mvFilterOnly", "type": "bool"},
    }

    def __init__(
        self,
        *,
        dimension: str,
        action: Union[str, "_models.FilterAction"],
        additional_properties: Optional[Dict[str, Any]] = None,
        values: Optional["_models.PlywoodSet"] = None,
        search: Optional[str] = None,
        exclude: Optional[bool] = None,
        mv_filter_only: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword dimension: ID of the dimension to which the filter applies. Required.
        :paramtype dimension: str
        :keyword action: Action performed by a filter clause. Required. Known values are: "overlap",
         "contains", "match", "intersect", and "ipMatch".
        :paramtype action: str or ~polaris.sdk.global_api.models.FilterAction
        :keyword values: A set of values.
        :paramtype values: ~polaris.sdk.global_api.models.PlywoodSet
        :keyword search: Search string to match.
        :paramtype search: str
        :keyword exclude: Whether the filter is an exclusion filter.
        :paramtype exclude: bool
        :keyword mv_filter_only: Whether to use MV_FILTER_ONLY for multi-value dimensions.
        :paramtype mv_filter_only: bool
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.dimension = dimension
        self.action = action
        self.values = values
        self.search = search
        self.exclude = exclude
        self.mv_filter_only = mv_filter_only


class GeoMarks(_serialization.Model):
    """GeoMarks.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "geo-marks"
    :vartype type: str or ~polaris.sdk.global_api.models.GeoMarksType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar markers: Dimensions to be shown by the markers. Required.
    :vartype markers: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "markers": {"required": True, "max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "markers": {"key": "markers", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        markers: List[Any],
        type: Optional[Union[str, "_models.GeoMarksType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "geo-marks"
        :paramtype type: str or ~polaris.sdk.global_api.models.GeoMarksType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword markers: Dimensions to be shown by the markers. Required.
        :paramtype markers: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.markers = markers


class GeoShade(_serialization.Model):
    """GeoShade.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "geo-shade"
    :vartype type: str or ~polaris.sdk.global_api.models.GeoShadeType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar markers: Dimensions to be shown by the markers. Required.
    :vartype markers: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "markers": {"required": True, "max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "markers": {"key": "markers", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        markers: List[Any],
        type: Optional[Union[str, "_models.GeoShadeType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "geo-shade"
        :paramtype type: str or ~polaris.sdk.global_api.models.GeoShadeType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword markers: Dimensions to be shown by the markers. Required.
        :paramtype markers: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.markers = markers


class GranularityPayload(_serialization.Model):
    """The table's rollup granularity. Determines how to bucket data across the time dimension, such
    as aggregating data by hour.
    When set, ``queryGranularity`` overrides the rollup granularity in ``timeResolution``.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    PeriodGranularityPayload, SimpleGranularityPayload

    All required parameters must be populated in order to send to server.

    :ivar type: The type of granularity.


     * ``simple``\\ - Simple granularity such as ``millisecond`` or ``hour``.
     * ``period``\\ - Period-based granularity that accepts an ISO 8601 period such as ``P6M``.
     Allows specification of time zone and origin. Required. Known values are: "simple" and
     "period".
    :vartype type: str or ~polaris.sdk.global_api.models.GranularityType
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    _subtype_map = {
        "type": {
            "period": "PeriodGranularityPayload",
            "simple": "SimpleGranularityPayload",
        }
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: Optional[str] = None


class GroupFilter(_serialization.Model):
    """ID of the user group (\\ ``groupFilters``\\ ) or the API key (\\ ``userFilters``\\ ) for the
    access filter. Use the `Identity Management API
    <https://docs.imply.io/api/polaris/api-reference#tag/identity>`_ to return user group IDs and
    the `API Keys API <https://docs.imply.io/api/polaris/api-reference#tag/apiKeys>`_ to return API
    key IDs.

    All required parameters must be populated in order to send to server.

    :ivar name: Name of the access filter. Required.
    :vartype name: str
    :ivar formula: SQL query to select data for the filter. Preface column names with ``t.``. For
     example, ``t.country``. Required.
    :vartype formula: str
    """

    _validation = {
        "name": {"required": True},
        "formula": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "formula": {"key": "formula", "type": "str"},
    }

    def __init__(self, *, name: str, formula: str, **kwargs: Any) -> None:
        """
        :keyword name: Name of the access filter. Required.
        :paramtype name: str
        :keyword formula: SQL query to select data for the filter. Preface column names with ``t.``.
         For example, ``t.country``. Required.
        :paramtype formula: str
        """
        super().__init__(**kwargs)
        self.name = name
        self.formula = formula


class GroupListRepresentation(_serialization.Model):
    """GroupListRepresentation.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.GroupRepresentation]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[GroupRepresentation]"},
    }

    def __init__(
        self, *, values: List["_models.GroupRepresentation"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.GroupRepresentation]
        """
        super().__init__(**kwargs)
        self.values = values


class GroupRepresentation(_serialization.Model):
    """GroupRepresentation.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: A generated, permanently unique ID for this group.
    :vartype id: str
    :ivar name: The group name.
    :vartype name: str
    :ivar read_only: Flag to indicate whether this group can be modified.
    :vartype read_only: bool
    :ivar permissions: The list of permissions assigned to the group.
    :vartype permissions: list[~polaris.sdk.global_api.models.PermissionRepresentation]
    :ivar user_count: The number of users assigned to this group.
    :vartype user_count: int
    """

    _validation = {
        "id": {"readonly": True},
        "read_only": {"readonly": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "read_only": {"key": "readOnly", "type": "bool"},
        "permissions": {"key": "permissions", "type": "[PermissionRepresentation]"},
        "user_count": {"key": "userCount", "type": "int"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        permissions: Optional[List["_models.PermissionRepresentation"]] = None,
        user_count: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: The group name.
        :paramtype name: str
        :keyword permissions: The list of permissions assigned to the group.
        :paramtype permissions: list[~polaris.sdk.global_api.models.PermissionRepresentation]
        :keyword user_count: The number of users assigned to this group.
        :paramtype user_count: int
        """
        super().__init__(**kwargs)
        self.id = None
        self.name = name
        self.read_only = None
        self.permissions = permissions
        self.user_count = user_count


class HavingFilter(_serialization.Model):
    """HAVING filter to apply to a measure.

    All required parameters must be populated in order to send to server.

    :ivar measure: ID of the measure to which the filter applies. Required.
    :vartype measure: str
    :ivar op: Operator for a HAVING filter. Required. Known values are: "lessThan" and
     "greaterThan".
    :vartype op: str or ~polaris.sdk.global_api.models.HavingFilterOperator
    :ivar value: Value to match. Required.
    :vartype value: float
    """

    _validation = {
        "measure": {"required": True},
        "op": {"required": True},
        "value": {"required": True},
    }

    _attribute_map = {
        "measure": {"key": "measure", "type": "str"},
        "op": {"key": "op", "type": "str"},
        "value": {"key": "value", "type": "float"},
    }

    def __init__(
        self,
        *,
        measure: str,
        op: Union[str, "_models.HavingFilterOperator"],
        value: float,
        **kwargs: Any
    ) -> None:
        """
        :keyword measure: ID of the measure to which the filter applies. Required.
        :paramtype measure: str
        :keyword op: Operator for a HAVING filter. Required. Known values are: "lessThan" and
         "greaterThan".
        :paramtype op: str or ~polaris.sdk.global_api.models.HavingFilterOperator
        :keyword value: Value to match. Required.
        :paramtype value: float
        """
        super().__init__(**kwargs)
        self.measure = measure
        self.op = op
        self.value = value


class HeatMap(_serialization.Model):
    """HeatMap.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "heatmap"
    :vartype type: str or ~polaris.sdk.global_api.models.HeatMapType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar rows: Dimensions to be displayed in the rows. Required.
    :vartype rows: list[any]
    :ivar columns: Dimensions to be displayed in the columns.
    :vartype columns: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "rows": {"required": True, "max_items": 1, "min_items": 1},
        "columns": {"max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "rows": {"key": "rows", "type": "[object]"},
        "columns": {"key": "columns", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        rows: List[Any],
        type: Optional[Union[str, "_models.HeatMapType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        columns: Optional[List[Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "heatmap"
        :paramtype type: str or ~polaris.sdk.global_api.models.HeatMapType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword rows: Dimensions to be displayed in the rows. Required.
        :paramtype rows: list[any]
        :keyword columns: Dimensions to be displayed in the columns.
        :paramtype columns: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.rows = rows
        self.columns = columns


class HorizontalBars(_serialization.Model):
    """HorizontalBars.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "horizontal-bars"
    :vartype type: str or ~polaris.sdk.global_api.models.HorizontalBarsType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar bars: Dimensions to be shown by the bars. Required.
    :vartype bars: list[any]
    :ivar stack: Dimensions to be shown by the stack.
    :vartype stack: list[any]
    :ivar multiples: Dimensions to be shown by the multiples.
    :vartype multiples: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "bars": {"required": True, "max_items": 1, "min_items": 1},
        "stack": {"max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "bars": {"key": "bars", "type": "[object]"},
        "stack": {"key": "stack", "type": "[object]"},
        "multiples": {"key": "multiples", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        bars: List[Any],
        type: Optional[Union[str, "_models.HorizontalBarsType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        stack: Optional[List[Any]] = None,
        multiples: Optional[List[Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "horizontal-bars"
        :paramtype type: str or ~polaris.sdk.global_api.models.HorizontalBarsType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword bars: Dimensions to be shown by the bars. Required.
        :paramtype bars: list[any]
        :keyword stack: Dimensions to be shown by the stack.
        :paramtype stack: list[any]
        :keyword multiples: Dimensions to be shown by the multiples.
        :paramtype multiples: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.bars = bars
        self.stack = stack
        self.multiples = multiples


class HttpBasicAuthSecretsProperties(_serialization.Model):
    """Properties specific to HTTP basic authentication secrets.

    :ivar username: Username of the account to use for authentication.
    :vartype username: str
    :ivar password: Password of the account to use for authentication.
    :vartype password: str
    """

    _attribute_map = {
        "username": {"key": "username", "type": "str"},
        "password": {"key": "password", "type": "str"},
    }

    def __init__(
        self,
        *,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword username: Username of the account to use for authentication.
        :paramtype username: str
        :keyword password: Password of the account to use for authentication.
        :paramtype password: str
        """
        super().__init__(**kwargs)
        self.username = username
        self.password = password


class HttpBasicAuthSecretsOptionalPayload(
    ConnectionSecretsOptionalPayload, HttpBasicAuthSecretsProperties
):
    """Configuration and credentials for HTTP basic authentication.

    All required parameters must be populated in order to send to server.

    :ivar username: Username of the account to use for authentication.
    :vartype username: str
    :ivar password: Password of the account to use for authentication.
    :vartype password: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "username": {"key": "username", "type": "str"},
        "password": {"key": "password", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self,
        *,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword username: Username of the account to use for authentication.
        :paramtype username: str
        :keyword password: Password of the account to use for authentication.
        :paramtype password: str
        """
        super().__init__(username=username, password=password, **kwargs)
        self.username = username
        self.password = password
        self.type: str = "basic"


class HttpBasicAuthSecretsPropertiesRequired(HttpBasicAuthSecretsProperties):
    """HttpBasicAuthSecretsPropertiesRequired.

    :ivar username: Username of the account to use for authentication.
    :vartype username: str
    :ivar password: Password of the account to use for authentication.
    :vartype password: str
    """


class HttpBasicAuthSecretsRequiredPayload(
    ConnectionSecretsRequiredPayload, HttpBasicAuthSecretsPropertiesRequired
):
    """Configuration and credentials for HTTP basic authentication.

    All required parameters must be populated in order to send to server.

    :ivar username: Username of the account to use for authentication.
    :vartype username: str
    :ivar password: Password of the account to use for authentication.
    :vartype password: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "username": {"key": "username", "type": "str"},
        "password": {"key": "password", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self,
        *,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword username: Username of the account to use for authentication.
        :paramtype username: str
        :keyword password: Password of the account to use for authentication.
        :paramtype password: str
        """
        super().__init__(username=username, password=password, **kwargs)
        self.username = username
        self.password = password
        self.type: str = "basic"


class IdentityRepresentation(_serialization.Model):
    """IdentityRepresentation.

    :ivar provider_id: The ID of the configured identity provider.
    :vartype provider_id: str
    """

    _attribute_map = {
        "provider_id": {"key": "providerId", "type": "str"},
    }

    def __init__(self, *, provider_id: Optional[str] = None, **kwargs: Any) -> None:
        """
        :keyword provider_id: The ID of the configured identity provider.
        :paramtype provider_id: str
        """
        super().__init__(**kwargs)
        self.provider_id = provider_id


class IngestionJobTotals(_serialization.Model):
    """Statistics about the rows processed and skipped by an ingestion job.
    For more information, see `Ingestion status reference
    <https://docs.imply.io/ui/saas/help/ingestion-status.html>`_.

    :ivar num_bytes_processed: The total number of uncompressed bytes processed, including data
     from rows that were processed with warnings or were skipped.
    :vartype num_bytes_processed: int
    :ivar num_rows_persisted: The number of rows stored in the table. If you ingested data into an
     aggregate table, Polaris applies `rollup <https://docs.imply.io/ui/saas/help/rollup.html>`_
     based on the specified rollup time granularity. This may cause ``numRowsPersisted`` to be less
     than ``numRowsProcessed``. Streaming ingestion jobs currently do not report this metric.
    :vartype num_rows_persisted: int
    :ivar num_rows_processed: The total number of rows successfully processed, excluding those with
     warnings.
    :vartype num_rows_processed: int
    :ivar num_rows_processed_with_warning: The number of rows partially processed due to warnings,
     such as unparseable data.
    :vartype num_rows_processed_with_warning: int
    :ivar num_rows_skipped_by_error: The number of rows that could not be processed due to an error
     in the data.
    :vartype num_rows_skipped_by_error: int
    :ivar num_rows_skipped_by_filter: The number of rows that were not processed due to being
     skipped by a filter, such as the interval for the ingestion job.
    :vartype num_rows_skipped_by_filter: int
    """

    _attribute_map = {
        "num_bytes_processed": {"key": "numBytesProcessed", "type": "int"},
        "num_rows_persisted": {"key": "numRowsPersisted", "type": "int"},
        "num_rows_processed": {"key": "numRowsProcessed", "type": "int"},
        "num_rows_processed_with_warning": {
            "key": "numRowsProcessedWithWarning",
            "type": "int",
        },
        "num_rows_skipped_by_error": {"key": "numRowsSkippedByError", "type": "int"},
        "num_rows_skipped_by_filter": {"key": "numRowsSkippedByFilter", "type": "int"},
    }

    def __init__(
        self,
        *,
        num_bytes_processed: Optional[int] = None,
        num_rows_persisted: Optional[int] = None,
        num_rows_processed: Optional[int] = None,
        num_rows_processed_with_warning: Optional[int] = None,
        num_rows_skipped_by_error: Optional[int] = None,
        num_rows_skipped_by_filter: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword num_bytes_processed: The total number of uncompressed bytes processed, including data
         from rows that were processed with warnings or were skipped.
        :paramtype num_bytes_processed: int
        :keyword num_rows_persisted: The number of rows stored in the table. If you ingested data into
         an aggregate table, Polaris applies `rollup <https://docs.imply.io/ui/saas/help/rollup.html>`_
         based on the specified rollup time granularity. This may cause ``numRowsPersisted`` to be less
         than ``numRowsProcessed``. Streaming ingestion jobs currently do not report this metric.
        :paramtype num_rows_persisted: int
        :keyword num_rows_processed: The total number of rows successfully processed, excluding those
         with warnings.
        :paramtype num_rows_processed: int
        :keyword num_rows_processed_with_warning: The number of rows partially processed due to
         warnings, such as unparseable data.
        :paramtype num_rows_processed_with_warning: int
        :keyword num_rows_skipped_by_error: The number of rows that could not be processed due to an
         error in the data.
        :paramtype num_rows_skipped_by_error: int
        :keyword num_rows_skipped_by_filter: The number of rows that were not processed due to being
         skipped by a filter, such as the interval for the ingestion job.
        :paramtype num_rows_skipped_by_filter: int
        """
        super().__init__(**kwargs)
        self.num_bytes_processed = num_bytes_processed
        self.num_rows_persisted = num_rows_persisted
        self.num_rows_processed = num_rows_processed
        self.num_rows_processed_with_warning = num_rows_processed_with_warning
        self.num_rows_skipped_by_error = num_rows_skipped_by_error
        self.num_rows_skipped_by_filter = num_rows_skipped_by_filter


class InlineAvroParseSchemaProvider(ParseSchemaProvider):
    """InlineAvroParseSchemaProvider.

    All required parameters must be populated in order to send to server.

    :ivar type: Data format:


     * ``connection`` - Retrieves the parse schema from an external source defined by a connection.
     * ``inline-avro`` - An inline Avro schema.
     * ``inline-protobuf`` - An inline compiled Protobuf descriptor, encoded as a Base64 string.
     Required. Known values are: "connection", "inline-avro", and "inline-protobuf".
    :vartype type: str or ~polaris.sdk.global_api.models.ParseSchemaProviderType
    :ivar schema: A reader schema to parse Avro records.
     For example:

     .. code-block::

        {
             "type": "record",
             "namespace": "com.example",
             "name": "FullName",
             "fields": [
               { "name": "first", "type": "string" },
               { "name": "last", "type": "string" }
             ]
        }.
    :vartype schema: dict[str, any]
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "schema": {"key": "schema", "type": "{object}"},
    }

    def __init__(
        self, *, schema: Optional[Dict[str, Any]] = None, **kwargs: Any
    ) -> None:
        """
        :keyword schema: A reader schema to parse Avro records.
         For example:

         .. code-block::

            {
                 "type": "record",
                 "namespace": "com.example",
                 "name": "FullName",
                 "fields": [
                   { "name": "first", "type": "string" },
                   { "name": "last", "type": "string" }
                 ]
            }.
        :paramtype schema: dict[str, any]
        """
        super().__init__(**kwargs)
        self.type: str = "inline-avro"
        self.schema = schema


class InlineJobSourceSummary(JobSourceSummary):
    """A summary of an inline source input.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    :ivar data: Inline data to ingest. Required.
    :vartype data: str
    """

    _validation = {
        "type": {"required": True},
        "data": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data": {"key": "data", "type": "str"},
    }

    def __init__(self, *, data: str, **kwargs: Any) -> None:
        """
        :keyword data: Inline data to ingest. Required.
        :paramtype data: str
        """
        super().__init__(**kwargs)
        self.type: str = "inline"
        self.data = data


class InlineJobSourceV2(JobSourceV2):
    """An input source where the data to be ingested is provided inline in the source specification.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    :ivar data: Inline data to ingest. Required.
    :vartype data: str
    :ivar input_schema: The schema of input data in terms of a list of input field names and their
     respective data types. Required.
    :vartype input_schema: list[~polaris.sdk.global_api.models.FieldNameAndDataType]
    :ivar format_settings: Data format settings that apply to all files in the ingestion job.
     Polaris automatically detects the file type based on the file extension. If you specify a value
     that does not match the automatically detected type, Polaris attempts to ingest based on the
     user-specified value.
    :vartype format_settings: ~polaris.sdk.global_api.models.DataFormatSettings
    """

    _validation = {
        "type": {"required": True},
        "data": {"required": True},
        "input_schema": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data": {"key": "data", "type": "str"},
        "input_schema": {"key": "inputSchema", "type": "[FieldNameAndDataType]"},
        "format_settings": {"key": "formatSettings", "type": "DataFormatSettings"},
    }

    def __init__(
        self,
        *,
        data: str,
        input_schema: List["_models.FieldNameAndDataType"] = [],
        format_settings: Optional["_models.DataFormatSettings"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword data: Inline data to ingest. Required.
        :paramtype data: str
        :keyword input_schema: The schema of input data in terms of a list of input field names and
         their respective data types. Required.
        :paramtype input_schema: list[~polaris.sdk.global_api.models.FieldNameAndDataType]
        :keyword format_settings: Data format settings that apply to all files in the ingestion job.
         Polaris automatically detects the file type based on the file extension. If you specify a value
         that does not match the automatically detected type, Polaris attempts to ingest based on the
         user-specified value.
        :paramtype format_settings: ~polaris.sdk.global_api.models.DataFormatSettings
        """
        super().__init__(**kwargs)
        self.type: str = "inline"
        self.data = data
        self.input_schema = input_schema
        self.format_settings = format_settings


class InlineProtobufParseSchemaProvider(ParseSchemaProvider):
    """InlineProtobufParseSchemaProvider.

    All required parameters must be populated in order to send to server.

    :ivar type: Data format:


     * ``connection`` - Retrieves the parse schema from an external source defined by a connection.
     * ``inline-avro`` - An inline Avro schema.
     * ``inline-protobuf`` - An inline compiled Protobuf descriptor, encoded as a Base64 string.
     Required. Known values are: "connection", "inline-avro", and "inline-protobuf".
    :vartype type: str or ~polaris.sdk.global_api.models.ParseSchemaProviderType
    :ivar descriptor: An inline compiled Protobuf descriptor, encoded as a Base64 string.
    :vartype descriptor: str
    :ivar proto_message_type: Protobuf message type from the descriptor. Polaris accepts either a
     short name or a
     fully qualified name for the message type. For example, in the following ``.proto`` snippet,
     both ``Person`` and ``tutorial.Person`` are valid message types.

     .. code-block::

        package tutorial;
        message Person {

     The parser uses the first message type found in the descriptor if not specified.
    :vartype proto_message_type: str
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "descriptor": {"key": "descriptor", "type": "str"},
        "proto_message_type": {"key": "protoMessageType", "type": "str"},
    }

    def __init__(
        self,
        *,
        descriptor: Optional[str] = None,
        proto_message_type: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword descriptor: An inline compiled Protobuf descriptor, encoded as a Base64 string.
        :paramtype descriptor: str
        :keyword proto_message_type: Protobuf message type from the descriptor. Polaris accepts either
         a short name or a
         fully qualified name for the message type. For example, in the following ``.proto`` snippet,
         both ``Person`` and ``tutorial.Person`` are valid message types.

         .. code-block::

            package tutorial;
            message Person {

         The parser uses the first message type found in the descriptor if not specified.
        :paramtype proto_message_type: str
        """
        super().__init__(**kwargs)
        self.type: str = "inline-protobuf"
        self.descriptor = descriptor
        self.proto_message_type = proto_message_type


class InnerError(_serialization.Model):
    """A detailed, service-specific error.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar code: The error code. Required.
    :vartype code: str
    :ivar message: The error message. Required.
    :vartype message: str
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        additional_properties: Optional[Dict[str, Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword code: The error code. Required.
        :paramtype code: str
        :keyword message: The error message. Required.
        :paramtype message: str
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.code = code
        self.message = message


class InnerError1(_serialization.Model):
    """A detailed, service-specific error.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        additional_properties: Optional[Dict[str, Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.code = code
        self.message = message


class InnerError2(_serialization.Model):
    """A detailed, service-specific error.

    All required parameters must be populated in order to send to server.

    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
    }

    def __init__(self, *, code: str, message: str, **kwargs: Any) -> None:
        """
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message


class InnerError3(_serialization.Model):
    """A detailed, service-specific error.

    All required parameters must be populated in order to send to server.

    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
    }

    def __init__(self, *, code: str, message: str, **kwargs: Any) -> None:
        """
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message


class InnerError4(_serialization.Model):
    """A detailed, service-specific error.

    All required parameters must be populated in order to send to server.

    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
    }

    def __init__(self, *, code: str, message: str, **kwargs: Any) -> None:
        """
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message


class InnerError5(_serialization.Model):
    """A detailed, service-specific error.

    All required parameters must be populated in order to send to server.

    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
    }

    def __init__(self, *, code: str, message: str, **kwargs: Any) -> None:
        """
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message


class InnerError6(_serialization.Model):
    """A detailed, service-specific error.

    All required parameters must be populated in order to send to server.

    :ivar code: Error code. Required.
    :vartype code: str
    :ivar message: Error message. Required.
    :vartype message: str
    """

    _validation = {
        "code": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
    }

    def __init__(self, *, code: str, message: str, **kwargs: Any) -> None:
        """
        :keyword code: Error code. Required.
        :paramtype code: str
        :keyword message: Error message. Required.
        :paramtype message: str
        """
        super().__init__(**kwargs)
        self.code = code
        self.message = message


class InputToTableSchemaMapping(_serialization.Model):
    """How to map input to an output column of a table schema, in the form of a pair of (\\
    ``columnName``\\ , ``expression``\\ ). The ``columnName`` specifies the output column of the
    schema, and the ``expression`` specifies how the column is defined with respect to the input
    fields. The ``expression`` must be a valid SQL expression.

    All required parameters must be populated in order to send to server.

    :ivar column_name: The name of the table column. Required.
    :vartype column_name: str
    :ivar expression: A valid SQL expression that describes how to compute the value of a table's
     column from a set of input fields. Wrap input field names in escaped quotation marks, such as
     ``SUM(\\"unitsSold\\")``. To map an input field to a Polaris column with the same name and
     values without any transformation, use the name of the input field for the expression, such as
     ``\\"unitsSold\\"``. If the Polaris table column is a measure column of an aggregate table, the
     expression must contain an aggregation function. The aggregation function should be compatible
     with the query aggregator set in the table's ``schema``\\ , if defined. Required.
    :vartype expression: str
    :ivar is_aggregation: If specified, indicates if this mapping is an aggregation function. If
     not specified, Polaris will refer to the table schema to see if ``columnName`` refers to an
     aggregate column to determine if the mapping is specified on an aggregate column. If the table
     schema does not contain a column named ``columnName``\\ , then Polaris assumes the mapping is
     not an aggregate mapping.
    :vartype is_aggregation: bool
    """

    _validation = {
        "column_name": {"required": True},
        "expression": {"required": True},
    }

    _attribute_map = {
        "column_name": {"key": "columnName", "type": "str"},
        "expression": {"key": "expression", "type": "str"},
        "is_aggregation": {"key": "isAggregation", "type": "bool"},
    }

    def __init__(
        self,
        *,
        column_name: str,
        expression: str,
        is_aggregation: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword column_name: The name of the table column. Required.
        :paramtype column_name: str
        :keyword expression: A valid SQL expression that describes how to compute the value of a
         table's column from a set of input fields. Wrap input field names in escaped quotation marks,
         such as ``SUM(\\"unitsSold\\")``. To map an input field to a Polaris column with the same name
         and values without any transformation, use the name of the input field for the expression, such
         as ``\\"unitsSold\\"``. If the Polaris table column is a measure column of an aggregate table,
         the expression must contain an aggregation function. The aggregation function should be
         compatible with the query aggregator set in the table's ``schema``\\ , if defined. Required.
        :paramtype expression: str
        :keyword is_aggregation: If specified, indicates if this mapping is an aggregation function. If
         not specified, Polaris will refer to the table schema to see if ``columnName`` refers to an
         aggregate column to determine if the mapping is specified on an aggregate column. If the table
         schema does not contain a column named ``columnName``\\ , then Polaris assumes the mapping is
         not an aggregate mapping.
        :paramtype is_aggregation: bool
        """
        super().__init__(**kwargs)
        self.column_name = column_name
        self.expression = expression
        self.is_aggregation = is_aggregation


class StoragePolicyPayload(_serialization.Model):
    """Storage policy that determines how long to retain or precache data.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    IntervalsPolicyPayload, PeriodPolicyPayload

    All required parameters must be populated in order to send to server.

    :ivar type: The type of storage policy to set. Required. Known values are: "intervals" and
     "period".
    :vartype type: str or ~polaris.sdk.global_api.models.StoragePolicyType
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    _subtype_map = {
        "type": {"intervals": "IntervalsPolicyPayload", "period": "PeriodPolicyPayload"}
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: Optional[str] = None


class IntervalsPolicyPayload(StoragePolicyPayload):
    """IntervalsPolicyPayload.

    All required parameters must be populated in order to send to server.

    :ivar type: The type of storage policy to set. Required. Known values are: "intervals" and
     "period".
    :vartype type: str or ~polaris.sdk.global_api.models.StoragePolicyType
    :ivar intervals: One or more time intervals in ISO 8601 format. The interval applies to the
     post-transform
     timestamp values stored in the ``__time`` column of the table. Required.
    :vartype intervals: list[str]
    :ivar period: Time duration in ISO 8601 format relative to the present time. The duration
     refers to the post-transform
     timestamp values stored in the ``__time`` column of the table. For example, the period
     ``P30D``
     retains or precaches data within 30 days of the present time.
    :vartype period: str
    """

    _validation = {
        "type": {"required": True},
        "intervals": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "intervals": {"key": "intervals", "type": "[str]"},
        "period": {"key": "period", "type": "str"},
    }

    def __init__(
        self, *, intervals: List[str], period: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword intervals: One or more time intervals in ISO 8601 format. The interval applies to the
         post-transform
         timestamp values stored in the ``__time`` column of the table. Required.
        :paramtype intervals: list[str]
        :keyword period: Time duration in ISO 8601 format relative to the present time. The duration
         refers to the post-transform
         timestamp values stored in the ``__time`` column of the table. For example, the period
         ``P30D``
         retains or precaches data within 30 days of the present time.
        :paramtype period: str
        """
        super().__init__(**kwargs)
        self.type: str = "intervals"
        self.intervals = intervals
        self.period = period


class JobHealthV2(_serialization.Model):
    """The health of a job.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    JobErrorHealthV2, JobOkHealthV2, JobWarningHealthV2

    All required parameters must be populated in order to send to server.

    :ivar status: The health status of the job.


     * ``ok``        - The job is in good health with no warnings or errors raised.
     * ``warn``      - The job has one or more warnings.
     * ``error``     - The job has one or more errors. Required. Known values are: "ok", "warn",
     and "error".
    :vartype status: str or ~polaris.sdk.global_api.models.JobHealthStatusV2
    """

    _validation = {
        "status": {"required": True},
    }

    _attribute_map = {
        "status": {"key": "status", "type": "str"},
    }

    _subtype_map = {
        "status": {
            "error": "JobErrorHealthV2",
            "ok": "JobOkHealthV2",
            "warning": "JobWarningHealthV2",
        }
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.status: Optional[str] = None


class JobErrorHealthV2(JobHealthV2):
    """The job has one or more errors.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar status: The health status of the job.


     * ``ok``        - The job is in good health with no warnings or errors raised.
     * ``warn``      - The job has one or more warnings.
     * ``error``     - The job has one or more errors. Required. Known values are: "ok", "warn",
     and "error".
    :vartype status: str or ~polaris.sdk.global_api.models.JobHealthStatusV2
    :ivar code: Status returned when a job completed with error. The following error statuses may
     be returned:


     * ``canceled``                            - The job was canceled.
     * ``cannot_parse_multi_value_dimension``  - The input contains multi-value dimension(s).
     Please wrap them in MV_TO_ARRAY().
     * ``cannot_parse_source``                 - The input source could not be parsed with the
     given format/configuration.
     * ``column_name_restricted``              - A column used a restricted column name.
     * ``column_type_not_supported``           - A column has an unsupported type.
     * ``could_not_connect_to_source``         - Polaris could not connect to the source input.
     * ``internal_error``                      - An internal error occurred. Please retry your
     request and contact support if the issue persists.
     * ``invalid_null_byte``                   - The input data contained a string with a null
     byte.
     * ``multiple``                            - Multiple errors resulted. See the `job logs
     <#tag/projectJobs/operation/describeJobLogsInProject>`_ for details.
     * ``no_rows_ingested``                    - An ingestion job produced no rows. Please check
     your data, timestamp mapping, and any ingestion filters.
     * ``null_timestamp``                      - The input data contained a null timestamp.
     * ``query_not_supported``                 - The ingestion query is not supported.
     * ``row_too_large``                       - The input data contained a row that was too large.
     * ``timestamp_out_of_bounds``             - The input data contained a timestamp outside of
     the bounds specified by OVERWRITE WHERE.
     * ``too_many_clustered_by_columns``       - The job is clustering by too many columns.
     * ``too_many_columns``                    - The job is creating too many output columns.
     * ``too_many_input_files``                - The job is ingesting too many input files.
     * ``too_many_partitions``                 - The job is creating too many output partitions.
     * ``too_many_rows_with_same_key``         - The input data contains too many rows with the
     same key.
     * ``too_many_time_buckets``               - The job is creating too many time buckets in the
     output. Required. Known values are: "canceled", "cannot_parse_multi_value_dimension",
     "cannot_parse_source", "column_name_restricted", "column_type_not_supported",
     "could_not_connect_to_source", "internal_error", "invalid_null_byte", "multiple",
     "no_rows_ingested", "null_timestamp", "query_not_supported", "row_too_large",
     "timestamp_out_of_bounds", "too_many_clustered_by_columns", "too_many_columns",
     "too_many_input_files", "too_many_partitions", "too_many_rows_with_same_key",
     "too_many_segments_in_time_chunk", and "too_many_time_buckets".
    :vartype code: str or ~polaris.sdk.global_api.models.JobErrorCodeV2
    :ivar log: An event, warning, or error logged during a job's processing.
    :vartype log: ~polaris.sdk.global_api.models.JobLogEntry
    :ivar message: A message describing the error.
    :vartype message: str
    """

    _validation = {
        "status": {"required": True},
        "code": {"required": True},
        "log": {"readonly": True},
    }

    _attribute_map = {
        "status": {"key": "status", "type": "str"},
        "code": {"key": "code", "type": "str"},
        "log": {"key": "log", "type": "JobLogEntry"},
        "message": {"key": "message", "type": "str"},
    }

    def __init__(
        self,
        *,
        code: Union[str, "_models.JobErrorCodeV2"],
        message: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword code: Status returned when a job completed with error. The following error statuses
         may be returned:


         * ``canceled``                            - The job was canceled.
         * ``cannot_parse_multi_value_dimension``  - The input contains multi-value dimension(s).
         Please wrap them in MV_TO_ARRAY().
         * ``cannot_parse_source``                 - The input source could not be parsed with the
         given format/configuration.
         * ``column_name_restricted``              - A column used a restricted column name.
         * ``column_type_not_supported``           - A column has an unsupported type.
         * ``could_not_connect_to_source``         - Polaris could not connect to the source input.
         * ``internal_error``                      - An internal error occurred. Please retry your
         request and contact support if the issue persists.
         * ``invalid_null_byte``                   - The input data contained a string with a null
         byte.
         * ``multiple``                            - Multiple errors resulted. See the `job logs
         <#tag/projectJobs/operation/describeJobLogsInProject>`_ for details.
         * ``no_rows_ingested``                    - An ingestion job produced no rows. Please check
         your data, timestamp mapping, and any ingestion filters.
         * ``null_timestamp``                      - The input data contained a null timestamp.
         * ``query_not_supported``                 - The ingestion query is not supported.
         * ``row_too_large``                       - The input data contained a row that was too large.
         * ``timestamp_out_of_bounds``             - The input data contained a timestamp outside of
         the bounds specified by OVERWRITE WHERE.
         * ``too_many_clustered_by_columns``       - The job is clustering by too many columns.
         * ``too_many_columns``                    - The job is creating too many output columns.
         * ``too_many_input_files``                - The job is ingesting too many input files.
         * ``too_many_partitions``                 - The job is creating too many output partitions.
         * ``too_many_rows_with_same_key``         - The input data contains too many rows with the
         same key.
         * ``too_many_time_buckets``               - The job is creating too many time buckets in the
         output. Required. Known values are: "canceled", "cannot_parse_multi_value_dimension",
         "cannot_parse_source", "column_name_restricted", "column_type_not_supported",
         "could_not_connect_to_source", "internal_error", "invalid_null_byte", "multiple",
         "no_rows_ingested", "null_timestamp", "query_not_supported", "row_too_large",
         "timestamp_out_of_bounds", "too_many_clustered_by_columns", "too_many_columns",
         "too_many_input_files", "too_many_partitions", "too_many_rows_with_same_key",
         "too_many_segments_in_time_chunk", and "too_many_time_buckets".
        :paramtype code: str or ~polaris.sdk.global_api.models.JobErrorCodeV2
        :keyword message: A message describing the error.
        :paramtype message: str
        """
        super().__init__(**kwargs)
        self.status: str = "error"
        self.code = code
        self.log = None
        self.message = message


class JobListResponse(_serialization.Model):
    """A list of job response objects.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.JobSummaryResponse]
    :ivar more_results_available: If true, more results are available after the paginationLimit and
     paginationOffset specified in the job list request.
    :vartype more_results_available: bool
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[JobSummaryResponse]"},
        "more_results_available": {"key": "moreResultsAvailable", "type": "bool"},
    }

    def __init__(
        self,
        *,
        values: List["_models.JobSummaryResponse"],
        more_results_available: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.JobSummaryResponse]
        :keyword more_results_available: If true, more results are available after the paginationLimit
         and paginationOffset specified in the job list request.
        :paramtype more_results_available: bool
        """
        super().__init__(**kwargs)
        self.values = values
        self.more_results_available = more_results_available


class JobLogEntry(_serialization.Model):
    """An event, warning, or error logged during a job's processing.

    :ivar timestamp: When the error occurred.
    :vartype timestamp: ~datetime.datetime
    :ivar health_status: The health status of the job.


     * ``ok``        - The job is in good health with no warnings or errors raised.
     * ``warn``      - The job has one or more warnings.
     * ``error``     - The job has one or more errors. Known values are: "ok", "warn", and "error".
    :vartype health_status: str or ~polaris.sdk.global_api.models.JobHealthStatusV2
    :ivar code: A machine-readable code specifying the event, warning, or error that occurred.
    :vartype code: str
    :ivar message: The logged message describing the event, warning, or error.
    :vartype message: str
    """

    _attribute_map = {
        "timestamp": {"key": "timestamp", "type": "iso-8601"},
        "health_status": {"key": "healthStatus", "type": "str"},
        "code": {"key": "code", "type": "str"},
        "message": {"key": "message", "type": "str"},
    }

    def __init__(
        self,
        *,
        timestamp: Optional[datetime.datetime] = None,
        health_status: Optional[Union[str, "_models.JobHealthStatusV2"]] = None,
        code: Optional[str] = None,
        message: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword timestamp: When the error occurred.
        :paramtype timestamp: ~datetime.datetime
        :keyword health_status: The health status of the job.


         * ``ok``        - The job is in good health with no warnings or errors raised.
         * ``warn``      - The job has one or more warnings.
         * ``error``     - The job has one or more errors. Known values are: "ok", "warn", and "error".
        :paramtype health_status: str or ~polaris.sdk.global_api.models.JobHealthStatusV2
        :keyword code: A machine-readable code specifying the event, warning, or error that occurred.
        :paramtype code: str
        :keyword message: The logged message describing the event, warning, or error.
        :paramtype message: str
        """
        super().__init__(**kwargs)
        self.timestamp = timestamp
        self.health_status = health_status
        self.code = code
        self.message = message


class JobLogsResponse(_serialization.Model):
    """Events, warnings, and errors logged during the processing of the job.

    All required parameters must be populated in order to send to server.

    :ivar logs: Required.
    :vartype logs: list[~polaris.sdk.global_api.models.JobLogEntry]
    """

    _validation = {
        "logs": {"required": True},
    }

    _attribute_map = {
        "logs": {"key": "logs", "type": "[JobLogEntry]"},
    }

    def __init__(self, *, logs: List["_models.JobLogEntry"], **kwargs: Any) -> None:
        """
        :keyword logs: Required.
        :paramtype logs: list[~polaris.sdk.global_api.models.JobLogEntry]
        """
        super().__init__(**kwargs)
        self.logs = logs


class JobMetricsResponse(_serialization.Model):
    """Detailed metrics about a job.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar totals: Statistics about the rows processed and skipped by an ingestion job.
     For more information, see `Ingestion status reference
     <https://docs.imply.io/ui/saas/help/ingestion-status.html>`_.
    :vartype totals: ~polaris.sdk.global_api.models.IngestionJobTotals
    """

    _validation = {
        "totals": {"readonly": True},
    }

    _attribute_map = {
        "totals": {"key": "totals", "type": "IngestionJobTotals"},
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.totals = None


class JobOkHealthV2(JobHealthV2):
    """The job is in good health with no warnings or errors raised.

    All required parameters must be populated in order to send to server.

    :ivar status: The health status of the job.


     * ``ok``        - The job is in good health with no warnings or errors raised.
     * ``warn``      - The job has one or more warnings.
     * ``error``     - The job has one or more errors. Required. Known values are: "ok", "warn",
     and "error".
    :vartype status: str or ~polaris.sdk.global_api.models.JobHealthStatusV2
    """

    _validation = {
        "status": {"required": True},
    }

    _attribute_map = {
        "status": {"key": "status", "type": "str"},
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.status: str = "ok"


class JobProgressResponse(_serialization.Model):
    """Overall progress of a job.

    All required parameters must be populated in order to send to server.

    :ivar overall_progress: Progress of the job from 0 to 1, where 1 indicates a completed job.
     Required.
    :vartype overall_progress: float
    """

    _validation = {
        "overall_progress": {"required": True},
    }

    _attribute_map = {
        "overall_progress": {"key": "overallProgress", "type": "float"},
    }

    def __init__(self, *, overall_progress: float, **kwargs: Any) -> None:
        """
        :keyword overall_progress: Progress of the job from 0 to 1, where 1 indicates a completed job.
         Required.
        :paramtype overall_progress: float
        """
        super().__init__(**kwargs)
        self.overall_progress = overall_progress


class JobStatusResponse(_serialization.Model):
    """Execution status of the job.

    All required parameters must be populated in order to send to server.

    :ivar execution_status: The execution status of the job.


     * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
     awaiting resources.
     * ``running``   - The job is currently in progress.
     * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
     warnings or errors.
     * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
     to ingest.
     * ``canceled``  - The job was canceled by the user.
     * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
     the failure.
     * ``suspended`` - The job is suspended by the user.
     * ``unknown``   - The execution status of the job is not known. This state typically occurs
     when a downstream error prevents retrieval of the job execution status. If a job persists in
     this state for an extended period of time (more than a few minutes), please contact Imply.
     Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
     "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
    """

    _validation = {
        "execution_status": {"required": True},
    }

    _attribute_map = {
        "execution_status": {"key": "executionStatus", "type": "str"},
    }

    def __init__(
        self,
        *,
        execution_status: Union[str, "_models.JobExecutionStatusV2"],
        **kwargs: Any
    ) -> None:
        """
        :keyword execution_status: The execution status of the job.


         * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
         awaiting resources.
         * ``running``   - The job is currently in progress.
         * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
         warnings or errors.
         * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
         to ingest.
         * ``canceled``  - The job was canceled by the user.
         * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
         the failure.
         * ``suspended`` - The job is suspended by the user.
         * ``unknown``   - The execution status of the job is not known. This state typically occurs
         when a downstream error prevents retrieval of the job execution status. If a job persists in
         this state for an extended period of time (more than a few minutes), please contact Imply.
         Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
         "suspended", and "unknown".
        :paramtype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
        """
        super().__init__(**kwargs)
        self.execution_status = execution_status


class JobTargetV2(_serialization.Model):
    """Target output of the job.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    TableJobTargetV2

    All required parameters must be populated in order to send to server.

    :ivar type: Type of job target.


     * ``table`` - Specifies that the job target is a table. Required. "table"
    :vartype type: str or ~polaris.sdk.global_api.models.JobTargetTypeV2
    :ivar intervals: Array of `ISO 8601 <https://en.wikipedia.org/wiki/ISO_8601#Time_intervals>`_
     time intervals for replacing or deleting data.

     Do not provide intervals in the following cases:


     * Streaming ingestion jobs
     * Batch ingestion jobs in ``append`` mode
     * Data deletion jobs when ``deleteAll`` is true
     * Restore data jobs

     For an ingestion job in ``replace`` mode, the specified intervals must align with this job's
     ``partitionedBy``\\ , if specified. If ``partitionedBy`` is not specified for the job,
     it defaults to the table's ``partitioningGranularity`` and the intervals must align with the
     table's time partitioning.

     For example, if the partitioning granularity is ``day``\\ , you can specify an eight
     day interval such as ``["2022-06-01/2022-06-09"]``. However, you can't specify an eight hour
     interval such
     as ``["2022-06-01T00:00:00Z/2022-06-01T08:00:00Z"]``. Polaris raises a ``400 Bad Request``
     error if an
     interval does not align.

     For data deletion, any interval is allowed. We recommend aligning the interval with the
     coarsest
     partitioning granularity you expect in the table. For most tables, this is the table's time
     partitioning.
     If a table has data ingested at different granularities and the provided interval partially
     overlaps
     data written at a coarser granularity, the provided interval will be expanded to fully include
     that data. For example, if you ingested data at ``day`` granularity for ``2022-06-01``\\ ,
     specifying the eight
     hour interval ``2024-06-01T00:00:00Z/2024-06-01T08:00:00Z`` will expand the deletion to
     include the full day
     of data.

     To delete data at a more granular level than the ingested data's partitioning granularity,
     create an ingestion job in ``replace`` mode. Use the same table for the source, and add a
     ``filterExpression`` to filter out the time range to delete.
    :vartype intervals: list[str]
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "intervals": {"key": "intervals", "type": "[str]"},
    }

    _subtype_map = {"type": {"table": "TableJobTargetV2"}}

    def __init__(self, *, intervals: Optional[List[str]] = None, **kwargs: Any) -> None:
        """
        :keyword intervals: Array of `ISO 8601
         <https://en.wikipedia.org/wiki/ISO_8601#Time_intervals>`_
         time intervals for replacing or deleting data.

         Do not provide intervals in the following cases:


         * Streaming ingestion jobs
         * Batch ingestion jobs in ``append`` mode
         * Data deletion jobs when ``deleteAll`` is true
         * Restore data jobs

         For an ingestion job in ``replace`` mode, the specified intervals must align with this job's
         ``partitionedBy``\\ , if specified. If ``partitionedBy`` is not specified for the job,
         it defaults to the table's ``partitioningGranularity`` and the intervals must align with the
         table's time partitioning.

         For example, if the partitioning granularity is ``day``\\ , you can specify an eight
         day interval such as ``["2022-06-01/2022-06-09"]``. However, you can't specify an eight hour
         interval such
         as ``["2022-06-01T00:00:00Z/2022-06-01T08:00:00Z"]``. Polaris raises a ``400 Bad Request``
         error if an
         interval does not align.

         For data deletion, any interval is allowed. We recommend aligning the interval with the
         coarsest
         partitioning granularity you expect in the table. For most tables, this is the table's time
         partitioning.
         If a table has data ingested at different granularities and the provided interval partially
         overlaps
         data written at a coarser granularity, the provided interval will be expanded to fully include
         that data. For example, if you ingested data at ``day`` granularity for ``2022-06-01``\\ ,
         specifying the eight
         hour interval ``2024-06-01T00:00:00Z/2024-06-01T08:00:00Z`` will expand the deletion to
         include the full day
         of data.

         To delete data at a more granular level than the ingested data's partitioning granularity,
         create an ingestion job in ``replace`` mode. Use the same table for the source, and add a
         ``filterExpression`` to filter out the time range to delete.
        :paramtype intervals: list[str]
        """
        super().__init__(**kwargs)
        self.type: Optional[str] = None
        self.intervals = intervals


class JobWarningHealthV2(JobHealthV2):
    """The job has one or more warnings.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar status: The health status of the job.


     * ``ok``        - The job is in good health with no warnings or errors raised.
     * ``warn``      - The job has one or more warnings.
     * ``error``     - The job has one or more errors. Required. Known values are: "ok", "warn",
     and "error".
    :vartype status: str or ~polaris.sdk.global_api.models.JobHealthStatusV2
    :ivar code: The warning code of the job. Warnings are non-fatal, so the job may still be
     running if a warning has been
     encountered. The following warning codes may be returned:


     * ``lost_connection_to_source`` - Polaris lost its connection to the source input that it had
     previously connected to.
     * ``no_rows_found``             - The job completed without ingesting or deleting any rows of
     data.
     * ``invalid_rows_found``        - Polaris detected invalid rows in the input data.
     * ``unable_to_proceed``         - Polaris was unable to proceed with ingestion.
     * ``multiple``                  - The job completed with multiple warnings. See the `job logs
     <#tag/projectJobs/operation/describeJobLogsInProject>`_ for details. Required. Known values
     are: "lost_connection_to_source", "no_rows_found", "invalid_rows_found", "unable_to_proceed",
     and "multiple".
    :vartype code: str or ~polaris.sdk.global_api.models.JobWarningCodeV2
    :ivar log: An event, warning, or error logged during a job's processing.
    :vartype log: ~polaris.sdk.global_api.models.JobLogEntry
    """

    _validation = {
        "status": {"required": True},
        "code": {"required": True},
        "log": {"readonly": True},
    }

    _attribute_map = {
        "status": {"key": "status", "type": "str"},
        "code": {"key": "code", "type": "str"},
        "log": {"key": "log", "type": "JobLogEntry"},
    }

    def __init__(
        self, *, code: Union[str, "_models.JobWarningCodeV2"], **kwargs: Any
    ) -> None:
        """
        :keyword code: The warning code of the job. Warnings are non-fatal, so the job may still be
         running if a warning has been
         encountered. The following warning codes may be returned:


         * ``lost_connection_to_source`` - Polaris lost its connection to the source input that it had
         previously connected to.
         * ``no_rows_found``             - The job completed without ingesting or deleting any rows of
         data.
         * ``invalid_rows_found``        - Polaris detected invalid rows in the input data.
         * ``unable_to_proceed``         - Polaris was unable to proceed with ingestion.
         * ``multiple``                  - The job completed with multiple warnings. See the `job logs
         <#tag/projectJobs/operation/describeJobLogsInProject>`_ for details. Required. Known values
         are: "lost_connection_to_source", "no_rows_found", "invalid_rows_found", "unable_to_proceed",
         and "multiple".
        :paramtype code: str or ~polaris.sdk.global_api.models.JobWarningCodeV2
        """
        super().__init__(**kwargs)
        self.status: str = "warning"
        self.code = code
        self.log = None


class JsonFormatSettings(DataFormatSettings):
    """JsonFormatSettings.

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    :ivar flatten_spec: A Druid ``flattenSpec`` object for pre-processing the input JSON. For more
     information, see `FlattenSpec
     <https://docs.imply.io/latest/druid/ingestion/data-formats/#flattenspec>`_.
    :vartype flatten_spec: dict[str, any]
    """

    _validation = {
        "format": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
        "flatten_spec": {"key": "flattenSpec", "type": "{object}"},
    }

    def __init__(
        self, *, flatten_spec: Optional[Dict[str, Any]] = None, **kwargs: Any
    ) -> None:
        """
        :keyword flatten_spec: A Druid ``flattenSpec`` object for pre-processing the input JSON. For
         more information, see `FlattenSpec
         <https://docs.imply.io/latest/druid/ingestion/data-formats/#flattenspec>`_.
        :paramtype flatten_spec: dict[str, any]
        """
        super().__init__(**kwargs)
        self.format: str = "nd-json"
        self.flatten_spec = flatten_spec


class KafkaConnectionPropertiesSsl(_serialization.Model):
    """SSL authentication and encryption settings.

    :ivar keystore: SSL keystore. Use these properties to configure mutual TLS (mTLS)
     authentication for a Kafka connection.
    :vartype keystore: ~polaris.sdk.global_api.models.KafkaConnectionSslKeystorePayload
    :ivar truststore: SSL truststore.
    :vartype truststore: ~polaris.sdk.global_api.models.KafkaConnectionSslTruststorePayload
    """

    _attribute_map = {
        "keystore": {"key": "keystore", "type": "KafkaConnectionSslKeystorePayload"},
        "truststore": {
            "key": "truststore",
            "type": "KafkaConnectionSslTruststorePayload",
        },
    }

    def __init__(
        self,
        *,
        keystore: Optional["_models.KafkaConnectionSslKeystorePayload"] = None,
        truststore: Optional["_models.KafkaConnectionSslTruststorePayload"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword keystore: SSL keystore. Use these properties to configure mutual TLS (mTLS)
         authentication for a Kafka connection.
        :paramtype keystore: ~polaris.sdk.global_api.models.KafkaConnectionSslKeystorePayload
        :keyword truststore: SSL truststore.
        :paramtype truststore: ~polaris.sdk.global_api.models.KafkaConnectionSslTruststorePayload
        """
        super().__init__(**kwargs)
        self.keystore = keystore
        self.truststore = truststore


class KafkaConnectionResponse(
    ConnectionResponse,
    KafkaConnectionPropertiesRequired,
    ConnectionSecretsRequiredPropertiesOptional,
):
    """A Kafka connection.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
    :ivar bootstrap_servers: List of host and port pairs used for establishing the initial
     connection to the Kafka cluster.
    :vartype bootstrap_servers: str
    :ivar client_rack: A rack identifier for this client. This can be any string value which
     indicates where this client is physically located. It corresponds with the broker config
     'broker.rack'.
    :vartype client_rack: str
    :ivar ssl: SSL authentication and encryption settings.
    :vartype ssl: ~polaris.sdk.global_api.models.KafkaConnectionPropertiesSsl
    :ivar topic_name: The topic name or a regular expression that identifies the Kafka topics.
    :vartype topic_name: str
    :ivar topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris looks
     for a single topic with the exact name in ``topicName``. If true, Polaris treats ``topicName``
     as a regular expression to match topic names. Use this option to ingest data from multiple
     topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
     ``topic23`` but not ``topicAB``.
    :vartype topic_name_is_pattern: bool
    :ivar modified_by_user: Required.
    :vartype modified_by_user: ~polaris.sdk.global_api.models.ConnectionResponseModifiedByUser
    :ivar modified_on_timestamp: Required.
    :vartype modified_on_timestamp: str
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar submitted_by_user: Required.
    :vartype submitted_by_user: ~polaris.sdk.global_api.models.ConnectionResponseSubmittedByUser
    :ivar submitted_on_timestamp: Required.
    :vartype submitted_on_timestamp: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "modified_by_user": {"required": True, "readonly": True},
        "modified_on_timestamp": {"required": True, "readonly": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "submitted_by_user": {"required": True, "readonly": True},
        "submitted_on_timestamp": {"required": True, "readonly": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsRequiredPayload"},
        "bootstrap_servers": {"key": "bootstrapServers", "type": "str"},
        "client_rack": {"key": "clientRack", "type": "str"},
        "ssl": {"key": "ssl", "type": "KafkaConnectionPropertiesSsl"},
        "topic_name": {"key": "topicName", "type": "str"},
        "topic_name_is_pattern": {"key": "topicNameIsPattern", "type": "bool"},
        "modified_by_user": {
            "key": "modifiedByUser",
            "type": "ConnectionResponseModifiedByUser",
        },
        "modified_on_timestamp": {"key": "modifiedOnTimestamp", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "submitted_by_user": {
            "key": "submittedByUser",
            "type": "ConnectionResponseSubmittedByUser",
        },
        "submitted_on_timestamp": {"key": "submittedOnTimestamp", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        secrets: Optional["_models.ConnectionSecretsRequiredPayload"] = None,
        bootstrap_servers: Optional[str] = None,
        client_rack: Optional[str] = None,
        ssl: Optional["_models.KafkaConnectionPropertiesSsl"] = None,
        topic_name: Optional[str] = None,
        topic_name_is_pattern: bool = False,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
        :keyword bootstrap_servers: List of host and port pairs used for establishing the initial
         connection to the Kafka cluster.
        :paramtype bootstrap_servers: str
        :keyword client_rack: A rack identifier for this client. This can be any string value which
         indicates where this client is physically located. It corresponds with the broker config
         'broker.rack'.
        :paramtype client_rack: str
        :keyword ssl: SSL authentication and encryption settings.
        :paramtype ssl: ~polaris.sdk.global_api.models.KafkaConnectionPropertiesSsl
        :keyword topic_name: The topic name or a regular expression that identifies the Kafka topics.
        :paramtype topic_name: str
        :keyword topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris
         looks for a single topic with the exact name in ``topicName``. If true, Polaris treats
         ``topicName`` as a regular expression to match topic names. Use this option to ingest data from
         multiple topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
         ``topic23`` but not ``topicAB``.
        :paramtype topic_name_is_pattern: bool
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            name=name,
            description=description,
            bootstrap_servers=bootstrap_servers,
            client_rack=client_rack,
            ssl=ssl,
            topic_name=topic_name,
            topic_name_is_pattern=topic_name_is_pattern,
            secrets=secrets,
            **kwargs
        )
        self.secrets = secrets
        self.bootstrap_servers = bootstrap_servers
        self.client_rack = client_rack
        self.ssl = ssl
        self.topic_name = topic_name
        self.topic_name_is_pattern = topic_name_is_pattern
        self.type: str = "kafka"
        self.modified_by_user = None
        self.modified_on_timestamp = None
        self.name = name
        self.submitted_by_user = None
        self.submitted_on_timestamp = None
        self.description = description


class KafkaConnectionSslKeystorePayload(_serialization.Model):
    """SSL keystore. Use these properties to configure mutual TLS (mTLS) authentication for a Kafka
    connection.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    KafkaConnectionSslKeystorePemPayload

    All required parameters must be populated in order to send to server.

    :ivar type: SSL keystore type. Required. "pem"
    :vartype type: str or ~polaris.sdk.global_api.models.KafkaConnectionSslKeystoreType
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    _subtype_map = {"type": {"pem": "KafkaConnectionSslKeystorePemPayload"}}

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: Optional[str] = None


class KafkaConnectionSslKeystorePemPayloadProperties(
    _serialization.Model
):  # pylint: disable=name-too-long
    """KafkaConnectionSslKeystorePemPayloadProperties.

    All required parameters must be populated in order to send to server.

    :ivar certificates: Trusted SSL certificates. Required.
    :vartype certificates: str
    :ivar key: Private key. Required.
    :vartype key: str
    :ivar key_password: Private key password.
    :vartype key_password: str
    """

    _validation = {
        "certificates": {"required": True},
        "key": {"required": True},
    }

    _attribute_map = {
        "certificates": {"key": "certificates", "type": "str"},
        "key": {"key": "key", "type": "str"},
        "key_password": {"key": "keyPassword", "type": "str"},
    }

    def __init__(
        self,
        *,
        certificates: str,
        key: str,
        key_password: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword certificates: Trusted SSL certificates. Required.
        :paramtype certificates: str
        :keyword key: Private key. Required.
        :paramtype key: str
        :keyword key_password: Private key password.
        :paramtype key_password: str
        """
        super().__init__(**kwargs)
        self.certificates = certificates
        self.key = key
        self.key_password = key_password


class KafkaConnectionSslKeystorePemPayload(
    KafkaConnectionSslKeystorePayload, KafkaConnectionSslKeystorePemPayloadProperties
):
    """A PEM-formatted SSL keystore.

    All required parameters must be populated in order to send to server.

    :ivar certificates: Trusted SSL certificates. Required.
    :vartype certificates: str
    :ivar key: Private key. Required.
    :vartype key: str
    :ivar key_password: Private key password.
    :vartype key_password: str
    :ivar type: SSL keystore type. Required. "pem"
    :vartype type: str or ~polaris.sdk.global_api.models.KafkaConnectionSslKeystoreType
    """

    _validation = {
        "certificates": {"required": True},
        "key": {"required": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "certificates": {"key": "certificates", "type": "str"},
        "key": {"key": "key", "type": "str"},
        "key_password": {"key": "keyPassword", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self,
        *,
        certificates: str,
        key: str,
        key_password: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword certificates: Trusted SSL certificates. Required.
        :paramtype certificates: str
        :keyword key: Private key. Required.
        :paramtype key: str
        :keyword key_password: Private key password.
        :paramtype key_password: str
        """
        super().__init__(
            certificates=certificates, key=key, key_password=key_password, **kwargs
        )
        self.certificates = certificates
        self.key = key
        self.key_password = key_password
        self.type: str = "pem"


class KafkaConnectionSslTruststorePayload(_serialization.Model):
    """SSL truststore.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    KafkaConnectionSslTruststorePemPayload

    All required parameters must be populated in order to send to server.

    :ivar type: SSL truststore type. Required. "pem"
    :vartype type: str or ~polaris.sdk.global_api.models.KafkaConnectionSslTruststoreType
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    _subtype_map = {"type": {"pem": "KafkaConnectionSslTruststorePemPayload"}}

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: Optional[str] = None


class KafkaConnectionSslTruststorePayloadProperties(
    _serialization.Model
):  # pylint: disable=name-too-long
    """KafkaConnectionSslTruststorePayloadProperties.

    All required parameters must be populated in order to send to server.

    :ivar certificates: Trusted SSL certificates. Required.
    :vartype certificates: str
    """

    _validation = {
        "certificates": {"required": True},
    }

    _attribute_map = {
        "certificates": {"key": "certificates", "type": "str"},
    }

    def __init__(self, *, certificates: str, **kwargs: Any) -> None:
        """
        :keyword certificates: Trusted SSL certificates. Required.
        :paramtype certificates: str
        """
        super().__init__(**kwargs)
        self.certificates = certificates


class KafkaConnectionSslTruststorePemPayload(
    KafkaConnectionSslTruststorePayload, KafkaConnectionSslTruststorePayloadProperties
):
    """A PEM-formatted SSL truststore.

    All required parameters must be populated in order to send to server.

    :ivar certificates: Trusted SSL certificates. Required.
    :vartype certificates: str
    :ivar type: SSL truststore type. Required. "pem"
    :vartype type: str or ~polaris.sdk.global_api.models.KafkaConnectionSslTruststoreType
    """

    _validation = {
        "certificates": {"required": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "certificates": {"key": "certificates", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(self, *, certificates: str, **kwargs: Any) -> None:
        """
        :keyword certificates: Trusted SSL certificates. Required.
        :paramtype certificates: str
        """
        super().__init__(certificates=certificates, **kwargs)
        self.certificates = certificates
        self.type: str = "pem"


class KafkaFormatSettings(DataFormatSettings):
    """KafkaFormatSettings.

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    :ivar value_format: Object to define the data format settings used to parse the Kafka value
     which contains your event data. For example, for a JSON payload: ``"valueFormat": {"format":
     "nd-json"}``. Required.
    :vartype value_format: ~polaris.sdk.global_api.models.KafkaFormatSettingsValueFormat
    :ivar header_format: The encoding of Kafka header values. This field is required when parsing
     Kafka headers. Supported values include: ``utf-8``\\ , ``utf-16``\\ , ``utf-16be``\\ ,
     ``utf-16le``\\ , ``iso-8859-1``\\ , ``us-ascii``.
    :vartype header_format: str
    :ivar header_label_prefix: Custom label prefix for all the header columns.
    :vartype header_label_prefix: str
    :ivar key_column_name: Name of the column for the Kafka record's key.
    :vartype key_column_name: str
    :ivar key_format: Object to define the data format settings used to parse the Kafka key.
     Polaris only uses the first key it finds in the key property.
     If the key is stored as a string, use the ``csv`` format. You must also
     specify the key in ``columns``. For example:

     .. code-block::

        "keyFormat": {
          "format": "csv",
          "columns": ["key"]
        }.
    :vartype key_format: ~polaris.sdk.global_api.models.KafkaFormatSettingsKeyFormat
    :ivar timestamp_column_name: Name of the column for the Kafka record's timestamp.
    :vartype timestamp_column_name: str
    """

    _validation = {
        "format": {"required": True},
        "value_format": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
        "value_format": {
            "key": "valueFormat",
            "type": "KafkaFormatSettingsValueFormat",
        },
        "header_format": {"key": "headerFormat", "type": "str"},
        "header_label_prefix": {"key": "headerLabelPrefix", "type": "str"},
        "key_column_name": {"key": "keyColumnName", "type": "str"},
        "key_format": {"key": "keyFormat", "type": "KafkaFormatSettingsKeyFormat"},
        "timestamp_column_name": {"key": "timestampColumnName", "type": "str"},
    }

    def __init__(
        self,
        *,
        value_format: "_models.KafkaFormatSettingsValueFormat",
        header_format: Optional[str] = None,
        header_label_prefix: str = "kafka.header.",
        key_column_name: str = "kafka.key",
        key_format: Optional["_models.KafkaFormatSettingsKeyFormat"] = None,
        timestamp_column_name: str = "kafka.timestamp",
        **kwargs: Any
    ) -> None:
        """
        :keyword value_format: Object to define the data format settings used to parse the Kafka value
         which contains your event data. For example, for a JSON payload: ``"valueFormat": {"format":
         "nd-json"}``. Required.
        :paramtype value_format: ~polaris.sdk.global_api.models.KafkaFormatSettingsValueFormat
        :keyword header_format: The encoding of Kafka header values. This field is required when
         parsing Kafka headers. Supported values include: ``utf-8``\\ , ``utf-16``\\ , ``utf-16be``\\ ,
         ``utf-16le``\\ , ``iso-8859-1``\\ , ``us-ascii``.
        :paramtype header_format: str
        :keyword header_label_prefix: Custom label prefix for all the header columns.
        :paramtype header_label_prefix: str
        :keyword key_column_name: Name of the column for the Kafka record's key.
        :paramtype key_column_name: str
        :keyword key_format: Object to define the data format settings used to parse the Kafka key.
         Polaris only uses the first key it finds in the key property.
         If the key is stored as a string, use the ``csv`` format. You must also
         specify the key in ``columns``. For example:

         .. code-block::

            "keyFormat": {
              "format": "csv",
              "columns": ["key"]
            }.
        :paramtype key_format: ~polaris.sdk.global_api.models.KafkaFormatSettingsKeyFormat
        :keyword timestamp_column_name: Name of the column for the Kafka record's timestamp.
        :paramtype timestamp_column_name: str
        """
        super().__init__(**kwargs)
        self.format: str = "kafka"
        self.value_format = value_format
        self.header_format = header_format
        self.header_label_prefix = header_label_prefix
        self.key_column_name = key_column_name
        self.key_format = key_format
        self.timestamp_column_name = timestamp_column_name


class KafkaFormatSettingsKeyFormat(DataFormatSettings):
    """Object to define the data format settings used to parse the Kafka key.
    Polaris only uses the first key it finds in the key property.
    If the key is stored as a string, use the ``csv`` format. You must also
    specify the key in ``columns``. For example:

    .. code-block::

       "keyFormat": {
         "format": "csv",
         "columns": ["key"]
       }.

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    """

    _validation = {
        "format": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.format: str = "KafkaFormatSettings-keyFormat"


class KafkaFormatSettingsValueFormat(DataFormatSettings):
    """Object to define the data format settings used to parse the Kafka value which contains your
    event data. For example, for a JSON payload: ``"valueFormat": {"format": "nd-json"}``.

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    """

    _validation = {
        "format": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.format: str = "KafkaFormatSettings-valueFormat"


class KinesisConnectionResponse(
    ConnectionResponse, KinesisConnectionPropertiesRequired
):
    """A Kinesis connection.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
    :vartype aws_assumed_role_arn: str
    :ivar aws_endpoint: The URL of the entry point for the AWS Kinesis connection.
    :vartype aws_endpoint: str
    :ivar stream: The Kinesis stream to read.
    :vartype stream: str
    :ivar modified_by_user: Required.
    :vartype modified_by_user: ~polaris.sdk.global_api.models.ConnectionResponseModifiedByUser
    :ivar modified_on_timestamp: Required.
    :vartype modified_on_timestamp: str
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar submitted_by_user: Required.
    :vartype submitted_by_user: ~polaris.sdk.global_api.models.ConnectionResponseSubmittedByUser
    :ivar submitted_on_timestamp: Required.
    :vartype submitted_on_timestamp: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "modified_by_user": {"required": True, "readonly": True},
        "modified_on_timestamp": {"required": True, "readonly": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "submitted_by_user": {"required": True, "readonly": True},
        "submitted_on_timestamp": {"required": True, "readonly": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "aws_assumed_role_arn": {"key": "awsAssumedRoleArn", "type": "str"},
        "aws_endpoint": {"key": "awsEndpoint", "type": "str"},
        "stream": {"key": "stream", "type": "str"},
        "modified_by_user": {
            "key": "modifiedByUser",
            "type": "ConnectionResponseModifiedByUser",
        },
        "modified_on_timestamp": {"key": "modifiedOnTimestamp", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "submitted_by_user": {
            "key": "submittedByUser",
            "type": "ConnectionResponseSubmittedByUser",
        },
        "submitted_on_timestamp": {"key": "submittedOnTimestamp", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        aws_assumed_role_arn: Optional[str] = None,
        aws_endpoint: Optional[str] = None,
        stream: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
        :paramtype aws_assumed_role_arn: str
        :keyword aws_endpoint: The URL of the entry point for the AWS Kinesis connection.
        :paramtype aws_endpoint: str
        :keyword stream: The Kinesis stream to read.
        :paramtype stream: str
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            name=name,
            description=description,
            aws_assumed_role_arn=aws_assumed_role_arn,
            aws_endpoint=aws_endpoint,
            stream=stream,
            **kwargs
        )
        self.aws_assumed_role_arn = aws_assumed_role_arn
        self.aws_endpoint = aws_endpoint
        self.stream = stream
        self.type: str = "kinesis"
        self.modified_by_user = None
        self.modified_on_timestamp = None
        self.name = name
        self.submitted_by_user = None
        self.submitted_on_timestamp = None
        self.description = description


class KinesisFormatSettings(DataFormatSettings):
    """KinesisFormatSettings.

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    :ivar value_format: Object to define the data format settings used to parse the Kinesis value
     which contains your event data. For example, for a JSON payload: ``"valueFormat": {"format":
     "nd-json"}``. Required.
    :vartype value_format: ~polaris.sdk.global_api.models.KinesisFormatSettingsValueFormat
    :ivar partition_key_column_name: Name of the column for the Kinesis record's partition key.
    :vartype partition_key_column_name: str
    :ivar timestamp_column_name: Name of the column for the Kinesis record's timestamp.
    :vartype timestamp_column_name: str
    """

    _validation = {
        "format": {"required": True},
        "value_format": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
        "value_format": {
            "key": "valueFormat",
            "type": "KinesisFormatSettingsValueFormat",
        },
        "partition_key_column_name": {"key": "partitionKeyColumnName", "type": "str"},
        "timestamp_column_name": {"key": "timestampColumnName", "type": "str"},
    }

    def __init__(
        self,
        *,
        value_format: "_models.KinesisFormatSettingsValueFormat",
        partition_key_column_name: str = "kinesis.partitionKey",
        timestamp_column_name: str = "kinesis.timestamp",
        **kwargs: Any
    ) -> None:
        """
        :keyword value_format: Object to define the data format settings used to parse the Kinesis
         value which contains your event data. For example, for a JSON payload: ``"valueFormat":
         {"format": "nd-json"}``. Required.
        :paramtype value_format: ~polaris.sdk.global_api.models.KinesisFormatSettingsValueFormat
        :keyword partition_key_column_name: Name of the column for the Kinesis record's partition key.
        :paramtype partition_key_column_name: str
        :keyword timestamp_column_name: Name of the column for the Kinesis record's timestamp.
        :paramtype timestamp_column_name: str
        """
        super().__init__(**kwargs)
        self.format: str = "kinesis"
        self.value_format = value_format
        self.partition_key_column_name = partition_key_column_name
        self.timestamp_column_name = timestamp_column_name


class KinesisFormatSettingsValueFormat(DataFormatSettings):
    """Object to define the data format settings used to parse the Kinesis value which contains your
    event data. For example, for a JSON payload: ``"valueFormat": {"format": "nd-json"}``.

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    """

    _validation = {
        "format": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.format: str = "KinesisFormatSettings-valueFormat"


class LineChart(_serialization.Model):
    """LineChart.

    All required parameters must be populated in order to send to server.

    :ivar type: Visualization type. "line-chart"
    :vartype type: str or ~polaris.sdk.global_api.models.LineChartType
    :ivar data_cube: Data cube ID. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to apply to the visualization. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar line: Dimensions to show in line. Required.
    :vartype line: list[any]
    :ivar layer: Dimensions to show in layers.
    :vartype layer: list[any]
    :ivar multiples: Dimensions to show in multiples.
    :vartype multiples: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "line": {"required": True, "max_items": 1, "min_items": 0},
        "layer": {"max_items": 1, "min_items": 0},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "line": {"key": "line", "type": "[object]"},
        "layer": {"key": "layer", "type": "[object]"},
        "multiples": {"key": "multiples", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        line: List[Any],
        type: Optional[Union[str, "_models.LineChartType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        layer: Optional[List[Any]] = None,
        multiples: Optional[List[Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Visualization type. "line-chart"
        :paramtype type: str or ~polaris.sdk.global_api.models.LineChartType
        :keyword data_cube: Data cube ID. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to apply to the visualization. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword line: Dimensions to show in line. Required.
        :paramtype line: list[any]
        :keyword layer: Dimensions to show in layers.
        :paramtype layer: list[any]
        :keyword multiples: Dimensions to show in multiples.
        :paramtype multiples: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.line = line
        self.layer = layer
        self.multiples = multiples


class LinkResponse(AuditRecord, EmbeddingLinkPayload):
    """LinkResponse.

    All required parameters must be populated in order to send to server.

    :ivar name: Name of the embedding link. Required.
    :vartype name: str
    :ivar description: Description of the embedding link.
    :vartype description: str
    :ivar view_description: Object containing the properties of the embedded view.
    :vartype view_description:
     ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadViewDescription
    :ivar explore_view: An `explore visualization
     <https://docs.imply.io/polaris/visualizations/#explore-visualizations>`_ for the embedding
     link.
    :vartype explore_view: ~polaris.sdk.global_api.models.EmbeddingExploreView
    :ivar layout: Show or hide the controls surrounding the visualization. Required. Known values
     are: "entire-view" and "visualization-only".
    :vartype layout: str or ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadLayout
    :ivar required_filter: SQL condition to apply to the underlying data. See `Create an access
     filter <https://docs.imply.io/polaris/embed-visualizations/#create-an-access-filter>`_ for more
     information.
    :vartype required_filter: str
    :ivar restricted: If set to true, a signature validated with the generated private key is
     required to access the link.
    :vartype restricted: bool
    :ivar ttl: Period of time in milliseconds for which the link is valid, after a user first
     accesses it. Applies to restricted links only. Defaults to 1 hour.
    :vartype ttl: float
    :ivar non_filterable_dimensions: Dimensions to exclude from the filter bar of the embedded
     visualization.
    :vartype non_filterable_dimensions: list[str]
    :ivar non_showable_dimensions: Dimensions to exclude from the show bar of the embedded
     visualization.
    :vartype non_showable_dimensions: list[str]
    :ivar non_showable_measures: Measures to exclude from the show bar of the embedded
     visualization.
    :vartype non_showable_measures: list[str]
    :ivar download_limit: Sets the maximum number of rows a user can download.
    :vartype download_limit: float
    :ivar enable_downloads: Enables downloading data from the embedding link. Users can download
     the number of rows specified in the ``downloadLimit`` property.
    :vartype enable_downloads: bool
    :ivar enable_async_downloads: Enables async downloads for the embedding link. Requires
     ``enableDownloads`` to be set to ``true``.
    :vartype enable_async_downloads: bool
    :ivar hide_fixed_time_filter: Set to ``true`` to hide the fixed time filter from the time
     filter UI in the embedded visualization. When ``false`` or omitted, the fixed time filter will
     be displayed.
    :vartype hide_fixed_time_filter: bool
    :ivar id: Asset ID. Required.
    :vartype id: str
    :ivar api_created: If true, the embedding link was created via API. If false, the embedding
     link was created via the Polaris UI. Required.
    :vartype api_created: bool
    :ivar embedding_secret: Private key generated for restricted embedding links. Only present in a
     response when the
     restricted link is initially created.
    :vartype embedding_secret: str
    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    """

    _validation = {
        "name": {"required": True},
        "layout": {"required": True},
        "id": {"required": True, "max_length": 255, "min_length": 1},
        "api_created": {"required": True},
        "created_at": {"required": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "view_description": {
            "key": "viewDescription",
            "type": "EmbeddingLinkRequestPayloadViewDescription",
        },
        "explore_view": {"key": "exploreView", "type": "EmbeddingExploreView"},
        "layout": {"key": "layout", "type": "str"},
        "required_filter": {"key": "requiredFilter", "type": "str"},
        "restricted": {"key": "restricted", "type": "bool"},
        "ttl": {"key": "ttl", "type": "float"},
        "non_filterable_dimensions": {
            "key": "nonFilterableDimensions",
            "type": "[str]",
        },
        "non_showable_dimensions": {"key": "nonShowableDimensions", "type": "[str]"},
        "non_showable_measures": {"key": "nonShowableMeasures", "type": "[str]"},
        "download_limit": {"key": "downloadLimit", "type": "float"},
        "enable_downloads": {"key": "enableDownloads", "type": "bool"},
        "enable_async_downloads": {"key": "enableAsyncDownloads", "type": "bool"},
        "hide_fixed_time_filter": {"key": "hideFixedTimeFilter", "type": "bool"},
        "id": {"key": "id", "type": "str"},
        "api_created": {"key": "apiCreated", "type": "bool"},
        "embedding_secret": {"key": "embeddingSecret", "type": "str"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        layout: Union[str, "_models.EmbeddingLinkRequestPayloadLayout"],
        id: str,  # pylint: disable=redefined-builtin
        api_created: bool,
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        description: Optional[str] = None,
        view_description: Optional[
            "_models.EmbeddingLinkRequestPayloadViewDescription"
        ] = None,
        explore_view: Optional["_models.EmbeddingExploreView"] = None,
        required_filter: Optional[str] = None,
        restricted: Optional[bool] = None,
        ttl: Optional[float] = None,
        non_filterable_dimensions: Optional[List[str]] = None,
        non_showable_dimensions: Optional[List[str]] = None,
        non_showable_measures: Optional[List[str]] = None,
        download_limit: Optional[float] = None,
        enable_downloads: Optional[bool] = None,
        enable_async_downloads: Optional[bool] = None,
        hide_fixed_time_filter: Optional[bool] = None,
        embedding_secret: Optional[str] = None,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the embedding link. Required.
        :paramtype name: str
        :keyword description: Description of the embedding link.
        :paramtype description: str
        :keyword view_description: Object containing the properties of the embedded view.
        :paramtype view_description:
         ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadViewDescription
        :keyword explore_view: An `explore visualization
         <https://docs.imply.io/polaris/visualizations/#explore-visualizations>`_ for the embedding
         link.
        :paramtype explore_view: ~polaris.sdk.global_api.models.EmbeddingExploreView
        :keyword layout: Show or hide the controls surrounding the visualization. Required. Known
         values are: "entire-view" and "visualization-only".
        :paramtype layout: str or ~polaris.sdk.global_api.models.EmbeddingLinkRequestPayloadLayout
        :keyword required_filter: SQL condition to apply to the underlying data. See `Create an access
         filter <https://docs.imply.io/polaris/embed-visualizations/#create-an-access-filter>`_ for more
         information.
        :paramtype required_filter: str
        :keyword restricted: If set to true, a signature validated with the generated private key is
         required to access the link.
        :paramtype restricted: bool
        :keyword ttl: Period of time in milliseconds for which the link is valid, after a user first
         accesses it. Applies to restricted links only. Defaults to 1 hour.
        :paramtype ttl: float
        :keyword non_filterable_dimensions: Dimensions to exclude from the filter bar of the embedded
         visualization.
        :paramtype non_filterable_dimensions: list[str]
        :keyword non_showable_dimensions: Dimensions to exclude from the show bar of the embedded
         visualization.
        :paramtype non_showable_dimensions: list[str]
        :keyword non_showable_measures: Measures to exclude from the show bar of the embedded
         visualization.
        :paramtype non_showable_measures: list[str]
        :keyword download_limit: Sets the maximum number of rows a user can download.
        :paramtype download_limit: float
        :keyword enable_downloads: Enables downloading data from the embedding link. Users can download
         the number of rows specified in the ``downloadLimit`` property.
        :paramtype enable_downloads: bool
        :keyword enable_async_downloads: Enables async downloads for the embedding link. Requires
         ``enableDownloads`` to be set to ``true``.
        :paramtype enable_async_downloads: bool
        :keyword hide_fixed_time_filter: Set to ``true`` to hide the fixed time filter from the time
         filter UI in the embedded visualization. When ``false`` or omitted, the fixed time filter will
         be displayed.
        :paramtype hide_fixed_time_filter: bool
        :keyword id: Asset ID. Required.
        :paramtype id: str
        :keyword api_created: If true, the embedding link was created via API. If false, the embedding
         link was created via the Polaris UI. Required.
        :paramtype api_created: bool
        :keyword embedding_secret: Private key generated for restricted embedding links. Only present
         in a response when the
         restricted link is initially created.
        :paramtype embedding_secret: str
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        """
        super().__init__(
            created_at=created_at,
            created_by=created_by,
            updated_at=updated_at,
            updated_by=updated_by,
            name=name,
            description=description,
            view_description=view_description,
            explore_view=explore_view,
            layout=layout,
            required_filter=required_filter,
            restricted=restricted,
            ttl=ttl,
            non_filterable_dimensions=non_filterable_dimensions,
            non_showable_dimensions=non_showable_dimensions,
            non_showable_measures=non_showable_measures,
            download_limit=download_limit,
            enable_downloads=enable_downloads,
            enable_async_downloads=enable_async_downloads,
            hide_fixed_time_filter=hide_fixed_time_filter,
            id=id,
            api_created=api_created,
            embedding_secret=embedding_secret,
            **kwargs
        )
        self.name = name
        self.description = description
        self.view_description = view_description
        self.explore_view = explore_view
        self.layout = layout
        self.required_filter = required_filter
        self.restricted = restricted
        self.ttl = ttl
        self.non_filterable_dimensions = non_filterable_dimensions
        self.non_showable_dimensions = non_showable_dimensions
        self.non_showable_measures = non_showable_measures
        self.download_limit = download_limit
        self.enable_downloads = enable_downloads
        self.enable_async_downloads = enable_async_downloads
        self.hide_fixed_time_filter = hide_fixed_time_filter
        self.id = id
        self.api_created = api_created
        self.embedding_secret = embedding_secret
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by


class LinkSummary(EmbedLinkDescription):
    """Object describing a link that already exists.

    All required parameters must be populated in order to send to server.

    :ivar name: Name of the embedding link. Required.
    :vartype name: str
    :ivar description: Description of the embedding link.
    :vartype description: str
    :ivar view_description: Object containing the properties of the embedded view. Required.
    :vartype view_description: ~polaris.sdk.global_api.models.EmbedLinkDescriptionViewDescription
    :ivar layout: Show or hide the controls surrounding the visualization. Required. Known values
     are: "entire-view" and "visualization-only".
    :vartype layout: str or ~polaris.sdk.global_api.models.EmbedLinkDescriptionLayout
    :ivar required_filter: A SQL condition to apply to the underlying data. See `Create an access
     filter <https://docs.imply.io/polaris/embed-visualizations/#create-an-access-filter>`_ for more
     information.
    :vartype required_filter: str
    :ivar restricted: If set to true, a signature validated with the generated private key is
     required to access the link.
    :vartype restricted: bool
    :ivar ttl: Period of time in milliseconds for which the link is valid, after a user first
     accesses it. Applies to restricted links only. Defaults to 1 hour.
    :vartype ttl: float
    :ivar non_filterable_dimensions: Dimensions to exclude from the filter bar of the embedded
     visualization.
    :vartype non_filterable_dimensions: list[str]
    :ivar non_showable_dimensions: Dimensions to exclude from the show bar of the embedded
     visualization.
    :vartype non_showable_dimensions: list[str]
    :ivar non_showable_measures: Measures to exclude from the show bar of the embedded
     visualization.
    :vartype non_showable_measures: list[str]
    :ivar download_limit: Sets the maximum number of rows a user can download.
    :vartype download_limit: float
    :ivar enable_downloads: Enables downloading data from the embedding link. Users can download
     the number of rows specified in the ``downloadLimit`` property.
    :vartype enable_downloads: bool
    :ivar enable_async_downloads: Enables async downloads for the embedding link. Requires
     ``enableDownloads`` to be set to ``true``.
    :vartype enable_async_downloads: bool
    :ivar hide_fixed_time_filter: Set to ``true`` to hide the fixed time filter from the time
     filter UI in the embedded visualization. When ``false`` or omitted, the fixed time filter will
     be displayed.
    :vartype hide_fixed_time_filter: bool
    :ivar link: Embedding link ID.
    :vartype link: str
    """

    _validation = {
        "name": {"required": True},
        "view_description": {"required": True},
        "layout": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "view_description": {
            "key": "viewDescription",
            "type": "EmbedLinkDescriptionViewDescription",
        },
        "layout": {"key": "layout", "type": "str"},
        "required_filter": {"key": "requiredFilter", "type": "str"},
        "restricted": {"key": "restricted", "type": "bool"},
        "ttl": {"key": "ttl", "type": "float"},
        "non_filterable_dimensions": {
            "key": "nonFilterableDimensions",
            "type": "[str]",
        },
        "non_showable_dimensions": {"key": "nonShowableDimensions", "type": "[str]"},
        "non_showable_measures": {"key": "nonShowableMeasures", "type": "[str]"},
        "download_limit": {"key": "downloadLimit", "type": "float"},
        "enable_downloads": {"key": "enableDownloads", "type": "bool"},
        "enable_async_downloads": {"key": "enableAsyncDownloads", "type": "bool"},
        "hide_fixed_time_filter": {"key": "hideFixedTimeFilter", "type": "bool"},
        "link": {"key": "link", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        view_description: "_models.EmbedLinkDescriptionViewDescription",
        layout: Union[str, "_models.EmbedLinkDescriptionLayout"],
        description: Optional[str] = None,
        required_filter: Optional[str] = None,
        restricted: Optional[bool] = None,
        ttl: Optional[float] = None,
        non_filterable_dimensions: Optional[List[str]] = None,
        non_showable_dimensions: Optional[List[str]] = None,
        non_showable_measures: Optional[List[str]] = None,
        download_limit: Optional[float] = None,
        enable_downloads: Optional[bool] = None,
        enable_async_downloads: Optional[bool] = None,
        hide_fixed_time_filter: Optional[bool] = None,
        link: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the embedding link. Required.
        :paramtype name: str
        :keyword description: Description of the embedding link.
        :paramtype description: str
        :keyword view_description: Object containing the properties of the embedded view. Required.
        :paramtype view_description: ~polaris.sdk.global_api.models.EmbedLinkDescriptionViewDescription
        :keyword layout: Show or hide the controls surrounding the visualization. Required. Known
         values are: "entire-view" and "visualization-only".
        :paramtype layout: str or ~polaris.sdk.global_api.models.EmbedLinkDescriptionLayout
        :keyword required_filter: A SQL condition to apply to the underlying data. See `Create an
         access filter <https://docs.imply.io/polaris/embed-visualizations/#create-an-access-filter>`_
         for more information.
        :paramtype required_filter: str
        :keyword restricted: If set to true, a signature validated with the generated private key is
         required to access the link.
        :paramtype restricted: bool
        :keyword ttl: Period of time in milliseconds for which the link is valid, after a user first
         accesses it. Applies to restricted links only. Defaults to 1 hour.
        :paramtype ttl: float
        :keyword non_filterable_dimensions: Dimensions to exclude from the filter bar of the embedded
         visualization.
        :paramtype non_filterable_dimensions: list[str]
        :keyword non_showable_dimensions: Dimensions to exclude from the show bar of the embedded
         visualization.
        :paramtype non_showable_dimensions: list[str]
        :keyword non_showable_measures: Measures to exclude from the show bar of the embedded
         visualization.
        :paramtype non_showable_measures: list[str]
        :keyword download_limit: Sets the maximum number of rows a user can download.
        :paramtype download_limit: float
        :keyword enable_downloads: Enables downloading data from the embedding link. Users can download
         the number of rows specified in the ``downloadLimit`` property.
        :paramtype enable_downloads: bool
        :keyword enable_async_downloads: Enables async downloads for the embedding link. Requires
         ``enableDownloads`` to be set to ``true``.
        :paramtype enable_async_downloads: bool
        :keyword hide_fixed_time_filter: Set to ``true`` to hide the fixed time filter from the time
         filter UI in the embedded visualization. When ``false`` or omitted, the fixed time filter will
         be displayed.
        :paramtype hide_fixed_time_filter: bool
        :keyword link: Embedding link ID.
        :paramtype link: str
        """
        super().__init__(
            name=name,
            description=description,
            view_description=view_description,
            layout=layout,
            required_filter=required_filter,
            restricted=restricted,
            ttl=ttl,
            non_filterable_dimensions=non_filterable_dimensions,
            non_showable_dimensions=non_showable_dimensions,
            non_showable_measures=non_showable_measures,
            download_limit=download_limit,
            enable_downloads=enable_downloads,
            enable_async_downloads=enable_async_downloads,
            hide_fixed_time_filter=hide_fixed_time_filter,
            **kwargs
        )
        self.link = link


class LiveMeasure(_serialization.Model):
    """Instance of a measure applied to a visualization.

    All required parameters must be populated in order to send to server.

    :ivar measure: Identifies the associated measure. Required.
    :vartype measure: str
    :ivar transform: Transformation to apply to a measure. Known values are: "none",
     "percent-of-parent", "percent-of-root", "percent-of-first-axis", and "percent-of-second-axis".
    :vartype transform: str or ~polaris.sdk.global_api.models.LiveMeasureTransform
    :ivar within: Measure filter to apply.
    :vartype within: ~polaris.sdk.global_api.models.NumberRange
    :ivar id: ID for the measure instance. Allows you to visualize multiple instances of the same
     measure.
    :vartype id: str
    """

    _validation = {
        "measure": {"required": True, "max_length": 255, "min_length": 1},
        "id": {"max_length": 255, "min_length": 1},
    }

    _attribute_map = {
        "measure": {"key": "measure", "type": "str"},
        "transform": {"key": "transform", "type": "str"},
        "within": {"key": "within", "type": "NumberRange"},
        "id": {"key": "id", "type": "str"},
    }

    def __init__(
        self,
        *,
        measure: str,
        transform: Optional[Union[str, "_models.LiveMeasureTransform"]] = None,
        within: Optional["_models.NumberRange"] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        **kwargs: Any
    ) -> None:
        """
        :keyword measure: Identifies the associated measure. Required.
        :paramtype measure: str
        :keyword transform: Transformation to apply to a measure. Known values are: "none",
         "percent-of-parent", "percent-of-root", "percent-of-first-axis", and "percent-of-second-axis".
        :paramtype transform: str or ~polaris.sdk.global_api.models.LiveMeasureTransform
        :keyword within: Measure filter to apply.
        :paramtype within: ~polaris.sdk.global_api.models.NumberRange
        :keyword id: ID for the measure instance. Allows you to visualize multiple instances of the
         same measure.
        :paramtype id: str
        """
        super().__init__(**kwargs)
        self.measure = measure
        self.transform = transform
        self.within = within
        self.id = id


class LogoFile(_serialization.Model):
    """A file containing a logo.

    All required parameters must be populated in order to send to server.

    :ivar file: Required.
    :vartype file: IO[bytes]
    """

    _validation = {
        "file": {"required": True},
    }

    _attribute_map = {
        "file": {"key": "file", "type": "IO"},
    }

    def __init__(self, *, file: IO[bytes], **kwargs: Any) -> None:
        """
        :keyword file: Required.
        :paramtype file: IO[bytes]
        """
        super().__init__(**kwargs)
        self.file = file


class ModificationTimestamp(_serialization.Model):
    """Date and time the resource was last updated.

    :ivar last_update_timestamp: Date and time the resource was last updated in ISO 8601 format.
    :vartype last_update_timestamp: ~datetime.datetime
    """

    _attribute_map = {
        "last_update_timestamp": {"key": "lastUpdateTimestamp", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        last_update_timestamp: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword last_update_timestamp: Date and time the resource was last updated in ISO 8601 format.
        :paramtype last_update_timestamp: ~datetime.datetime
        """
        super().__init__(**kwargs)
        self.last_update_timestamp = last_update_timestamp


class LogoResponse(ModificationTimestamp):
    """Logo file details.

    All required parameters must be populated in order to send to server.

    :ivar last_update_timestamp: Date and time the resource was last updated in ISO 8601 format.
    :vartype last_update_timestamp: ~datetime.datetime
    :ivar kind: Logo type. Required. Known values are: "full" and "favicon".
    :vartype kind: str or ~polaris.sdk.global_api.models.LogoKind
    :ivar file_type: File type. Required. Known values are: "png" and "svg".
    :vartype file_type: str or ~polaris.sdk.global_api.models.LogoFileType
    :ivar url: URL of the logo. Required.
    :vartype url: str
    """

    _validation = {
        "kind": {"required": True},
        "file_type": {"required": True},
        "url": {"required": True},
    }

    _attribute_map = {
        "last_update_timestamp": {"key": "lastUpdateTimestamp", "type": "iso-8601"},
        "kind": {"key": "kind", "type": "str"},
        "file_type": {"key": "fileType", "type": "str"},
        "url": {"key": "url", "type": "str"},
    }

    def __init__(
        self,
        *,
        kind: Union[str, "_models.LogoKind"],
        file_type: Union[str, "_models.LogoFileType"],
        url: str,
        last_update_timestamp: Optional[datetime.datetime] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword last_update_timestamp: Date and time the resource was last updated in ISO 8601 format.
        :paramtype last_update_timestamp: ~datetime.datetime
        :keyword kind: Logo type. Required. Known values are: "full" and "favicon".
        :paramtype kind: str or ~polaris.sdk.global_api.models.LogoKind
        :keyword file_type: File type. Required. Known values are: "png" and "svg".
        :paramtype file_type: str or ~polaris.sdk.global_api.models.LogoFileType
        :keyword url: URL of the logo. Required.
        :paramtype url: str
        """
        super().__init__(last_update_timestamp=last_update_timestamp, **kwargs)
        self.kind = kind
        self.file_type = file_type
        self.url = url


class LogosResponse(_serialization.Model):
    """Describes the logos for a Polaris organization.

    :ivar full: The main logo that appears on the Polaris login dialog and in the top left corner
     of most pages in the Polaris interface.
    :vartype full: ~polaris.sdk.global_api.models.LogoResponse
    :ivar favicon: A small icon that appears in the browser tab title. Note that due to a browser
     limitation, the favicon doesn't appear on Safari tabs.
    :vartype favicon: ~polaris.sdk.global_api.models.LogoResponse
    """

    _attribute_map = {
        "full": {"key": "full", "type": "LogoResponse"},
        "favicon": {"key": "favicon", "type": "LogoResponse"},
    }

    def __init__(
        self,
        *,
        full: Optional["_models.LogoResponse"] = None,
        favicon: Optional["_models.LogoResponse"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword full: The main logo that appears on the Polaris login dialog and in the top left
         corner of most pages in the Polaris interface.
        :paramtype full: ~polaris.sdk.global_api.models.LogoResponse
        :keyword favicon: A small icon that appears in the browser tab title. Note that due to a
         browser limitation, the favicon doesn't appear on Safari tabs.
        :paramtype favicon: ~polaris.sdk.global_api.models.LogoResponse
        """
        super().__init__(**kwargs)
        self.full = full
        self.favicon = favicon


class LookupAliasListResponse(_serialization.Model):
    """A list of lookup alias response objects.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.LookupAliasResponse]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[LookupAliasResponse]"},
    }

    def __init__(
        self, *, values: List["_models.LookupAliasResponse"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.LookupAliasResponse]
        """
        super().__init__(**kwargs)
        self.values = values


class LookupAliasPayload(_serialization.Model):
    """The payload of a lookup alias.

    All required parameters must be populated in order to send to server.

    :ivar key: The key identifying a column in the lookup table. Required.
    :vartype key: str
    :ivar name: Unique name of the lookup alias. Required.
    :vartype name: str
    :ivar value: The string value targeting a column in the lookup table. Required.
    :vartype value: str
    """

    _validation = {
        "key": {"required": True},
        "name": {"required": True},
        "value": {"required": True},
    }

    _attribute_map = {
        "key": {"key": "key", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "value": {"key": "value", "type": "str"},
    }

    def __init__(self, *, key: str, name: str, value: str, **kwargs: Any) -> None:
        """
        :keyword key: The key identifying a column in the lookup table. Required.
        :paramtype key: str
        :keyword name: Unique name of the lookup alias. Required.
        :paramtype name: str
        :keyword value: The string value targeting a column in the lookup table. Required.
        :paramtype value: str
        """
        super().__init__(**kwargs)
        self.key = key
        self.name = name
        self.value = value


class LookupAliasResponse(LookupAliasPayload):
    """A lookup alias response.

    All required parameters must be populated in order to send to server.

    :ivar key: The key identifying a column in the lookup table. Required.
    :vartype key: str
    :ivar name: Unique name of the lookup alias. Required.
    :vartype name: str
    :ivar value: The string value targeting a column in the lookup table. Required.
    :vartype value: str
    """


class LookupListResponse(_serialization.Model):
    """A list of lookup response objects.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.LookupResponse]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[LookupResponse]"},
    }

    def __init__(
        self, *, values: List["_models.LookupResponse"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.LookupResponse]
        """
        super().__init__(**kwargs)
        self.values = values


class LookupResponse(_serialization.Model):
    """A lookup response.

    All required parameters must be populated in order to send to server.

    :ivar name: Required.
    :vartype name: str
    :ivar source: The source of a lookup.
     The following lookup type is supported:


     * ``table``\\ : A lookup source that references a table. The table
       must be partitioned by ALL granularity and contain a single segment. Required.
    :vartype source: ~polaris.sdk.global_api.models.LookupSourcePayload
    """

    _validation = {
        "name": {"required": True},
        "source": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "source": {"key": "source", "type": "LookupSourcePayload"},
    }

    def __init__(
        self, *, name: str, source: "_models.LookupSourcePayload", **kwargs: Any
    ) -> None:
        """
        :keyword name: Required.
        :paramtype name: str
        :keyword source: The source of a lookup.
         The following lookup type is supported:


         * ``table``\\ : A lookup source that references a table. The table
           must be partitioned by ALL granularity and contain a single segment. Required.
        :paramtype source: ~polaris.sdk.global_api.models.LookupSourcePayload
        """
        super().__init__(**kwargs)
        self.name = name
        self.source = source


class LookupSourcePayload(_serialization.Model):
    """The source of a lookup.
    The following lookup type is supported:


    * ``table``\\ : A lookup source that references a table. The table
      must be partitioned by ALL granularity and contain a single segment.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    LookupSourceTablePayload

    All required parameters must be populated in order to send to server.

    :ivar type: Required. "table"
    :vartype type: str or ~polaris.sdk.global_api.models.LookupSourcePayloadType
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    _subtype_map = {"type": {"table": "LookupSourceTablePayload"}}

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: Optional[str] = None


class LookupSourceTablePayload(LookupSourcePayload):
    """LookupSourceTablePayload.

    All required parameters must be populated in order to send to server.

    :ivar type: Required. "table"
    :vartype type: str or ~polaris.sdk.global_api.models.LookupSourcePayloadType
    :ivar table_name: Name of the source table. Required.
    :vartype table_name: str
    """

    _validation = {
        "type": {"required": True},
        "table_name": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "table_name": {"key": "tableName", "type": "str"},
    }

    def __init__(self, *, table_name: str, **kwargs: Any) -> None:
        """
        :keyword table_name: Name of the source table. Required.
        :paramtype table_name: str
        """
        super().__init__(**kwargs)
        self.type: str = "table"
        self.table_name = table_name


class Measure(_serialization.Model):
    """Measure.

    :ivar name: Measure ID.
    :vartype name: str
    :ivar transform: Transform type to apply. Known values are: "none", "percent-of-parent", and
     "percent-of-root".
    :vartype transform: str or ~polaris.sdk.global_api.models.Transform
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "transform": {"key": "transform", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        transform: Optional[Union[str, "_models.Transform"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Measure ID.
        :paramtype name: str
        :keyword transform: Transform type to apply. Known values are: "none", "percent-of-parent", and
         "percent-of-root".
        :paramtype transform: str or ~polaris.sdk.global_api.models.Transform
        """
        super().__init__(**kwargs)
        self.name = name
        self.transform = transform


class MeasureFilter(_serialization.Model):
    """Filter to apply to a measure.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar measure: ID of the measure to which the filter applies. Required.
    :vartype measure: str
    :ivar min_op: Operator for the lower bound on a measure filter. Known values are: "greaterThan"
     and "greaterThanOrEqual".
    :vartype min_op: str or ~polaris.sdk.global_api.models.MeasureFilterFromOperator
    :ivar min_value: Minimum value to match.
    :vartype min_value: float
    :ivar max_op: Operator for the upper bound on a measure filter. Known values are: "lessThan"
     and "lessThanOrEqual".
    :vartype max_op: str or ~polaris.sdk.global_api.models.MeasureFilterToOperator
    :ivar max_value: Maximum value to match.
    :vartype max_value: float
    :ivar exclude: Toggles whether the filter is an exclusion filter.
    :vartype exclude: bool
    """

    _validation = {
        "measure": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "measure": {"key": "measure", "type": "str"},
        "min_op": {"key": "minOp", "type": "str"},
        "min_value": {"key": "minValue", "type": "float"},
        "max_op": {"key": "maxOp", "type": "str"},
        "max_value": {"key": "maxValue", "type": "float"},
        "exclude": {"key": "exclude", "type": "bool"},
    }

    def __init__(
        self,
        *,
        measure: str,
        additional_properties: Optional[Dict[str, Any]] = None,
        min_op: Optional[Union[str, "_models.MeasureFilterFromOperator"]] = None,
        min_value: Optional[float] = None,
        max_op: Optional[Union[str, "_models.MeasureFilterToOperator"]] = None,
        max_value: Optional[float] = None,
        exclude: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword measure: ID of the measure to which the filter applies. Required.
        :paramtype measure: str
        :keyword min_op: Operator for the lower bound on a measure filter. Known values are:
         "greaterThan" and "greaterThanOrEqual".
        :paramtype min_op: str or ~polaris.sdk.global_api.models.MeasureFilterFromOperator
        :keyword min_value: Minimum value to match.
        :paramtype min_value: float
        :keyword max_op: Operator for the upper bound on a measure filter. Known values are: "lessThan"
         and "lessThanOrEqual".
        :paramtype max_op: str or ~polaris.sdk.global_api.models.MeasureFilterToOperator
        :keyword max_value: Maximum value to match.
        :paramtype max_value: float
        :keyword exclude: Toggles whether the filter is an exclusion filter.
        :paramtype exclude: bool
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.measure = measure
        self.min_op = min_op
        self.min_value = min_value
        self.max_op = max_op
        self.max_value = max_value
        self.exclude = exclude


class MeasureFilter1(_serialization.Model):
    """A filter applied to the measure of the visualization.

    All required parameters must be populated in order to send to server.

    :ivar filter_type: Required. "measure"
    :vartype filter_type: str or ~polaris.sdk.global_api.models.MeasureFilter1FilterType
    :ivar measure: Anything. Required.
    :vartype measure: any
    :ivar max_op: Required. Known values are: "gte" and "gt".
    :vartype max_op: str or ~polaris.sdk.global_api.models.MeasureFilter1MaxOp
    :ivar min_op: Required. Known values are: "lte" and "lt".
    :vartype min_op: str or ~polaris.sdk.global_api.models.MeasureFilter1MinOp
    :ivar max_value: Required.
    :vartype max_value: float
    :ivar min_value: Required.
    :vartype min_value: float
    :ivar exclude:
    :vartype exclude: bool
    """

    _validation = {
        "filter_type": {"required": True},
        "measure": {"required": True},
        "max_op": {"required": True},
        "min_op": {"required": True},
        "max_value": {"required": True},
        "min_value": {"required": True},
    }

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "measure": {"key": "measure", "type": "object"},
        "max_op": {"key": "maxOp", "type": "str"},
        "min_op": {"key": "minOp", "type": "str"},
        "max_value": {"key": "maxValue", "type": "float"},
        "min_value": {"key": "minValue", "type": "float"},
        "exclude": {"key": "exclude", "type": "bool"},
    }

    def __init__(
        self,
        *,
        filter_type: Union[str, "_models.MeasureFilter1FilterType"],
        measure: Any,
        max_op: Union[str, "_models.MeasureFilter1MaxOp"],
        min_op: Union[str, "_models.MeasureFilter1MinOp"],
        max_value: float,
        min_value: float,
        exclude: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword filter_type: Required. "measure"
        :paramtype filter_type: str or ~polaris.sdk.global_api.models.MeasureFilter1FilterType
        :keyword measure: Anything. Required.
        :paramtype measure: any
        :keyword max_op: Required. Known values are: "gte" and "gt".
        :paramtype max_op: str or ~polaris.sdk.global_api.models.MeasureFilter1MaxOp
        :keyword min_op: Required. Known values are: "lte" and "lt".
        :paramtype min_op: str or ~polaris.sdk.global_api.models.MeasureFilter1MinOp
        :keyword max_value: Required.
        :paramtype max_value: float
        :keyword min_value: Required.
        :paramtype min_value: float
        :keyword exclude:
        :paramtype exclude: bool
        """
        super().__init__(**kwargs)
        self.filter_type = filter_type
        self.measure = measure
        self.max_op = max_op
        self.min_op = min_op
        self.max_value = max_value
        self.min_value = min_value
        self.exclude = exclude


class MeasureListResponse(_serialization.Model):
    """A list of data cube measures.

    All required parameters must be populated in order to send to server.

    :ivar values: Array of data cube measures. Required.
    :vartype values: list[~polaris.sdk.global_api.models.MeasureListResponseValuesItem]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[MeasureListResponseValuesItem]"},
    }

    def __init__(
        self, *, values: List["_models.MeasureListResponseValuesItem"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Array of data cube measures. Required.
        :paramtype values: list[~polaris.sdk.global_api.models.MeasureListResponseValuesItem]
        """
        super().__init__(**kwargs)
        self.values = values


class MeasurePayload(_serialization.Model):
    """Measures are numeric data values derived from the original data source. For example,
    a measure can be an aggregation or a function output.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar title: Measure title.
    :vartype title: str
    :ivar description: Measure description.
    :vartype description: str
    :ivar group: Groups measures with the same group value together in the measures panel.
    :vartype group: str
    :ivar units: Added as a suffix.
    :vartype units: str
    :ivar formula: SQL expression for the measure. Refer to tables with the alias "t".
    :vartype formula: str
    :ivar transform: You can transform a measure to be displayed as Percent of parent segment or as
     Percent of total instead
     of the default measure display. Known values are: "none", "percent-of-parent", and
     "percent-of-root".
    :vartype transform: str or ~polaris.sdk.global_api.models.MeasureTransform
    :ivar number_style: Measure formatting.
    :vartype number_style: ~polaris.sdk.global_api.models.NumberStyle
    :ivar missing_value_fill: Specifies how to fill empty values for a measure on continuous
     visualizations:


     * ``zero``\\ : (default) Fill missing data with zeros. This is most suitable if the measure
     represents an additive quantity.
     * ``none``\\ : Leave missing data empty. This is suitable when missing values indicate that
     the data is not collected.
     * ``previous``\\ : Fill missing data with last value seen. This is suitable for sensor type
     data.
     * ``interpolate``\\ : Interpolate the missing data between the seen value. This is suitable
     for sensor type data. Known values are: "zero", "none", "previous", and "interpolate".
    :vartype missing_value_fill: str or ~polaris.sdk.global_api.models.MissingValueFill
    :ivar scale_behavior: Determines how the scale behaves in "continuous" visualizations (such as
     the line chart):


     * ``pin-zero``\\ : Always include 0 for reference.
     * ``unpinned``\\ : Do not force 0 into the scale. Known values are: "pin-zero" and "unpinned".
    :vartype scale_behavior: str or ~polaris.sdk.global_api.models.ScaleBehavior
    :ivar comparison_colors: Determines the display coloring for increased and decreased values.
    :vartype comparison_colors: ~polaris.sdk.global_api.models.ComparisonColors
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "group": {"key": "group", "type": "str"},
        "units": {"key": "units", "type": "str"},
        "formula": {"key": "formula", "type": "str"},
        "transform": {"key": "transform", "type": "str"},
        "number_style": {"key": "numberStyle", "type": "NumberStyle"},
        "missing_value_fill": {"key": "missingValueFill", "type": "str"},
        "scale_behavior": {"key": "scaleBehavior", "type": "str"},
        "comparison_colors": {"key": "comparisonColors", "type": "ComparisonColors"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        title: Optional[str] = None,
        description: Optional[str] = None,
        group: Optional[str] = None,
        units: Optional[str] = None,
        formula: Optional[str] = None,
        transform: Optional[Union[str, "_models.MeasureTransform"]] = None,
        number_style: Optional["_models.NumberStyle"] = None,
        missing_value_fill: Optional[Union[str, "_models.MissingValueFill"]] = None,
        scale_behavior: Optional[Union[str, "_models.ScaleBehavior"]] = None,
        comparison_colors: Optional["_models.ComparisonColors"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword title: Measure title.
        :paramtype title: str
        :keyword description: Measure description.
        :paramtype description: str
        :keyword group: Groups measures with the same group value together in the measures panel.
        :paramtype group: str
        :keyword units: Added as a suffix.
        :paramtype units: str
        :keyword formula: SQL expression for the measure. Refer to tables with the alias "t".
        :paramtype formula: str
        :keyword transform: You can transform a measure to be displayed as Percent of parent segment or
         as Percent of total instead
         of the default measure display. Known values are: "none", "percent-of-parent", and
         "percent-of-root".
        :paramtype transform: str or ~polaris.sdk.global_api.models.MeasureTransform
        :keyword number_style: Measure formatting.
        :paramtype number_style: ~polaris.sdk.global_api.models.NumberStyle
        :keyword missing_value_fill: Specifies how to fill empty values for a measure on continuous
         visualizations:


         * ``zero``\\ : (default) Fill missing data with zeros. This is most suitable if the measure
         represents an additive quantity.
         * ``none``\\ : Leave missing data empty. This is suitable when missing values indicate that
         the data is not collected.
         * ``previous``\\ : Fill missing data with last value seen. This is suitable for sensor type
         data.
         * ``interpolate``\\ : Interpolate the missing data between the seen value. This is suitable
         for sensor type data. Known values are: "zero", "none", "previous", and "interpolate".
        :paramtype missing_value_fill: str or ~polaris.sdk.global_api.models.MissingValueFill
        :keyword scale_behavior: Determines how the scale behaves in "continuous" visualizations (such
         as the line chart):


         * ``pin-zero``\\ : Always include 0 for reference.
         * ``unpinned``\\ : Do not force 0 into the scale. Known values are: "pin-zero" and "unpinned".
        :paramtype scale_behavior: str or ~polaris.sdk.global_api.models.ScaleBehavior
        :keyword comparison_colors: Determines the display coloring for increased and decreased values.
        :paramtype comparison_colors: ~polaris.sdk.global_api.models.ComparisonColors
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.title = title
        self.description = description
        self.group = group
        self.units = units
        self.formula = formula
        self.transform = transform
        self.number_style = number_style
        self.missing_value_fill = missing_value_fill
        self.scale_behavior = scale_behavior
        self.comparison_colors = comparison_colors


class MeasureListResponseValuesItem(MeasurePayload):
    """MeasureListResponseValuesItem.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar title: Measure title.
    :vartype title: str
    :ivar description: Measure description.
    :vartype description: str
    :ivar group: Groups measures with the same group value together in the measures panel.
    :vartype group: str
    :ivar units: Added as a suffix.
    :vartype units: str
    :ivar formula: SQL expression for the measure. Refer to tables with the alias "t".
    :vartype formula: str
    :ivar transform: You can transform a measure to be displayed as Percent of parent segment or as
     Percent of total instead
     of the default measure display. Known values are: "none", "percent-of-parent", and
     "percent-of-root".
    :vartype transform: str or ~polaris.sdk.global_api.models.MeasureTransform
    :ivar number_style: Measure formatting.
    :vartype number_style: ~polaris.sdk.global_api.models.NumberStyle
    :ivar missing_value_fill: Specifies how to fill empty values for a measure on continuous
     visualizations:


     * ``zero``\\ : (default) Fill missing data with zeros. This is most suitable if the measure
     represents an additive quantity.
     * ``none``\\ : Leave missing data empty. This is suitable when missing values indicate that
     the data is not collected.
     * ``previous``\\ : Fill missing data with last value seen. This is suitable for sensor type
     data.
     * ``interpolate``\\ : Interpolate the missing data between the seen value. This is suitable
     for sensor type data. Known values are: "zero", "none", "previous", and "interpolate".
    :vartype missing_value_fill: str or ~polaris.sdk.global_api.models.MissingValueFill
    :ivar scale_behavior: Determines how the scale behaves in "continuous" visualizations (such as
     the line chart):


     * ``pin-zero``\\ : Always include 0 for reference.
     * ``unpinned``\\ : Do not force 0 into the scale. Known values are: "pin-zero" and "unpinned".
    :vartype scale_behavior: str or ~polaris.sdk.global_api.models.ScaleBehavior
    :ivar comparison_colors: Determines the display coloring for increased and decreased values.
    :vartype comparison_colors: ~polaris.sdk.global_api.models.ComparisonColors
    """


class MeasureResponse(MeasurePayload):
    """MeasureResponse.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar title: Measure title.
    :vartype title: str
    :ivar description: Measure description.
    :vartype description: str
    :ivar group: Groups measures with the same group value together in the measures panel.
    :vartype group: str
    :ivar units: Added as a suffix.
    :vartype units: str
    :ivar formula: SQL expression for the measure. Refer to tables with the alias "t".
    :vartype formula: str
    :ivar transform: You can transform a measure to be displayed as Percent of parent segment or as
     Percent of total instead
     of the default measure display. Known values are: "none", "percent-of-parent", and
     "percent-of-root".
    :vartype transform: str or ~polaris.sdk.global_api.models.MeasureTransform
    :ivar number_style: Measure formatting.
    :vartype number_style: ~polaris.sdk.global_api.models.NumberStyle
    :ivar missing_value_fill: Specifies how to fill empty values for a measure on continuous
     visualizations:


     * ``zero``\\ : (default) Fill missing data with zeros. This is most suitable if the measure
     represents an additive quantity.
     * ``none``\\ : Leave missing data empty. This is suitable when missing values indicate that
     the data is not collected.
     * ``previous``\\ : Fill missing data with last value seen. This is suitable for sensor type
     data.
     * ``interpolate``\\ : Interpolate the missing data between the seen value. This is suitable
     for sensor type data. Known values are: "zero", "none", "previous", and "interpolate".
    :vartype missing_value_fill: str or ~polaris.sdk.global_api.models.MissingValueFill
    :ivar scale_behavior: Determines how the scale behaves in "continuous" visualizations (such as
     the line chart):


     * ``pin-zero``\\ : Always include 0 for reference.
     * ``unpinned``\\ : Do not force 0 into the scale. Known values are: "pin-zero" and "unpinned".
    :vartype scale_behavior: str or ~polaris.sdk.global_api.models.ScaleBehavior
    :ivar comparison_colors: Determines the display coloring for increased and decreased values.
    :vartype comparison_colors: ~polaris.sdk.global_api.models.ComparisonColors
    """


class NetworkPolicy(_serialization.Model):
    """Network policy object.

    All required parameters must be populated in order to send to server.

    :ivar enabled: Enable the network policy. When you set ``enabled`` to false, Polaris retains
     the network policy without enforcing it and accepts API requests from any IP address. Required.
    :vartype enabled: bool
    :ivar entries: Container that holds network policy details for each specified IPv4 address or
     CIDR. Required.
    :vartype entries: dict[str,
     ~polaris.sdk.global_api.models.Components16X07DtSchemasNetworkpolicyPropertiesEntriesAdditionalproperties]
    """

    _validation = {
        "enabled": {"required": True},
        "entries": {"required": True},
    }

    _attribute_map = {
        "enabled": {"key": "enabled", "type": "bool"},
        "entries": {
            "key": "entries",
            "type": "{Components16X07DtSchemasNetworkpolicyPropertiesEntriesAdditionalproperties}",
        },
    }

    def __init__(
        self,
        *,
        enabled: bool,
        entries: Dict[
            str,
            "_models.Components16X07DtSchemasNetworkpolicyPropertiesEntriesAdditionalproperties",
        ],
        **kwargs: Any
    ) -> None:
        """
        :keyword enabled: Enable the network policy. When you set ``enabled`` to false, Polaris retains
         the network policy without enforcing it and accepts API requests from any IP address. Required.
        :paramtype enabled: bool
        :keyword entries: Container that holds network policy details for each specified IPv4 address
         or CIDR. Required.
        :paramtype entries: dict[str,
         ~polaris.sdk.global_api.models.Components16X07DtSchemasNetworkpolicyPropertiesEntriesAdditionalproperties]
        """
        super().__init__(**kwargs)
        self.enabled = enabled
        self.entries = entries


class NoneSecretsOptionalPayload(ConnectionSecretsOptionalPayload):
    """A payload for no connection secrets.

    All required parameters must be populated in order to send to server.

    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: str = "NoneSecretsOptionalPayload"


class NoneSecretsRequiredPayload(ConnectionSecretsRequiredPayload):
    """A payload for no connection secrets.

    All required parameters must be populated in order to send to server.

    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: str = "NoneSecretsRequiredPayload"


class NumberRange(_serialization.Model):
    """Defines a start and end boundary for a numeric range.

    All required parameters must be populated in order to send to server.

    :ivar start: Start of the number range. Required.
    :vartype start: float
    :ivar end: End of the number range. Required.
    :vartype end: float
    :ivar bounds: Bounds string describing the range.
    :vartype bounds: str
    """

    _validation = {
        "start": {"required": True},
        "end": {"required": True},
    }

    _attribute_map = {
        "start": {"key": "start", "type": "float"},
        "end": {"key": "end", "type": "float"},
        "bounds": {"key": "bounds", "type": "str"},
    }

    def __init__(
        self, *, start: float, end: float, bounds: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword start: Start of the number range. Required.
        :paramtype start: float
        :keyword end: End of the number range. Required.
        :paramtype end: float
        :keyword bounds: Bounds string describing the range.
        :paramtype bounds: str
        """
        super().__init__(**kwargs)
        self.start = start
        self.end = end
        self.bounds = bounds


class NumberStyle(_serialization.Model):
    """Measure formatting.

    :ivar type: Numeric formatting and abbreviation type. Known values are: "raw", "si", "dollar",
     "dollar-raw", "byte", "byte-decimal", "byte-iec", "bit-per-second", "bit-per-second-decimal",
     "bit-per-second-iec", "percent", "percent-raw", "millisecond", "microsecond", "nanosecond",
     "milliwatt", "seconds-as-time", "duration", "duration-ago", and "time-format".
    :vartype type: str or ~polaris.sdk.global_api.models.AbbreviationType
    :ivar leading: Use leading zeros to pad the number to a fixed length.
    :vartype leading: float
    :ivar min_decimals: Minimum number of decimal places to show.
    :vartype min_decimals: float
    :ivar max_decimals: Maximum number of decimal places to show.
    :vartype max_decimals: float
    :ivar optional_decimal: Show decimal places only if necessary.
    :vartype optional_decimal: bool
    :ivar negative_parentheses: Show negative numbers in parentheses.
    :vartype negative_parentheses: bool
    :ivar signed: Show positive numbers with a plus sign.
    :vartype signed: bool
    :ivar integer: Indicates that the underlying number is an integer and does not include
     fractional values.
    :vartype integer: bool
    :ivar thousands_delimiter: Character to use as the thousands delimiter.
    :vartype thousands_delimiter: str
    :ivar decimal_delimiter: Character to use as the decimal delimiter.
    :vartype decimal_delimiter: str
    :ivar force_abbreviation: Format all values using the same SI power abbreviation. Valid values
     are 1-4:


     * ``1``\\ : k (thousands)
     * ``2``\\ : m (millions)
     * ``3``\\ : b (billions)
     * ``4``\\ : t (trillions).
    :vartype force_abbreviation: float
    :ivar abbreviation_space: Add a space between the number and the abbreviation. For example,
     "1.2 m" instead of "1.2m".
    :vartype abbreviation_space: bool
    :ivar raw_unit: Raw unit value to use when there is no applicable abbreviation.
    :vartype raw_unit: str
    :ivar time_format: Date/time format to use for time dimensions. See `MomentJS docs
     <https://momentjs.com/docs/?/displaying/format/#/displaying/>`_
     for more information.
    :vartype time_format: str
    """

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "leading": {"key": "leading", "type": "float"},
        "min_decimals": {"key": "minDecimals", "type": "float"},
        "max_decimals": {"key": "maxDecimals", "type": "float"},
        "optional_decimal": {"key": "optionalDecimal", "type": "bool"},
        "negative_parentheses": {"key": "negativeParentheses", "type": "bool"},
        "signed": {"key": "signed", "type": "bool"},
        "integer": {"key": "integer", "type": "bool"},
        "thousands_delimiter": {"key": "thousandsDelimiter", "type": "str"},
        "decimal_delimiter": {"key": "decimalDelimiter", "type": "str"},
        "force_abbreviation": {"key": "forceAbbreviation", "type": "float"},
        "abbreviation_space": {"key": "abbreviationSpace", "type": "bool"},
        "raw_unit": {"key": "rawUnit", "type": "str"},
        "time_format": {"key": "timeFormat", "type": "str"},
    }

    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.AbbreviationType"]] = None,
        leading: Optional[float] = None,
        min_decimals: Optional[float] = None,
        max_decimals: Optional[float] = None,
        optional_decimal: Optional[bool] = None,
        negative_parentheses: Optional[bool] = None,
        signed: Optional[bool] = None,
        integer: Optional[bool] = None,
        thousands_delimiter: Optional[str] = None,
        decimal_delimiter: Optional[str] = None,
        force_abbreviation: Optional[float] = None,
        abbreviation_space: Optional[bool] = None,
        raw_unit: Optional[str] = None,
        time_format: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Numeric formatting and abbreviation type. Known values are: "raw", "si",
         "dollar", "dollar-raw", "byte", "byte-decimal", "byte-iec", "bit-per-second",
         "bit-per-second-decimal", "bit-per-second-iec", "percent", "percent-raw", "millisecond",
         "microsecond", "nanosecond", "milliwatt", "seconds-as-time", "duration", "duration-ago", and
         "time-format".
        :paramtype type: str or ~polaris.sdk.global_api.models.AbbreviationType
        :keyword leading: Use leading zeros to pad the number to a fixed length.
        :paramtype leading: float
        :keyword min_decimals: Minimum number of decimal places to show.
        :paramtype min_decimals: float
        :keyword max_decimals: Maximum number of decimal places to show.
        :paramtype max_decimals: float
        :keyword optional_decimal: Show decimal places only if necessary.
        :paramtype optional_decimal: bool
        :keyword negative_parentheses: Show negative numbers in parentheses.
        :paramtype negative_parentheses: bool
        :keyword signed: Show positive numbers with a plus sign.
        :paramtype signed: bool
        :keyword integer: Indicates that the underlying number is an integer and does not include
         fractional values.
        :paramtype integer: bool
        :keyword thousands_delimiter: Character to use as the thousands delimiter.
        :paramtype thousands_delimiter: str
        :keyword decimal_delimiter: Character to use as the decimal delimiter.
        :paramtype decimal_delimiter: str
        :keyword force_abbreviation: Format all values using the same SI power abbreviation. Valid
         values are 1-4:


         * ``1``\\ : k (thousands)
         * ``2``\\ : m (millions)
         * ``3``\\ : b (billions)
         * ``4``\\ : t (trillions).
        :paramtype force_abbreviation: float
        :keyword abbreviation_space: Add a space between the number and the abbreviation. For example,
         "1.2 m" instead of "1.2m".
        :paramtype abbreviation_space: bool
        :keyword raw_unit: Raw unit value to use when there is no applicable abbreviation.
        :paramtype raw_unit: str
        :keyword time_format: Date/time format to use for time dimensions. See `MomentJS docs
         <https://momentjs.com/docs/?/displaying/format/#/displaying/>`_
         for more information.
        :paramtype time_format: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.leading = leading
        self.min_decimals = min_decimals
        self.max_decimals = max_decimals
        self.optional_decimal = optional_decimal
        self.negative_parentheses = negative_parentheses
        self.signed = signed
        self.integer = integer
        self.thousands_delimiter = thousands_delimiter
        self.decimal_delimiter = decimal_delimiter
        self.force_abbreviation = force_abbreviation
        self.abbreviation_space = abbreviation_space
        self.raw_unit = raw_unit
        self.time_format = time_format


class NumericFilter(_serialization.Model):
    """A filter applied to a numeric dimension.

    :ivar filter_type: "numeric"
    :vartype filter_type: str or ~polaris.sdk.global_api.models.NumericFilterType
    :ivar dimension:
    :vartype dimension: str
    :ivar operator: Known values are: "gt", "gte", "lt", "lte", "eq", and "ne".
    :vartype operator: str or ~polaris.sdk.global_api.models.NumericFilterOperator
    :ivar value:
    :vartype value: float
    """

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "dimension": {"key": "dimension", "type": "str"},
        "operator": {"key": "operator", "type": "str"},
        "value": {"key": "value", "type": "float"},
    }

    def __init__(
        self,
        *,
        filter_type: Optional[Union[str, "_models.NumericFilterType"]] = None,
        dimension: Optional[str] = None,
        operator: Optional[Union[str, "_models.NumericFilterOperator"]] = None,
        value: Optional[float] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword filter_type: "numeric"
        :paramtype filter_type: str or ~polaris.sdk.global_api.models.NumericFilterType
        :keyword dimension:
        :paramtype dimension: str
        :keyword operator: Known values are: "gt", "gte", "lt", "lte", "eq", and "ne".
        :paramtype operator: str or ~polaris.sdk.global_api.models.NumericFilterOperator
        :keyword value:
        :paramtype value: float
        """
        super().__init__(**kwargs)
        self.filter_type = filter_type
        self.dimension = dimension
        self.operator = operator
        self.value = value


class ObjectMeta(_serialization.Model):
    """Metadata to identify the project.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar uid: ID of the project.
    :vartype uid: str
    :ivar name: Display name of the project. Required.
    :vartype name: str
    :ivar created_on_timestamp: Date and time the project was created in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype created_on_timestamp: ~datetime.datetime
    """

    _validation = {
        "uid": {"readonly": True},
        "name": {"required": True, "max_length": 128, "min_length": 1},
        "created_on_timestamp": {"readonly": True},
    }

    _attribute_map = {
        "uid": {"key": "uid", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "created_on_timestamp": {"key": "createdOnTimestamp", "type": "iso-8601"},
    }

    def __init__(self, *, name: str, **kwargs: Any) -> None:
        """
        :keyword name: Display name of the project. Required.
        :paramtype name: str
        """
        super().__init__(**kwargs)
        self.uid = None
        self.name = name
        self.created_on_timestamp = None


class OrcFormatSettings(DataFormatSettings):
    """OrcFormatSettings.

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    :ivar binary_as_string: Specifies if the binary orc column which is not logically marked as a
     string should be treated as a UTF-8 encoded string.
    :vartype binary_as_string: bool
    :ivar flatten_spec: A Druid ``flattenSpec`` object for pre-processing the input ORC. For more
     information, see `FlattenSpec
     <https://docs.imply.io/latest/druid/ingestion/data-formats/#flattenspec>`_.
    :vartype flatten_spec: dict[str, any]
    """

    _validation = {
        "format": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
        "binary_as_string": {"key": "binaryAsString", "type": "bool"},
        "flatten_spec": {"key": "flattenSpec", "type": "{object}"},
    }

    def __init__(
        self,
        *,
        binary_as_string: bool = False,
        flatten_spec: Optional[Dict[str, Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword binary_as_string: Specifies if the binary orc column which is not logically marked as
         a string should be treated as a UTF-8 encoded string.
        :paramtype binary_as_string: bool
        :keyword flatten_spec: A Druid ``flattenSpec`` object for pre-processing the input ORC. For
         more information, see `FlattenSpec
         <https://docs.imply.io/latest/druid/ingestion/data-formats/#flattenspec>`_.
        :paramtype flatten_spec: dict[str, any]
        """
        super().__init__(**kwargs)
        self.format: str = "orc"
        self.binary_as_string = binary_as_string
        self.flatten_spec = flatten_spec


class PageListResponse(_serialization.Model):
    """Array of dashboard pages.

    All required parameters must be populated in order to send to server.

    :ivar values: Array of dashboard pages. Required.
    :vartype values: list[~polaris.sdk.global_api.models.PageListResponseValuesItem]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[PageListResponseValuesItem]"},
    }

    def __init__(
        self, *, values: List["_models.PageListResponseValuesItem"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Array of dashboard pages. Required.
        :paramtype values: list[~polaris.sdk.global_api.models.PageListResponseValuesItem]
        """
        super().__init__(**kwargs)
        self.values = values


class PageListResponseValuesItem(PagePayload):
    """PageListResponseValuesItem.

    :ivar id: Asset ID.
    :vartype id: str
    :ivar label: Page label to display in the Polaris UI.
    :vartype label: str
    :ivar tiles: Dashboard page tiles.
    :vartype tiles: list[~polaris.sdk.global_api.models.PagePayloadTilesItem]
    """


class TilePayload(_serialization.Model):
    """Visualization of a data cube within a dashboard page.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar type: Tile type. ``blank`` tiles are empty. ``visualization`` tiles display a data cube
     visualization.
     ``markdown`` tiles display a block of text using `Markdown <https://commonmark.org/help/>`_
     formatting. Known values are: "blank", "visualization", and "markdown".
    :vartype type: str or ~polaris.sdk.global_api.models.TileType
    :ivar title: Tile title to display in the dashboard UI. If not set, defaults to an
     auto-generated title
     based on the displayed dimensions and measures.
    :vartype title: str
    :ivar description: Tile description to display in info popovers in the dashboard UI.
    :vartype description: str
    :ivar position: Position of a tile within a dashboard page.
    :vartype position: ~polaris.sdk.global_api.models.TilePosition
    :ivar essence: Visualization definition for data cubes. This is not applicable to Polaris.
    :vartype essence: dict[str, any]
    :ivar facet_essence: Visualization definition for data cubes.
    :vartype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
    :ivar explore_essence: Visualization definition for data cubes of specific types, including
     overall, gauge, flat table, and time series.
     If you want to use any of these visualizations but you don't see them in Polaris, contact
     Imply support.
    :vartype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
    :ivar title_hidden: Hide the tile title.
    :vartype title_hidden: bool
    :ivar info_hidden: Hide the tile info popover.
    :vartype info_hidden: bool
    :ivar can_expand: Tile can be expanded into a full data cube view.
    :vartype can_expand: bool
    :ivar content: Markdown content to display in the tile. Only applicable if "type" is set to
     "markdown".
     Polaris renders markdown content using `Markdown <https://commonmark.org/help/>`_ formatting.
    :vartype content: str
    :ivar legend_side: Side of the tile to display the legend. Only applicable if ``type`` is set
     to ``visualization``. Known values are: "none", "right", and "bottom".
    :vartype legend_side: str or ~polaris.sdk.global_api.models.LegendSide
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "position": {"key": "position", "type": "TilePosition"},
        "essence": {"key": "essence", "type": "{object}"},
        "facet_essence": {"key": "facetEssence", "type": "FacetEssence"},
        "explore_essence": {"key": "exploreEssence", "type": "ExploreEssence"},
        "title_hidden": {"key": "titleHidden", "type": "bool"},
        "info_hidden": {"key": "infoHidden", "type": "bool"},
        "can_expand": {"key": "canExpand", "type": "bool"},
        "content": {"key": "content", "type": "str"},
        "legend_side": {"key": "legendSide", "type": "str"},
    }

    def __init__(
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        type: Optional[Union[str, "_models.TileType"]] = None,
        title: Optional[str] = None,
        description: Optional[str] = None,
        position: Optional["_models.TilePosition"] = None,
        essence: Optional[Dict[str, Any]] = None,
        facet_essence: Optional["_models.FacetEssence"] = None,
        explore_essence: Optional["_models.ExploreEssence"] = None,
        title_hidden: bool = False,
        info_hidden: bool = False,
        can_expand: bool = True,
        content: Optional[str] = None,
        legend_side: Optional[Union[str, "_models.LegendSide"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword type: Tile type. ``blank`` tiles are empty. ``visualization`` tiles display a data
         cube visualization.
         ``markdown`` tiles display a block of text using `Markdown <https://commonmark.org/help/>`_
         formatting. Known values are: "blank", "visualization", and "markdown".
        :paramtype type: str or ~polaris.sdk.global_api.models.TileType
        :keyword title: Tile title to display in the dashboard UI. If not set, defaults to an
         auto-generated title
         based on the displayed dimensions and measures.
        :paramtype title: str
        :keyword description: Tile description to display in info popovers in the dashboard UI.
        :paramtype description: str
        :keyword position: Position of a tile within a dashboard page.
        :paramtype position: ~polaris.sdk.global_api.models.TilePosition
        :keyword essence: Visualization definition for data cubes. This is not applicable to Polaris.
        :paramtype essence: dict[str, any]
        :keyword facet_essence: Visualization definition for data cubes.
        :paramtype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
        :keyword explore_essence: Visualization definition for data cubes of specific types, including
         overall, gauge, flat table, and time series.
         If you want to use any of these visualizations but you don't see them in Polaris, contact
         Imply support.
        :paramtype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
        :keyword title_hidden: Hide the tile title.
        :paramtype title_hidden: bool
        :keyword info_hidden: Hide the tile info popover.
        :paramtype info_hidden: bool
        :keyword can_expand: Tile can be expanded into a full data cube view.
        :paramtype can_expand: bool
        :keyword content: Markdown content to display in the tile. Only applicable if "type" is set to
         "markdown".
         Polaris renders markdown content using `Markdown <https://commonmark.org/help/>`_ formatting.
        :paramtype content: str
        :keyword legend_side: Side of the tile to display the legend. Only applicable if ``type`` is
         set to ``visualization``. Known values are: "none", "right", and "bottom".
        :paramtype legend_side: str or ~polaris.sdk.global_api.models.LegendSide
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.type = type
        self.title = title
        self.description = description
        self.position = position
        self.essence = essence
        self.facet_essence = facet_essence
        self.explore_essence = explore_essence
        self.title_hidden = title_hidden
        self.info_hidden = info_hidden
        self.can_expand = can_expand
        self.content = content
        self.legend_side = legend_side


class PagePayloadTilesItem(TilePayload):
    """PagePayloadTilesItem.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar type: Tile type. ``blank`` tiles are empty. ``visualization`` tiles display a data cube
     visualization.
     ``markdown`` tiles display a block of text using `Markdown <https://commonmark.org/help/>`_
     formatting. Known values are: "blank", "visualization", and "markdown".
    :vartype type: str or ~polaris.sdk.global_api.models.TileType
    :ivar title: Tile title to display in the dashboard UI. If not set, defaults to an
     auto-generated title
     based on the displayed dimensions and measures.
    :vartype title: str
    :ivar description: Tile description to display in info popovers in the dashboard UI.
    :vartype description: str
    :ivar position: Position of a tile within a dashboard page.
    :vartype position: ~polaris.sdk.global_api.models.TilePosition
    :ivar essence: Visualization definition for data cubes. This is not applicable to Polaris.
    :vartype essence: dict[str, any]
    :ivar facet_essence: Visualization definition for data cubes.
    :vartype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
    :ivar explore_essence: Visualization definition for data cubes of specific types, including
     overall, gauge, flat table, and time series.
     If you want to use any of these visualizations but you don't see them in Polaris, contact
     Imply support.
    :vartype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
    :ivar title_hidden: Hide the tile title.
    :vartype title_hidden: bool
    :ivar info_hidden: Hide the tile info popover.
    :vartype info_hidden: bool
    :ivar can_expand: Tile can be expanded into a full data cube view.
    :vartype can_expand: bool
    :ivar content: Markdown content to display in the tile. Only applicable if "type" is set to
     "markdown".
     Polaris renders markdown content using `Markdown <https://commonmark.org/help/>`_ formatting.
    :vartype content: str
    :ivar legend_side: Side of the tile to display the legend. Only applicable if ``type`` is set
     to ``visualization``. Known values are: "none", "right", and "bottom".
    :vartype legend_side: str or ~polaris.sdk.global_api.models.LegendSide
    """


class PageResponse(PagePayload):
    """PageResponse.

    :ivar id: Asset ID.
    :vartype id: str
    :ivar label: Page label to display in the Polaris UI.
    :vartype label: str
    :ivar tiles: Dashboard page tiles.
    :vartype tiles: list[~polaris.sdk.global_api.models.PagePayloadTilesItem]
    """


class PaginationLinks(_serialization.Model):
    """Holds pagination links for paginated responses.

    :ivar next_link:
    :vartype next_link: str
    :ivar prev_link:
    :vartype prev_link: str
    """

    _attribute_map = {
        "next_link": {"key": "@nextLink", "type": "str"},
        "prev_link": {"key": "@prevLink", "type": "str"},
    }

    def __init__(
        self,
        *,
        next_link: Optional[str] = None,
        prev_link: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword next_link:
        :paramtype next_link: str
        :keyword prev_link:
        :paramtype prev_link: str
        """
        super().__init__(**kwargs)
        self.next_link = next_link
        self.prev_link = prev_link


class ParquetFormatSettings(DataFormatSettings):
    """ParquetFormatSettings.

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    :ivar binary_as_string: Specifies if the bytes Parquet column which is not logically marked as
     a string or enum type should be treated as a UTF-8 encoded string.
    :vartype binary_as_string: bool
    :ivar flatten_spec: A Druid ``flattenSpec`` object for pre-processing the input Parquet. For
     more information, see `FlattenSpec
     <https://docs.imply.io/latest/druid/ingestion/data-formats/#flattenspec>`_.
    :vartype flatten_spec: dict[str, any]
    """

    _validation = {
        "format": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
        "binary_as_string": {"key": "binaryAsString", "type": "bool"},
        "flatten_spec": {"key": "flattenSpec", "type": "{object}"},
    }

    def __init__(
        self,
        *,
        binary_as_string: bool = False,
        flatten_spec: Optional[Dict[str, Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword binary_as_string: Specifies if the bytes Parquet column which is not logically marked
         as a string or enum type should be treated as a UTF-8 encoded string.
        :paramtype binary_as_string: bool
        :keyword flatten_spec: A Druid ``flattenSpec`` object for pre-processing the input Parquet. For
         more information, see `FlattenSpec
         <https://docs.imply.io/latest/druid/ingestion/data-formats/#flattenspec>`_.
        :paramtype flatten_spec: dict[str, any]
        """
        super().__init__(**kwargs)
        self.format: str = "parquet"
        self.binary_as_string = binary_as_string
        self.flatten_spec = flatten_spec


class PathTree(_serialization.Model):
    """PathTree.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "path-tree"
    :vartype type: str or ~polaris.sdk.global_api.models.PathTreeType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar group: Dimensions to be shown by the group. Required.
    :vartype group: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "group": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "group": {"key": "group", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        group: List[Any],
        type: Optional[Union[str, "_models.PathTreeType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "path-tree"
        :paramtype type: str or ~polaris.sdk.global_api.models.PathTreeType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword group: Dimensions to be shown by the group. Required.
        :paramtype group: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.group = group


class PeriodGranularityPayload(GranularityPayload):
    """Period-based granularity that accepts an ISO 8601 period such as ``P6M``. Allows specification
    of time zone and origin.

    All required parameters must be populated in order to send to server.

    :ivar type: The type of granularity.


     * ``simple``\\ - Simple granularity such as ``millisecond`` or ``hour``.
     * ``period``\\ - Period-based granularity that accepts an ISO 8601 period such as ``P6M``.
     Allows specification of time zone and origin. Required. Known values are: "simple" and
     "period".
    :vartype type: str or ~polaris.sdk.global_api.models.GranularityType
    :ivar origin: Timestamp in ISO 8601 format that determines the starting point for locating the
     first granularity bucket.
     Defaults to ``1970-01-01T00:00:00`` in the given time zone.
    :vartype origin: str
    :ivar period: Arbitrary period combination of years, months, weeks, hours, minutes, and seconds
     in ISO 8601 format.
     For example, ``P2W``\\ , ``P3M``\\ , ``PT1H30M``\\ , ``PT0.750S``. Required.
    :vartype period: str
    :ivar time_zone: Time zone that determines where period boundaries start as well as the time
     zone of the returned
     timestamps. Defaults to UTC.
    :vartype time_zone: str
    """

    _validation = {
        "type": {"required": True},
        "period": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "origin": {"key": "origin", "type": "str"},
        "period": {"key": "period", "type": "str"},
        "time_zone": {"key": "timeZone", "type": "str"},
    }

    def __init__(
        self,
        *,
        period: str,
        origin: Optional[str] = None,
        time_zone: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword origin: Timestamp in ISO 8601 format that determines the starting point for locating
         the first granularity bucket.
         Defaults to ``1970-01-01T00:00:00`` in the given time zone.
        :paramtype origin: str
        :keyword period: Arbitrary period combination of years, months, weeks, hours, minutes, and
         seconds in ISO 8601 format.
         For example, ``P2W``\\ , ``P3M``\\ , ``PT1H30M``\\ , ``PT0.750S``. Required.
        :paramtype period: str
        :keyword time_zone: Time zone that determines where period boundaries start as well as the time
         zone of the returned
         timestamps. Defaults to UTC.
        :paramtype time_zone: str
        """
        super().__init__(**kwargs)
        self.type: str = "period"
        self.origin = origin
        self.period = period
        self.time_zone = time_zone


class PeriodPolicyPayload(StoragePolicyPayload):
    """PeriodPolicyPayload.

    All required parameters must be populated in order to send to server.

    :ivar type: The type of storage policy to set. Required. Known values are: "intervals" and
     "period".
    :vartype type: str or ~polaris.sdk.global_api.models.StoragePolicyType
    :ivar period: Time duration in ISO 8601 format relative to the present time. The duration
     refers to the post-transform
     timestamp values stored in the ``__time`` column of the table. For example, the period
     ``P30D``
     retains or precaches data within 30 days of the present time. Required.
    :vartype period: str
    """

    _validation = {
        "type": {"required": True},
        "period": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "period": {"key": "period", "type": "str"},
    }

    def __init__(self, *, period: str, **kwargs: Any) -> None:
        """
        :keyword period: Time duration in ISO 8601 format relative to the present time. The duration
         refers to the post-transform
         timestamp values stored in the ``__time`` column of the table. For example, the period
         ``P30D``
         retains or precaches data within 30 days of the present time. Required.
        :paramtype period: str
        """
        super().__init__(**kwargs)
        self.type: str = "period"
        self.period = period


class PermissionListRepresentation(_serialization.Model):
    """PermissionListRepresentation.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.PermissionRepresentation]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[PermissionRepresentation]"},
    }

    def __init__(
        self, *, values: List["_models.PermissionRepresentation"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.PermissionRepresentation]
        """
        super().__init__(**kwargs)
        self.values = values


class PermissionRepresentation(_serialization.Model):
    """PermissionRepresentation.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: A generated, permanently unique ID for this permission.
    :vartype id: str
    :ivar name: The permission name.
    :vartype name: str
    :ivar description: A description of the permission.
    :vartype description: str
    :ivar resources: The list of resources this permission will apply to.
    :vartype resources: list[str]
    """

    _validation = {
        "id": {"readonly": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "resources": {"key": "resources", "type": "[str]"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        resources: Optional[List[str]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: The permission name.
        :paramtype name: str
        :keyword description: A description of the permission.
        :paramtype description: str
        :keyword resources: The list of resources this permission will apply to.
        :paramtype resources: list[str]
        """
        super().__init__(**kwargs)
        self.id = None
        self.name = name
        self.description = description
        self.resources = resources


class PieChart(_serialization.Model):
    """PieChart.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "pie-chart"
    :vartype type: str or ~polaris.sdk.global_api.models.PieChartType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar layout: Dimensions to be shown by the layout. Required.
    :vartype layout: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "layout": {"required": True, "max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "layout": {"key": "layout", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        layout: List[Any],
        type: Optional[Union[str, "_models.PieChartType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "pie-chart"
        :paramtype type: str or ~polaris.sdk.global_api.models.PieChartType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword layout: Dimensions to be shown by the layout. Required.
        :paramtype layout: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.layout = layout


class PlywoodRange(_serialization.Model):
    """Range of values.

    All required parameters must be populated in order to send to server.

    :ivar start: Anything. Required.
    :vartype start: any
    :ivar end: Anything. Required.
    :vartype end: any
    :ivar bounds: Bounds string describing the range.
    :vartype bounds: str
    """

    _validation = {
        "start": {"required": True},
        "end": {"required": True},
    }

    _attribute_map = {
        "start": {"key": "start", "type": "object"},
        "end": {"key": "end", "type": "object"},
        "bounds": {"key": "bounds", "type": "str"},
    }

    def __init__(
        self, *, start: Any, end: Any, bounds: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword start: Anything. Required.
        :paramtype start: any
        :keyword end: Anything. Required.
        :paramtype end: any
        :keyword bounds: Bounds string describing the range.
        :paramtype bounds: str
        """
        super().__init__(**kwargs)
        self.start = start
        self.end = end
        self.bounds = bounds


class PlywoodSet(_serialization.Model):
    """A set of values.

    All required parameters must be populated in order to send to server.

    :ivar set_type: The concrete type for a single datum. Required. Known values are: "NULL",
     "BOOLEAN", "NUMBER", "TIME", "STRING", "NUMBER_RANGE", "IP", "TIME_SERIES", "TIME_RANGE",
     "STRING_RANGE", "SET", "SET/NULL", "SET/BOOLEAN", "SET/NUMBER", "SET/TIME", "SET/STRING",
     "SET/NUMBER_RANGE", "SET/TIME_RANGE", "SET/IP", "SET/STRING_RANGE", and "DATASET".
    :vartype set_type: str or ~polaris.sdk.global_api.models.PlywoodType
    :ivar elements: The values in the set. Required.
    :vartype elements: list[any]
    """

    _validation = {
        "set_type": {"required": True},
        "elements": {"required": True},
    }

    _attribute_map = {
        "set_type": {"key": "setType", "type": "str"},
        "elements": {"key": "elements", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        set_type: Union[str, "_models.PlywoodType"],
        elements: List[Any],
        **kwargs: Any
    ) -> None:
        """
        :keyword set_type: The concrete type for a single datum. Required. Known values are: "NULL",
         "BOOLEAN", "NUMBER", "TIME", "STRING", "NUMBER_RANGE", "IP", "TIME_SERIES", "TIME_RANGE",
         "STRING_RANGE", "SET", "SET/NULL", "SET/BOOLEAN", "SET/NUMBER", "SET/TIME", "SET/STRING",
         "SET/NUMBER_RANGE", "SET/TIME_RANGE", "SET/IP", "SET/STRING_RANGE", and "DATASET".
        :paramtype set_type: str or ~polaris.sdk.global_api.models.PlywoodType
        :keyword elements: The values in the set. Required.
        :paramtype elements: list[any]
        """
        super().__init__(**kwargs)
        self.set_type = set_type
        self.elements = elements


class Project(_serialization.Model):
    """Metadata and status information for a Polaris project.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar metadata: Metadata to identify the project. Required.
    :vartype metadata: ~polaris.sdk.global_api.models.ObjectMeta
    :ivar spec: Information about the plan and desired state of the project. Required.
    :vartype spec: ~polaris.sdk.global_api.models.ProjectSpec
    :ivar status:
    :vartype status: ~polaris.sdk.global_api.models.ProjectStatus
    """

    _validation = {
        "metadata": {"required": True},
        "spec": {"required": True},
        "status": {"readonly": True},
    }

    _attribute_map = {
        "metadata": {"key": "metadata", "type": "ObjectMeta"},
        "spec": {"key": "spec", "type": "ProjectSpec"},
        "status": {"key": "status", "type": "ProjectStatus"},
    }

    def __init__(
        self,
        *,
        metadata: "_models.ObjectMeta",
        spec: "_models.ProjectSpec",
        **kwargs: Any
    ) -> None:
        """
        :keyword metadata: Metadata to identify the project. Required.
        :paramtype metadata: ~polaris.sdk.global_api.models.ObjectMeta
        :keyword spec: Information about the plan and desired state of the project. Required.
        :paramtype spec: ~polaris.sdk.global_api.models.ProjectSpec
        """
        super().__init__(**kwargs)
        self.metadata = metadata
        self.spec = spec
        self.status = None


class ProjectPlan(_serialization.Model):
    """Metadata of a Polaris project.

    :ivar name: Project plan.
    :vartype name: str
    :ivar max_bytes: Max data size of the project in bytes.
    :vartype max_bytes: int
    :ivar memory: Total memory allocated to the project in GB.
    :vartype memory: str
    :ivar cpu: Total CPUs allocated to the project.
    :vartype cpu: str
    """

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "max_bytes": {"key": "maxBytes", "type": "int"},
        "memory": {"key": "memory", "type": "str"},
        "cpu": {"key": "cpu", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: Optional[str] = None,
        max_bytes: Optional[int] = None,
        memory: Optional[str] = None,
        cpu: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Project plan.
        :paramtype name: str
        :keyword max_bytes: Max data size of the project in bytes.
        :paramtype max_bytes: int
        :keyword memory: Total memory allocated to the project in GB.
        :paramtype memory: str
        :keyword cpu: Total CPUs allocated to the project.
        :paramtype cpu: str
        """
        super().__init__(**kwargs)
        self.name = name
        self.max_bytes = max_bytes
        self.memory = memory
        self.cpu = cpu


class ProjectSpec(_serialization.Model):
    """Information about the plan and desired state of the project.

    :ivar plan: Project plan.
    :vartype plan: str
    :ivar desired_state: Desired state of the project. Known values are: "running", "paused", and
     "stopped".
    :vartype desired_state: str or ~polaris.sdk.global_api.models.ProjectSpecDesiredState
    :ivar deletion_protection: Prevents the project from being deleted.
    :vartype deletion_protection: bool
    :ivar stop_protection: Prevents the project from being paused or stopped.
    :vartype stop_protection: bool
    :ivar region: Cloud region for the project. For supported regions, see `Cloud providers and
     regions <https://docs.imply.io/polaris/regions>`_. Known values are: "us-east-1", "us-east-2",
     "eu-central-1", "eu-west-1", "us-west-2", "ap-northeast-2", "ap-south-1", "eastus",
     "germanywestcentral", and "westus2".
    :vartype region: str or ~polaris.sdk.global_api.models.RegionEnum
    """

    _attribute_map = {
        "plan": {"key": "plan", "type": "str"},
        "desired_state": {"key": "desiredState", "type": "str"},
        "deletion_protection": {"key": "deletionProtection", "type": "bool"},
        "stop_protection": {"key": "stopProtection", "type": "bool"},
        "region": {"key": "region", "type": "str"},
    }

    def __init__(
        self,
        *,
        plan: Optional[str] = None,
        desired_state: Optional[Union[str, "_models.ProjectSpecDesiredState"]] = None,
        deletion_protection: bool = False,
        stop_protection: bool = False,
        region: Optional[Union[str, "_models.RegionEnum"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword plan: Project plan.
        :paramtype plan: str
        :keyword desired_state: Desired state of the project. Known values are: "running", "paused",
         and "stopped".
        :paramtype desired_state: str or ~polaris.sdk.global_api.models.ProjectSpecDesiredState
        :keyword deletion_protection: Prevents the project from being deleted.
        :paramtype deletion_protection: bool
        :keyword stop_protection: Prevents the project from being paused or stopped.
        :paramtype stop_protection: bool
        :keyword region: Cloud region for the project. For supported regions, see `Cloud providers and
         regions <https://docs.imply.io/polaris/regions>`_. Known values are: "us-east-1", "us-east-2",
         "eu-central-1", "eu-west-1", "us-west-2", "ap-northeast-2", "ap-south-1", "eastus",
         "germanywestcentral", and "westus2".
        :paramtype region: str or ~polaris.sdk.global_api.models.RegionEnum
        """
        super().__init__(**kwargs)
        self.plan = plan
        self.desired_state = desired_state
        self.deletion_protection = deletion_protection
        self.stop_protection = stop_protection
        self.region = region


class ProjectStatusAutoGenerated(_serialization.Model):
    """Information about the current state of the project.

    :ivar max_bytes: Max data size of the project in bytes.
    :vartype max_bytes: int
    :ivar current_bytes: Current data size of the project in bytes.
    :vartype current_bytes: int
    :ivar deep_storage_bytes: Deep storage size of the project in bytes.
    :vartype deep_storage_bytes: int
    :ivar state: Current state of the project.


     * ``creating`` - The project is in creation.
     * ``pending`` - The project is pending for creation or update.
     * ``running`` - The project is running.
     * ``pausing`` - The project is being paused.
     * ``paused`` -  The project is paused while the storage volume is kept.
     * ``stopping`` - The project is being stopped.
     * ``stopped`` - The project is stopped while the storage volume is also removed.
     * ``deleting`` - The project is being deleted.
     * ``deleted`` - The project is deleted.
     * ``updating`` - The project is being updated.
     * ``balancing`` - The segments are being balanced when the project is scaling up and down.
     * ``failed`` - The project is failed.
     * ``resuming`` - The project is being resumed from ``paused`` or ``stopped`` state.
     * ``unknown`` - The project is in unknown state.
     * ``restarting`` - The project is restarting. Known values are: "creating", "pending",
     "running", "pausing", "paused", "stopping", "stopped", "deleting", "deleted", "updating",
     "balancing", "failed", "resuming", "unknown", and "restarting".
    :vartype state: str or ~polaris.sdk.global_api.models.ProjectStatusState
    :ivar version: Current version of the project.
    :vartype version: str
    """

    _attribute_map = {
        "max_bytes": {"key": "maxBytes", "type": "int"},
        "current_bytes": {"key": "currentBytes", "type": "int"},
        "deep_storage_bytes": {"key": "deepStorageBytes", "type": "int"},
        "state": {"key": "state", "type": "str"},
        "version": {"key": "version", "type": "str"},
    }

    def __init__(
        self,
        *,
        max_bytes: Optional[int] = None,
        current_bytes: Optional[int] = None,
        deep_storage_bytes: Optional[int] = None,
        state: Optional[Union[str, "_models.ProjectStatusState"]] = None,
        version: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword max_bytes: Max data size of the project in bytes.
        :paramtype max_bytes: int
        :keyword current_bytes: Current data size of the project in bytes.
        :paramtype current_bytes: int
        :keyword deep_storage_bytes: Deep storage size of the project in bytes.
        :paramtype deep_storage_bytes: int
        :keyword state: Current state of the project.


         * ``creating`` - The project is in creation.
         * ``pending`` - The project is pending for creation or update.
         * ``running`` - The project is running.
         * ``pausing`` - The project is being paused.
         * ``paused`` -  The project is paused while the storage volume is kept.
         * ``stopping`` - The project is being stopped.
         * ``stopped`` - The project is stopped while the storage volume is also removed.
         * ``deleting`` - The project is being deleted.
         * ``deleted`` - The project is deleted.
         * ``updating`` - The project is being updated.
         * ``balancing`` - The segments are being balanced when the project is scaling up and down.
         * ``failed`` - The project is failed.
         * ``resuming`` - The project is being resumed from ``paused`` or ``stopped`` state.
         * ``unknown`` - The project is in unknown state.
         * ``restarting`` - The project is restarting. Known values are: "creating", "pending",
         "running", "pausing", "paused", "stopping", "stopped", "deleting", "deleted", "updating",
         "balancing", "failed", "resuming", "unknown", and "restarting".
        :paramtype state: str or ~polaris.sdk.global_api.models.ProjectStatusState
        :keyword version: Current version of the project.
        :paramtype version: str
        """
        super().__init__(**kwargs)
        self.max_bytes = max_bytes
        self.current_bytes = current_bytes
        self.deep_storage_bytes = deep_storage_bytes
        self.state = state
        self.version = version


class ProjectStatus(ProjectStatusAutoGenerated):
    """ProjectStatus.

    :ivar max_bytes: Max data size of the project in bytes.
    :vartype max_bytes: int
    :ivar current_bytes: Current data size of the project in bytes.
    :vartype current_bytes: int
    :ivar deep_storage_bytes: Deep storage size of the project in bytes.
    :vartype deep_storage_bytes: int
    :ivar state: Current state of the project.


     * ``creating`` - The project is in creation.
     * ``pending`` - The project is pending for creation or update.
     * ``running`` - The project is running.
     * ``pausing`` - The project is being paused.
     * ``paused`` -  The project is paused while the storage volume is kept.
     * ``stopping`` - The project is being stopped.
     * ``stopped`` - The project is stopped while the storage volume is also removed.
     * ``deleting`` - The project is being deleted.
     * ``deleted`` - The project is deleted.
     * ``updating`` - The project is being updated.
     * ``balancing`` - The segments are being balanced when the project is scaling up and down.
     * ``failed`` - The project is failed.
     * ``resuming`` - The project is being resumed from ``paused`` or ``stopped`` state.
     * ``unknown`` - The project is in unknown state.
     * ``restarting`` - The project is restarting. Known values are: "creating", "pending",
     "running", "pausing", "paused", "stopping", "stopped", "deleting", "deleted", "updating",
     "balancing", "failed", "resuming", "unknown", and "restarting".
    :vartype state: str or ~polaris.sdk.global_api.models.ProjectStatusState
    :ivar version: Current version of the project.
    :vartype version: str
    """


class ProtobufFormatSettings(DataFormatSettings):
    """ProtobufFormatSettings.

    All required parameters must be populated in order to send to server.

    :ivar format: Data format:


     * ``avro_ocf`` - Avro OCF (Object Container Format) for batch ingestion
     * ``avro_stream`` - Avro for stream ingestion
     * ``csv`` - Delimiter-separated data including CSV and TSV
     * ``kafka`` - Format to ingest Kafka values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``kinesis`` - Format to ingest Kinesis values in one of the `supported formats
     <https://docs.imply.io/ui/saas/help/supported-formats>`_ as well as event metadata
     * ``nd-json`` - Newline-delimited JSON (one JSON record per line)
     * ``orc`` - ORC format
     * ``parquet`` - Parquet format
     * ``protobuf`` - Protobuf format
     * ``regex`` - Format to parse using a regular expression. Required. Known values are:
     "avro_ocf", "avro_stream", "csv", "kafka", "kinesis", "nd-json", "orc", "parquet", and
     "protobuf".
    :vartype format: str or ~polaris.sdk.global_api.models.DataFormat
    :ivar flatten_spec: A Druid ``flattenSpec`` object for pre-processing the input Protobuf. For
     more information, see `FlattenSpec
     <https://docs.imply.io/latest/druid/ingestion/data-formats/#flattenspec>`_.
    :vartype flatten_spec: dict[str, any]
    :ivar parse_schema_provider: A parse schema provider describes the source of schema information
     used to parse input data. These are used for input data types that have external schemas (i.e.,
     where the schema is not stored with the data itself), such as Protobuf and Avro. Required.
    :vartype parse_schema_provider: ~polaris.sdk.global_api.models.ParseSchemaProvider
    """

    _validation = {
        "format": {"required": True},
        "parse_schema_provider": {"required": True},
    }

    _attribute_map = {
        "format": {"key": "format", "type": "str"},
        "flatten_spec": {"key": "flattenSpec", "type": "{object}"},
        "parse_schema_provider": {
            "key": "parseSchemaProvider",
            "type": "ParseSchemaProvider",
        },
    }

    def __init__(
        self,
        *,
        parse_schema_provider: "_models.ParseSchemaProvider",
        flatten_spec: Optional[Dict[str, Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword flatten_spec: A Druid ``flattenSpec`` object for pre-processing the input Protobuf.
         For more information, see `FlattenSpec
         <https://docs.imply.io/latest/druid/ingestion/data-formats/#flattenspec>`_.
        :paramtype flatten_spec: dict[str, any]
        :keyword parse_schema_provider: A parse schema provider describes the source of schema
         information used to parse input data. These are used for input data types that have external
         schemas (i.e., where the schema is not stored with the data itself), such as Protobuf and Avro.
         Required.
        :paramtype parse_schema_provider: ~polaris.sdk.global_api.models.ParseSchemaProvider
        """
        super().__init__(**kwargs)
        self.format: str = "protobuf"
        self.flatten_spec = flatten_spec
        self.parse_schema_provider = parse_schema_provider


class PushStreamingConnectionResponse(
    ConnectionResponse, PushStreamingConnectionProperties
):
    """A specific push streaming connection.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar endpoint_url:
    :vartype endpoint_url: str
    :ivar modified_by_user: Required.
    :vartype modified_by_user: ~polaris.sdk.global_api.models.ConnectionResponseModifiedByUser
    :ivar modified_on_timestamp: Required.
    :vartype modified_on_timestamp: str
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar submitted_by_user: Required.
    :vartype submitted_by_user: ~polaris.sdk.global_api.models.ConnectionResponseSubmittedByUser
    :ivar submitted_on_timestamp: Required.
    :vartype submitted_on_timestamp: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "endpoint_url": {"readonly": True},
        "modified_by_user": {"required": True, "readonly": True},
        "modified_on_timestamp": {"required": True, "readonly": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "submitted_by_user": {"required": True, "readonly": True},
        "submitted_on_timestamp": {"required": True, "readonly": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "endpoint_url": {"key": "endpointUrl", "type": "str"},
        "modified_by_user": {
            "key": "modifiedByUser",
            "type": "ConnectionResponseModifiedByUser",
        },
        "modified_on_timestamp": {"key": "modifiedOnTimestamp", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "submitted_by_user": {
            "key": "submittedByUser",
            "type": "ConnectionResponseSubmittedByUser",
        },
        "submitted_on_timestamp": {"key": "submittedOnTimestamp", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self, *, name: str, description: Optional[str] = None, **kwargs: Any
    ) -> None:
        """
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(name=name, description=description, **kwargs)
        self.endpoint_url = None
        self.type: str = "push_streaming"
        self.modified_by_user = None
        self.modified_on_timestamp = None
        self.name = name
        self.submitted_by_user = None
        self.submitted_on_timestamp = None
        self.description = description


class Raw(_serialization.Model):
    """Raw.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "raw"
    :vartype type: str or ~polaris.sdk.global_api.models.RawType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        type: Optional[Union[str, "_models.RawType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "raw"
        :paramtype type: str or ~polaris.sdk.global_api.models.RawType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures


class RelativeCompare(_serialization.Model):
    """Relative time comparison.

    All required parameters must be populated in order to send to server.

    :ivar type: Required. "relative"
    :vartype type: str or ~polaris.sdk.global_api.models.RelativeCompareType
    :ivar duration: Relative time period expressed as an `ISO 8601 duration
     <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_. Required.
    :vartype duration: ~datetime.timedelta
    """

    _validation = {
        "type": {"required": True},
        "duration": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "duration": {"key": "duration", "type": "duration"},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.RelativeCompareType"],
        duration: datetime.timedelta,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Required. "relative"
        :paramtype type: str or ~polaris.sdk.global_api.models.RelativeCompareType
        :keyword duration: Relative time period expressed as an `ISO 8601 duration
         <https://en.wikipedia.org/wiki/ISO_8601#Durations>`_. Required.
        :paramtype duration: ~datetime.timedelta
        """
        super().__init__(**kwargs)
        self.type = type
        self.duration = duration


class ReportPayload(_serialization.Model):
    """Reports conditions and evaluation criteria.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar creation_date: Timestamp when the report was created.
    :vartype creation_date: ~datetime.datetime
    :ivar owner: User ID of the report owner. The owner can modify the report and its recipient
     list.
    :vartype owner: str
    :ivar title: Report title to display in the Polaris UI, and in emails and webhooks.
    :vartype title: str
    :ivar description: Report description to display in the Polaris UI, and in emails and webhooks.
    :vartype description: str
    :ivar disabled: Disables the report. Polaris doesn't evaluate disabled reports or send
     notifications.
    :vartype disabled: bool
    :ivar delivery: Defines when and how often to evaluate the report.
    :vartype delivery: ~polaris.sdk.global_api.models.Delivery
    :ivar preferred_view: View to use when viewing the report in Polaris. Defaults to ``pivot1``.
     When supplying
     a ``facetEssence``\\ , set to ``pivot2``. When supplying an ``exploreEssence``\\ , set to
     ``explore``. Known values are: "pivot1", "pivot2", and "explore".
    :vartype preferred_view: str or ~polaris.sdk.global_api.models.ReportPayloadPreferredView
    :ivar time_frame: Controls the amount of data Polaris considers when evaluating the report
     criteria based upon a time interval.
    :vartype time_frame: ~polaris.sdk.global_api.models.TimeFrame
    :ivar essence: Visualization definition for classic data cubes. This is not applicable to
     Polaris.
    :vartype essence: dict[str, any]
    :ivar facet_essence: Visualization definition for Pivot 2 data cubes.
    :vartype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
    :ivar explore_essence: Visualization definition for data cubes of specific types, including
     overall, gauge, flat table, and time series.
     If you want to use any of these visualizations but you don't see them in Polaris, contact
     Imply support.
    :vartype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
    :ivar admins: List of users who can modify the report.
    :vartype admins: ~polaris.sdk.global_api.models.AccessList
    :ivar read_access: List of users who can view the report.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar recipients: List of users to receive report notifications.
    :vartype recipients: ~polaris.sdk.global_api.models.AccessList
    :ivar external_emails: External email addresses to receive report notications.
    :vartype external_emails: list[str]
    :ivar timezone: Timezone to use when evaluating report criteria. Defaults to ``UTC``.
    :vartype timezone: str
    :ivar send_data_file: Sends the report data as an attachment.
    :vartype send_data_file: bool
    :ivar add_total_row_to_file: Adds a line to the attachment that shows an overall total. You
     can't apply this
     option to JSON format attachments.
    :vartype add_total_row_to_file: bool
    :ivar file_format: Format of the report data attachment. Defaults to ``CSV``. Known values are:
     "csv", "tsv", "xlsx", and "json".
    :vartype file_format: str or ~polaris.sdk.global_api.models.ReportPayloadFileFormat
    :ivar download_limit: Maximum number of rows to include in the report attachment. Defaults to
     ``500``.
    :vartype download_limit: float
    :ivar enforce_decimal_formatting: Formats numeric values in the report attachment as decimals.
    :vartype enforce_decimal_formatting: bool
    :ivar send_email: Sends email notifications to the report recipients when the report is
     generated.
    :vartype send_email: bool
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
        "owner": {"max_length": 255, "min_length": 1},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "creation_date": {"key": "creationDate", "type": "iso-8601"},
        "owner": {"key": "owner", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "disabled": {"key": "disabled", "type": "bool"},
        "delivery": {"key": "delivery", "type": "Delivery"},
        "preferred_view": {"key": "preferredView", "type": "str"},
        "time_frame": {"key": "timeFrame", "type": "TimeFrame"},
        "essence": {"key": "essence", "type": "{object}"},
        "facet_essence": {"key": "facetEssence", "type": "FacetEssence"},
        "explore_essence": {"key": "exploreEssence", "type": "ExploreEssence"},
        "admins": {"key": "admins", "type": "AccessList"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "recipients": {"key": "recipients", "type": "AccessList"},
        "external_emails": {"key": "externalEmails", "type": "[str]"},
        "timezone": {"key": "timezone", "type": "str"},
        "send_data_file": {"key": "sendDataFile", "type": "bool"},
        "add_total_row_to_file": {"key": "addTotalRowToFile", "type": "bool"},
        "file_format": {"key": "fileFormat", "type": "str"},
        "download_limit": {"key": "downloadLimit", "type": "float"},
        "enforce_decimal_formatting": {
            "key": "enforceDecimalFormatting",
            "type": "bool",
        },
        "send_email": {"key": "sendEmail", "type": "bool"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        creation_date: Optional[datetime.datetime] = None,
        owner: Optional[str] = None,
        title: Optional[str] = None,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        delivery: Optional["_models.Delivery"] = None,
        preferred_view: Union[str, "_models.ReportPayloadPreferredView"] = "pivot1",
        time_frame: Optional["_models.TimeFrame"] = None,
        essence: Optional[Dict[str, Any]] = None,
        facet_essence: Optional["_models.FacetEssence"] = None,
        explore_essence: Optional["_models.ExploreEssence"] = None,
        admins: Optional["_models.AccessList"] = None,
        read_access: Optional["_models.AccessList"] = None,
        recipients: Optional["_models.AccessList"] = None,
        external_emails: Optional[List[str]] = None,
        timezone: str = "Etc/UTC",
        send_data_file: bool = True,
        add_total_row_to_file: bool = False,
        file_format: Union[str, "_models.ReportPayloadFileFormat"] = "csv",
        download_limit: float = 500,
        enforce_decimal_formatting: bool = False,
        send_email: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword creation_date: Timestamp when the report was created.
        :paramtype creation_date: ~datetime.datetime
        :keyword owner: User ID of the report owner. The owner can modify the report and its recipient
         list.
        :paramtype owner: str
        :keyword title: Report title to display in the Polaris UI, and in emails and webhooks.
        :paramtype title: str
        :keyword description: Report description to display in the Polaris UI, and in emails and
         webhooks.
        :paramtype description: str
        :keyword disabled: Disables the report. Polaris doesn't evaluate disabled reports or send
         notifications.
        :paramtype disabled: bool
        :keyword delivery: Defines when and how often to evaluate the report.
        :paramtype delivery: ~polaris.sdk.global_api.models.Delivery
        :keyword preferred_view: View to use when viewing the report in Polaris. Defaults to
         ``pivot1``. When supplying
         a ``facetEssence``\\ , set to ``pivot2``. When supplying an ``exploreEssence``\\ , set to
         ``explore``. Known values are: "pivot1", "pivot2", and "explore".
        :paramtype preferred_view: str or ~polaris.sdk.global_api.models.ReportPayloadPreferredView
        :keyword time_frame: Controls the amount of data Polaris considers when evaluating the report
         criteria based upon a time interval.
        :paramtype time_frame: ~polaris.sdk.global_api.models.TimeFrame
        :keyword essence: Visualization definition for classic data cubes. This is not applicable to
         Polaris.
        :paramtype essence: dict[str, any]
        :keyword facet_essence: Visualization definition for Pivot 2 data cubes.
        :paramtype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
        :keyword explore_essence: Visualization definition for data cubes of specific types, including
         overall, gauge, flat table, and time series.
         If you want to use any of these visualizations but you don't see them in Polaris, contact
         Imply support.
        :paramtype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
        :keyword admins: List of users who can modify the report.
        :paramtype admins: ~polaris.sdk.global_api.models.AccessList
        :keyword read_access: List of users who can view the report.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword recipients: List of users to receive report notifications.
        :paramtype recipients: ~polaris.sdk.global_api.models.AccessList
        :keyword external_emails: External email addresses to receive report notications.
        :paramtype external_emails: list[str]
        :keyword timezone: Timezone to use when evaluating report criteria. Defaults to ``UTC``.
        :paramtype timezone: str
        :keyword send_data_file: Sends the report data as an attachment.
        :paramtype send_data_file: bool
        :keyword add_total_row_to_file: Adds a line to the attachment that shows an overall total. You
         can't apply this
         option to JSON format attachments.
        :paramtype add_total_row_to_file: bool
        :keyword file_format: Format of the report data attachment. Defaults to ``CSV``. Known values
         are: "csv", "tsv", "xlsx", and "json".
        :paramtype file_format: str or ~polaris.sdk.global_api.models.ReportPayloadFileFormat
        :keyword download_limit: Maximum number of rows to include in the report attachment. Defaults
         to ``500``.
        :paramtype download_limit: float
        :keyword enforce_decimal_formatting: Formats numeric values in the report attachment as
         decimals.
        :paramtype enforce_decimal_formatting: bool
        :keyword send_email: Sends email notifications to the report recipients when the report is
         generated.
        :paramtype send_email: bool
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.creation_date = creation_date
        self.owner = owner
        self.title = title
        self.description = description
        self.disabled = disabled
        self.delivery = delivery
        self.preferred_view = preferred_view
        self.time_frame = time_frame
        self.essence = essence
        self.facet_essence = facet_essence
        self.explore_essence = explore_essence
        self.admins = admins
        self.read_access = read_access
        self.recipients = recipients
        self.external_emails = external_emails
        self.timezone = timezone
        self.send_data_file = send_data_file
        self.add_total_row_to_file = add_total_row_to_file
        self.file_format = file_format
        self.download_limit = download_limit
        self.enforce_decimal_formatting = enforce_decimal_formatting
        self.send_email = send_email


class ReportBody(ReportPayload):
    """ReportBody.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar creation_date: Timestamp when the report was created.
    :vartype creation_date: ~datetime.datetime
    :ivar owner: User ID of the report owner. The owner can modify the report and its recipient
     list.
    :vartype owner: str
    :ivar title: Report title to display in the Polaris UI, and in emails and webhooks.
    :vartype title: str
    :ivar description: Report description to display in the Polaris UI, and in emails and webhooks.
    :vartype description: str
    :ivar disabled: Disables the report. Polaris doesn't evaluate disabled reports or send
     notifications.
    :vartype disabled: bool
    :ivar delivery: Defines when and how often to evaluate the report.
    :vartype delivery: ~polaris.sdk.global_api.models.Delivery
    :ivar preferred_view: View to use when viewing the report in Polaris. Defaults to ``pivot1``.
     When supplying
     a ``facetEssence``\\ , set to ``pivot2``. When supplying an ``exploreEssence``\\ , set to
     ``explore``. Known values are: "pivot1", "pivot2", and "explore".
    :vartype preferred_view: str or ~polaris.sdk.global_api.models.ReportPayloadPreferredView
    :ivar time_frame: Controls the amount of data Polaris considers when evaluating the report
     criteria based upon a time interval.
    :vartype time_frame: ~polaris.sdk.global_api.models.TimeFrame
    :ivar essence: Visualization definition for classic data cubes. This is not applicable to
     Polaris.
    :vartype essence: dict[str, any]
    :ivar facet_essence: Visualization definition for Pivot 2 data cubes.
    :vartype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
    :ivar explore_essence: Visualization definition for data cubes of specific types, including
     overall, gauge, flat table, and time series.
     If you want to use any of these visualizations but you don't see them in Polaris, contact
     Imply support.
    :vartype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
    :ivar admins: List of users who can modify the report.
    :vartype admins: ~polaris.sdk.global_api.models.AccessList
    :ivar read_access: List of users who can view the report.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar recipients: List of users to receive report notifications.
    :vartype recipients: ~polaris.sdk.global_api.models.AccessList
    :ivar external_emails: External email addresses to receive report notications.
    :vartype external_emails: list[str]
    :ivar timezone: Timezone to use when evaluating report criteria. Defaults to ``UTC``.
    :vartype timezone: str
    :ivar send_data_file: Sends the report data as an attachment.
    :vartype send_data_file: bool
    :ivar add_total_row_to_file: Adds a line to the attachment that shows an overall total. You
     can't apply this
     option to JSON format attachments.
    :vartype add_total_row_to_file: bool
    :ivar file_format: Format of the report data attachment. Defaults to ``CSV``. Known values are:
     "csv", "tsv", "xlsx", and "json".
    :vartype file_format: str or ~polaris.sdk.global_api.models.ReportPayloadFileFormat
    :ivar download_limit: Maximum number of rows to include in the report attachment. Defaults to
     ``500``.
    :vartype download_limit: float
    :ivar enforce_decimal_formatting: Formats numeric values in the report attachment as decimals.
    :vartype enforce_decimal_formatting: bool
    :ivar send_email: Sends email notifications to the report recipients when the report is
     generated.
    :vartype send_email: bool
    """


class ReportEvaluationError(_serialization.Model):
    """Error that occurred during report evaluation.

    All required parameters must be populated in order to send to server.

    :ivar type: Type of error that occurred during report evaluation. Required. Known values are:
     "internal-error", "misconfiguration-error", and "email-error".
    :vartype type: str or ~polaris.sdk.global_api.models.ReportEvaluationErrorType
    :ivar message: Error message. Required.
    :vartype message: str
    """

    _validation = {
        "type": {"required": True},
        "message": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "message": {"key": "message", "type": "str"},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.ReportEvaluationErrorType"],
        message: str,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Type of error that occurred during report evaluation. Required. Known values
         are: "internal-error", "misconfiguration-error", and "email-error".
        :paramtype type: str or ~polaris.sdk.global_api.models.ReportEvaluationErrorType
        :keyword message: Error message. Required.
        :paramtype message: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.message = message


class ReportEvaluationListResponse(_serialization.Model):
    """List of report evaluations.

    All required parameters must be populated in order to send to server.

    :ivar values: Array of report evaluations. Required.
    :vartype values: list[~polaris.sdk.global_api.models.ReportEvaluationPayload]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[ReportEvaluationPayload]"},
    }

    def __init__(
        self, *, values: List["_models.ReportEvaluationPayload"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Array of report evaluations. Required.
        :paramtype values: list[~polaris.sdk.global_api.models.ReportEvaluationPayload]
        """
        super().__init__(**kwargs)
        self.values = values


class ReportEvaluationPayload(_serialization.Model):
    """Single instance when the report was evaluated, its conditions, and the value of the data.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID. Required.
    :vartype id: str
    :ivar report: ID of the evaluated report. Required.
    :vartype report: ~polaris.sdk.global_api.models.ReportPayload
    :ivar send_date: Timestamp of when the report was sent. Required.
    :vartype send_date: ~datetime.datetime
    :ivar errors: Errors that occurred during report evaluation. Required.
    :vartype errors: list[~polaris.sdk.global_api.models.ReportEvaluationError]
    """

    _validation = {
        "id": {"required": True, "max_length": 255, "min_length": 1},
        "report": {"required": True},
        "send_date": {"required": True},
        "errors": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "report": {"key": "report", "type": "ReportPayload"},
        "send_date": {"key": "sendDate", "type": "iso-8601"},
        "errors": {"key": "errors", "type": "[ReportEvaluationError]"},
    }

    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        report: "_models.ReportPayload",
        send_date: datetime.datetime,
        errors: List["_models.ReportEvaluationError"],
        additional_properties: Optional[Dict[str, Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID. Required.
        :paramtype id: str
        :keyword report: ID of the evaluated report. Required.
        :paramtype report: ~polaris.sdk.global_api.models.ReportPayload
        :keyword send_date: Timestamp of when the report was sent. Required.
        :paramtype send_date: ~datetime.datetime
        :keyword errors: Errors that occurred during report evaluation. Required.
        :paramtype errors: list[~polaris.sdk.global_api.models.ReportEvaluationError]
        """
        super().__init__(**kwargs)
        self.additional_properties = additional_properties
        self.id = id
        self.report = report
        self.send_date = send_date
        self.errors = errors


class ReportListResponse(_serialization.Model):
    """Array of reports.

    All required parameters must be populated in order to send to server.

    :ivar values: Array of reports. Required.
    :vartype values: list[~polaris.sdk.global_api.models.ReportListResponseValuesItem]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[ReportListResponseValuesItem]"},
    }

    def __init__(
        self, *, values: List["_models.ReportListResponseValuesItem"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Array of reports. Required.
        :paramtype values: list[~polaris.sdk.global_api.models.ReportListResponseValuesItem]
        """
        super().__init__(**kwargs)
        self.values = values


class ReportListResponseValuesItem(AuditRecord, ReportPayload):
    """ReportListResponseValuesItem.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar creation_date: Timestamp when the report was created.
    :vartype creation_date: ~datetime.datetime
    :ivar owner: User ID of the report owner. The owner can modify the report and its recipient
     list.
    :vartype owner: str
    :ivar title: Report title to display in the Polaris UI, and in emails and webhooks.
    :vartype title: str
    :ivar description: Report description to display in the Polaris UI, and in emails and webhooks.
    :vartype description: str
    :ivar disabled: Disables the report. Polaris doesn't evaluate disabled reports or send
     notifications.
    :vartype disabled: bool
    :ivar delivery: Defines when and how often to evaluate the report.
    :vartype delivery: ~polaris.sdk.global_api.models.Delivery
    :ivar preferred_view: View to use when viewing the report in Polaris. Defaults to ``pivot1``.
     When supplying
     a ``facetEssence``\\ , set to ``pivot2``. When supplying an ``exploreEssence``\\ , set to
     ``explore``. Known values are: "pivot1", "pivot2", and "explore".
    :vartype preferred_view: str or ~polaris.sdk.global_api.models.ReportPayloadPreferredView
    :ivar time_frame: Controls the amount of data Polaris considers when evaluating the report
     criteria based upon a time interval.
    :vartype time_frame: ~polaris.sdk.global_api.models.TimeFrame
    :ivar essence: Visualization definition for classic data cubes. This is not applicable to
     Polaris.
    :vartype essence: dict[str, any]
    :ivar facet_essence: Visualization definition for Pivot 2 data cubes.
    :vartype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
    :ivar explore_essence: Visualization definition for data cubes of specific types, including
     overall, gauge, flat table, and time series.
     If you want to use any of these visualizations but you don't see them in Polaris, contact
     Imply support.
    :vartype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
    :ivar admins: List of users who can modify the report.
    :vartype admins: ~polaris.sdk.global_api.models.AccessList
    :ivar read_access: List of users who can view the report.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar recipients: List of users to receive report notifications.
    :vartype recipients: ~polaris.sdk.global_api.models.AccessList
    :ivar external_emails: External email addresses to receive report notications.
    :vartype external_emails: list[str]
    :ivar timezone: Timezone to use when evaluating report criteria. Defaults to ``UTC``.
    :vartype timezone: str
    :ivar send_data_file: Sends the report data as an attachment.
    :vartype send_data_file: bool
    :ivar add_total_row_to_file: Adds a line to the attachment that shows an overall total. You
     can't apply this
     option to JSON format attachments.
    :vartype add_total_row_to_file: bool
    :ivar file_format: Format of the report data attachment. Defaults to ``CSV``. Known values are:
     "csv", "tsv", "xlsx", and "json".
    :vartype file_format: str or ~polaris.sdk.global_api.models.ReportPayloadFileFormat
    :ivar download_limit: Maximum number of rows to include in the report attachment. Defaults to
     ``500``.
    :vartype download_limit: float
    :ivar enforce_decimal_formatting: Formats numeric values in the report attachment as decimals.
    :vartype enforce_decimal_formatting: bool
    :ivar send_email: Sends email notifications to the report recipients when the report is
     generated.
    :vartype send_email: bool
    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
        "owner": {"max_length": 255, "min_length": 1},
        "created_at": {"required": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "creation_date": {"key": "creationDate", "type": "iso-8601"},
        "owner": {"key": "owner", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "disabled": {"key": "disabled", "type": "bool"},
        "delivery": {"key": "delivery", "type": "Delivery"},
        "preferred_view": {"key": "preferredView", "type": "str"},
        "time_frame": {"key": "timeFrame", "type": "TimeFrame"},
        "essence": {"key": "essence", "type": "{object}"},
        "facet_essence": {"key": "facetEssence", "type": "FacetEssence"},
        "explore_essence": {"key": "exploreEssence", "type": "ExploreEssence"},
        "admins": {"key": "admins", "type": "AccessList"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "recipients": {"key": "recipients", "type": "AccessList"},
        "external_emails": {"key": "externalEmails", "type": "[str]"},
        "timezone": {"key": "timezone", "type": "str"},
        "send_data_file": {"key": "sendDataFile", "type": "bool"},
        "add_total_row_to_file": {"key": "addTotalRowToFile", "type": "bool"},
        "file_format": {"key": "fileFormat", "type": "str"},
        "download_limit": {"key": "downloadLimit", "type": "float"},
        "enforce_decimal_formatting": {
            "key": "enforceDecimalFormatting",
            "type": "bool",
        },
        "send_email": {"key": "sendEmail", "type": "bool"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        creation_date: Optional[datetime.datetime] = None,
        owner: Optional[str] = None,
        title: Optional[str] = None,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        delivery: Optional["_models.Delivery"] = None,
        preferred_view: Union[str, "_models.ReportPayloadPreferredView"] = "pivot1",
        time_frame: Optional["_models.TimeFrame"] = None,
        essence: Optional[Dict[str, Any]] = None,
        facet_essence: Optional["_models.FacetEssence"] = None,
        explore_essence: Optional["_models.ExploreEssence"] = None,
        admins: Optional["_models.AccessList"] = None,
        read_access: Optional["_models.AccessList"] = None,
        recipients: Optional["_models.AccessList"] = None,
        external_emails: Optional[List[str]] = None,
        timezone: str = "Etc/UTC",
        send_data_file: bool = True,
        add_total_row_to_file: bool = False,
        file_format: Union[str, "_models.ReportPayloadFileFormat"] = "csv",
        download_limit: float = 500,
        enforce_decimal_formatting: bool = False,
        send_email: Optional[bool] = None,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword creation_date: Timestamp when the report was created.
        :paramtype creation_date: ~datetime.datetime
        :keyword owner: User ID of the report owner. The owner can modify the report and its recipient
         list.
        :paramtype owner: str
        :keyword title: Report title to display in the Polaris UI, and in emails and webhooks.
        :paramtype title: str
        :keyword description: Report description to display in the Polaris UI, and in emails and
         webhooks.
        :paramtype description: str
        :keyword disabled: Disables the report. Polaris doesn't evaluate disabled reports or send
         notifications.
        :paramtype disabled: bool
        :keyword delivery: Defines when and how often to evaluate the report.
        :paramtype delivery: ~polaris.sdk.global_api.models.Delivery
        :keyword preferred_view: View to use when viewing the report in Polaris. Defaults to
         ``pivot1``. When supplying
         a ``facetEssence``\\ , set to ``pivot2``. When supplying an ``exploreEssence``\\ , set to
         ``explore``. Known values are: "pivot1", "pivot2", and "explore".
        :paramtype preferred_view: str or ~polaris.sdk.global_api.models.ReportPayloadPreferredView
        :keyword time_frame: Controls the amount of data Polaris considers when evaluating the report
         criteria based upon a time interval.
        :paramtype time_frame: ~polaris.sdk.global_api.models.TimeFrame
        :keyword essence: Visualization definition for classic data cubes. This is not applicable to
         Polaris.
        :paramtype essence: dict[str, any]
        :keyword facet_essence: Visualization definition for Pivot 2 data cubes.
        :paramtype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
        :keyword explore_essence: Visualization definition for data cubes of specific types, including
         overall, gauge, flat table, and time series.
         If you want to use any of these visualizations but you don't see them in Polaris, contact
         Imply support.
        :paramtype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
        :keyword admins: List of users who can modify the report.
        :paramtype admins: ~polaris.sdk.global_api.models.AccessList
        :keyword read_access: List of users who can view the report.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword recipients: List of users to receive report notifications.
        :paramtype recipients: ~polaris.sdk.global_api.models.AccessList
        :keyword external_emails: External email addresses to receive report notications.
        :paramtype external_emails: list[str]
        :keyword timezone: Timezone to use when evaluating report criteria. Defaults to ``UTC``.
        :paramtype timezone: str
        :keyword send_data_file: Sends the report data as an attachment.
        :paramtype send_data_file: bool
        :keyword add_total_row_to_file: Adds a line to the attachment that shows an overall total. You
         can't apply this
         option to JSON format attachments.
        :paramtype add_total_row_to_file: bool
        :keyword file_format: Format of the report data attachment. Defaults to ``CSV``. Known values
         are: "csv", "tsv", "xlsx", and "json".
        :paramtype file_format: str or ~polaris.sdk.global_api.models.ReportPayloadFileFormat
        :keyword download_limit: Maximum number of rows to include in the report attachment. Defaults
         to ``500``.
        :paramtype download_limit: float
        :keyword enforce_decimal_formatting: Formats numeric values in the report attachment as
         decimals.
        :paramtype enforce_decimal_formatting: bool
        :keyword send_email: Sends email notifications to the report recipients when the report is
         generated.
        :paramtype send_email: bool
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        """
        super().__init__(
            created_at=created_at,
            created_by=created_by,
            updated_at=updated_at,
            updated_by=updated_by,
            additional_properties=additional_properties,
            id=id,
            creation_date=creation_date,
            owner=owner,
            title=title,
            description=description,
            disabled=disabled,
            delivery=delivery,
            preferred_view=preferred_view,
            time_frame=time_frame,
            essence=essence,
            facet_essence=facet_essence,
            explore_essence=explore_essence,
            admins=admins,
            read_access=read_access,
            recipients=recipients,
            external_emails=external_emails,
            timezone=timezone,
            send_data_file=send_data_file,
            add_total_row_to_file=add_total_row_to_file,
            file_format=file_format,
            download_limit=download_limit,
            enforce_decimal_formatting=enforce_decimal_formatting,
            send_email=send_email,
            **kwargs
        )
        self.additional_properties = additional_properties
        self.id = id
        self.creation_date = creation_date
        self.owner = owner
        self.title = title
        self.description = description
        self.disabled = disabled
        self.delivery = delivery
        self.preferred_view = preferred_view
        self.time_frame = time_frame
        self.essence = essence
        self.facet_essence = facet_essence
        self.explore_essence = explore_essence
        self.admins = admins
        self.read_access = read_access
        self.recipients = recipients
        self.external_emails = external_emails
        self.timezone = timezone
        self.send_data_file = send_data_file
        self.add_total_row_to_file = add_total_row_to_file
        self.file_format = file_format
        self.download_limit = download_limit
        self.enforce_decimal_formatting = enforce_decimal_formatting
        self.send_email = send_email
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by


class ReportResponse(AuditRecord, ReportPayload):
    """ReportResponse.

    All required parameters must be populated in order to send to server.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar creation_date: Timestamp when the report was created.
    :vartype creation_date: ~datetime.datetime
    :ivar owner: User ID of the report owner. The owner can modify the report and its recipient
     list.
    :vartype owner: str
    :ivar title: Report title to display in the Polaris UI, and in emails and webhooks.
    :vartype title: str
    :ivar description: Report description to display in the Polaris UI, and in emails and webhooks.
    :vartype description: str
    :ivar disabled: Disables the report. Polaris doesn't evaluate disabled reports or send
     notifications.
    :vartype disabled: bool
    :ivar delivery: Defines when and how often to evaluate the report.
    :vartype delivery: ~polaris.sdk.global_api.models.Delivery
    :ivar preferred_view: View to use when viewing the report in Polaris. Defaults to ``pivot1``.
     When supplying
     a ``facetEssence``\\ , set to ``pivot2``. When supplying an ``exploreEssence``\\ , set to
     ``explore``. Known values are: "pivot1", "pivot2", and "explore".
    :vartype preferred_view: str or ~polaris.sdk.global_api.models.ReportPayloadPreferredView
    :ivar time_frame: Controls the amount of data Polaris considers when evaluating the report
     criteria based upon a time interval.
    :vartype time_frame: ~polaris.sdk.global_api.models.TimeFrame
    :ivar essence: Visualization definition for classic data cubes. This is not applicable to
     Polaris.
    :vartype essence: dict[str, any]
    :ivar facet_essence: Visualization definition for Pivot 2 data cubes.
    :vartype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
    :ivar explore_essence: Visualization definition for data cubes of specific types, including
     overall, gauge, flat table, and time series.
     If you want to use any of these visualizations but you don't see them in Polaris, contact
     Imply support.
    :vartype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
    :ivar admins: List of users who can modify the report.
    :vartype admins: ~polaris.sdk.global_api.models.AccessList
    :ivar read_access: List of users who can view the report.
    :vartype read_access: ~polaris.sdk.global_api.models.AccessList
    :ivar recipients: List of users to receive report notifications.
    :vartype recipients: ~polaris.sdk.global_api.models.AccessList
    :ivar external_emails: External email addresses to receive report notications.
    :vartype external_emails: list[str]
    :ivar timezone: Timezone to use when evaluating report criteria. Defaults to ``UTC``.
    :vartype timezone: str
    :ivar send_data_file: Sends the report data as an attachment.
    :vartype send_data_file: bool
    :ivar add_total_row_to_file: Adds a line to the attachment that shows an overall total. You
     can't apply this
     option to JSON format attachments.
    :vartype add_total_row_to_file: bool
    :ivar file_format: Format of the report data attachment. Defaults to ``CSV``. Known values are:
     "csv", "tsv", "xlsx", and "json".
    :vartype file_format: str or ~polaris.sdk.global_api.models.ReportPayloadFileFormat
    :ivar download_limit: Maximum number of rows to include in the report attachment. Defaults to
     ``500``.
    :vartype download_limit: float
    :ivar enforce_decimal_formatting: Formats numeric values in the report attachment as decimals.
    :vartype enforce_decimal_formatting: bool
    :ivar send_email: Sends email notifications to the report recipients when the report is
     generated.
    :vartype send_email: bool
    :ivar created_at: Time the asset was created. Required.
    :vartype created_at: ~datetime.datetime
    :ivar created_by: ID of the user who created the asset.
    :vartype created_by: str
    :ivar updated_at: Time the asset was last modified. Required.
    :vartype updated_at: ~datetime.datetime
    :ivar updated_by: ID of the user who last modified the asset.
    :vartype updated_by: str
    """

    _validation = {
        "id": {"max_length": 255, "min_length": 1},
        "owner": {"max_length": 255, "min_length": 1},
        "created_at": {"required": True},
        "updated_at": {"required": True},
    }

    _attribute_map = {
        "additional_properties": {"key": "", "type": "{object}"},
        "id": {"key": "id", "type": "str"},
        "creation_date": {"key": "creationDate", "type": "iso-8601"},
        "owner": {"key": "owner", "type": "str"},
        "title": {"key": "title", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "disabled": {"key": "disabled", "type": "bool"},
        "delivery": {"key": "delivery", "type": "Delivery"},
        "preferred_view": {"key": "preferredView", "type": "str"},
        "time_frame": {"key": "timeFrame", "type": "TimeFrame"},
        "essence": {"key": "essence", "type": "{object}"},
        "facet_essence": {"key": "facetEssence", "type": "FacetEssence"},
        "explore_essence": {"key": "exploreEssence", "type": "ExploreEssence"},
        "admins": {"key": "admins", "type": "AccessList"},
        "read_access": {"key": "readAccess", "type": "AccessList"},
        "recipients": {"key": "recipients", "type": "AccessList"},
        "external_emails": {"key": "externalEmails", "type": "[str]"},
        "timezone": {"key": "timezone", "type": "str"},
        "send_data_file": {"key": "sendDataFile", "type": "bool"},
        "add_total_row_to_file": {"key": "addTotalRowToFile", "type": "bool"},
        "file_format": {"key": "fileFormat", "type": "str"},
        "download_limit": {"key": "downloadLimit", "type": "float"},
        "enforce_decimal_formatting": {
            "key": "enforceDecimalFormatting",
            "type": "bool",
        },
        "send_email": {"key": "sendEmail", "type": "bool"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "created_by": {"key": "createdBy", "type": "str"},
        "updated_at": {"key": "updatedAt", "type": "iso-8601"},
        "updated_by": {"key": "updatedBy", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        created_at: datetime.datetime,
        updated_at: datetime.datetime,
        additional_properties: Optional[Dict[str, Any]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        creation_date: Optional[datetime.datetime] = None,
        owner: Optional[str] = None,
        title: Optional[str] = None,
        description: Optional[str] = None,
        disabled: Optional[bool] = None,
        delivery: Optional["_models.Delivery"] = None,
        preferred_view: Union[str, "_models.ReportPayloadPreferredView"] = "pivot1",
        time_frame: Optional["_models.TimeFrame"] = None,
        essence: Optional[Dict[str, Any]] = None,
        facet_essence: Optional["_models.FacetEssence"] = None,
        explore_essence: Optional["_models.ExploreEssence"] = None,
        admins: Optional["_models.AccessList"] = None,
        read_access: Optional["_models.AccessList"] = None,
        recipients: Optional["_models.AccessList"] = None,
        external_emails: Optional[List[str]] = None,
        timezone: str = "Etc/UTC",
        send_data_file: bool = True,
        add_total_row_to_file: bool = False,
        file_format: Union[str, "_models.ReportPayloadFileFormat"] = "csv",
        download_limit: float = 500,
        enforce_decimal_formatting: bool = False,
        send_email: Optional[bool] = None,
        created_by: Optional[str] = None,
        updated_by: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword additional_properties: Unmatched properties from the message are deserialized to this
         collection.
        :paramtype additional_properties: dict[str, any]
        :keyword id: Asset ID.
        :paramtype id: str
        :keyword creation_date: Timestamp when the report was created.
        :paramtype creation_date: ~datetime.datetime
        :keyword owner: User ID of the report owner. The owner can modify the report and its recipient
         list.
        :paramtype owner: str
        :keyword title: Report title to display in the Polaris UI, and in emails and webhooks.
        :paramtype title: str
        :keyword description: Report description to display in the Polaris UI, and in emails and
         webhooks.
        :paramtype description: str
        :keyword disabled: Disables the report. Polaris doesn't evaluate disabled reports or send
         notifications.
        :paramtype disabled: bool
        :keyword delivery: Defines when and how often to evaluate the report.
        :paramtype delivery: ~polaris.sdk.global_api.models.Delivery
        :keyword preferred_view: View to use when viewing the report in Polaris. Defaults to
         ``pivot1``. When supplying
         a ``facetEssence``\\ , set to ``pivot2``. When supplying an ``exploreEssence``\\ , set to
         ``explore``. Known values are: "pivot1", "pivot2", and "explore".
        :paramtype preferred_view: str or ~polaris.sdk.global_api.models.ReportPayloadPreferredView
        :keyword time_frame: Controls the amount of data Polaris considers when evaluating the report
         criteria based upon a time interval.
        :paramtype time_frame: ~polaris.sdk.global_api.models.TimeFrame
        :keyword essence: Visualization definition for classic data cubes. This is not applicable to
         Polaris.
        :paramtype essence: dict[str, any]
        :keyword facet_essence: Visualization definition for Pivot 2 data cubes.
        :paramtype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
        :keyword explore_essence: Visualization definition for data cubes of specific types, including
         overall, gauge, flat table, and time series.
         If you want to use any of these visualizations but you don't see them in Polaris, contact
         Imply support.
        :paramtype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
        :keyword admins: List of users who can modify the report.
        :paramtype admins: ~polaris.sdk.global_api.models.AccessList
        :keyword read_access: List of users who can view the report.
        :paramtype read_access: ~polaris.sdk.global_api.models.AccessList
        :keyword recipients: List of users to receive report notifications.
        :paramtype recipients: ~polaris.sdk.global_api.models.AccessList
        :keyword external_emails: External email addresses to receive report notications.
        :paramtype external_emails: list[str]
        :keyword timezone: Timezone to use when evaluating report criteria. Defaults to ``UTC``.
        :paramtype timezone: str
        :keyword send_data_file: Sends the report data as an attachment.
        :paramtype send_data_file: bool
        :keyword add_total_row_to_file: Adds a line to the attachment that shows an overall total. You
         can't apply this
         option to JSON format attachments.
        :paramtype add_total_row_to_file: bool
        :keyword file_format: Format of the report data attachment. Defaults to ``CSV``. Known values
         are: "csv", "tsv", "xlsx", and "json".
        :paramtype file_format: str or ~polaris.sdk.global_api.models.ReportPayloadFileFormat
        :keyword download_limit: Maximum number of rows to include in the report attachment. Defaults
         to ``500``.
        :paramtype download_limit: float
        :keyword enforce_decimal_formatting: Formats numeric values in the report attachment as
         decimals.
        :paramtype enforce_decimal_formatting: bool
        :keyword send_email: Sends email notifications to the report recipients when the report is
         generated.
        :paramtype send_email: bool
        :keyword created_at: Time the asset was created. Required.
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: ID of the user who created the asset.
        :paramtype created_by: str
        :keyword updated_at: Time the asset was last modified. Required.
        :paramtype updated_at: ~datetime.datetime
        :keyword updated_by: ID of the user who last modified the asset.
        :paramtype updated_by: str
        """
        super().__init__(
            created_at=created_at,
            created_by=created_by,
            updated_at=updated_at,
            updated_by=updated_by,
            additional_properties=additional_properties,
            id=id,
            creation_date=creation_date,
            owner=owner,
            title=title,
            description=description,
            disabled=disabled,
            delivery=delivery,
            preferred_view=preferred_view,
            time_frame=time_frame,
            essence=essence,
            facet_essence=facet_essence,
            explore_essence=explore_essence,
            admins=admins,
            read_access=read_access,
            recipients=recipients,
            external_emails=external_emails,
            timezone=timezone,
            send_data_file=send_data_file,
            add_total_row_to_file=add_total_row_to_file,
            file_format=file_format,
            download_limit=download_limit,
            enforce_decimal_formatting=enforce_decimal_formatting,
            send_email=send_email,
            **kwargs
        )
        self.additional_properties = additional_properties
        self.id = id
        self.creation_date = creation_date
        self.owner = owner
        self.title = title
        self.description = description
        self.disabled = disabled
        self.delivery = delivery
        self.preferred_view = preferred_view
        self.time_frame = time_frame
        self.essence = essence
        self.facet_essence = facet_essence
        self.explore_essence = explore_essence
        self.admins = admins
        self.read_access = read_access
        self.recipients = recipients
        self.external_emails = external_emails
        self.timezone = timezone
        self.send_data_file = send_data_file
        self.add_total_row_to_file = add_total_row_to_file
        self.file_format = file_format
        self.download_limit = download_limit
        self.enforce_decimal_formatting = enforce_decimal_formatting
        self.send_email = send_email
        self.created_at = created_at
        self.created_by = created_by
        self.updated_at = updated_at
        self.updated_by = updated_by


class RepositoryMetadata(_serialization.Model):
    """Information about the file repository itself.

    All required parameters must be populated in order to send to server.

    :ivar allocated_bytes: The total space allocated for the repository in bytes (e.g., ``usedBytes
     + remainingBytes``\\ ). Required.
    :vartype allocated_bytes: int
    :ivar used_bytes: The amount of space used by files in the repository in bytes (e.g.,
     ``allocatedBytes - remainingBytes``\\ ). Required.
    :vartype used_bytes: int
    :ivar remaining_bytes: The amount of unused space in the repository in bytes (e.g.,
     ``allocatedBytes - usedBytes``\\ ). Required.
    :vartype remaining_bytes: int
    """

    _validation = {
        "allocated_bytes": {"required": True},
        "used_bytes": {"required": True},
        "remaining_bytes": {"required": True},
    }

    _attribute_map = {
        "allocated_bytes": {"key": "allocatedBytes", "type": "int"},
        "used_bytes": {"key": "usedBytes", "type": "int"},
        "remaining_bytes": {"key": "remainingBytes", "type": "int"},
    }

    def __init__(
        self,
        *,
        allocated_bytes: int,
        used_bytes: int,
        remaining_bytes: int,
        **kwargs: Any
    ) -> None:
        """
        :keyword allocated_bytes: The total space allocated for the repository in bytes (e.g.,
         ``usedBytes + remainingBytes``\\ ). Required.
        :paramtype allocated_bytes: int
        :keyword used_bytes: The amount of space used by files in the repository in bytes (e.g.,
         ``allocatedBytes - remainingBytes``\\ ). Required.
        :paramtype used_bytes: int
        :keyword remaining_bytes: The amount of unused space in the repository in bytes (e.g.,
         ``allocatedBytes - usedBytes``\\ ). Required.
        :paramtype remaining_bytes: int
        """
        super().__init__(**kwargs)
        self.allocated_bytes = allocated_bytes
        self.used_bytes = used_bytes
        self.remaining_bytes = remaining_bytes


class RestoreDataJobResponse(JobResponse):
    """A restore data job response.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: Required. Known values are: "pending", "running", "completed", "idle",
     "canceled", "failed", "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobResponseExecutionStatus
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar spec: An abstract request to create a job. Required.
    :vartype spec: ~polaris.sdk.global_api.models.CreateJobRequest
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    :ivar interval: A single time interval in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_ describing the range of data from
     the table to restore. Required.
    :vartype interval: str
    :ivar versions: List of segment versions in the specified interval to restore or delete.
    :vartype versions: list[str]
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True, "readonly": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "spec": {"required": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
        "interval": {"required": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "spec": {"key": "spec", "type": "CreateJobRequest"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
        "interval": {"key": "interval", "type": "str"},
        "versions": {"key": "versions", "type": "[str]"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        spec: "_models.CreateJobRequest",
        target: "_models.JobTargetV2",
        interval: str,
        versions: Optional[List[str]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword spec: An abstract request to create a job. Required.
        :paramtype spec: ~polaris.sdk.global_api.models.CreateJobRequest
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        :keyword interval: A single time interval in `ISO 8601 format
         <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_ describing the range of data from
         the table to restore. Required.
        :paramtype interval: str
        :keyword versions: List of segment versions in the specified interval to restore or delete.
        :paramtype versions: list[str]
        """
        super().__init__(
            desired_execution_status=desired_execution_status,
            spec=spec,
            target=target,
            **kwargs
        )
        self.type: str = "restore_data"
        self.interval = interval
        self.versions = versions


class RestoreDataJobSummaryResponse(JobSummaryResponse):
    """A data restore job.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: The execution status of the job.


     * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
     awaiting resources.
     * ``running``   - The job is currently in progress.
     * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
     warnings or errors.
     * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
     to ingest.
     * ``canceled``  - The job was canceled by the user.
     * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
     the failure.
     * ``suspended`` - The job is suspended by the user.
     * ``unknown``   - The execution status of the job is not known. This state typically occurs
     when a downstream error prevents retrieval of the job execution status. If a job persists in
     this state for an extended period of time (more than a few minutes), please contact Imply.
     Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
     "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        execution_status: Union[str, "_models.JobExecutionStatusV2"],
        target: "_models.JobTargetV2",
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword execution_status: The execution status of the job.


         * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
         awaiting resources.
         * ``running``   - The job is currently in progress.
         * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
         warnings or errors.
         * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
         to ingest.
         * ``canceled``  - The job was canceled by the user.
         * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
         the failure.
         * ``suspended`` - The job is suspended by the user.
         * ``unknown``   - The execution status of the job is not known. This state typically occurs
         when a downstream error prevents retrieval of the job execution status. If a job persists in
         this state for an extended period of time (more than a few minutes), please contact Imply.
         Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
         "suspended", and "unknown".
        :paramtype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        """
        super().__init__(
            desired_execution_status=desired_execution_status,
            execution_status=execution_status,
            target=target,
            **kwargs
        )
        self.type: str = "restore_data"


class S3ConnectionResponse(
    ConnectionResponse,
    S3ConnectionPropertiesRequired,
    ConnectionSecretsRequiredPropertiesOptional,
):
    """An S3 bucket connection.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
    :ivar aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
    :vartype aws_assumed_role_arn: str
    :ivar aws_endpoint: The URL of the entry point for the Amazon S3 bucket.
    :vartype aws_endpoint: str
    :ivar bucket: The name of the bucket containing the desired object.
    :vartype bucket: str
    :ivar prefix: Prefix to restrict the connection to specific keys.
    :vartype prefix: str
    :ivar modified_by_user: Required.
    :vartype modified_by_user: ~polaris.sdk.global_api.models.ConnectionResponseModifiedByUser
    :ivar modified_on_timestamp: Required.
    :vartype modified_on_timestamp: str
    :ivar name: Name of the connection. A connection name can only contain ASCII letters, numbers,
     and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a connection
     name is 64. Required.
    :vartype name: str
    :ivar submitted_by_user: Required.
    :vartype submitted_by_user: ~polaris.sdk.global_api.models.ConnectionResponseSubmittedByUser
    :ivar submitted_on_timestamp: Required.
    :vartype submitted_on_timestamp: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "modified_by_user": {"required": True, "readonly": True},
        "modified_on_timestamp": {"required": True, "readonly": True},
        "name": {"required": True, "max_length": 64, "min_length": 1},
        "submitted_by_user": {"required": True, "readonly": True},
        "submitted_on_timestamp": {"required": True, "readonly": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsRequiredPayload"},
        "aws_assumed_role_arn": {"key": "awsAssumedRoleArn", "type": "str"},
        "aws_endpoint": {"key": "awsEndpoint", "type": "str"},
        "bucket": {"key": "bucket", "type": "str"},
        "prefix": {"key": "prefix", "type": "str"},
        "modified_by_user": {
            "key": "modifiedByUser",
            "type": "ConnectionResponseModifiedByUser",
        },
        "modified_on_timestamp": {"key": "modifiedOnTimestamp", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "submitted_by_user": {
            "key": "submittedByUser",
            "type": "ConnectionResponseSubmittedByUser",
        },
        "submitted_on_timestamp": {"key": "submittedOnTimestamp", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        secrets: Optional["_models.ConnectionSecretsRequiredPayload"] = None,
        aws_assumed_role_arn: Optional[str] = None,
        aws_endpoint: Optional[str] = None,
        bucket: Optional[str] = None,
        prefix: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : AWS IAM role assumption. Supported for Kafka (MSK) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsRequiredPayload
        :keyword aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
        :paramtype aws_assumed_role_arn: str
        :keyword aws_endpoint: The URL of the entry point for the Amazon S3 bucket.
        :paramtype aws_endpoint: str
        :keyword bucket: The name of the bucket containing the desired object.
        :paramtype bucket: str
        :keyword prefix: Prefix to restrict the connection to specific keys.
        :paramtype prefix: str
        :keyword name: Name of the connection. A connection name can only contain ASCII letters,
         numbers, and the following characters: ``.``\\ , ``_``\\ , ``-``. The maximum length of a
         connection name is 64. Required.
        :paramtype name: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            name=name,
            description=description,
            aws_assumed_role_arn=aws_assumed_role_arn,
            aws_endpoint=aws_endpoint,
            bucket=bucket,
            prefix=prefix,
            secrets=secrets,
            **kwargs
        )
        self.secrets = secrets
        self.aws_assumed_role_arn = aws_assumed_role_arn
        self.aws_endpoint = aws_endpoint
        self.bucket = bucket
        self.prefix = prefix
        self.type: str = "s3"
        self.modified_by_user = None
        self.modified_on_timestamp = None
        self.name = name
        self.submitted_by_user = None
        self.submitted_on_timestamp = None
        self.description = description


class S3JobSourceSummary(JobSourceSummary):
    """A summary of an S3 source input.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    :ivar connection_name: Name of the connection to ingest from. Required.
    :vartype connection_name: str
    """

    _validation = {
        "type": {"required": True},
        "connection_name": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "connection_name": {"key": "connectionName", "type": "str"},
    }

    def __init__(self, *, connection_name: str, **kwargs: Any) -> None:
        """
        :keyword connection_name: Name of the connection to ingest from. Required.
        :paramtype connection_name: str
        """
        super().__init__(**kwargs)
        self.type: str = "s3"
        self.connection_name = connection_name


class S3JobSourceV2(JobSourceV2):
    """An S3 source input. Designate one of ``uris``\\ , ``prefixes``\\ , ``objects``\\ , or
    ``pattern`` for the data to ingest.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    :ivar connection_name: Name of the connection to ingest from. Required.
    :vartype connection_name: str
    :ivar input_schema: The schema of input data in terms of a list of input field names and their
     respective data types. Required.
    :vartype input_schema: list[~polaris.sdk.global_api.models.FieldNameAndDataType]
    :ivar format_settings: Data format settings that apply to all files in the ingestion job.
     Polaris automatically detects the file type based on the file extension. If you specify a value
     that does not match the automatically detected type, Polaris attempts to ingest based on the
     user-specified value.
    :vartype format_settings: ~polaris.sdk.global_api.models.DataFormatSettings
    :ivar objects: JSON array of S3 objects to ingest from the connection.
    :vartype objects: list[str]
    :ivar pattern: Glob pattern matching against the names of S3 buckets and folders. Polaris will
     ingest objects that match the pattern.
    :vartype pattern: str
    :ivar prefixes: JSON array of S3 object prefixes. Polaris will ingest everything with the
     specified prefixes aside from empty objects.
    :vartype prefixes: list[str]
    :ivar uris: JSON array of URIs of S3 objects to ingest.
    :vartype uris: list[str]
    """

    _validation = {
        "type": {"required": True},
        "connection_name": {"required": True},
        "input_schema": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "connection_name": {"key": "connectionName", "type": "str"},
        "input_schema": {"key": "inputSchema", "type": "[FieldNameAndDataType]"},
        "format_settings": {"key": "formatSettings", "type": "DataFormatSettings"},
        "objects": {"key": "objects", "type": "[str]"},
        "pattern": {"key": "pattern", "type": "str"},
        "prefixes": {"key": "prefixes", "type": "[str]"},
        "uris": {"key": "uris", "type": "[str]"},
    }

    def __init__(
        self,
        *,
        connection_name: str,
        input_schema: List["_models.FieldNameAndDataType"] = [],
        format_settings: Optional["_models.DataFormatSettings"] = None,
        objects: Optional[List[str]] = None,
        pattern: Optional[str] = None,
        prefixes: Optional[List[str]] = None,
        uris: Optional[List[str]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword connection_name: Name of the connection to ingest from. Required.
        :paramtype connection_name: str
        :keyword input_schema: The schema of input data in terms of a list of input field names and
         their respective data types. Required.
        :paramtype input_schema: list[~polaris.sdk.global_api.models.FieldNameAndDataType]
        :keyword format_settings: Data format settings that apply to all files in the ingestion job.
         Polaris automatically detects the file type based on the file extension. If you specify a value
         that does not match the automatically detected type, Polaris attempts to ingest based on the
         user-specified value.
        :paramtype format_settings: ~polaris.sdk.global_api.models.DataFormatSettings
        :keyword objects: JSON array of S3 objects to ingest from the connection.
        :paramtype objects: list[str]
        :keyword pattern: Glob pattern matching against the names of S3 buckets and folders. Polaris
         will ingest objects that match the pattern.
        :paramtype pattern: str
        :keyword prefixes: JSON array of S3 object prefixes. Polaris will ingest everything with the
         specified prefixes aside from empty objects.
        :paramtype prefixes: list[str]
        :keyword uris: JSON array of URIs of S3 objects to ingest.
        :paramtype uris: list[str]
        """
        super().__init__(**kwargs)
        self.type: str = "s3"
        self.connection_name = connection_name
        self.input_schema = input_schema
        self.format_settings = format_settings
        self.objects = objects
        self.pattern = pattern
        self.prefixes = prefixes
        self.uris = uris


class Sankey(_serialization.Model):
    """Sankey.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "sankey"
    :vartype type: str or ~polaris.sdk.global_api.models.SankeyType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar left: Dimensions to be shown on the left. Required.
    :vartype left: list[any]
    :ivar right: Dimensions to be shown on the right. Required.
    :vartype right: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "left": {"required": True, "max_items": 1, "min_items": 1},
        "right": {"required": True, "max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "left": {"key": "left", "type": "[object]"},
        "right": {"key": "right", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        left: List[Any],
        right: List[Any],
        type: Optional[Union[str, "_models.SankeyType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "sankey"
        :paramtype type: str or ~polaris.sdk.global_api.models.SankeyType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword left: Dimensions to be shown on the left. Required.
        :paramtype left: list[any]
        :keyword right: Dimensions to be shown on the right. Required.
        :paramtype right: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.left = left
        self.right = right


class SaslPlainSecretsProperties(_serialization.Model):
    """Properties specific to SASL/PLAIN secrets.

    :ivar username: Username of the account to use for authentication.
    :vartype username: str
    :ivar password: Password of the account to use for authentication.
    :vartype password: str
    """

    _attribute_map = {
        "username": {"key": "username", "type": "str"},
        "password": {"key": "password", "type": "str"},
    }

    def __init__(
        self,
        *,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword username: Username of the account to use for authentication.
        :paramtype username: str
        :keyword password: Password of the account to use for authentication.
        :paramtype password: str
        """
        super().__init__(**kwargs)
        self.username = username
        self.password = password


class SaslPlainSecretsOptionalPayload(
    ConnectionSecretsOptionalPayload, SaslPlainSecretsProperties
):
    """Configuration and credentials for SASL/PLAIN authentication.

    All required parameters must be populated in order to send to server.

    :ivar username: Username of the account to use for authentication.
    :vartype username: str
    :ivar password: Password of the account to use for authentication.
    :vartype password: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "username": {"key": "username", "type": "str"},
        "password": {"key": "password", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self,
        *,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword username: Username of the account to use for authentication.
        :paramtype username: str
        :keyword password: Password of the account to use for authentication.
        :paramtype password: str
        """
        super().__init__(username=username, password=password, **kwargs)
        self.username = username
        self.password = password
        self.type: str = "sasl_plain"


class SaslPlainSecretsPropertiesRequired(SaslPlainSecretsProperties):
    """SaslPlainSecretsPropertiesRequired.

    :ivar username: Username of the account to use for authentication.
    :vartype username: str
    :ivar password: Password of the account to use for authentication.
    :vartype password: str
    """


class SaslPlainSecretsRequiredPayload(
    ConnectionSecretsRequiredPayload, SaslPlainSecretsPropertiesRequired
):
    """Configuration and credentials for SASL/PLAIN authentication.

    All required parameters must be populated in order to send to server.

    :ivar username: Username of the account to use for authentication.
    :vartype username: str
    :ivar password: Password of the account to use for authentication.
    :vartype password: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "username": {"key": "username", "type": "str"},
        "password": {"key": "password", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self,
        *,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword username: Username of the account to use for authentication.
        :paramtype username: str
        :keyword password: Password of the account to use for authentication.
        :paramtype password: str
        """
        super().__init__(username=username, password=password, **kwargs)
        self.username = username
        self.password = password
        self.type: str = "sasl_plain"


class SaslScramSecretsProperties(_serialization.Model):
    """Properties specific to SASL/SCRAM secrets.

    :ivar mechanism: The SASL/SCRAM mechanism to use:


     * ``SCRAM-SHA-256`` to use the SHA-256 algorithm.
     * ``SCRAM-SHA-512`` to use the SHA-512 algorithm.

     The specified mechanism must be included in ``sasl.enabled.mechanisms`` in the Kafka cluster's
     configuration. Known values are: "SCRAM-SHA-256" and "SCRAM-SHA-512".
    :vartype mechanism: str or ~polaris.sdk.global_api.models.SaslScramMechanismPayload
    :ivar username: Username of the account to use for authentication.
    :vartype username: str
    :ivar password: Password of the account to use for authentication.
    :vartype password: str
    """

    _attribute_map = {
        "mechanism": {"key": "mechanism", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "password": {"key": "password", "type": "str"},
    }

    def __init__(
        self,
        *,
        mechanism: Optional[Union[str, "_models.SaslScramMechanismPayload"]] = None,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword mechanism: The SASL/SCRAM mechanism to use:


         * ``SCRAM-SHA-256`` to use the SHA-256 algorithm.
         * ``SCRAM-SHA-512`` to use the SHA-512 algorithm.

         The specified mechanism must be included in ``sasl.enabled.mechanisms`` in the Kafka cluster's
         configuration. Known values are: "SCRAM-SHA-256" and "SCRAM-SHA-512".
        :paramtype mechanism: str or ~polaris.sdk.global_api.models.SaslScramMechanismPayload
        :keyword username: Username of the account to use for authentication.
        :paramtype username: str
        :keyword password: Password of the account to use for authentication.
        :paramtype password: str
        """
        super().__init__(**kwargs)
        self.mechanism = mechanism
        self.username = username
        self.password = password


class SaslScramSecretsOptionalPayload(
    ConnectionSecretsOptionalPayload, SaslScramSecretsProperties
):
    """Configuration and credentials for SASL/SCRAM authentication.

    All required parameters must be populated in order to send to server.

    :ivar mechanism: The SASL/SCRAM mechanism to use:


     * ``SCRAM-SHA-256`` to use the SHA-256 algorithm.
     * ``SCRAM-SHA-512`` to use the SHA-512 algorithm.

     The specified mechanism must be included in ``sasl.enabled.mechanisms`` in the Kafka cluster's
     configuration. Known values are: "SCRAM-SHA-256" and "SCRAM-SHA-512".
    :vartype mechanism: str or ~polaris.sdk.global_api.models.SaslScramMechanismPayload
    :ivar username: Username of the account to use for authentication.
    :vartype username: str
    :ivar password: Password of the account to use for authentication.
    :vartype password: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "mechanism": {"key": "mechanism", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "password": {"key": "password", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self,
        *,
        mechanism: Optional[Union[str, "_models.SaslScramMechanismPayload"]] = None,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword mechanism: The SASL/SCRAM mechanism to use:


         * ``SCRAM-SHA-256`` to use the SHA-256 algorithm.
         * ``SCRAM-SHA-512`` to use the SHA-512 algorithm.

         The specified mechanism must be included in ``sasl.enabled.mechanisms`` in the Kafka cluster's
         configuration. Known values are: "SCRAM-SHA-256" and "SCRAM-SHA-512".
        :paramtype mechanism: str or ~polaris.sdk.global_api.models.SaslScramMechanismPayload
        :keyword username: Username of the account to use for authentication.
        :paramtype username: str
        :keyword password: Password of the account to use for authentication.
        :paramtype password: str
        """
        super().__init__(
            mechanism=mechanism, username=username, password=password, **kwargs
        )
        self.mechanism = mechanism
        self.username = username
        self.password = password
        self.type: str = "sasl_scram"


class SaslScramSecretsPropertiesRequired(SaslScramSecretsProperties):
    """SaslScramSecretsPropertiesRequired.

    :ivar mechanism: The SASL/SCRAM mechanism to use:


     * ``SCRAM-SHA-256`` to use the SHA-256 algorithm.
     * ``SCRAM-SHA-512`` to use the SHA-512 algorithm.

     The specified mechanism must be included in ``sasl.enabled.mechanisms`` in the Kafka cluster's
     configuration. Known values are: "SCRAM-SHA-256" and "SCRAM-SHA-512".
    :vartype mechanism: str or ~polaris.sdk.global_api.models.SaslScramMechanismPayload
    :ivar username: Username of the account to use for authentication.
    :vartype username: str
    :ivar password: Password of the account to use for authentication.
    :vartype password: str
    """


class SaslScramSecretsRequiredPayload(
    ConnectionSecretsRequiredPayload, SaslScramSecretsPropertiesRequired
):
    """Configuration and credentials for SASL/SCRAM authentication.

    All required parameters must be populated in order to send to server.

    :ivar mechanism: The SASL/SCRAM mechanism to use:


     * ``SCRAM-SHA-256`` to use the SHA-256 algorithm.
     * ``SCRAM-SHA-512`` to use the SHA-512 algorithm.

     The specified mechanism must be included in ``sasl.enabled.mechanisms`` in the Kafka cluster's
     configuration. Known values are: "SCRAM-SHA-256" and "SCRAM-SHA-512".
    :vartype mechanism: str or ~polaris.sdk.global_api.models.SaslScramMechanismPayload
    :ivar username: Username of the account to use for authentication.
    :vartype username: str
    :ivar password: Password of the account to use for authentication.
    :vartype password: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "mechanism": {"key": "mechanism", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "password": {"key": "password", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(
        self,
        *,
        mechanism: Optional[Union[str, "_models.SaslScramMechanismPayload"]] = None,
        username: Optional[str] = None,
        password: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword mechanism: The SASL/SCRAM mechanism to use:


         * ``SCRAM-SHA-256`` to use the SHA-256 algorithm.
         * ``SCRAM-SHA-512`` to use the SHA-512 algorithm.

         The specified mechanism must be included in ``sasl.enabled.mechanisms`` in the Kafka cluster's
         configuration. Known values are: "SCRAM-SHA-256" and "SCRAM-SHA-512".
        :paramtype mechanism: str or ~polaris.sdk.global_api.models.SaslScramMechanismPayload
        :keyword username: Username of the account to use for authentication.
        :paramtype username: str
        :keyword password: Password of the account to use for authentication.
        :paramtype password: str
        """
        super().__init__(
            mechanism=mechanism, username=username, password=password, **kwargs
        )
        self.mechanism = mechanism
        self.username = username
        self.password = password
        self.type: str = "sasl_scram"


class SasTokenSecretsProperties(_serialization.Model):
    """Properties specific to Azure SAS token secrets.

    :ivar sas_token: SAS token for your Azure Blob storage account.
    :vartype sas_token: str
    """

    _attribute_map = {
        "sas_token": {"key": "sasToken", "type": "str"},
    }

    def __init__(self, *, sas_token: Optional[str] = None, **kwargs: Any) -> None:
        """
        :keyword sas_token: SAS token for your Azure Blob storage account.
        :paramtype sas_token: str
        """
        super().__init__(**kwargs)
        self.sas_token = sas_token


class SasTokenSecretsOptionalPayload(
    ConnectionSecretsOptionalPayload, SasTokenSecretsProperties
):
    """Configuration and credentials for SAS token authentication.

    All required parameters must be populated in order to send to server.

    :ivar sas_token: SAS token for your Azure Blob storage account.
    :vartype sas_token: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "sas_token": {"key": "sasToken", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(self, *, sas_token: Optional[str] = None, **kwargs: Any) -> None:
        """
        :keyword sas_token: SAS token for your Azure Blob storage account.
        :paramtype sas_token: str
        """
        super().__init__(sas_token=sas_token, **kwargs)
        self.sas_token = sas_token
        self.type: str = "sas_token"


class SasTokenSecretsPropertiesRequired(SasTokenSecretsProperties):
    """SasTokenSecretsPropertiesRequired.

    :ivar sas_token: SAS token for your Azure Blob storage account.
    :vartype sas_token: str
    """


class SasTokenSecretsRequiredPayload(
    ConnectionSecretsRequiredPayload, SasTokenSecretsPropertiesRequired
):
    """Configuration and credentials for SAS token authentication.

    All required parameters must be populated in order to send to server.

    :ivar sas_token: SAS token for your Azure Blob storage account.
    :vartype sas_token: str
    :ivar type: Required. Known values are: "access_key", "aws_iam", "basic", "confluent",
     "sas_token", "sasl_plain", and "sasl_scram".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionSecretsTypePayload
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "sas_token": {"key": "sasToken", "type": "str"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(self, *, sas_token: Optional[str] = None, **kwargs: Any) -> None:
        """
        :keyword sas_token: SAS token for your Azure Blob storage account.
        :paramtype sas_token: str
        """
        super().__init__(sas_token=sas_token, **kwargs)
        self.sas_token = sas_token
        self.type: str = "sas_token"


class SegmentMetadataListResponse(_serialization.Model):
    """A list of segment metadata response objects.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.SegmentMetadataResponse]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[SegmentMetadataResponse]"},
    }

    def __init__(
        self, *, values: List["_models.SegmentMetadataResponse"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.SegmentMetadataResponse]
        """
        super().__init__(**kwargs)
        self.values = values


class SegmentMetadataResponse(_serialization.Model):
    """Metadata about a segment.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_on_timestamp: The date and time this object was created in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_on_timestamp: ~datetime.datetime
    :ivar last_updated_on_timestamp: The date and time this segment was last updated in `ISO 8601
     format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
     If the segment is an unused segment, this time represents the time that the segment was
     soft-deleted.
    :vartype last_updated_on_timestamp: ~datetime.datetime
    :ivar id: The unique identifier of a segment. Required.
    :vartype id: str
    :ivar interval: A single time interval in ISO 8601 format. Required.
    :vartype interval: str
    :ivar partition_number: The partition number of the segment. Required.
    :vartype partition_number: int
    :ivar size_bytes: The total size of the segment in bytes. Required.
    :vartype size_bytes: int
    :ivar table_name: The unique, immutable name of the table. Required.
    :vartype table_name: str
    :ivar version: The version of the segment. Required.
    :vartype version: str
    """

    _validation = {
        "created_on_timestamp": {"required": True, "readonly": True},
        "last_updated_on_timestamp": {"readonly": True},
        "id": {"required": True},
        "interval": {"required": True},
        "partition_number": {"required": True},
        "size_bytes": {"required": True},
        "table_name": {"required": True, "max_length": 255, "min_length": 1},
        "version": {"required": True},
    }

    _attribute_map = {
        "created_on_timestamp": {"key": "createdOnTimestamp", "type": "iso-8601"},
        "last_updated_on_timestamp": {
            "key": "lastUpdatedOnTimestamp",
            "type": "iso-8601",
        },
        "id": {"key": "id", "type": "str"},
        "interval": {"key": "interval", "type": "str"},
        "partition_number": {"key": "partitionNumber", "type": "int"},
        "size_bytes": {"key": "sizeBytes", "type": "int"},
        "table_name": {"key": "tableName", "type": "str"},
        "version": {"key": "version", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        interval: str,
        partition_number: int,
        size_bytes: int,
        table_name: str,
        version: str,
        **kwargs: Any
    ) -> None:
        """
        :keyword id: The unique identifier of a segment. Required.
        :paramtype id: str
        :keyword interval: A single time interval in ISO 8601 format. Required.
        :paramtype interval: str
        :keyword partition_number: The partition number of the segment. Required.
        :paramtype partition_number: int
        :keyword size_bytes: The total size of the segment in bytes. Required.
        :paramtype size_bytes: int
        :keyword table_name: The unique, immutable name of the table. Required.
        :paramtype table_name: str
        :keyword version: The version of the segment. Required.
        :paramtype version: str
        """
        super().__init__(**kwargs)
        self.created_on_timestamp = None
        self.last_updated_on_timestamp = None
        self.id = id
        self.interval = interval
        self.partition_number = partition_number
        self.size_bytes = size_bytes
        self.table_name = table_name
        self.version = version


class SimpleGranularityPayload(GranularityPayload):
    """Simple granularity such as ``millisecond`` or ``hour``.

    All required parameters must be populated in order to send to server.

    :ivar type: The type of granularity.


     * ``simple``\\ - Simple granularity such as ``millisecond`` or ``hour``.
     * ``period``\\ - Period-based granularity that accepts an ISO 8601 period such as ``P6M``.
     Allows specification of time zone and origin. Required. Known values are: "simple" and
     "period".
    :vartype type: str or ~polaris.sdk.global_api.models.GranularityType
    :ivar granularity: The table's rollup granularity. See `Introduction to data rollup
     <https://docs.imply.io/ui/saas/help/rollup.html>`_ for more details.

     You can specify a variable duration or a time zone and origin for a ``period``\\ -type query
     granularity.
     When set, ``queryGranularity`` overrides the rollup granularity in ``timeResolution``. Known
     values are: "millisecond", "second", "minute", "fifteen_minute", "thirty_minute", "hour",
     "day", "week", "month", "quarter", "year", and "all".
    :vartype granularity: str or ~polaris.sdk.global_api.models.TimeResolution
    """

    _validation = {
        "type": {"required": True},
        "granularity": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "granularity": {"key": "granularity", "type": "str"},
    }

    def __init__(
        self,
        *,
        granularity: Union[str, "_models.TimeResolution"] = "millisecond",
        **kwargs: Any
    ) -> None:
        """
        :keyword granularity: The table's rollup granularity. See `Introduction to data rollup
         <https://docs.imply.io/ui/saas/help/rollup.html>`_ for more details.

         You can specify a variable duration or a time zone and origin for a ``period``\\ -type query
         granularity.
         When set, ``queryGranularity`` overrides the rollup granularity in ``timeResolution``. Known
         values are: "millisecond", "second", "minute", "fifteen_minute", "thirty_minute", "hour",
         "day", "week", "month", "quarter", "year", and "all".
        :paramtype granularity: str or ~polaris.sdk.global_api.models.TimeResolution
        """
        super().__init__(**kwargs)
        self.type: str = "simple"
        self.granularity = granularity


class SingleAccessList(_serialization.Model):
    """Single-user or single-role access control list for the asset.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar access: Required. "single"
    :vartype access: str or ~polaris.sdk.global_api.models.SingleAccessListAccess
    :ivar users: List of user IDs with access to the asset.
    :vartype users: list[str]
    :ivar roles: List of role IDs with access to the asset.
    :vartype roles: list[str]
    """

    _validation = {
        "access": {"required": True},
        "users": {"readonly": True},
        "roles": {"readonly": True},
    }

    _attribute_map = {
        "access": {"key": "access", "type": "str"},
        "users": {"key": "users", "type": "[str]"},
        "roles": {"key": "roles", "type": "[str]"},
    }

    def __init__(
        self, *, access: Union[str, "_models.SingleAccessListAccess"], **kwargs: Any
    ) -> None:
        """
        :keyword access: Required. "single"
        :paramtype access: str or ~polaris.sdk.global_api.models.SingleAccessListAccess
        """
        super().__init__(**kwargs)
        self.access = access
        self.users = None
        self.roles = None


class SparkLine(_serialization.Model):
    """SparkLine.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "spark-line"
    :vartype type: str or ~polaris.sdk.global_api.models.SparkLineType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar line: Dimensions to be shown by the line. Required.
    :vartype line: list[any]
    :ivar rows: Dimensions to be displayed in the rows.
    :vartype rows: list[any]
    :ivar columns: Dimensions to be displayed in the columns.
    :vartype columns: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "line": {"required": True, "max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "line": {"key": "line", "type": "[object]"},
        "rows": {"key": "rows", "type": "[object]"},
        "columns": {"key": "columns", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        line: List[Any],
        type: Optional[Union[str, "_models.SparkLineType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        rows: Optional[List[Any]] = None,
        columns: Optional[List[Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "spark-line"
        :paramtype type: str or ~polaris.sdk.global_api.models.SparkLineType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword line: Dimensions to be shown by the line. Required.
        :paramtype line: list[any]
        :keyword rows: Dimensions to be displayed in the rows.
        :paramtype rows: list[any]
        :keyword columns: Dimensions to be displayed in the columns.
        :paramtype columns: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.line = line
        self.rows = rows
        self.columns = columns


class SpecificAccessList(_serialization.Model):
    """Multi-user/role access control list for the asset.

    All required parameters must be populated in order to send to server.

    :ivar access: Required. "specific"
    :vartype access: str or ~polaris.sdk.global_api.models.SpecificAccessListAccess
    :ivar users: List of user IDs with access to the asset.
    :vartype users: list[str]
    :ivar roles: List of role IDs with access to the asset.
    :vartype roles: list[str]
    """

    _validation = {
        "access": {"required": True},
    }

    _attribute_map = {
        "access": {"key": "access", "type": "str"},
        "users": {"key": "users", "type": "[str]"},
        "roles": {"key": "roles", "type": "[str]"},
    }

    def __init__(
        self,
        *,
        access: Union[str, "_models.SpecificAccessListAccess"],
        users: Optional[List[str]] = None,
        roles: Optional[List[str]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword access: Required. "specific"
        :paramtype access: str or ~polaris.sdk.global_api.models.SpecificAccessListAccess
        :keyword users: List of user IDs with access to the asset.
        :paramtype users: list[str]
        :keyword roles: List of role IDs with access to the asset.
        :paramtype roles: list[str]
        """
        super().__init__(**kwargs)
        self.access = access
        self.users = users
        self.roles = roles


class SplitCombineFull(_serialization.Model):
    """SplitCombineFull.

    All required parameters must be populated in order to send to server.

    :ivar dimension: ID of the dimension to split on. Required.
    :vartype dimension: str
    :ivar bucket_action: Dictionary of :code:`<any>`.
    :vartype bucket_action: dict[str, any]
    :ivar sort_type: Sort type for a split combine. Known values are: "dimension", "measure",
     "measure-delta", "measure-percent-delta", "measure-absolute-delta", and
     "measure-absolute-percent-delta".
    :vartype sort_type: str or ~polaris.sdk.global_api.models.SplitCombineSortType
    :ivar sort_measure: ID of the measure to sort on.
    :vartype sort_measure: str
    :ivar direction: Sort direction for a split combine. Known values are: "ascending" and
     "descending".
    :vartype direction: str or ~polaris.sdk.global_api.models.SplitCombineSortDirection
    :ivar limit: The maximum number of buckets to return.
    :vartype limit: int
    :ivar having_values: A set of values.
    :vartype having_values: ~polaris.sdk.global_api.models.PlywoodSet
    :ivar possible_having_values: A set of values.
    :vartype possible_having_values: ~polaris.sdk.global_api.models.PlywoodSet
    :ivar total_mode: Whether a field should be shown or hidden. Known values are: "show" and
     "hide".
    :vartype total_mode: str or ~polaris.sdk.global_api.models.Visibility
    :ivar others_mode: Whether a field should be shown or hidden. Known values are: "show" and
     "hide".
    :vartype others_mode: str or ~polaris.sdk.global_api.models.Visibility
    :ivar mv_filter_only_values: A set of values.
    :vartype mv_filter_only_values: ~polaris.sdk.global_api.models.PlywoodSet
    :ivar fill_empty_buckets: Whether to fill empty buckets with a default value.
    :vartype fill_empty_buckets: bool
    """

    _validation = {
        "dimension": {"required": True},
    }

    _attribute_map = {
        "dimension": {"key": "dimension", "type": "str"},
        "bucket_action": {"key": "bucketAction", "type": "{object}"},
        "sort_type": {"key": "sortType", "type": "str"},
        "sort_measure": {"key": "sortMeasure", "type": "str"},
        "direction": {"key": "direction", "type": "str"},
        "limit": {"key": "limit", "type": "int"},
        "having_values": {"key": "havingValues", "type": "PlywoodSet"},
        "possible_having_values": {"key": "possibleHavingValues", "type": "PlywoodSet"},
        "total_mode": {"key": "totalMode", "type": "str"},
        "others_mode": {"key": "othersMode", "type": "str"},
        "mv_filter_only_values": {"key": "mvFilterOnlyValues", "type": "PlywoodSet"},
        "fill_empty_buckets": {"key": "fillEmptyBuckets", "type": "bool"},
    }

    def __init__(
        self,
        *,
        dimension: str,
        bucket_action: Optional[Dict[str, Any]] = None,
        sort_type: Optional[Union[str, "_models.SplitCombineSortType"]] = None,
        sort_measure: Optional[str] = None,
        direction: Optional[Union[str, "_models.SplitCombineSortDirection"]] = None,
        limit: Optional[int] = None,
        having_values: Optional["_models.PlywoodSet"] = None,
        possible_having_values: Optional["_models.PlywoodSet"] = None,
        total_mode: Optional[Union[str, "_models.Visibility"]] = None,
        others_mode: Optional[Union[str, "_models.Visibility"]] = None,
        mv_filter_only_values: Optional["_models.PlywoodSet"] = None,
        fill_empty_buckets: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword dimension: ID of the dimension to split on. Required.
        :paramtype dimension: str
        :keyword bucket_action: Dictionary of :code:`<any>`.
        :paramtype bucket_action: dict[str, any]
        :keyword sort_type: Sort type for a split combine. Known values are: "dimension", "measure",
         "measure-delta", "measure-percent-delta", "measure-absolute-delta", and
         "measure-absolute-percent-delta".
        :paramtype sort_type: str or ~polaris.sdk.global_api.models.SplitCombineSortType
        :keyword sort_measure: ID of the measure to sort on.
        :paramtype sort_measure: str
        :keyword direction: Sort direction for a split combine. Known values are: "ascending" and
         "descending".
        :paramtype direction: str or ~polaris.sdk.global_api.models.SplitCombineSortDirection
        :keyword limit: The maximum number of buckets to return.
        :paramtype limit: int
        :keyword having_values: A set of values.
        :paramtype having_values: ~polaris.sdk.global_api.models.PlywoodSet
        :keyword possible_having_values: A set of values.
        :paramtype possible_having_values: ~polaris.sdk.global_api.models.PlywoodSet
        :keyword total_mode: Whether a field should be shown or hidden. Known values are: "show" and
         "hide".
        :paramtype total_mode: str or ~polaris.sdk.global_api.models.Visibility
        :keyword others_mode: Whether a field should be shown or hidden. Known values are: "show" and
         "hide".
        :paramtype others_mode: str or ~polaris.sdk.global_api.models.Visibility
        :keyword mv_filter_only_values: A set of values.
        :paramtype mv_filter_only_values: ~polaris.sdk.global_api.models.PlywoodSet
        :keyword fill_empty_buckets: Whether to fill empty buckets with a default value.
        :paramtype fill_empty_buckets: bool
        """
        super().__init__(**kwargs)
        self.dimension = dimension
        self.bucket_action = bucket_action
        self.sort_type = sort_type
        self.sort_measure = sort_measure
        self.direction = direction
        self.limit = limit
        self.having_values = having_values
        self.possible_having_values = possible_having_values
        self.total_mode = total_mode
        self.others_mode = others_mode
        self.mv_filter_only_values = mv_filter_only_values
        self.fill_empty_buckets = fill_empty_buckets


class SpotMatrix(_serialization.Model):
    """SpotMatrix.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "spot-matrix"
    :vartype type: str or ~polaris.sdk.global_api.models.SpotMatrixType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar rows: Dimensions to be displayed in the rows. Required.
    :vartype rows: list[any]
    :ivar columns: Dimensions to be displayed in the columns.
    :vartype columns: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "rows": {"required": True, "max_items": 1, "min_items": 1},
        "columns": {"max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "rows": {"key": "rows", "type": "[object]"},
        "columns": {"key": "columns", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        rows: List[Any],
        type: Optional[Union[str, "_models.SpotMatrixType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        columns: Optional[List[Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "spot-matrix"
        :paramtype type: str or ~polaris.sdk.global_api.models.SpotMatrixType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword rows: Dimensions to be displayed in the rows. Required.
        :paramtype rows: list[any]
        :keyword columns: Dimensions to be displayed in the columns.
        :paramtype columns: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.rows = rows
        self.columns = columns


class SqlErrorResponse(_serialization.Model):
    """SqlErrorResponse.

    :ivar error: Summary of the encountered error.
    :vartype error: str
    :ivar error_code: Well-defined error code.
    :vartype error_code: str
    :ivar persona: Role or persona associated with the error.
    :vartype persona: str
    :ivar category: Classification of the error. Known values are: "DEFENSIVE", "INVALID_INPUT",
     "UNAUTHORIZED", "FORBIDDEN", "CAPACITY_EXCEEDED", "CANCELED", "RUNTIME_FAILURE", "TIMEOUT",
     "UNSUPPORTED", and "UNCATEGORIZED".
    :vartype category: str or ~polaris.sdk.global_api.models.SqlErrorResponseCategory
    :ivar error_message: Summary of the encountered issue with expanded information.
    :vartype error_message: str
    :ivar context: Additional context about the error.
    :vartype context: JSON
    """

    _attribute_map = {
        "error": {"key": "error", "type": "str"},
        "error_code": {"key": "errorCode", "type": "str"},
        "persona": {"key": "persona", "type": "str"},
        "category": {"key": "category", "type": "str"},
        "error_message": {"key": "errorMessage", "type": "str"},
        "context": {"key": "context", "type": "object"},
    }

    def __init__(
        self,
        *,
        error: Optional[str] = None,
        error_code: Optional[str] = None,
        persona: Optional[str] = None,
        category: Optional[Union[str, "_models.SqlErrorResponseCategory"]] = None,
        error_message: Optional[str] = None,
        context: Optional[JSON] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword error: Summary of the encountered error.
        :paramtype error: str
        :keyword error_code: Well-defined error code.
        :paramtype error_code: str
        :keyword persona: Role or persona associated with the error.
        :paramtype persona: str
        :keyword category: Classification of the error. Known values are: "DEFENSIVE", "INVALID_INPUT",
         "UNAUTHORIZED", "FORBIDDEN", "CAPACITY_EXCEEDED", "CANCELED", "RUNTIME_FAILURE", "TIMEOUT",
         "UNSUPPORTED", and "UNCATEGORIZED".
        :paramtype category: str or ~polaris.sdk.global_api.models.SqlErrorResponseCategory
        :keyword error_message: Summary of the encountered issue with expanded information.
        :paramtype error_message: str
        :keyword context: Additional context about the error.
        :paramtype context: JSON
        """
        super().__init__(**kwargs)
        self.error = error
        self.error_code = error_code
        self.persona = persona
        self.category = category
        self.error_message = error_message
        self.context = context


class SqlErrorResponseWrapper(_serialization.Model):
    """SqlErrorResponseWrapper.

    :ivar task_id: The server-generated ID of the Druid task.
    :vartype task_id: str
    :ivar state: State of the query. Known values are: "ACCEPTED", "RUNNING", "FAILED", and
     "SUCCESS".
    :vartype state: str or ~polaris.sdk.global_api.models.SqlState
    :ivar error:
    :vartype error: ~polaris.sdk.global_api.models.SqlErrorResponse
    """

    _attribute_map = {
        "task_id": {"key": "taskId", "type": "str"},
        "state": {"key": "state", "type": "str"},
        "error": {"key": "error", "type": "SqlErrorResponse"},
    }

    def __init__(
        self,
        *,
        task_id: Optional[str] = None,
        state: Optional[Union[str, "_models.SqlState"]] = None,
        error: Optional["_models.SqlErrorResponse"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword task_id: The server-generated ID of the Druid task.
        :paramtype task_id: str
        :keyword state: State of the query. Known values are: "ACCEPTED", "RUNNING", "FAILED", and
         "SUCCESS".
        :paramtype state: str or ~polaris.sdk.global_api.models.SqlState
        :keyword error:
        :paramtype error: ~polaris.sdk.global_api.models.SqlErrorResponse
        """
        super().__init__(**kwargs)
        self.task_id = task_id
        self.state = state
        self.error = error


class SqlJobResponse(JobResponse):
    """SQL job response.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: Required. Known values are: "pending", "running", "completed", "idle",
     "canceled", "failed", "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobResponseExecutionStatus
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar spec: An abstract request to create a job. Required.
    :vartype spec: ~polaris.sdk.global_api.models.CreateJobRequest
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    :ivar query: The SQL query. Required.
    :vartype query: str
    :ivar context: Context parameters used to specify various query configuration parameters. For
     more information, see `SQL ingestion reference
     <https://docs.imply.io/ui/saas/help/sql-ingestion-reference.html>`_.
    :vartype context: dict[str, any]
    :ivar parameters: Array of type and value pairs for dynamic parameters in parameterized SQL
     queries. For more information, see `Submit parameterized SQL ingestion
     <https://docs.imply.io/ui/saas/help/api-sql-ingestion.html>`_.
    :vartype parameters: list[~polaris.sdk.global_api.models.SqlParameter]
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True, "readonly": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "spec": {"required": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
        "query": {"required": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "spec": {"key": "spec", "type": "CreateJobRequest"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
        "query": {"key": "query", "type": "str"},
        "context": {"key": "context", "type": "{object}"},
        "parameters": {"key": "parameters", "type": "[SqlParameter]"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        spec: "_models.CreateJobRequest",
        target: "_models.JobTargetV2",
        query: str,
        context: Optional[Dict[str, Any]] = None,
        parameters: List["_models.SqlParameter"] = [],
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword spec: An abstract request to create a job. Required.
        :paramtype spec: ~polaris.sdk.global_api.models.CreateJobRequest
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        :keyword query: The SQL query. Required.
        :paramtype query: str
        :keyword context: Context parameters used to specify various query configuration parameters.
         For more information, see `SQL ingestion reference
         <https://docs.imply.io/ui/saas/help/sql-ingestion-reference.html>`_.
        :paramtype context: dict[str, any]
        :keyword parameters: Array of type and value pairs for dynamic parameters in parameterized SQL
         queries. For more information, see `Submit parameterized SQL ingestion
         <https://docs.imply.io/ui/saas/help/api-sql-ingestion.html>`_.
        :paramtype parameters: list[~polaris.sdk.global_api.models.SqlParameter]
        """
        super().__init__(
            desired_execution_status=desired_execution_status,
            spec=spec,
            target=target,
            **kwargs
        )
        self.type: str = "sql"
        self.query = query
        self.context = context
        self.parameters = parameters


class SqlJobSourceV2(JobSourceV2):
    """SQL source input.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    :ivar connection_name: Name of the connection to ingest from. Must refer to a connection of
     type ``sql``. Required.
    :vartype connection_name: str
    :ivar fold_case: Enable case-folding of database column names - appropriate where the database
     returns
     case-insensitive column names in query results.
    :vartype fold_case: bool
    :ivar input_schema: The schema of input data in terms of a list of input field names and their
     respective data types. Required.
    :vartype input_schema: list[~polaris.sdk.global_api.models.FieldNameAndDataType]
    :ivar sqls: List of one or more SQL queries to retrieve data from the SQL database.
     For example, if you include ``SELECT * FROM "table1"`` and ``SELECT * FROM "table2"``\\ ,
     then data from both tables are available through the connection.
    :vartype sqls: list[str]
    """

    _validation = {
        "type": {"required": True},
        "connection_name": {"required": True},
        "input_schema": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "connection_name": {"key": "connectionName", "type": "str"},
        "fold_case": {"key": "foldCase", "type": "bool"},
        "input_schema": {"key": "inputSchema", "type": "[FieldNameAndDataType]"},
        "sqls": {"key": "sqls", "type": "[str]"},
    }

    def __init__(
        self,
        *,
        connection_name: str,
        input_schema: List["_models.FieldNameAndDataType"] = [],
        fold_case: bool = False,
        sqls: Optional[List[str]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword connection_name: Name of the connection to ingest from. Must refer to a connection of
         type ``sql``. Required.
        :paramtype connection_name: str
        :keyword fold_case: Enable case-folding of database column names - appropriate where the
         database returns
         case-insensitive column names in query results.
        :paramtype fold_case: bool
        :keyword input_schema: The schema of input data in terms of a list of input field names and
         their respective data types. Required.
        :paramtype input_schema: list[~polaris.sdk.global_api.models.FieldNameAndDataType]
        :keyword sqls: List of one or more SQL queries to retrieve data from the SQL database.
         For example, if you include ``SELECT * FROM "table1"`` and ``SELECT * FROM "table2"``\\ ,
         then data from both tables are available through the connection.
        :paramtype sqls: list[str]
        """
        super().__init__(**kwargs)
        self.type: str = "SqlJobSourceV2"
        self.connection_name = connection_name
        self.fold_case = fold_case
        self.input_schema = input_schema
        self.sqls = sqls


class SqlJobSummaryResponse(JobSummaryResponse):
    """A SQL-based ingestion job.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: The execution status of the job.


     * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
     awaiting resources.
     * ``running``   - The job is currently in progress.
     * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
     warnings or errors.
     * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
     to ingest.
     * ``canceled``  - The job was canceled by the user.
     * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
     the failure.
     * ``suspended`` - The job is suspended by the user.
     * ``unknown``   - The execution status of the job is not known. This state typically occurs
     when a downstream error prevents retrieval of the job execution status. If a job persists in
     this state for an extended period of time (more than a few minutes), please contact Imply.
     Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
     "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        execution_status: Union[str, "_models.JobExecutionStatusV2"],
        target: "_models.JobTargetV2",
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword execution_status: The execution status of the job.


         * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
         awaiting resources.
         * ``running``   - The job is currently in progress.
         * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
         warnings or errors.
         * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
         to ingest.
         * ``canceled``  - The job was canceled by the user.
         * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
         the failure.
         * ``suspended`` - The job is suspended by the user.
         * ``unknown``   - The execution status of the job is not known. This state typically occurs
         when a downstream error prevents retrieval of the job execution status. If a job persists in
         this state for an extended period of time (more than a few minutes), please contact Imply.
         Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
         "suspended", and "unknown".
        :paramtype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        """
        super().__init__(
            desired_execution_status=desired_execution_status,
            execution_status=execution_status,
            target=target,
            **kwargs
        )
        self.type: str = "sql"


class SqlParameter(_serialization.Model):
    """A placeholder for a variable that contains some value of some type when executing a
    general-purpose query.

    All required parameters must be populated in order to send to server.

    :ivar type: The data type of the value used in a parameterized SQL query.
     See `SQL data types <https://docs.imply.io/latest/druid/querying/sql-data-types/>`_
     for the supported SQL types. Required.
    :vartype type: str
    :ivar value: The value to substitute into a parameterized SQL query. Required.
    :vartype value: JSON
    """

    _validation = {
        "type": {"required": True},
        "value": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "value": {"key": "value", "type": "object"},
    }

    def __init__(self, *, type: str, value: JSON, **kwargs: Any) -> None:
        """
        :keyword type: The data type of the value used in a parameterized SQL query.
         See `SQL data types <https://docs.imply.io/latest/druid/querying/sql-data-types/>`_
         for the supported SQL types. Required.
        :paramtype type: str
        :keyword value: The value to substitute into a parameterized SQL query. Required.
        :paramtype value: JSON
        """
        super().__init__(**kwargs)
        self.type = type
        self.value = value


class SqlRequest(_serialization.Model):
    """SqlRequest.

    All required parameters must be populated in order to send to server.

    :ivar query: The SQL query. Required.
    :vartype query: str
    :ivar result_format: String that indicates the format to return query results. Select one of
     the following formats:


     * `object`: Returns a JSON array of JSON objects with the HTTP response header `Content-Type:
     application/json`.
        Object field names match the columns returned by the SQL query in the same order as the SQL
     query.


     *
       `array`: Returns a JSON array of JSON arrays with the HTTP response header `Content-Type:
     application/json`.
        Each inner array has elements matching the columns returned by the SQL query, in order.

     *
       `objectLines`: Returns newline-delimited JSON objects with the HTTP response header
     `Content-Type: text/plain`.
        Newline separation facilitates parsing the entire response set as a stream if you don't
     have a streaming JSON parser.
        This format includes a single trailing newline character so you can detect a truncated
     response.

     *
       `arrayLines`: Returns newline-delimited JSON arrays with the HTTP response header
     `Content-Type: text/plain`.
        Newline separation facilitates parsing the entire response set as a stream if you don't
     have a streaming JSON parser.
        This format includes a single trailing newline character so you can detect a truncated
     response.

     *
       `csv`: Returns comma-separated values with one row per line. Sent with the HTTP response
     header `Content-Type: text/csv`.

        Druid uses double quotes to escape individual field values. For example, a value with a
     comma returns ``"A,B"``.
        If the field value contains a double quote character, Druid escapes it with a second double
     quote character.
        For example, ``foo"bar`` becomes ``foo""bar``.
        This format includes a single trailing newline character so you can detect a truncated
     response. Known values are: "object", "array", "objectLines", "arrayLines", and "csv".
    :vartype result_format: str or ~polaris.sdk.global_api.models.ResultFormat
    :ivar header: Boolean value that determines whether to return information on column names. When
     set to ``true``\\ , Polaris returns the column names as the first row of the results. To also
     get information on the column types, set ``typesHeader`` or ``sqlTypesHeader`` to ``true``.
    :vartype header: bool
    :ivar types_header: Adds runtime type information in the header. Requires ``header`` to be set
     to ``true``. Complex types, like sketches, will be reported as ``COMPLEX<typeName>`` if a
     particular complex type name is known for that field, or as ``COMPLEX`` if the particular type
     name is unknown or mixed.
    :vartype types_header: bool
    :ivar sql_types_header: Adds SQL type information in the header. Requires ``header`` to be set
     to ``true``.
     For compatibility, Druid returns the HTTP header ``X-Druid-SQL-Header-Included: yes`` when all
     of the following conditions are met:


     * The ``header`` property is set to true.
     * The version of Druid supports ``typesHeader`` and ``sqlTypesHeader``\\ , regardless of
     whether either property is set.
    :vartype sql_types_header: bool
    :ivar context: JSON object containing optional SQL query context parameters, such as to set the
     query ID, time zone, and whether to use an approximation algorithm for distinct count.
     For supported parameters, see `Druid SQL query context
     <https://docs.imply.io/latest/druid/querying/sql-query-context>`_.
    :vartype context: dict[str, any]
    :ivar parameters: List of Druid SQL query parameters for parameterized queries.
     Each parameter in the array should be a JSON object containing
     the parameter's SQL data type and parameter value.

     For example, the following query
     returns results with timestamps later than ``2019-08-21 00:00:00``\\ :

     .. code-block::

        {
          "query": "SELECT \\"col1\\" FROM \\"myTable\\" WHERE __time > ? AND ARRAY_CONTAINS(?,
     \\"col1\\")",
          "parameters": [
            {
              "type": "TIMESTAMP",
              "value": "2019-08-21 00:00:00"
            },
            {
              "type": "ARRAY",
              "value": [-25.7, null, 36.85]
            }
          ]
        }.
    :vartype parameters: list[JSON]
    """

    _validation = {
        "query": {"required": True},
    }

    _attribute_map = {
        "query": {"key": "query", "type": "str"},
        "result_format": {"key": "resultFormat", "type": "str"},
        "header": {"key": "header", "type": "bool"},
        "types_header": {"key": "typesHeader", "type": "bool"},
        "sql_types_header": {"key": "sqlTypesHeader", "type": "bool"},
        "context": {"key": "context", "type": "{object}"},
        "parameters": {"key": "parameters", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        query: str,
        result_format: Union[str, "_models.ResultFormat"] = "object",
        header: bool = False,
        types_header: bool = False,
        sql_types_header: bool = False,
        context: Optional[Dict[str, Any]] = None,
        parameters: Optional[List[JSON]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword query: The SQL query. Required.
        :paramtype query: str
        :keyword result_format: String that indicates the format to return query results. Select one of
         the following formats:


         * `object`: Returns a JSON array of JSON objects with the HTTP response header `Content-Type:
         application/json`.
            Object field names match the columns returned by the SQL query in the same order as the SQL
         query.


         *
           `array`: Returns a JSON array of JSON arrays with the HTTP response header `Content-Type:
         application/json`.
            Each inner array has elements matching the columns returned by the SQL query, in order.

         *
           `objectLines`: Returns newline-delimited JSON objects with the HTTP response header
         `Content-Type: text/plain`.
            Newline separation facilitates parsing the entire response set as a stream if you don't
         have a streaming JSON parser.
            This format includes a single trailing newline character so you can detect a truncated
         response.

         *
           `arrayLines`: Returns newline-delimited JSON arrays with the HTTP response header
         `Content-Type: text/plain`.
            Newline separation facilitates parsing the entire response set as a stream if you don't
         have a streaming JSON parser.
            This format includes a single trailing newline character so you can detect a truncated
         response.

         *
           `csv`: Returns comma-separated values with one row per line. Sent with the HTTP response
         header `Content-Type: text/csv`.

            Druid uses double quotes to escape individual field values. For example, a value with a
         comma returns ``"A,B"``.
            If the field value contains a double quote character, Druid escapes it with a second double
         quote character.
            For example, ``foo"bar`` becomes ``foo""bar``.
            This format includes a single trailing newline character so you can detect a truncated
         response. Known values are: "object", "array", "objectLines", "arrayLines", and "csv".
        :paramtype result_format: str or ~polaris.sdk.global_api.models.ResultFormat
        :keyword header: Boolean value that determines whether to return information on column names.
         When set to ``true``\\ , Polaris returns the column names as the first row of the results. To
         also get information on the column types, set ``typesHeader`` or ``sqlTypesHeader`` to
         ``true``.
        :paramtype header: bool
        :keyword types_header: Adds runtime type information in the header. Requires ``header`` to be
         set to ``true``. Complex types, like sketches, will be reported as ``COMPLEX<typeName>`` if a
         particular complex type name is known for that field, or as ``COMPLEX`` if the particular type
         name is unknown or mixed.
        :paramtype types_header: bool
        :keyword sql_types_header: Adds SQL type information in the header. Requires ``header`` to be
         set to ``true``.
         For compatibility, Druid returns the HTTP header ``X-Druid-SQL-Header-Included: yes`` when all
         of the following conditions are met:


         * The ``header`` property is set to true.
         * The version of Druid supports ``typesHeader`` and ``sqlTypesHeader``\\ , regardless of
         whether either property is set.
        :paramtype sql_types_header: bool
        :keyword context: JSON object containing optional SQL query context parameters, such as to set
         the query ID, time zone, and whether to use an approximation algorithm for distinct count.
         For supported parameters, see `Druid SQL query context
         <https://docs.imply.io/latest/druid/querying/sql-query-context>`_.
        :paramtype context: dict[str, any]
        :keyword parameters: List of Druid SQL query parameters for parameterized queries.
         Each parameter in the array should be a JSON object containing
         the parameter's SQL data type and parameter value.

         For example, the following query
         returns results with timestamps later than ``2019-08-21 00:00:00``\\ :

         .. code-block::

            {
              "query": "SELECT \\"col1\\" FROM \\"myTable\\" WHERE __time > ? AND ARRAY_CONTAINS(?,
         \\"col1\\")",
              "parameters": [
                {
                  "type": "TIMESTAMP",
                  "value": "2019-08-21 00:00:00"
                },
                {
                  "type": "ARRAY",
                  "value": [-25.7, null, 36.85]
                }
              ]
            }.
        :paramtype parameters: list[JSON]
        """
        super().__init__(**kwargs)
        self.query = query
        self.result_format = result_format
        self.header = header
        self.types_header = types_header
        self.sql_types_header = sql_types_header
        self.context = context
        self.parameters = parameters


class SqlStatus(_serialization.Model):
    """SqlStatus.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar query_id:
    :vartype query_id: str
    :ivar state: State of the query. Known values are: "ACCEPTED", "RUNNING", "FAILED", and
     "SUCCESS".
    :vartype state: str or ~polaris.sdk.global_api.models.SqlState
    :ivar created_at: The date and time this query was created in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype created_at: ~datetime.datetime
    :ivar schema: Schema of the query results.
    :vartype schema: list[any]
    :ivar duration_ms: Duration of the query in milliseconds.
    :vartype duration_ms: int
    :ivar result: Summarized information about query results, including the total number of rows
     and sample records.
    :vartype result: ~polaris.sdk.global_api.models.StatusResult
    :ivar stages: Returned when the query string parameter ``detail`` is true. Summarizes
     information about different stages used for query execution, such as stage number, phase, start
     time, duration, input and output information, processing methods, and partitioning.
    :vartype stages: JSON
    :ivar counters: Returned when the query string parameter ``detail`` is true. Provides details
     on the rows, bytes, and files processed at various stages for each worker across different
     channels, along with sort process.
    :vartype counters: JSON
    :ivar warnings: Returned when the query string parameter ``detail`` is true. Provides details
     about any warnings.
    :vartype warnings: JSON
    """

    _validation = {
        "created_at": {"readonly": True},
    }

    _attribute_map = {
        "query_id": {"key": "queryId", "type": "str"},
        "state": {"key": "state", "type": "str"},
        "created_at": {"key": "createdAt", "type": "iso-8601"},
        "schema": {"key": "schema", "type": "[object]"},
        "duration_ms": {"key": "durationMs", "type": "int"},
        "result": {"key": "result", "type": "StatusResult"},
        "stages": {"key": "stages", "type": "object"},
        "counters": {"key": "counters", "type": "object"},
        "warnings": {"key": "warnings", "type": "object"},
    }

    def __init__(
        self,
        *,
        query_id: Optional[str] = None,
        state: Optional[Union[str, "_models.SqlState"]] = None,
        schema: Optional[List[Any]] = None,
        duration_ms: Optional[int] = None,
        result: Optional["_models.StatusResult"] = None,
        stages: Optional[JSON] = None,
        counters: Optional[JSON] = None,
        warnings: Optional[JSON] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword query_id:
        :paramtype query_id: str
        :keyword state: State of the query. Known values are: "ACCEPTED", "RUNNING", "FAILED", and
         "SUCCESS".
        :paramtype state: str or ~polaris.sdk.global_api.models.SqlState
        :keyword schema: Schema of the query results.
        :paramtype schema: list[any]
        :keyword duration_ms: Duration of the query in milliseconds.
        :paramtype duration_ms: int
        :keyword result: Summarized information about query results, including the total number of rows
         and sample records.
        :paramtype result: ~polaris.sdk.global_api.models.StatusResult
        :keyword stages: Returned when the query string parameter ``detail`` is true. Summarizes
         information about different stages used for query execution, such as stage number, phase, start
         time, duration, input and output information, processing methods, and partitioning.
        :paramtype stages: JSON
        :keyword counters: Returned when the query string parameter ``detail`` is true. Provides
         details on the rows, bytes, and files processed at various stages for each worker across
         different channels, along with sort process.
        :paramtype counters: JSON
        :keyword warnings: Returned when the query string parameter ``detail`` is true. Provides
         details about any warnings.
        :paramtype warnings: JSON
        """
        super().__init__(**kwargs)
        self.query_id = query_id
        self.state = state
        self.created_at = None
        self.schema = schema
        self.duration_ms = duration_ms
        self.result = result
        self.stages = stages
        self.counters = counters
        self.warnings = warnings


class StackAreaChart(_serialization.Model):
    """StackAreaChart.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "stack-area-chart"
    :vartype type: str or ~polaris.sdk.global_api.models.StackAreaChartType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar line: Dimensions to be shown by the line. Required.
    :vartype line: list[any]
    :ivar stack: Dimensions to be shown by the stack.
    :vartype stack: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "line": {"required": True, "max_items": 1, "min_items": 1},
        "stack": {"max_items": 1, "min_items": 0},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "line": {"key": "line", "type": "[object]"},
        "stack": {"key": "stack", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        line: List[Any],
        type: Optional[Union[str, "_models.StackAreaChartType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        stack: Optional[List[Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "stack-area-chart"
        :paramtype type: str or ~polaris.sdk.global_api.models.StackAreaChartType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword line: Dimensions to be shown by the line. Required.
        :paramtype line: list[any]
        :keyword stack: Dimensions to be shown by the stack.
        :paramtype stack: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.line = line
        self.stack = stack


class StatusPageObject(_serialization.Model):
    """StatusPageObject.

    :ivar id: Page number of query results.
    :vartype id: int
    :ivar num_rows: Number of rows in the current page of results.
    :vartype num_rows: int
    :ivar size_in_bytes: Size of the page.
    :vartype size_in_bytes: int
    """

    _attribute_map = {
        "id": {"key": "id", "type": "int"},
        "num_rows": {"key": "numRows", "type": "int"},
        "size_in_bytes": {"key": "sizeInBytes", "type": "int"},
    }

    def __init__(
        self,
        *,
        id: Optional[int] = None,  # pylint: disable=redefined-builtin
        num_rows: Optional[int] = None,
        size_in_bytes: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword id: Page number of query results.
        :paramtype id: int
        :keyword num_rows: Number of rows in the current page of results.
        :paramtype num_rows: int
        :keyword size_in_bytes: Size of the page.
        :paramtype size_in_bytes: int
        """
        super().__init__(**kwargs)
        self.id = id
        self.num_rows = num_rows
        self.size_in_bytes = size_in_bytes


class StatusResult(_serialization.Model):
    """Summarized information about query results, including the total number of rows and sample
    records.

    :ivar num_total_rows: Total number of rows in the results.
    :vartype num_total_rows: int
    :ivar total_size_in_bytes: Total size of the results.
    :vartype total_size_in_bytes: int
    :ivar data_source: Name of the datasource that was queried.
    :vartype data_source: str
    :ivar sample_records: Sample query results.
    :vartype sample_records: list[any]
    :ivar pages: Metadata for each page of query results.
    :vartype pages: list[~polaris.sdk.global_api.models.StatusPageObject]
    """

    _attribute_map = {
        "num_total_rows": {"key": "numTotalRows", "type": "int"},
        "total_size_in_bytes": {"key": "totalSizeInBytes", "type": "int"},
        "data_source": {"key": "dataSource", "type": "str"},
        "sample_records": {"key": "sampleRecords", "type": "[object]"},
        "pages": {"key": "pages", "type": "[StatusPageObject]"},
    }

    def __init__(
        self,
        *,
        num_total_rows: Optional[int] = None,
        total_size_in_bytes: Optional[int] = None,
        data_source: Optional[str] = None,
        sample_records: Optional[List[Any]] = None,
        pages: Optional[List["_models.StatusPageObject"]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword num_total_rows: Total number of rows in the results.
        :paramtype num_total_rows: int
        :keyword total_size_in_bytes: Total size of the results.
        :paramtype total_size_in_bytes: int
        :keyword data_source: Name of the datasource that was queried.
        :paramtype data_source: str
        :keyword sample_records: Sample query results.
        :paramtype sample_records: list[any]
        :keyword pages: Metadata for each page of query results.
        :paramtype pages: list[~polaris.sdk.global_api.models.StatusPageObject]
        """
        super().__init__(**kwargs)
        self.num_total_rows = num_total_rows
        self.total_size_in_bytes = total_size_in_bytes
        self.data_source = data_source
        self.sample_records = sample_records
        self.pages = pages


class StreamingJobResponse(JobResponse):
    """A streaming job response.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: Required. Known values are: "pending", "running", "completed", "idle",
     "canceled", "failed", "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobResponseExecutionStatus
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar spec: An abstract request to create a job. Required.
    :vartype spec: ~polaris.sdk.global_api.models.CreateJobRequest
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    :ivar source: Source input of the job. Required.
    :vartype source: ~polaris.sdk.global_api.models.JobSourceV2
    :ivar mappings: Relationship between the input fields and the output columns of a table's
     schema.
     Define the Polaris column name in ``columnName``\\ , and specify how the column is defined
     with respect to the input fields in ``expression``. ``expression`` must be a valid SQL
     expression.

     For batch ingestion jobs, you must include a mapping for each field. Polaris ignores
     unmapped input fields. Streaming ingestion jobs may apply schema auto-discovery for
     Polaris to discover input fields and map them directly to table dimensions.
     Always specify a mapping for ``__time`` and when you want to transform an input field.

     For more information, see
     `Map and transform data with input expressions
     <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_
     and `Schema auto-discovery on ingestion jobs
     <https://docs.imply.io/ui/saas/help/job-auto-discovery.html>`_.
    :vartype mappings: list[~polaris.sdk.global_api.models.InputToTableSchemaMapping]
    :ivar dimension_exclusions: The names of dimensions to exclude from ingestion. This list is
     only used if the target table is
     ``flexible``\\ , otherwise it is ignored.
    :vartype dimension_exclusions: list[str]
    :ivar use_schema_discovery: Set to true to allow for data to be discovered and written to the
     target table during ingestion. Only applies when ``schemaMode`` on the table is ``flexible``.
    :vartype use_schema_discovery: bool
    :ivar filter_expression: SQL expression to use for filtering the source data. For more
     information, see `Filter data to ingest
     <https://docs.imply.io/ui/saas/help//ingest-with-filters.html>`_.
    :vartype filter_expression: str
    :ivar late_message_rejection_period: An ISO 8601 duration such as ``P1D``\\ , indicating how
     far in the past data will be accepted. If both a filter expression and late message rejection
     period are specified, only rows that meet both criteria are accepted. The default in Polaris is
     ``P30D``\\ , indicating messages with a primary timestamp (\\ ``__time``\\ ) older than 30 days
     will be skipped.
    :vartype late_message_rejection_period: str
    :ivar early_message_rejection_period: An ISO 8601 duration such as ``P1D``\\ , indicating how
     far in the future data will be accepted. If both a filter expression and early message
     rejection period are specified, only rows that meet both criteria are accepted. The default in
     Polaris is ``P2000D``\\ , indicating messages with a primary timestamp (\\ ``__time``\\ ) more
     than 2000 days in the future will be skipped.
    :vartype early_message_rejection_period: str
    :ivar read_from_point: Sets the point to start reading from in a stream:


     * ``earliest`` tells Polaris to read data from the earliest available point in the stream. Use
     this if there is already data in the stream that you wish to ingest. Note that Polaris will
     only ingest data whose timestamp is within the last 30 days. If you have older data you wish to
     ingest, we recommend exporting it to a file and batch ingesting it.
     * ``latest`` tells Polaris to read data from the latest point available in the stream. Polaris
     will only ingest data published to the stream after the job is created (provided the data's
     timestamp is within the last 30 days). Known values are: "earliest" and "latest".
    :vartype read_from_point: str or ~polaris.sdk.global_api.models.StreamingReadFromPoint
    :ivar max_parse_exceptions: Configuration parameter that specifies the maximum number of parse
     exceptions that a task can tolerate before failing.
    :vartype max_parse_exceptions: int
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True, "readonly": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "spec": {"required": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
        "source": {"required": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "spec": {"key": "spec", "type": "CreateJobRequest"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
        "source": {"key": "source", "type": "JobSourceV2"},
        "mappings": {"key": "mappings", "type": "[InputToTableSchemaMapping]"},
        "dimension_exclusions": {"key": "dimensionExclusions", "type": "[str]"},
        "use_schema_discovery": {"key": "useSchemaDiscovery", "type": "bool"},
        "filter_expression": {"key": "filterExpression", "type": "str"},
        "late_message_rejection_period": {
            "key": "lateMessageRejectionPeriod",
            "type": "str",
        },
        "early_message_rejection_period": {
            "key": "earlyMessageRejectionPeriod",
            "type": "str",
        },
        "read_from_point": {"key": "readFromPoint", "type": "str"},
        "max_parse_exceptions": {"key": "maxParseExceptions", "type": "int"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        spec: "_models.CreateJobRequest",
        target: "_models.JobTargetV2",
        source: "_models.JobSourceV2",
        mappings: List["_models.InputToTableSchemaMapping"] = [],
        dimension_exclusions: List[str] = [],
        use_schema_discovery: bool = False,
        filter_expression: Optional[str] = None,
        late_message_rejection_period: str = "P30D",
        early_message_rejection_period: str = "P2000D",
        read_from_point: Union[str, "_models.StreamingReadFromPoint"] = "latest",
        max_parse_exceptions: int = 2147483647,
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword spec: An abstract request to create a job. Required.
        :paramtype spec: ~polaris.sdk.global_api.models.CreateJobRequest
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        :keyword source: Source input of the job. Required.
        :paramtype source: ~polaris.sdk.global_api.models.JobSourceV2
        :keyword mappings: Relationship between the input fields and the output columns of a table's
         schema.
         Define the Polaris column name in ``columnName``\\ , and specify how the column is defined
         with respect to the input fields in ``expression``. ``expression`` must be a valid SQL
         expression.

         For batch ingestion jobs, you must include a mapping for each field. Polaris ignores
         unmapped input fields. Streaming ingestion jobs may apply schema auto-discovery for
         Polaris to discover input fields and map them directly to table dimensions.
         Always specify a mapping for ``__time`` and when you want to transform an input field.

         For more information, see
         `Map and transform data with input expressions
         <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_
         and `Schema auto-discovery on ingestion jobs
         <https://docs.imply.io/ui/saas/help/job-auto-discovery.html>`_.
        :paramtype mappings: list[~polaris.sdk.global_api.models.InputToTableSchemaMapping]
        :keyword dimension_exclusions: The names of dimensions to exclude from ingestion. This list is
         only used if the target table is
         ``flexible``\\ , otherwise it is ignored.
        :paramtype dimension_exclusions: list[str]
        :keyword use_schema_discovery: Set to true to allow for data to be discovered and written to
         the target table during ingestion. Only applies when ``schemaMode`` on the table is
         ``flexible``.
        :paramtype use_schema_discovery: bool
        :keyword filter_expression: SQL expression to use for filtering the source data. For more
         information, see `Filter data to ingest
         <https://docs.imply.io/ui/saas/help//ingest-with-filters.html>`_.
        :paramtype filter_expression: str
        :keyword late_message_rejection_period: An ISO 8601 duration such as ``P1D``\\ , indicating how
         far in the past data will be accepted. If both a filter expression and late message rejection
         period are specified, only rows that meet both criteria are accepted. The default in Polaris is
         ``P30D``\\ , indicating messages with a primary timestamp (\\ ``__time``\\ ) older than 30 days
         will be skipped.
        :paramtype late_message_rejection_period: str
        :keyword early_message_rejection_period: An ISO 8601 duration such as ``P1D``\\ , indicating
         how far in the future data will be accepted. If both a filter expression and early message
         rejection period are specified, only rows that meet both criteria are accepted. The default in
         Polaris is ``P2000D``\\ , indicating messages with a primary timestamp (\\ ``__time``\\ ) more
         than 2000 days in the future will be skipped.
        :paramtype early_message_rejection_period: str
        :keyword read_from_point: Sets the point to start reading from in a stream:


         * ``earliest`` tells Polaris to read data from the earliest available point in the stream. Use
         this if there is already data in the stream that you wish to ingest. Note that Polaris will
         only ingest data whose timestamp is within the last 30 days. If you have older data you wish to
         ingest, we recommend exporting it to a file and batch ingesting it.
         * ``latest`` tells Polaris to read data from the latest point available in the stream. Polaris
         will only ingest data published to the stream after the job is created (provided the data's
         timestamp is within the last 30 days). Known values are: "earliest" and "latest".
        :paramtype read_from_point: str or ~polaris.sdk.global_api.models.StreamingReadFromPoint
        :keyword max_parse_exceptions: Configuration parameter that specifies the maximum number of
         parse exceptions that a task can tolerate before failing.
        :paramtype max_parse_exceptions: int
        """
        super().__init__(
            desired_execution_status=desired_execution_status,
            spec=spec,
            target=target,
            **kwargs
        )
        self.type: str = "streaming"
        self.source = source
        self.mappings = mappings
        self.dimension_exclusions = dimension_exclusions
        self.use_schema_discovery = use_schema_discovery
        self.filter_expression = filter_expression
        self.late_message_rejection_period = late_message_rejection_period
        self.early_message_rejection_period = early_message_rejection_period
        self.read_from_point = read_from_point
        self.max_parse_exceptions = max_parse_exceptions


class StreamingJobSummaryResponse(JobSummaryResponse):
    """A streaming ingestion job. The only source type allowed for this job is ``connection``.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar created_by: A user. Required.
    :vartype created_by: ~polaris.sdk.global_api.models.UserV2
    :ivar created_timestamp: The date and time this job was created by the user in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_timestamp: ~datetime.datetime
    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    :ivar execution_status: The execution status of the job.


     * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
     awaiting resources.
     * ``running``   - The job is currently in progress.
     * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
     warnings or errors.
     * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
     to ingest.
     * ``canceled``  - The job was canceled by the user.
     * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
     the failure.
     * ``suspended`` - The job is suspended by the user.
     * ``unknown``   - The execution status of the job is not known. This state typically occurs
     when a downstream error prevents retrieval of the job execution status. If a job persists in
     this state for an extended period of time (more than a few minutes), please contact Imply.
     Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
     "suspended", and "unknown".
    :vartype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
    :ivar health: The health of a job. Required.
    :vartype health: ~polaris.sdk.global_api.models.JobHealthV2
    :ivar id: A generated, permanently unique ID for this job. Required.
    :vartype id: str
    :ivar last_modified_by: A user. Required.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.UserV2
    :ivar last_updated_timestamp: The date and time this job was last updated by the user in `ISO
     8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype last_updated_timestamp: ~datetime.datetime
    :ivar target: Target output of the job. Required.
    :vartype target: ~polaris.sdk.global_api.models.JobTargetV2
    :ivar type: Type of job:


     * ``batch``        - A batch ingestion job.
     * ``delete_data``  - A job to delete data within a table.
     * ``drop_table``   - A job to delete a table and all of its data.
     * ``restore_data`` - A job to restore deleted data in a table.
     * ``streaming``    - A streaming ingestion job.
     *
       ``sql``          - A SQL-based ingestion job.

       You can't drop a table that's used as a lookup source.

       For information about ingestion jobs, see
       `Create an ingestion job <https://docs.imply.io/ui/saas/help/ingestion-job.html>`_ and
       `Ingest using SQL <https://docs.imply.io/ui/saas/help/sql-based-ingestion.html>`_. Known
     values are: "batch", "delete_data", "drop_table", "restore_data", "streaming", and "sql".
    :vartype type: str or ~polaris.sdk.global_api.models.JobTypeV2
    :ivar completed_timestamp: The date and time this job transitioned to a ``completed`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype completed_timestamp: ~datetime.datetime
    :ivar started_timestamp: The date and time this job transitioned to a ``running`` execution
     status in `ISO 8601 format <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_.
    :vartype started_timestamp: ~datetime.datetime
    :ivar source: Source summary of the job. Required.
    :vartype source: ~polaris.sdk.global_api.models.JobSourceSummary
    """

    _validation = {
        "created_by": {"required": True, "readonly": True},
        "created_timestamp": {"required": True, "readonly": True},
        "desired_execution_status": {"required": True},
        "execution_status": {"required": True},
        "health": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "last_modified_by": {"required": True, "readonly": True},
        "last_updated_timestamp": {"required": True, "readonly": True},
        "target": {"required": True},
        "type": {"required": True},
        "completed_timestamp": {"readonly": True},
        "started_timestamp": {"readonly": True},
        "source": {"required": True},
    }

    _attribute_map = {
        "created_by": {"key": "createdBy", "type": "UserV2"},
        "created_timestamp": {"key": "createdTimestamp", "type": "iso-8601"},
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
        "execution_status": {"key": "executionStatus", "type": "str"},
        "health": {"key": "health", "type": "JobHealthV2"},
        "id": {"key": "id", "type": "str"},
        "last_modified_by": {"key": "lastModifiedBy", "type": "UserV2"},
        "last_updated_timestamp": {"key": "lastUpdatedTimestamp", "type": "iso-8601"},
        "target": {"key": "target", "type": "JobTargetV2"},
        "type": {"key": "type", "type": "str"},
        "completed_timestamp": {"key": "completedTimestamp", "type": "iso-8601"},
        "started_timestamp": {"key": "startedTimestamp", "type": "iso-8601"},
        "source": {"key": "source", "type": "JobSourceSummary"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        execution_status: Union[str, "_models.JobExecutionStatusV2"],
        target: "_models.JobTargetV2",
        source: "_models.JobSourceSummary",
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        :keyword execution_status: The execution status of the job.


         * ``pending``   - The job is waiting to run. Jobs are typically in this state when they are
         awaiting resources.
         * ``running``   - The job is currently in progress.
         * ``completed`` - The job completed. Refer to the job's ``health`` field to check for any
         warnings or errors.
         * ``idle``      - The job is idle. This may occur when a streaming ingestion job has no data
         to ingest.
         * ``canceled``  - The job was canceled by the user.
         * ``failed``    - The job failed. Refer to the job's ``health`` field for more details about
         the failure.
         * ``suspended`` - The job is suspended by the user.
         * ``unknown``   - The execution status of the job is not known. This state typically occurs
         when a downstream error prevents retrieval of the job execution status. If a job persists in
         this state for an extended period of time (more than a few minutes), please contact Imply.
         Required. Known values are: "pending", "running", "completed", "idle", "canceled", "failed",
         "suspended", and "unknown".
        :paramtype execution_status: str or ~polaris.sdk.global_api.models.JobExecutionStatusV2
        :keyword target: Target output of the job. Required.
        :paramtype target: ~polaris.sdk.global_api.models.JobTargetV2
        :keyword source: Source summary of the job. Required.
        :paramtype source: ~polaris.sdk.global_api.models.JobSourceSummary
        """
        super().__init__(
            desired_execution_status=desired_execution_status,
            execution_status=execution_status,
            target=target,
            **kwargs
        )
        self.type: str = "streaming"
        self.source = source


class StringFilter(_serialization.Model):
    """A filter applied to a string dimension.

    :ivar filter_type: "string"
    :vartype filter_type: str or ~polaris.sdk.global_api.models.StringFilterType
    :ivar dimension:
    :vartype dimension: str
    :ivar operator: Known values are: "eq", "ne", "contains", and "in".
    :vartype operator: str or ~polaris.sdk.global_api.models.StringFilterOperator
    :ivar value:
    :vartype value: str
    """

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "dimension": {"key": "dimension", "type": "str"},
        "operator": {"key": "operator", "type": "str"},
        "value": {"key": "value", "type": "str"},
    }

    def __init__(
        self,
        *,
        filter_type: Optional[Union[str, "_models.StringFilterType"]] = None,
        dimension: Optional[str] = None,
        operator: Optional[Union[str, "_models.StringFilterOperator"]] = None,
        value: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword filter_type: "string"
        :paramtype filter_type: str or ~polaris.sdk.global_api.models.StringFilterType
        :keyword dimension:
        :paramtype dimension: str
        :keyword operator: Known values are: "eq", "ne", "contains", and "in".
        :paramtype operator: str or ~polaris.sdk.global_api.models.StringFilterOperator
        :keyword value:
        :paramtype value: str
        """
        super().__init__(**kwargs)
        self.filter_type = filter_type
        self.dimension = dimension
        self.operator = operator
        self.value = value


class Sunburst(_serialization.Model):
    """Sunburst.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "sunburst"
    :vartype type: str or ~polaris.sdk.global_api.models.SunburstType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar layout: Dimensions to be shown by the layout. Required.
    :vartype layout: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "layout": {"required": True, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "layout": {"key": "layout", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        layout: List[Any],
        type: Optional[Union[str, "_models.SunburstType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "sunburst"
        :paramtype type: str or ~polaris.sdk.global_api.models.SunburstType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword layout: Dimensions to be shown by the layout. Required.
        :paramtype layout: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.layout = layout


class Table(_serialization.Model):
    """Table.

    All required parameters must be populated in order to send to server.

    :ivar type: Visualization type. Known values are: "table", "detail", and "aggregate".
    :vartype type: str or ~polaris.sdk.global_api.models.TableType
    :ivar data_cube: Data cube ID. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to apply to the visualization. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar rows: Dimensions to display in rows. Required.
    :vartype rows: list[any]
    :ivar columns: Dimensions to display in columns.
    :vartype columns: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "rows": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "rows": {"key": "rows", "type": "[object]"},
        "columns": {"key": "columns", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        rows: List[Any],
        type: Optional[Union[str, "_models.TableType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        columns: Optional[List[Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Visualization type. Known values are: "table", "detail", and "aggregate".
        :paramtype type: str or ~polaris.sdk.global_api.models.TableType
        :keyword data_cube: Data cube ID. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to apply to the visualization. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword rows: Dimensions to display in rows. Required.
        :paramtype rows: list[any]
        :keyword columns: Dimensions to display in columns.
        :paramtype columns: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.rows = rows
        self.columns = columns


class TableJobSourceSummary(JobSourceSummary):
    """A summary of a table source input.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    :ivar table_name: Name of the table to ingest from. Required.
    :vartype table_name: str
    """

    _validation = {
        "type": {"required": True},
        "table_name": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "table_name": {"key": "tableName", "type": "str"},
    }

    def __init__(self, *, table_name: str, **kwargs: Any) -> None:
        """
        :keyword table_name: Name of the table to ingest from. Required.
        :paramtype table_name: str
        """
        super().__init__(**kwargs)
        self.type: str = "table"
        self.table_name = table_name


class TableJobSourceV2(JobSourceV2):
    """A table source input.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    :ivar interval: A single time interval in ISO8601 format describing the range of data from the
     table to ingest.
    :vartype interval: str
    :ivar table_name: Name of the table to ingest from. Required.
    :vartype table_name: str
    """

    _validation = {
        "type": {"required": True},
        "table_name": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "interval": {"key": "interval", "type": "str"},
        "table_name": {"key": "tableName", "type": "str"},
    }

    def __init__(
        self,
        *,
        table_name: str,
        interval: str = "-1000-01-01T00:00:00.000Z/5000-01-01T00:00:00.000Z",
        **kwargs: Any
    ) -> None:
        """
        :keyword interval: A single time interval in ISO8601 format describing the range of data from
         the table to ingest.
        :paramtype interval: str
        :keyword table_name: Name of the table to ingest from. Required.
        :paramtype table_name: str
        """
        super().__init__(**kwargs)
        self.type: str = "table"
        self.interval = interval
        self.table_name = table_name


class TableJobTargetV2(JobTargetV2):
    """A table target output.

    All required parameters must be populated in order to send to server.

    :ivar type: Type of job target.


     * ``table`` - Specifies that the job target is a table. Required. "table"
    :vartype type: str or ~polaris.sdk.global_api.models.JobTargetTypeV2
    :ivar intervals: Array of `ISO 8601 <https://en.wikipedia.org/wiki/ISO_8601#Time_intervals>`_
     time intervals for replacing or deleting data.

     Do not provide intervals in the following cases:


     * Streaming ingestion jobs
     * Batch ingestion jobs in ``append`` mode
     * Data deletion jobs when ``deleteAll`` is true
     * Restore data jobs

     For an ingestion job in ``replace`` mode, the specified intervals must align with this job's
     ``partitionedBy``\\ , if specified. If ``partitionedBy`` is not specified for the job,
     it defaults to the table's ``partitioningGranularity`` and the intervals must align with the
     table's time partitioning.

     For example, if the partitioning granularity is ``day``\\ , you can specify an eight
     day interval such as ``["2022-06-01/2022-06-09"]``. However, you can't specify an eight hour
     interval such
     as ``["2022-06-01T00:00:00Z/2022-06-01T08:00:00Z"]``. Polaris raises a ``400 Bad Request``
     error if an
     interval does not align.

     For data deletion, any interval is allowed. We recommend aligning the interval with the
     coarsest
     partitioning granularity you expect in the table. For most tables, this is the table's time
     partitioning.
     If a table has data ingested at different granularities and the provided interval partially
     overlaps
     data written at a coarser granularity, the provided interval will be expanded to fully include
     that data. For example, if you ingested data at ``day`` granularity for ``2022-06-01``\\ ,
     specifying the eight
     hour interval ``2024-06-01T00:00:00Z/2024-06-01T08:00:00Z`` will expand the deletion to
     include the full day
     of data.

     To delete data at a more granular level than the ingested data's partitioning granularity,
     create an ingestion job in ``replace`` mode. Use the same table for the source, and add a
     ``filterExpression`` to filter out the time range to delete.
    :vartype intervals: list[str]
    :ivar table_name: Name of the table that this job applies to. If the table doesn't already
     exist, set ``createTableIfNotExists`` to true to automatically create the table. Required.
    :vartype table_name: str
    """

    _validation = {
        "type": {"required": True},
        "table_name": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "intervals": {"key": "intervals", "type": "[str]"},
        "table_name": {"key": "tableName", "type": "str"},
    }

    def __init__(
        self, *, table_name: str, intervals: Optional[List[str]] = None, **kwargs: Any
    ) -> None:
        """
        :keyword intervals: Array of `ISO 8601
         <https://en.wikipedia.org/wiki/ISO_8601#Time_intervals>`_
         time intervals for replacing or deleting data.

         Do not provide intervals in the following cases:


         * Streaming ingestion jobs
         * Batch ingestion jobs in ``append`` mode
         * Data deletion jobs when ``deleteAll`` is true
         * Restore data jobs

         For an ingestion job in ``replace`` mode, the specified intervals must align with this job's
         ``partitionedBy``\\ , if specified. If ``partitionedBy`` is not specified for the job,
         it defaults to the table's ``partitioningGranularity`` and the intervals must align with the
         table's time partitioning.

         For example, if the partitioning granularity is ``day``\\ , you can specify an eight
         day interval such as ``["2022-06-01/2022-06-09"]``. However, you can't specify an eight hour
         interval such
         as ``["2022-06-01T00:00:00Z/2022-06-01T08:00:00Z"]``. Polaris raises a ``400 Bad Request``
         error if an
         interval does not align.

         For data deletion, any interval is allowed. We recommend aligning the interval with the
         coarsest
         partitioning granularity you expect in the table. For most tables, this is the table's time
         partitioning.
         If a table has data ingested at different granularities and the provided interval partially
         overlaps
         data written at a coarser granularity, the provided interval will be expanded to fully include
         that data. For example, if you ingested data at ``day`` granularity for ``2022-06-01``\\ ,
         specifying the eight
         hour interval ``2024-06-01T00:00:00Z/2024-06-01T08:00:00Z`` will expand the deletion to
         include the full day
         of data.

         To delete data at a more granular level than the ingested data's partitioning granularity,
         create an ingestion job in ``replace`` mode. Use the same table for the source, and add a
         ``filterExpression`` to filter out the time range to delete.
        :paramtype intervals: list[str]
        :keyword table_name: Name of the table that this job applies to. If the table doesn't already
         exist, set ``createTableIfNotExists`` to true to automatically create the table. Required.
        :paramtype table_name: str
        """
        super().__init__(intervals=intervals, **kwargs)
        self.type: str = "table"
        self.table_name = table_name


class TableListResponse(_serialization.Model):
    """A list of tables.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.TableSummaryPayload]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[TableSummaryPayload]"},
    }

    def __init__(
        self, *, values: List["_models.TableSummaryPayload"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.TableSummaryPayload]
        """
        super().__init__(**kwargs)
        self.values = values


class TableStoragePolicy(_serialization.Model):
    """Policy specifying the time range of data to retain or precache.


    * The ``retain`` storage policy determines how long to keep data after which it is deleted.
    * The ``cached`` storage policy determines how long to keep data precached.
      Outside of the ``cached`` policy time range, data isn't precached and only resides in lower
    cost deep storage.

    By default, Polaris retains all data and precaches all data.
    You can’t set a custom storage policy for a table that’s actively used by a lookup.
    For more information, see
    `Data lifecycle management
    <https://docs.imply.io/ui/saas/help/data-lifecycle-management.html>`_.

    :ivar cached: Storage policy that determines how long to retain or precache data.
    :vartype cached: ~polaris.sdk.global_api.models.StoragePolicyPayload
    :ivar retain: Storage policy that determines how long to retain or precache data.
    :vartype retain: ~polaris.sdk.global_api.models.StoragePolicyPayload
    """

    _attribute_map = {
        "cached": {"key": "cached", "type": "StoragePolicyPayload"},
        "retain": {"key": "retain", "type": "StoragePolicyPayload"},
    }

    def __init__(
        self,
        *,
        cached: Optional["_models.StoragePolicyPayload"] = None,
        retain: Optional["_models.StoragePolicyPayload"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword cached: Storage policy that determines how long to retain or precache data.
        :paramtype cached: ~polaris.sdk.global_api.models.StoragePolicyPayload
        :keyword retain: Storage policy that determines how long to retain or precache data.
        :paramtype retain: ~polaris.sdk.global_api.models.StoragePolicyPayload
        """
        super().__init__(**kwargs)
        self.cached = cached
        self.retain = retain


class TableSummaryPayload(_serialization.Model):
    """A table summary, returned as part of a tables list.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar availability: The availability status of the table:


     * ``available``   - All data in table is available for querying.
     * ``deleting``    - The table is being deleted.
     * ``unavailable`` - Not all data in the table is available for querying. Required. Known
     values are: "available", "deleting", and "unavailable".
    :vartype availability: str or ~polaris.sdk.global_api.models.TableAvailability
    :ivar created_by_user: The user who created the initial object. Required.
    :vartype created_by_user: ~polaris.sdk.global_api.models.CreatedByUserResponse
    :ivar created_on_timestamp: The date and time this object was created in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype created_on_timestamp: ~datetime.datetime
    :ivar id: A generated, permanently unique ID for this table. Required.
    :vartype id: str
    :ivar modified_by_user: The user who modified the object last. Required.
    :vartype modified_by_user: ~polaris.sdk.global_api.models.ModifiedByUserResponse
    :ivar modified_on_timestamp: The date and time this table was last modified in `ISO 8601 format
     <https://datatracker.ietf.org/doc/html/rfc3339#section-5.6>`_. Required.
    :vartype modified_on_timestamp: ~datetime.datetime
    :ivar name: The unique, immutable name of the table. Required.
    :vartype name: str
    :ivar partitioning_granularity: The `time partitioning
     <https://docs.imply.io/ui/saas/help/partitioning.html>`_ of the table. The ``all`` granularity
     groups all data into a single bucket. The ``week`` granularity is deprecated. You can't create
     a new table with the time partitioning set to ``week``. A table sourced by a lookup can only
     use all partitioning. You can’t change this setting on a table that’s actively used by a
     lookup. Known values are: "second", "minute", "five_minute", "ten_minute", "fifteen_minute",
     "thirty_minute", "hour", "six_hour", "eight_hour", "day", "week", "month", "quarter", "year",
     and "all".
    :vartype partitioning_granularity: str or
     ~polaris.sdk.global_api.models.TablePartitioningGranularity
    :ivar schema_mode: The table's schema enforcement mode. For more information, see `Introduction
     to tables <https://docs.imply.io/ui/saas/help/tables.html>`_. Required. Known values are:
     "flexible" and "strict".
    :vartype schema_mode: str or ~polaris.sdk.global_api.models.TableSchemaMode
    :ivar segment_count: The number of segments in the table. Required.
    :vartype segment_count: int
    :ivar storage_policy: Policy specifying the time range of data to retain or precache.


     * The ``retain`` storage policy determines how long to keep data after which it is deleted.
     * The ``cached`` storage policy determines how long to keep data precached.
       Outside of the ``cached`` policy time range, data isn't precached and only resides in lower
     cost deep storage.

     By default, Polaris retains all data and precaches all data.
     You can’t set a custom storage policy for a table that’s actively used by a lookup.
     For more information, see
     `Data lifecycle management
     <https://docs.imply.io/ui/saas/help/data-lifecycle-management.html>`_.
    :vartype storage_policy: ~polaris.sdk.global_api.models.TableStoragePolicy
    :ivar precached_data_size_bytes: The precached size of the table in bytes. Required.
    :vartype precached_data_size_bytes: int
    :ivar total_data_size_bytes: The total size of the table in bytes. Required.
    :vartype total_data_size_bytes: int
    :ivar total_rows: The total number of rows stored in the table. Required.
    :vartype total_rows: int
    :ivar type: Visualization type. Required. Known values are: "table", "detail", and "aggregate".
    :vartype type: str or ~polaris.sdk.global_api.models.TableType
    :ivar version: The version number of the table. Newly created tables are always initialized at
     version 0. Do not provide the version number when creating a table. When updating a table,
     provide the current table version number. If the version number in the request is not the
     current version, Polaris raises a ``409 Conflict`` error. In that case, retrieve the latest
     version and retry the request to avoid concurrently conflicting changes. Required.
    :vartype version: int
    :ivar description: The table's description, limited to 1000 characters.
    :vartype description: str
    """

    _validation = {
        "availability": {"required": True, "readonly": True},
        "created_by_user": {"required": True, "readonly": True},
        "created_on_timestamp": {"required": True, "readonly": True},
        "id": {"required": True, "readonly": True},
        "modified_by_user": {"required": True, "readonly": True},
        "modified_on_timestamp": {"required": True, "readonly": True},
        "name": {"required": True, "max_length": 255, "min_length": 1},
        "partitioning_granularity": {"required": True},
        "schema_mode": {"required": True},
        "segment_count": {"required": True, "readonly": True},
        "precached_data_size_bytes": {"required": True, "readonly": True},
        "total_data_size_bytes": {"required": True, "readonly": True},
        "total_rows": {"required": True, "readonly": True},
        "type": {"required": True},
        "version": {"required": True},
    }

    _attribute_map = {
        "availability": {"key": "availability", "type": "str"},
        "created_by_user": {"key": "createdByUser", "type": "CreatedByUserResponse"},
        "created_on_timestamp": {"key": "createdOnTimestamp", "type": "iso-8601"},
        "id": {"key": "id", "type": "str"},
        "modified_by_user": {"key": "modifiedByUser", "type": "ModifiedByUserResponse"},
        "modified_on_timestamp": {"key": "modifiedOnTimestamp", "type": "iso-8601"},
        "name": {"key": "name", "type": "str"},
        "partitioning_granularity": {"key": "partitioningGranularity", "type": "str"},
        "schema_mode": {"key": "schemaMode", "type": "str"},
        "segment_count": {"key": "segmentCount", "type": "int"},
        "storage_policy": {"key": "storagePolicy", "type": "TableStoragePolicy"},
        "precached_data_size_bytes": {"key": "precachedDataSizeBytes", "type": "int"},
        "total_data_size_bytes": {"key": "totalDataSizeBytes", "type": "int"},
        "total_rows": {"key": "totalRows", "type": "int"},
        "type": {"key": "type", "type": "str"},
        "version": {"key": "version", "type": "int"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        partitioning_granularity: Union[
            str, "_models.TablePartitioningGranularity"
        ] = "day",
        schema_mode: Union[str, "_models.TableSchemaMode"],
        type: Union[str, "_models.TableType"],
        version: int = 0,
        storage_policy: Optional["_models.TableStoragePolicy"] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: The unique, immutable name of the table. Required.
        :paramtype name: str
        :keyword partitioning_granularity: The `time partitioning
         <https://docs.imply.io/ui/saas/help/partitioning.html>`_ of the table. The ``all`` granularity
         groups all data into a single bucket. The ``week`` granularity is deprecated. You can't create
         a new table with the time partitioning set to ``week``. A table sourced by a lookup can only
         use all partitioning. You can’t change this setting on a table that’s actively used by a
         lookup. Known values are: "second", "minute", "five_minute", "ten_minute", "fifteen_minute",
         "thirty_minute", "hour", "six_hour", "eight_hour", "day", "week", "month", "quarter", "year",
         and "all".
        :paramtype partitioning_granularity: str or
         ~polaris.sdk.global_api.models.TablePartitioningGranularity
        :keyword schema_mode: The table's schema enforcement mode. For more information, see
         `Introduction to tables <https://docs.imply.io/ui/saas/help/tables.html>`_. Required. Known
         values are: "flexible" and "strict".
        :paramtype schema_mode: str or ~polaris.sdk.global_api.models.TableSchemaMode
        :keyword storage_policy: Policy specifying the time range of data to retain or precache.


         * The ``retain`` storage policy determines how long to keep data after which it is deleted.
         * The ``cached`` storage policy determines how long to keep data precached.
           Outside of the ``cached`` policy time range, data isn't precached and only resides in lower
         cost deep storage.

         By default, Polaris retains all data and precaches all data.
         You can’t set a custom storage policy for a table that’s actively used by a lookup.
         For more information, see
         `Data lifecycle management
         <https://docs.imply.io/ui/saas/help/data-lifecycle-management.html>`_.
        :paramtype storage_policy: ~polaris.sdk.global_api.models.TableStoragePolicy
        :keyword type: Visualization type. Required. Known values are: "table", "detail", and
         "aggregate".
        :paramtype type: str or ~polaris.sdk.global_api.models.TableType
        :keyword version: The version number of the table. Newly created tables are always initialized
         at version 0. Do not provide the version number when creating a table. When updating a table,
         provide the current table version number. If the version number in the request is not the
         current version, Polaris raises a ``409 Conflict`` error. In that case, retrieve the latest
         version and retry the request to avoid concurrently conflicting changes. Required.
        :paramtype version: int
        :keyword description: The table's description, limited to 1000 characters.
        :paramtype description: str
        """
        super().__init__(**kwargs)
        self.availability = None
        self.created_by_user = None
        self.created_on_timestamp = None
        self.id = None
        self.modified_by_user = None
        self.modified_on_timestamp = None
        self.name = name
        self.partitioning_granularity = partitioning_granularity
        self.schema_mode = schema_mode
        self.segment_count = None
        self.storage_policy = storage_policy
        self.precached_data_size_bytes = None
        self.total_data_size_bytes = None
        self.total_rows = None
        self.type = type
        self.version = version
        self.description = description


class ThemeResponse(Theme, ModificationRecord):
    """Response that includes a theme and its modification record.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar last_modified_by: The user who last modified the customizations.
    :vartype last_modified_by: ~polaris.sdk.global_api.models.User
    :ivar last_update_timestamp: Date and time of the last update in ISO 8601 format.
    :vartype last_update_timestamp: ~datetime.datetime
    :ivar app_palette: Color palette for the Polaris UI.
    :vartype app_palette: ~polaris.sdk.global_api.models.AppColorPalette
    :ivar vis_palette: Color palette for visualizations.
    :vartype vis_palette: ~polaris.sdk.global_api.models.VisualizationColorPalette
    """

    _validation = {
        "last_modified_by": {"readonly": True},
    }

    _attribute_map = {
        "last_modified_by": {"key": "lastModifiedBy", "type": "User"},
        "last_update_timestamp": {"key": "lastUpdateTimestamp", "type": "iso-8601"},
        "app_palette": {"key": "appPalette", "type": "AppColorPalette"},
        "vis_palette": {"key": "visPalette", "type": "VisualizationColorPalette"},
    }

    def __init__(
        self,
        *,
        last_update_timestamp: Optional[datetime.datetime] = None,
        app_palette: Optional["_models.AppColorPalette"] = None,
        vis_palette: Optional["_models.VisualizationColorPalette"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword last_update_timestamp: Date and time of the last update in ISO 8601 format.
        :paramtype last_update_timestamp: ~datetime.datetime
        :keyword app_palette: Color palette for the Polaris UI.
        :paramtype app_palette: ~polaris.sdk.global_api.models.AppColorPalette
        :keyword vis_palette: Color palette for visualizations.
        :paramtype vis_palette: ~polaris.sdk.global_api.models.VisualizationColorPalette
        """
        super().__init__(
            app_palette=app_palette,
            vis_palette=vis_palette,
            last_update_timestamp=last_update_timestamp,
            **kwargs
        )
        self.last_modified_by = None
        self.last_update_timestamp = last_update_timestamp
        self.app_palette = app_palette
        self.vis_palette = vis_palette


class TileBody(TilePayload):
    """TileBody.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar type: Tile type. ``blank`` tiles are empty. ``visualization`` tiles display a data cube
     visualization.
     ``markdown`` tiles display a block of text using `Markdown <https://commonmark.org/help/>`_
     formatting. Known values are: "blank", "visualization", and "markdown".
    :vartype type: str or ~polaris.sdk.global_api.models.TileType
    :ivar title: Tile title to display in the dashboard UI. If not set, defaults to an
     auto-generated title
     based on the displayed dimensions and measures.
    :vartype title: str
    :ivar description: Tile description to display in info popovers in the dashboard UI.
    :vartype description: str
    :ivar position: Position of a tile within a dashboard page.
    :vartype position: ~polaris.sdk.global_api.models.TilePosition
    :ivar essence: Visualization definition for data cubes. This is not applicable to Polaris.
    :vartype essence: dict[str, any]
    :ivar facet_essence: Visualization definition for data cubes.
    :vartype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
    :ivar explore_essence: Visualization definition for data cubes of specific types, including
     overall, gauge, flat table, and time series.
     If you want to use any of these visualizations but you don't see them in Polaris, contact
     Imply support.
    :vartype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
    :ivar title_hidden: Hide the tile title.
    :vartype title_hidden: bool
    :ivar info_hidden: Hide the tile info popover.
    :vartype info_hidden: bool
    :ivar can_expand: Tile can be expanded into a full data cube view.
    :vartype can_expand: bool
    :ivar content: Markdown content to display in the tile. Only applicable if "type" is set to
     "markdown".
     Polaris renders markdown content using `Markdown <https://commonmark.org/help/>`_ formatting.
    :vartype content: str
    :ivar legend_side: Side of the tile to display the legend. Only applicable if ``type`` is set
     to ``visualization``. Known values are: "none", "right", and "bottom".
    :vartype legend_side: str or ~polaris.sdk.global_api.models.LegendSide
    """


class TileListResponse(_serialization.Model):
    """An array of dashboard page tiles.

    All required parameters must be populated in order to send to server.

    :ivar values: An array of dashboard page tiles. Required.
    :vartype values: list[~polaris.sdk.global_api.models.TileListResponseValuesItem]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[TileListResponseValuesItem]"},
    }

    def __init__(
        self, *, values: List["_models.TileListResponseValuesItem"], **kwargs: Any
    ) -> None:
        """
        :keyword values: An array of dashboard page tiles. Required.
        :paramtype values: list[~polaris.sdk.global_api.models.TileListResponseValuesItem]
        """
        super().__init__(**kwargs)
        self.values = values


class TileListResponseValuesItem(TilePayload):
    """TileListResponseValuesItem.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar type: Tile type. ``blank`` tiles are empty. ``visualization`` tiles display a data cube
     visualization.
     ``markdown`` tiles display a block of text using `Markdown <https://commonmark.org/help/>`_
     formatting. Known values are: "blank", "visualization", and "markdown".
    :vartype type: str or ~polaris.sdk.global_api.models.TileType
    :ivar title: Tile title to display in the dashboard UI. If not set, defaults to an
     auto-generated title
     based on the displayed dimensions and measures.
    :vartype title: str
    :ivar description: Tile description to display in info popovers in the dashboard UI.
    :vartype description: str
    :ivar position: Position of a tile within a dashboard page.
    :vartype position: ~polaris.sdk.global_api.models.TilePosition
    :ivar essence: Visualization definition for data cubes. This is not applicable to Polaris.
    :vartype essence: dict[str, any]
    :ivar facet_essence: Visualization definition for data cubes.
    :vartype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
    :ivar explore_essence: Visualization definition for data cubes of specific types, including
     overall, gauge, flat table, and time series.
     If you want to use any of these visualizations but you don't see them in Polaris, contact
     Imply support.
    :vartype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
    :ivar title_hidden: Hide the tile title.
    :vartype title_hidden: bool
    :ivar info_hidden: Hide the tile info popover.
    :vartype info_hidden: bool
    :ivar can_expand: Tile can be expanded into a full data cube view.
    :vartype can_expand: bool
    :ivar content: Markdown content to display in the tile. Only applicable if "type" is set to
     "markdown".
     Polaris renders markdown content using `Markdown <https://commonmark.org/help/>`_ formatting.
    :vartype content: str
    :ivar legend_side: Side of the tile to display the legend. Only applicable if ``type`` is set
     to ``visualization``. Known values are: "none", "right", and "bottom".
    :vartype legend_side: str or ~polaris.sdk.global_api.models.LegendSide
    """


class TilePosition(_serialization.Model):
    """Position of a tile within a dashboard page.

    All required parameters must be populated in order to send to server.

    :ivar x: x-coordinate of the tile within the page, in grid units.
    :vartype x: int
    :ivar y: y-coordinate of the tile within the page, in grid units.
    :vartype y: int
    :ivar width: Width of the tile, in grid units. Required.
    :vartype width: int
    :ivar height: Height of the tile, in grid units. Required.
    :vartype height: int
    """

    _validation = {
        "width": {"required": True},
        "height": {"required": True},
    }

    _attribute_map = {
        "x": {"key": "x", "type": "int"},
        "y": {"key": "y", "type": "int"},
        "width": {"key": "width", "type": "int"},
        "height": {"key": "height", "type": "int"},
    }

    def __init__(
        self, *, width: int, height: int, x: int = 0, y: int = 0, **kwargs: Any
    ) -> None:
        """
        :keyword x: x-coordinate of the tile within the page, in grid units.
        :paramtype x: int
        :keyword y: y-coordinate of the tile within the page, in grid units.
        :paramtype y: int
        :keyword width: Width of the tile, in grid units. Required.
        :paramtype width: int
        :keyword height: Height of the tile, in grid units. Required.
        :paramtype height: int
        """
        super().__init__(**kwargs)
        self.x = x
        self.y = y
        self.width = width
        self.height = height


class TileResponse(TilePayload):
    """TileResponse.

    :ivar additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :vartype additional_properties: dict[str, any]
    :ivar id: Asset ID.
    :vartype id: str
    :ivar type: Tile type. ``blank`` tiles are empty. ``visualization`` tiles display a data cube
     visualization.
     ``markdown`` tiles display a block of text using `Markdown <https://commonmark.org/help/>`_
     formatting. Known values are: "blank", "visualization", and "markdown".
    :vartype type: str or ~polaris.sdk.global_api.models.TileType
    :ivar title: Tile title to display in the dashboard UI. If not set, defaults to an
     auto-generated title
     based on the displayed dimensions and measures.
    :vartype title: str
    :ivar description: Tile description to display in info popovers in the dashboard UI.
    :vartype description: str
    :ivar position: Position of a tile within a dashboard page.
    :vartype position: ~polaris.sdk.global_api.models.TilePosition
    :ivar essence: Visualization definition for data cubes. This is not applicable to Polaris.
    :vartype essence: dict[str, any]
    :ivar facet_essence: Visualization definition for data cubes.
    :vartype facet_essence: ~polaris.sdk.global_api.models.FacetEssence
    :ivar explore_essence: Visualization definition for data cubes of specific types, including
     overall, gauge, flat table, and time series.
     If you want to use any of these visualizations but you don't see them in Polaris, contact
     Imply support.
    :vartype explore_essence: ~polaris.sdk.global_api.models.ExploreEssence
    :ivar title_hidden: Hide the tile title.
    :vartype title_hidden: bool
    :ivar info_hidden: Hide the tile info popover.
    :vartype info_hidden: bool
    :ivar can_expand: Tile can be expanded into a full data cube view.
    :vartype can_expand: bool
    :ivar content: Markdown content to display in the tile. Only applicable if "type" is set to
     "markdown".
     Polaris renders markdown content using `Markdown <https://commonmark.org/help/>`_ formatting.
    :vartype content: str
    :ivar legend_side: Side of the tile to display the legend. Only applicable if ``type`` is set
     to ``visualization``. Known values are: "none", "right", and "bottom".
    :vartype legend_side: str or ~polaris.sdk.global_api.models.LegendSide
    """


class TimeFilter(_serialization.Model):
    """A filter applied to a time dimension.

    :ivar filter_type: "__time"
    :vartype filter_type: str or ~polaris.sdk.global_api.models.TimeFilterType
    :ivar dimension:
    :vartype dimension: str
    :ivar operator: Known values are: "gt", "gte", "lt", and "lte".
    :vartype operator: str or ~polaris.sdk.global_api.models.TimeFilterOperator
    :ivar value:
    :vartype value: str
    """

    _attribute_map = {
        "filter_type": {"key": "filterType", "type": "str"},
        "dimension": {"key": "dimension", "type": "str"},
        "operator": {"key": "operator", "type": "str"},
        "value": {"key": "value", "type": "str"},
    }

    def __init__(
        self,
        *,
        filter_type: Optional[Union[str, "_models.TimeFilterType"]] = None,
        dimension: Optional[str] = None,
        operator: Optional[Union[str, "_models.TimeFilterOperator"]] = None,
        value: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword filter_type: "__time"
        :paramtype filter_type: str or ~polaris.sdk.global_api.models.TimeFilterType
        :keyword dimension:
        :paramtype dimension: str
        :keyword operator: Known values are: "gt", "gte", "lt", and "lte".
        :paramtype operator: str or ~polaris.sdk.global_api.models.TimeFilterOperator
        :keyword value:
        :paramtype value: str
        """
        super().__init__(**kwargs)
        self.filter_type = filter_type
        self.dimension = dimension
        self.operator = operator
        self.value = value


class TimeFilterPreset(_serialization.Model):
    """Custom preset to show in the time filter menu.

    All required parameters must be populated in order to send to server.

    :ivar name: Appears as the UI label in the presets dropdown. Required.
    :vartype name: str
    :ivar selection: Expression defining the time range for the preset. Required.
    :vartype selection: str
    :ivar pill_label: Appears as the label when the value is selected.
    :vartype pill_label: str
    """

    _validation = {
        "name": {"required": True},
        "selection": {"required": True},
    }

    _attribute_map = {
        "name": {"key": "name", "type": "str"},
        "selection": {"key": "selection", "type": "str"},
        "pill_label": {"key": "pillLabel", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        selection: str,
        pill_label: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword name: Appears as the UI label in the presets dropdown. Required.
        :paramtype name: str
        :keyword selection: Expression defining the time range for the preset. Required.
        :paramtype selection: str
        :keyword pill_label: Appears as the label when the value is selected.
        :paramtype pill_label: str
        """
        super().__init__(**kwargs)
        self.name = name
        self.selection = selection
        self.pill_label = pill_label


class TimeFrame(_serialization.Model):
    """TimeFrame.

    All required parameters must be populated in order to send to server.

    :ivar interval: Required. Known values are: "previous_day", "current_day", "previous_week",
     "current_week", "previous_month", "current_month", "previous_quarter", "current_quarter",
     "previous_year", and "current_year".
    :vartype interval: str or ~polaris.sdk.global_api.models.TimeFrameInterval
    :ivar start_day: Required.
    :vartype start_day: float
    :ivar start_time: Required.
    :vartype start_time: float
    """

    _validation = {
        "interval": {"required": True},
        "start_day": {"required": True},
        "start_time": {"required": True},
    }

    _attribute_map = {
        "interval": {"key": "interval", "type": "str"},
        "start_day": {"key": "startDay", "type": "float"},
        "start_time": {"key": "startTime", "type": "float"},
    }

    def __init__(
        self,
        *,
        interval: Union[str, "_models.TimeFrameInterval"],
        start_day: float,
        start_time: float,
        **kwargs: Any
    ) -> None:
        """
        :keyword interval: Required. Known values are: "previous_day", "current_day", "previous_week",
         "current_week", "previous_month", "current_month", "previous_quarter", "current_quarter",
         "previous_year", and "current_year".
        :paramtype interval: str or ~polaris.sdk.global_api.models.TimeFrameInterval
        :keyword start_day: Required.
        :paramtype start_day: float
        :keyword start_time: Required.
        :paramtype start_time: float
        """
        super().__init__(**kwargs)
        self.interval = interval
        self.start_day = start_day
        self.start_time = start_time


class TimeRange(_serialization.Model):
    """Defines a start and end boundary for a time range.

    All required parameters must be populated in order to send to server.

    :ivar start: Start of the time range. Required.
    :vartype start: ~datetime.datetime
    :ivar end: End of the time range. Required.
    :vartype end: ~datetime.datetime
    :ivar bounds: Bounds string describing the range.
    :vartype bounds: str
    """

    _validation = {
        "start": {"required": True},
        "end": {"required": True},
    }

    _attribute_map = {
        "start": {"key": "start", "type": "iso-8601"},
        "end": {"key": "end", "type": "iso-8601"},
        "bounds": {"key": "bounds", "type": "str"},
    }

    def __init__(
        self,
        *,
        start: datetime.datetime,
        end: datetime.datetime,
        bounds: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword start: Start of the time range. Required.
        :paramtype start: ~datetime.datetime
        :keyword end: End of the time range. Required.
        :paramtype end: ~datetime.datetime
        :keyword bounds: Bounds string describing the range.
        :paramtype bounds: str
        """
        super().__init__(**kwargs)
        self.start = start
        self.end = end
        self.bounds = bounds


class Totals(_serialization.Model):
    """Totals.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "totals"
    :vartype type: str or ~polaris.sdk.global_api.models.TotalsType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        type: Optional[Union[str, "_models.TotalsType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "totals"
        :paramtype type: str or ~polaris.sdk.global_api.models.TotalsType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison


class TransferGroup(_serialization.Model):
    """Associates a parameter type with a transfer group. Any parameters belonging to the specified
    type
    and with the same transfer group retain their values when switching visualizations.

    :ivar type:
    :vartype type: str
    :ivar control:
    :vartype control: ~polaris.sdk.global_api.models.TransferGroupControl
    """

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "control": {"key": "control", "type": "TransferGroupControl"},
    }

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        control: Optional["_models.TransferGroupControl"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type:
        :paramtype type: str
        :keyword control:
        :paramtype control: ~polaris.sdk.global_api.models.TransferGroupControl
        """
        super().__init__(**kwargs)
        self.type = type
        self.control = control


class TransferGroupControl(_serialization.Model):
    """TransferGroupControl.

    :ivar transfer_group:
    :vartype transfer_group: str
    """

    _attribute_map = {
        "transfer_group": {"key": "transferGroup", "type": "str"},
    }

    def __init__(self, *, transfer_group: Optional[str] = None, **kwargs: Any) -> None:
        """
        :keyword transfer_group:
        :paramtype transfer_group: str
        """
        super().__init__(**kwargs)
        self.transfer_group = transfer_group


class TreeMap(_serialization.Model):
    """TreeMap.

    All required parameters must be populated in order to send to server.

    :ivar type: Name of the visualization. "treemap"
    :vartype type: str or ~polaris.sdk.global_api.models.TreeMapType
    :ivar data_cube: Id of the description. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar layout: Dimensions to be shown by the layout. Required.
    :vartype layout: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "max_items": 1, "min_items": 1},
        "layout": {"required": True, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "layout": {"key": "layout", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        layout: List[Any],
        type: Optional[Union[str, "_models.TreeMapType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Name of the visualization. "treemap"
        :paramtype type: str or ~polaris.sdk.global_api.models.TreeMapType
        :keyword data_cube: Id of the description. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword layout: Dimensions to be shown by the layout. Required.
        :paramtype layout: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.layout = layout


class UpdateConnectionRequest(_serialization.Model):
    """An abstract request to update a connection.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    UpdateAzureConnectionRequest, UpdateConfluentConnectionRequest,
    UpdateConfluentSchemaRegistryConnectionRequest, UpdateKafkaConnectionRequest,
    UpdateKinesisConnectionRequest, UpdatePushStreamingConnectionRequest, UpdateS3ConnectionRequest

    All required parameters must be populated in order to send to server.

    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    _subtype_map = {
        "type": {
            "azure": "UpdateAzureConnectionRequest",
            "confluent": "UpdateConfluentConnectionRequest",
            "confluent_schema_registry": "UpdateConfluentSchemaRegistryConnectionRequest",
            "kafka": "UpdateKafkaConnectionRequest",
            "kinesis": "UpdateKinesisConnectionRequest",
            "push_streaming": "UpdatePushStreamingConnectionRequest",
            "s3": "UpdateS3ConnectionRequest",
        }
    }

    def __init__(self, *, description: Optional[str] = None, **kwargs: Any) -> None:
        """
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(**kwargs)
        self.type: Optional[str] = None
        self.description = description


class UpdateAzureConnectionRequest(
    UpdateConnectionRequest,
    AzureConnectionProperties,
    ConnectionSecretsOptionalProperties,
):
    """A specific Azure update connection request.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
    :ivar storage_account: Name of the storage account in Azure Blob Storage.
    :vartype storage_account: str
    :ivar container: Name of the container in the specified storage account in Azure Blob Storage.
    :vartype container: str
    :ivar prefix: Prefix to restrict the connection to specific blobs.
    :vartype prefix: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsOptionalPayload"},
        "storage_account": {"key": "storageAccount", "type": "str"},
        "container": {"key": "container", "type": "str"},
        "prefix": {"key": "prefix", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        secrets: Optional["_models.ConnectionSecretsOptionalPayload"] = None,
        storage_account: Optional[str] = None,
        container: Optional[str] = None,
        prefix: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
        :keyword storage_account: Name of the storage account in Azure Blob Storage.
        :paramtype storage_account: str
        :keyword container: Name of the container in the specified storage account in Azure Blob
         Storage.
        :paramtype container: str
        :keyword prefix: Prefix to restrict the connection to specific blobs.
        :paramtype prefix: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            description=description,
            storage_account=storage_account,
            container=container,
            prefix=prefix,
            secrets=secrets,
            **kwargs
        )
        self.secrets = secrets
        self.storage_account = storage_account
        self.container = container
        self.prefix = prefix
        self.type: str = "azure"
        self.description = description


class UpdateConfluentConnectionRequest(
    UpdateConnectionRequest,
    ConfluentConnectionProperties,
    ConnectionSecretsOptionalProperties,
):
    """A specific Confluent update connection request.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
    :ivar bootstrap_servers: List of host and port pairs used for establishing the initial
     connection to the Kafka cluster.
    :vartype bootstrap_servers: str
    :ivar topic_name: The topic name or a regular expression that identifies the Kafka topics.
    :vartype topic_name: str
    :ivar topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris looks
     for a single topic with the exact name in ``topicName``. If true, Polaris treats ``topicName``
     as a regular expression to match topic names. Use this option to ingest data from multiple
     topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
     ``topic23`` but not ``topicAB``.
    :vartype topic_name_is_pattern: bool
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsOptionalPayload"},
        "bootstrap_servers": {"key": "bootstrapServers", "type": "str"},
        "topic_name": {"key": "topicName", "type": "str"},
        "topic_name_is_pattern": {"key": "topicNameIsPattern", "type": "bool"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        secrets: Optional["_models.ConnectionSecretsOptionalPayload"] = None,
        bootstrap_servers: Optional[str] = None,
        topic_name: Optional[str] = None,
        topic_name_is_pattern: bool = False,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
        :keyword bootstrap_servers: List of host and port pairs used for establishing the initial
         connection to the Kafka cluster.
        :paramtype bootstrap_servers: str
        :keyword topic_name: The topic name or a regular expression that identifies the Kafka topics.
        :paramtype topic_name: str
        :keyword topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris
         looks for a single topic with the exact name in ``topicName``. If true, Polaris treats
         ``topicName`` as a regular expression to match topic names. Use this option to ingest data from
         multiple topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
         ``topic23`` but not ``topicAB``.
        :paramtype topic_name_is_pattern: bool
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            description=description,
            bootstrap_servers=bootstrap_servers,
            topic_name=topic_name,
            topic_name_is_pattern=topic_name_is_pattern,
            secrets=secrets,
            **kwargs
        )
        self.secrets = secrets
        self.bootstrap_servers = bootstrap_servers
        self.topic_name = topic_name
        self.topic_name_is_pattern = topic_name_is_pattern
        self.type: str = "confluent"
        self.description = description


class UpdateConfluentSchemaRegistryConnectionRequest(
    UpdateConnectionRequest,
    ConfluentSchemaRegistryConnectionProperties,
    ConnectionSecretsOptionalProperties,
):  # pylint: disable=name-too-long
    """A specific Confluent schema registry update connection request.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
    :ivar urls: List of URLs of Schema Registry instances to look up schemas.
    :vartype urls: list[str]
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsOptionalPayload"},
        "urls": {"key": "urls", "type": "[str]"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        secrets: Optional["_models.ConnectionSecretsOptionalPayload"] = None,
        urls: List[str] = [],
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
        :keyword urls: List of URLs of Schema Registry instances to look up schemas.
        :paramtype urls: list[str]
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(description=description, urls=urls, secrets=secrets, **kwargs)
        self.secrets = secrets
        self.urls = urls
        self.type: str = "confluent_schema_registry"
        self.description = description


class UpdateJobStatusRequest(_serialization.Model):
    """A request to update a job.

    All required parameters must be populated in order to send to server.

    :ivar desired_execution_status: Desired execution status of the job. This field only applies to
     updating an ingestion job and is ignored when creating jobs. You cannot update a deletion job.
     The default desired execution status is ``running`` for jobs that should run to completion.
     Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an unsupported value
     is supplied, Polaris raises a ``400 Bad Request`` error. Known values are: "running",
     "canceled", and "suspended".
    :vartype desired_execution_status: str or
     ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
    """

    _validation = {
        "desired_execution_status": {"required": True},
    }

    _attribute_map = {
        "desired_execution_status": {"key": "desiredExecutionStatus", "type": "str"},
    }

    def __init__(
        self,
        *,
        desired_execution_status: Union[
            str, "_models.DesiredJobExecutionStatusV2"
        ] = "running",
        **kwargs: Any
    ) -> None:
        """
        :keyword desired_execution_status: Desired execution status of the job. This field only applies
         to updating an ingestion job and is ignored when creating jobs. You cannot update a deletion
         job. The default desired execution status is ``running`` for jobs that should run to
         completion. Otherwise, specify the value ``canceled`` to cancel an ingestion job. If an
         unsupported value is supplied, Polaris raises a ``400 Bad Request`` error. Known values are:
         "running", "canceled", and "suspended".
        :paramtype desired_execution_status: str or
         ~polaris.sdk.global_api.models.DesiredJobExecutionStatusV2
        """
        super().__init__(**kwargs)
        self.desired_execution_status = desired_execution_status


class UpdateKafkaConnectionRequest(
    UpdateConnectionRequest,
    KafkaConnectionProperties,
    ConnectionSecretsOptionalProperties,
):
    """A specific Kafka update connection request.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
    :ivar bootstrap_servers: List of host and port pairs used for establishing the initial
     connection to the Kafka cluster.
    :vartype bootstrap_servers: str
    :ivar client_rack: A rack identifier for this client. This can be any string value which
     indicates where this client is physically located. It corresponds with the broker config
     'broker.rack'.
    :vartype client_rack: str
    :ivar ssl: SSL authentication and encryption settings.
    :vartype ssl: ~polaris.sdk.global_api.models.KafkaConnectionPropertiesSsl
    :ivar topic_name: The topic name or a regular expression that identifies the Kafka topics.
    :vartype topic_name: str
    :ivar topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris looks
     for a single topic with the exact name in ``topicName``. If true, Polaris treats ``topicName``
     as a regular expression to match topic names. Use this option to ingest data from multiple
     topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
     ``topic23`` but not ``topicAB``.
    :vartype topic_name_is_pattern: bool
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsOptionalPayload"},
        "bootstrap_servers": {"key": "bootstrapServers", "type": "str"},
        "client_rack": {"key": "clientRack", "type": "str"},
        "ssl": {"key": "ssl", "type": "KafkaConnectionPropertiesSsl"},
        "topic_name": {"key": "topicName", "type": "str"},
        "topic_name_is_pattern": {"key": "topicNameIsPattern", "type": "bool"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        secrets: Optional["_models.ConnectionSecretsOptionalPayload"] = None,
        bootstrap_servers: Optional[str] = None,
        client_rack: Optional[str] = None,
        ssl: Optional["_models.KafkaConnectionPropertiesSsl"] = None,
        topic_name: Optional[str] = None,
        topic_name_is_pattern: bool = False,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
        :keyword bootstrap_servers: List of host and port pairs used for establishing the initial
         connection to the Kafka cluster.
        :paramtype bootstrap_servers: str
        :keyword client_rack: A rack identifier for this client. This can be any string value which
         indicates where this client is physically located. It corresponds with the broker config
         'broker.rack'.
        :paramtype client_rack: str
        :keyword ssl: SSL authentication and encryption settings.
        :paramtype ssl: ~polaris.sdk.global_api.models.KafkaConnectionPropertiesSsl
        :keyword topic_name: The topic name or a regular expression that identifies the Kafka topics.
        :paramtype topic_name: str
        :keyword topic_name_is_pattern: Whether the topic name is a regex pattern. If false, Polaris
         looks for a single topic with the exact name in ``topicName``. If true, Polaris treats
         ``topicName`` as a regular expression to match topic names. Use this option to ingest data from
         multiple topics from the same connection. For example, ``topic[0-9]*`` matches ``topic1`` and
         ``topic23`` but not ``topicAB``.
        :paramtype topic_name_is_pattern: bool
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            description=description,
            bootstrap_servers=bootstrap_servers,
            client_rack=client_rack,
            ssl=ssl,
            topic_name=topic_name,
            topic_name_is_pattern=topic_name_is_pattern,
            secrets=secrets,
            **kwargs
        )
        self.secrets = secrets
        self.bootstrap_servers = bootstrap_servers
        self.client_rack = client_rack
        self.ssl = ssl
        self.topic_name = topic_name
        self.topic_name_is_pattern = topic_name_is_pattern
        self.type: str = "kafka"
        self.description = description


class UpdateKinesisConnectionRequest(
    UpdateConnectionRequest, KinesisConnectionProperties
):
    """A specific Kinesis update connection request.

    All required parameters must be populated in order to send to server.

    :ivar aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
    :vartype aws_assumed_role_arn: str
    :ivar aws_endpoint: The URL of the entry point for the AWS Kinesis connection.
    :vartype aws_endpoint: str
    :ivar stream: The Kinesis stream to read.
    :vartype stream: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "aws_assumed_role_arn": {"key": "awsAssumedRoleArn", "type": "str"},
        "aws_endpoint": {"key": "awsEndpoint", "type": "str"},
        "stream": {"key": "stream", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        aws_assumed_role_arn: Optional[str] = None,
        aws_endpoint: Optional[str] = None,
        stream: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
        :paramtype aws_assumed_role_arn: str
        :keyword aws_endpoint: The URL of the entry point for the AWS Kinesis connection.
        :paramtype aws_endpoint: str
        :keyword stream: The Kinesis stream to read.
        :paramtype stream: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            description=description,
            aws_assumed_role_arn=aws_assumed_role_arn,
            aws_endpoint=aws_endpoint,
            stream=stream,
            **kwargs
        )
        self.aws_assumed_role_arn = aws_assumed_role_arn
        self.aws_endpoint = aws_endpoint
        self.stream = stream
        self.type: str = "kinesis"
        self.description = description


class UpdateLookupAliasesRequest(_serialization.Model):
    """A request to update lookup aliases for a lookup.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.LookupAliasPayload]
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[LookupAliasPayload]"},
    }

    def __init__(
        self, *, values: List["_models.LookupAliasPayload"], **kwargs: Any
    ) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.LookupAliasPayload]
        """
        super().__init__(**kwargs)
        self.values = values


class UpdateLookupRequest(_serialization.Model):
    """A request to update a lookup.

    All required parameters must be populated in order to send to server.

    :ivar source: The source of a lookup.
     The following lookup type is supported:


     * ``table``\\ : A lookup source that references a table. The table
       must be partitioned by ALL granularity and contain a single segment. Required.
    :vartype source: ~polaris.sdk.global_api.models.LookupSourcePayload
    """

    _validation = {
        "source": {"required": True},
    }

    _attribute_map = {
        "source": {"key": "source", "type": "LookupSourcePayload"},
    }

    def __init__(self, *, source: "_models.LookupSourcePayload", **kwargs: Any) -> None:
        """
        :keyword source: The source of a lookup.
         The following lookup type is supported:


         * ``table``\\ : A lookup source that references a table. The table
           must be partitioned by ALL granularity and contain a single segment. Required.
        :paramtype source: ~polaris.sdk.global_api.models.LookupSourcePayload
        """
        super().__init__(**kwargs)
        self.source = source


class UpdatePushStreamingConnectionRequest(
    UpdateConnectionRequest, PushStreamingConnectionProperties
):
    """A specific push streaming update connection request.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to server.

    :ivar endpoint_url:
    :vartype endpoint_url: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "endpoint_url": {"readonly": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "endpoint_url": {"key": "endpointUrl", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(self, *, description: Optional[str] = None, **kwargs: Any) -> None:
        """
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(description=description, **kwargs)
        self.endpoint_url = None
        self.type: str = "push_streaming"
        self.description = description


class UpdateS3ConnectionRequest(
    UpdateConnectionRequest, S3ConnectionProperties, ConnectionSecretsOptionalProperties
):
    """A specific S3 update connection request.

    All required parameters must be populated in order to send to server.

    :ivar secrets: Type of connection secrets.
     The following secrets types are supported:


     * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
     * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
     * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
     use a Confluent Schema Registry API key and secret.
     * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
     * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
     * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
     Cloud connections.
     * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
    :vartype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
    :ivar aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
    :vartype aws_assumed_role_arn: str
    :ivar aws_endpoint: The URL of the entry point for the Amazon S3 bucket.
    :vartype aws_endpoint: str
    :ivar bucket: The name of the bucket containing the desired object.
    :vartype bucket: str
    :ivar prefix: Prefix to restrict the connection to specific keys.
    :vartype prefix: str
    :ivar type: Connection type. For reference on the information required for each connection
     type, see `Create a connection <https://docs.imply.io/polaris/connections>`_. Required. Known
     values are: "azure", "confluent", "confluent_schema_registry", "kafka", "kinesis",
     "push_streaming", and "s3".
    :vartype type: str or ~polaris.sdk.global_api.models.ConnectionTypePayload
    :ivar description: Optional description for the connection.
    :vartype description: str
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "secrets": {"key": "secrets", "type": "ConnectionSecretsOptionalPayload"},
        "aws_assumed_role_arn": {"key": "awsAssumedRoleArn", "type": "str"},
        "aws_endpoint": {"key": "awsEndpoint", "type": "str"},
        "bucket": {"key": "bucket", "type": "str"},
        "prefix": {"key": "prefix", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "description": {"key": "description", "type": "str"},
    }

    def __init__(
        self,
        *,
        secrets: Optional["_models.ConnectionSecretsOptionalPayload"] = None,
        aws_assumed_role_arn: Optional[str] = None,
        aws_endpoint: Optional[str] = None,
        bucket: Optional[str] = None,
        prefix: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword secrets: Type of connection secrets.
         The following secrets types are supported:


         * ``access_key``\\ : Access key to authenticate Azure Blob Storage or AWS S3 connections.
         * ``aws_iam``\\ : For AWS IAM role assumption. Supported for MSK (Kafka) connections.
         * ``basic``\\ : Basic access authentication. Select this type for SQL connections or when you
         use a Confluent Schema Registry API key and secret.
         * ``confluent``\\ : Deprecated. For Confluent connections only. Instead use ``sasl_plain``.
         * ``sas_token``\\ : Shared access signature (SAS) token for Azure Blob Storage.
         * ``sasl_plain``\\ : Authentication mechanism of SASL/PLAIN. Supported for Kafka and Confluent
         Cloud connections.
         * ``sasl_scram``\\ : Authentication mechanism of SASL/SCRAM. Supported for Kafka connections.
        :paramtype secrets: ~polaris.sdk.global_api.models.ConnectionSecretsOptionalPayload
        :keyword aws_assumed_role_arn: The AWS assumed role to use for additional permissions.
        :paramtype aws_assumed_role_arn: str
        :keyword aws_endpoint: The URL of the entry point for the Amazon S3 bucket.
        :paramtype aws_endpoint: str
        :keyword bucket: The name of the bucket containing the desired object.
        :paramtype bucket: str
        :keyword prefix: Prefix to restrict the connection to specific keys.
        :paramtype prefix: str
        :keyword description: Optional description for the connection.
        :paramtype description: str
        """
        super().__init__(
            description=description,
            aws_assumed_role_arn=aws_assumed_role_arn,
            aws_endpoint=aws_endpoint,
            bucket=bucket,
            prefix=prefix,
            secrets=secrets,
            **kwargs
        )
        self.secrets = secrets
        self.aws_assumed_role_arn = aws_assumed_role_arn
        self.aws_endpoint = aws_endpoint
        self.bucket = bucket
        self.prefix = prefix
        self.type: str = "s3"
        self.description = description


class UploadedJobSourceSummary(JobSourceSummary):
    """A summary of a source input comprised of a set of files uploaded to Imply Polaris.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
    }

    def __init__(self, **kwargs: Any) -> None:
        """ """
        super().__init__(**kwargs)
        self.type: str = "uploaded"


class UploadedJobSourceV2(JobSourceV2):
    """A source input comprised of a set of files uploaded to Imply Polaris.

    All required parameters must be populated in order to send to server.

    :ivar type: Source of input data for an ingestion job:
    
    
     * ``azure``\\ : Ingest data from an Azure Blob Storage connection.
     * ``connection``\\ : Ingest data from a connection. Don't use this source type for ``azure``\\
     , ``s3``\\ , or ``sql`` connections.
     * ``s3``\\ : Ingest data from an Amazon S3 connection.
     * ``table``\\ : Ingest data from an existing Polaris table.
     * ``inline``\\ : Ingest inline data.
     * ``uploaded``\\ : Ingest data from one or more files uploaded to Polaris. Required. Known
     values are: "azure", "connection", "s3", "table", "inline", and "uploaded".
    :vartype type: str or ~polaris.sdk.global_api.models.JobSourceTypeV2
    :ivar file_list: List of files to ingest. All files must have the same format, for example,
     newline-delimited JSON. To ingest files with different formats or format settings, split into
     multiple ingestion jobs. Required.
    :vartype file_list: list[str]
    :ivar input_schema: The schema of input data in terms of a list of input field names and their
     respective data types. Required.
    :vartype input_schema: list[~polaris.sdk.global_api.models.FieldNameAndDataType]
    :ivar format_settings: Data format settings that apply to all files in the ingestion job.
     Polaris automatically detects the file type based on the file extension. If you specify a value
     that does not match the automatically detected type, Polaris attempts to ingest based on the
     user-specified value.
    :vartype format_settings: ~polaris.sdk.global_api.models.DataFormatSettings
    """

    _validation = {
        "type": {"required": True},
        "file_list": {"required": True},
        "input_schema": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "file_list": {"key": "fileList", "type": "[str]"},
        "input_schema": {"key": "inputSchema", "type": "[FieldNameAndDataType]"},
        "format_settings": {"key": "formatSettings", "type": "DataFormatSettings"},
    }

    def __init__(
        self,
        *,
        file_list: List[str],
        input_schema: List["_models.FieldNameAndDataType"] = [],
        format_settings: Optional["_models.DataFormatSettings"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword file_list: List of files to ingest. All files must have the same format, for example,
         newline-delimited JSON. To ingest files with different formats or format settings, split into
         multiple ingestion jobs. Required.
        :paramtype file_list: list[str]
        :keyword input_schema: The schema of input data in terms of a list of input field names and
         their respective data types. Required.
        :paramtype input_schema: list[~polaris.sdk.global_api.models.FieldNameAndDataType]
        :keyword format_settings: Data format settings that apply to all files in the ingestion job.
         Polaris automatically detects the file type based on the file extension. If you specify a value
         that does not match the automatically detected type, Polaris attempts to ingest based on the
         user-specified value.
        :paramtype format_settings: ~polaris.sdk.global_api.models.DataFormatSettings
        """
        super().__init__(**kwargs)
        self.type: str = "uploaded"
        self.file_list = file_list
        self.input_schema = input_schema
        self.format_settings = format_settings


class User(_serialization.Model):
    """The user.

    All required parameters must be populated in order to send to server.

    :ivar username: The username of the user. Required.
    :vartype username: str
    :ivar user_id: The unique ID of the user. Required.
    :vartype user_id: str
    """

    _validation = {
        "username": {"required": True},
        "user_id": {"required": True},
    }

    _attribute_map = {
        "username": {"key": "username", "type": "str"},
        "user_id": {"key": "userId", "type": "str"},
    }

    def __init__(self, *, username: str, user_id: str, **kwargs: Any) -> None:
        """
        :keyword username: The username of the user. Required.
        :paramtype username: str
        :keyword user_id: The unique ID of the user. Required.
        :paramtype user_id: str
        """
        super().__init__(**kwargs)
        self.username = username
        self.user_id = user_id


class User1(_serialization.Model):
    """Username.

    :ivar username: Username.
    :vartype username: str
    :ivar user_id: User ID.
    :vartype user_id: str
    """

    _attribute_map = {
        "username": {"key": "username", "type": "str"},
        "user_id": {"key": "userId", "type": "str"},
    }

    def __init__(
        self,
        *,
        username: Optional[str] = None,
        user_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword username: Username.
        :paramtype username: str
        :keyword user_id: User ID.
        :paramtype user_id: str
        """
        super().__init__(**kwargs)
        self.username = username
        self.user_id = user_id


class User2(_serialization.Model):
    """Username.

    :ivar username: Username of the user.
    :vartype username: str
    :ivar user_id: ID of the user.
    :vartype user_id: str
    """

    _attribute_map = {
        "username": {"key": "username", "type": "str"},
        "user_id": {"key": "userId", "type": "str"},
    }

    def __init__(
        self,
        *,
        username: Optional[str] = None,
        user_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword username: Username of the user.
        :paramtype username: str
        :keyword user_id: ID of the user.
        :paramtype user_id: str
        """
        super().__init__(**kwargs)
        self.username = username
        self.user_id = user_id


class UserListRepresentation(_serialization.Model):
    """UserListRepresentation.

    All required parameters must be populated in order to send to server.

    :ivar values: Required.
    :vartype values: list[~polaris.sdk.global_api.models.UserRepresentation]
    :ivar count: The total number of items that can be paged through.
    :vartype count: int
    """

    _validation = {
        "values": {"required": True},
    }

    _attribute_map = {
        "values": {"key": "values", "type": "[UserRepresentation]"},
        "count": {"key": "count", "type": "int"},
    }

    def __init__(
        self,
        *,
        values: List["_models.UserRepresentation"],
        count: Optional[int] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword values: Required.
        :paramtype values: list[~polaris.sdk.global_api.models.UserRepresentation]
        :keyword count: The total number of items that can be paged through.
        :paramtype count: int
        """
        super().__init__(**kwargs)
        self.values = values
        self.count = count


class UserRepresentation(_serialization.Model):
    """UserRepresentation.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar id: A generated, permanently unique ID for this user.
    :vartype id: str
    :ivar username: The username for the user. The username must be a valid email address. Once
     set, ``username`` cannot be modified.
    :vartype username: str
    :ivar email: The user's email address. This property is set to the same value as ``username``.
    :vartype email: str
    :ivar first_name: The user's first name.
    :vartype first_name: str
    :ivar last_name: The user's last name.
    :vartype last_name: str
    :ivar enabled: Flag to indicate the user is enabled.
    :vartype enabled: bool
    :ivar email_verified: Flag to indicate the user's email has been verified.
    :vartype email_verified: bool
    :ivar permissions: The list of permissions individually assigned to the user.
    :vartype permissions: list[~polaris.sdk.global_api.models.PermissionRepresentation]
    :ivar groups: The list of groups the user belongs to.
    :vartype groups: list[~polaris.sdk.global_api.models.GroupRepresentation]
    :ivar identities: The list of external identities for the user.
    :vartype identities: list[~polaris.sdk.global_api.models.IdentityRepresentation]
    :ivar actions: The list of tasks a user must complete before being able to login.
    :vartype actions: list[str or ~polaris.sdk.global_api.models.UserRepresentationActionsItem]
    :ivar created_on: Time of creation.
    :vartype created_on: ~datetime.datetime
    """

    _validation = {
        "id": {"readonly": True},
        "email": {"readonly": True},
        "email_verified": {"readonly": True},
        "identities": {"readonly": True},
        "created_on": {"readonly": True},
    }

    _attribute_map = {
        "id": {"key": "id", "type": "str"},
        "username": {"key": "username", "type": "str"},
        "email": {"key": "email", "type": "str"},
        "first_name": {"key": "firstName", "type": "str"},
        "last_name": {"key": "lastName", "type": "str"},
        "enabled": {"key": "enabled", "type": "bool"},
        "email_verified": {"key": "emailVerified", "type": "bool"},
        "permissions": {"key": "permissions", "type": "[PermissionRepresentation]"},
        "groups": {"key": "groups", "type": "[GroupRepresentation]"},
        "identities": {"key": "identities", "type": "[IdentityRepresentation]"},
        "actions": {"key": "actions", "type": "[str]"},
        "created_on": {"key": "createdOn", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        username: Optional[str] = None,
        first_name: Optional[str] = None,
        last_name: Optional[str] = None,
        enabled: bool = True,
        permissions: Optional[List["_models.PermissionRepresentation"]] = None,
        groups: Optional[List["_models.GroupRepresentation"]] = None,
        actions: Optional[
            List[Union[str, "_models.UserRepresentationActionsItem"]]
        ] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword username: The username for the user. The username must be a valid email address. Once
         set, ``username`` cannot be modified.
        :paramtype username: str
        :keyword first_name: The user's first name.
        :paramtype first_name: str
        :keyword last_name: The user's last name.
        :paramtype last_name: str
        :keyword enabled: Flag to indicate the user is enabled.
        :paramtype enabled: bool
        :keyword permissions: The list of permissions individually assigned to the user.
        :paramtype permissions: list[~polaris.sdk.global_api.models.PermissionRepresentation]
        :keyword groups: The list of groups the user belongs to.
        :paramtype groups: list[~polaris.sdk.global_api.models.GroupRepresentation]
        :keyword actions: The list of tasks a user must complete before being able to login.
        :paramtype actions: list[str or ~polaris.sdk.global_api.models.UserRepresentationActionsItem]
        """
        super().__init__(**kwargs)
        self.id = None
        self.username = username
        self.email = None
        self.first_name = first_name
        self.last_name = last_name
        self.enabled = enabled
        self.email_verified = None
        self.permissions = permissions
        self.groups = groups
        self.identities = None
        self.actions = actions
        self.created_on = None


class VerticalBars(_serialization.Model):
    """VerticalBars.

    All required parameters must be populated in order to send to server.

    :ivar type: Visualization type. "vertical-bars"
    :vartype type: str or ~polaris.sdk.global_api.models.VerticalBarsType
    :ivar data_cube: Data cube ID. Required.
    :vartype data_cube: str
    :ivar filter: Filter to apply to a query.
    :vartype filter: ~polaris.sdk.global_api.models.Filter
    :ivar measures: Array of measures to be displayed. Required.
    :vartype measures: list[any]
    :ivar comparison:
    :vartype comparison: ~polaris.sdk.global_api.models.Comparison
    :ivar bars: Dimensions to be shown by the bars. Required.
    :vartype bars: list[any]
    :ivar stack: Dimensions to be shown by the stack.
    :vartype stack: list[any]
    :ivar multiples: Dimensions to be shown by the multiples.
    :vartype multiples: list[any]
    """

    _validation = {
        "data_cube": {"required": True},
        "measures": {"required": True, "min_items": 1},
        "bars": {"required": True, "max_items": 1, "min_items": 1},
        "stack": {"max_items": 1, "min_items": 1},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "data_cube": {"key": "dataCube", "type": "str"},
        "filter": {"key": "filter", "type": "Filter"},
        "measures": {"key": "measures", "type": "[object]"},
        "comparison": {"key": "comparison", "type": "Comparison"},
        "bars": {"key": "bars", "type": "[object]"},
        "stack": {"key": "stack", "type": "[object]"},
        "multiples": {"key": "multiples", "type": "[object]"},
    }

    def __init__(
        self,
        *,
        data_cube: str,
        measures: List[Any],
        bars: List[Any],
        type: Optional[Union[str, "_models.VerticalBarsType"]] = None,
        filter: Optional["_models.Filter"] = None,  # pylint: disable=redefined-builtin
        comparison: Optional["_models.Comparison"] = None,
        stack: Optional[List[Any]] = None,
        multiples: Optional[List[Any]] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Visualization type. "vertical-bars"
        :paramtype type: str or ~polaris.sdk.global_api.models.VerticalBarsType
        :keyword data_cube: Data cube ID. Required.
        :paramtype data_cube: str
        :keyword filter: Filter to apply to a query.
        :paramtype filter: ~polaris.sdk.global_api.models.Filter
        :keyword measures: Array of measures to be displayed. Required.
        :paramtype measures: list[any]
        :keyword comparison:
        :paramtype comparison: ~polaris.sdk.global_api.models.Comparison
        :keyword bars: Dimensions to be shown by the bars. Required.
        :paramtype bars: list[any]
        :keyword stack: Dimensions to be shown by the stack.
        :paramtype stack: list[any]
        :keyword multiples: Dimensions to be shown by the multiples.
        :paramtype multiples: list[any]
        """
        super().__init__(**kwargs)
        self.type = type
        self.data_cube = data_cube
        self.filter = filter
        self.measures = measures
        self.comparison = comparison
        self.bars = bars
        self.stack = stack
        self.multiples = multiples


class VisualizationColorPalette(_serialization.Model):
    """Color palette for visualizations. Use the 6-character hex format for all colors.

    :ivar primary_color: The primary color to apply to a visualization. For a bar chart with a
     single dimension, bars adopt this color.
    :vartype primary_color: str
    :ivar null_color: A single color for background and unpopulated areas.
    :vartype null_color: str
    :ivar other_color: The color for dimensional values that do not fit in a visualization.
    :vartype other_color: str
    :ivar categorical_palette: A set of colors used to differentiate category-oriented data.
     Configure a minimum of 2 colors and a maximum of 20 colors.
    :vartype categorical_palette: list[str]
    :ivar diverging_palette: Color palette to apply to Heatmap visualizations only.
    :vartype diverging_palette: ~polaris.sdk.global_api.models.DivergingColorPalette
    """

    _validation = {
        "primary_color": {"pattern": r"^#[\da-fA-F]{6}$"},
        "null_color": {"pattern": r"^#[\da-fA-F]{6}$"},
        "other_color": {"pattern": r"^#[\da-fA-F]{6}$"},
        "categorical_palette": {"max_items": 20, "min_items": 2},
    }

    _attribute_map = {
        "primary_color": {"key": "primaryColor", "type": "str"},
        "null_color": {"key": "nullColor", "type": "str"},
        "other_color": {"key": "otherColor", "type": "str"},
        "categorical_palette": {"key": "categoricalPalette", "type": "[str]"},
        "diverging_palette": {
            "key": "divergingPalette",
            "type": "DivergingColorPalette",
        },
    }

    def __init__(
        self,
        *,
        primary_color: Optional[str] = None,
        null_color: Optional[str] = None,
        other_color: Optional[str] = None,
        categorical_palette: Optional[List[str]] = None,
        diverging_palette: Optional["_models.DivergingColorPalette"] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword primary_color: The primary color to apply to a visualization. For a bar chart with a
         single dimension, bars adopt this color.
        :paramtype primary_color: str
        :keyword null_color: A single color for background and unpopulated areas.
        :paramtype null_color: str
        :keyword other_color: The color for dimensional values that do not fit in a visualization.
        :paramtype other_color: str
        :keyword categorical_palette: A set of colors used to differentiate category-oriented data.
         Configure a minimum of 2 colors and a maximum of 20 colors.
        :paramtype categorical_palette: list[str]
        :keyword diverging_palette: Color palette to apply to Heatmap visualizations only.
        :paramtype diverging_palette: ~polaris.sdk.global_api.models.DivergingColorPalette
        """
        super().__init__(**kwargs)
        self.primary_color = primary_color
        self.null_color = null_color
        self.other_color = other_color
        self.categorical_palette = categorical_palette
        self.diverging_palette = diverging_palette


class Webhook(_serialization.Model):
    """URL and payload for a webhook to call when the alert triggers.

    All required parameters must be populated in order to send to server.

    :ivar type: Specify ``slack`` to send a preconfigured Slack message, or ``custom`` to define a
     custom payload. Required. Known values are: "slack" and "custom".
    :vartype type: str or ~polaris.sdk.global_api.models.WebhookType
    :ivar url: URL to call when the alert triggers. Required.
    :vartype url: str
    :ivar auth_header: Authorization header to include in the webhook call.
    :vartype auth_header: str
    :ivar payload: Stringified JSON payload to send with the webhook call. You can include the
     following
     template variables in the payload, expressed as ``%variableName%``\\ :


     * ``%title%``\\ : Alert title.
     * ``%triggerDate%``\\ : Timestamp when the alert was triggered.
     * ``%color%``\\ : Alert color determined by its severity, expressed as an HTML color code.
     * ``%link%``\\ : Link to the alert evaluation in Polaris.
     * ``%summary%``\\ : Alert summary.
     * ``%summaryData%``\\ : Alert details.
     * ``%severity%``\\ : Alert severity.
     * ``%footer%``\\ : "Sent by Imply"
     * ``%checkFrequency%``\\ : Human-readableCheck frequency.
     * ``%timeFrame%``\\ : Human-readable alert timeframe. Required.
    :vartype payload: str
    """

    _validation = {
        "type": {"required": True},
        "url": {"required": True},
        "payload": {"required": True},
    }

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "url": {"key": "url", "type": "str"},
        "auth_header": {"key": "authHeader", "type": "str"},
        "payload": {"key": "payload", "type": "str"},
    }

    def __init__(
        self,
        *,
        type: Union[str, "_models.WebhookType"],
        url: str,
        payload: str,
        auth_header: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """
        :keyword type: Specify ``slack`` to send a preconfigured Slack message, or ``custom`` to define
         a custom payload. Required. Known values are: "slack" and "custom".
        :paramtype type: str or ~polaris.sdk.global_api.models.WebhookType
        :keyword url: URL to call when the alert triggers. Required.
        :paramtype url: str
        :keyword auth_header: Authorization header to include in the webhook call.
        :paramtype auth_header: str
        :keyword payload: Stringified JSON payload to send with the webhook call. You can include the
         following
         template variables in the payload, expressed as ``%variableName%``\\ :


         * ``%title%``\\ : Alert title.
         * ``%triggerDate%``\\ : Timestamp when the alert was triggered.
         * ``%color%``\\ : Alert color determined by its severity, expressed as an HTML color code.
         * ``%link%``\\ : Link to the alert evaluation in Polaris.
         * ``%summary%``\\ : Alert summary.
         * ``%summaryData%``\\ : Alert details.
         * ``%severity%``\\ : Alert severity.
         * ``%footer%``\\ : "Sent by Imply"
         * ``%checkFrequency%``\\ : Human-readableCheck frequency.
         * ``%timeFrame%``\\ : Human-readable alert timeframe. Required.
        :paramtype payload: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.url = url
        self.auth_header = auth_header
        self.payload = payload
