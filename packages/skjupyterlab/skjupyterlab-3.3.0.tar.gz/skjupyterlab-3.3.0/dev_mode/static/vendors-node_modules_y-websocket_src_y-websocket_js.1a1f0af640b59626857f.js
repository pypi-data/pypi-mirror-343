(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_y-websocket_src_y-websocket_js"],{

/***/ "../node_modules/lib0/broadcastchannel.js":
/*!************************************************!*\
  !*** ../node_modules/lib0/broadcastchannel.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "subscribe": () => (/* binding */ subscribe),
/* harmony export */   "unsubscribe": () => (/* binding */ unsubscribe),
/* harmony export */   "publish": () => (/* binding */ publish)
/* harmony export */ });
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ "../node_modules/lib0/map.js");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "../node_modules/lib0/buffer.js");
/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage.js */ "../node_modules/lib0/storage.js");
/* eslint-env browser */

/**
 * Helpers for cross-tab communication using broadcastchannel with LocalStorage fallback.
 *
 * ```js
 * // In browser window A:
 * broadcastchannel.subscribe('my events', data => console.log(data))
 * broadcastchannel.publish('my events', 'Hello world!') // => A: 'Hello world!' fires synchronously in same tab
 *
 * // In browser window B:
 * broadcastchannel.publish('my events', 'hello from tab B') // => A: 'hello from tab B'
 * ```
 *
 * @module broadcastchannel
 */

// @todo before next major: use Uint8Array instead as buffer object





/**
 * @typedef {Object} Channel
 * @property {Set<Function>} Channel.subs
 * @property {any} Channel.bc
 */

/**
 * @type {Map<string, Channel>}
 */
const channels = new Map()

class LocalStoragePolyfill {
  /**
   * @param {string} room
   */
  constructor (room) {
    this.room = room
    /**
     * @type {null|function({data:ArrayBuffer}):void}
     */
    this.onmessage = null
    _storage_js__WEBPACK_IMPORTED_MODULE_0__.onChange(e => e.key === room && this.onmessage !== null && this.onmessage({ data: _buffer_js__WEBPACK_IMPORTED_MODULE_1__.fromBase64(e.newValue || '') }))
  }

  /**
   * @param {ArrayBuffer} buf
   */
  postMessage (buf) {
    _storage_js__WEBPACK_IMPORTED_MODULE_0__.varStorage.setItem(this.room, _buffer_js__WEBPACK_IMPORTED_MODULE_1__.toBase64(_buffer_js__WEBPACK_IMPORTED_MODULE_1__.createUint8ArrayFromArrayBuffer(buf)))
  }
}

// Use BroadcastChannel or Polyfill
const BC = typeof BroadcastChannel === 'undefined' ? LocalStoragePolyfill : BroadcastChannel

/**
 * @param {string} room
 * @return {Channel}
 */
const getChannel = room =>
  _map_js__WEBPACK_IMPORTED_MODULE_2__.setIfUndefined(channels, room, () => {
    const subs = new Set()
    const bc = new BC(room)
    /**
     * @param {{data:ArrayBuffer}} e
     */
    bc.onmessage = e => subs.forEach(sub => sub(e.data))
    return {
      bc, subs
    }
  })

/**
 * Subscribe to global `publish` events.
 *
 * @function
 * @param {string} room
 * @param {function(any):any} f
 */
const subscribe = (room, f) => getChannel(room).subs.add(f)

/**
 * Unsubscribe from `publish` global events.
 *
 * @function
 * @param {string} room
 * @param {function(any):any} f
 */
const unsubscribe = (room, f) => getChannel(room).subs.delete(f)

/**
 * Publish data to all subscribers (including subscribers on this tab)
 *
 * @function
 * @param {string} room
 * @param {any} data
 */
const publish = (room, data) => {
  const c = getChannel(room)
  c.bc.postMessage(data)
  c.subs.forEach(sub => sub(data))
}


/***/ }),

/***/ "../node_modules/lib0/mutex.js":
/*!*************************************!*\
  !*** ../node_modules/lib0/mutex.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMutex": () => (/* binding */ createMutex)
/* harmony export */ });
/**
 * Mutual exclude for JavaScript.
 *
 * @module mutex
 */

/**
 * @callback mutex
 * @param {function():void} cb Only executed when this mutex is not in the current stack
 * @param {function():void} [elseCb] Executed when this mutex is in the current stack
 */

/**
 * Creates a mutual exclude function with the following property:
 *
 * ```js
 * const mutex = createMutex()
 * mutex(() => {
 *   // This function is immediately executed
 *   mutex(() => {
 *     // This function is not executed, as the mutex is already active.
 *   })
 * })
 * ```
 *
 * @return {mutex} A mutual exclude function
 * @public
 */
const createMutex = () => {
  let token = true
  return (f, g) => {
    if (token) {
      token = false
      try {
        f()
      } finally {
        token = true
      }
    } else if (g !== undefined) {
      g()
    }
  }
}


/***/ }),

/***/ "../node_modules/lib0/url.js":
/*!***********************************!*\
  !*** ../node_modules/lib0/url.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeQueryParams": () => (/* binding */ decodeQueryParams),
/* harmony export */   "encodeQueryParams": () => (/* binding */ encodeQueryParams)
/* harmony export */ });
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object.js */ "../node_modules/lib0/object.js");
/**
 * Utility module to work with urls.
 *
 * @module url
 */



/**
 * Parse query parameters from an url.
 *
 * @param {string} url
 * @return {Object<string,string>}
 */
const decodeQueryParams = url => {
  /**
   * @type {Object<string,string>}
   */
  const query = {}
  const urlQuerySplit = url.split('?')
  const pairs = urlQuerySplit[urlQuerySplit.length - 1].split('&')
  for (var i = 0; i < pairs.length; i++) {
    const item = pairs[i]
    if (item.length > 0) {
      const pair = item.split('=')
      query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '')
    }
  }
  return query
}

/**
 * @param {Object<string,string>} params
 * @return {string}
 */
const encodeQueryParams = params =>
  _object_js__WEBPACK_IMPORTED_MODULE_0__.map(params, (val, key) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join('&')


/***/ }),

/***/ "../node_modules/y-protocols/auth.js":
/*!*******************************************!*\
  !*** ../node_modules/y-protocols/auth.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "messagePermissionDenied": () => (/* binding */ messagePermissionDenied),
/* harmony export */   "writePermissionDenied": () => (/* binding */ writePermissionDenied),
/* harmony export */   "readAuthMessage": () => (/* binding */ readAuthMessage)
/* harmony export */ });
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/encoding */ "../node_modules/lib0/encoding.js");
/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/decoding */ "../node_modules/lib0/decoding.js");

 // eslint-disable-line



const messagePermissionDenied = 0

/**
 * @param {encoding.Encoder} encoder
 * @param {string} reason
 */
const writePermissionDenied = (encoder, reason) => {
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint(encoder, messagePermissionDenied)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarString(encoder, reason)
}

/**
 * @callback PermissionDeniedHandler
 * @param {any} y
 * @param {string} reason
 */

/**
 *
 * @param {decoding.Decoder} decoder
 * @param {Y.Doc} y
 * @param {PermissionDeniedHandler} permissionDeniedHandler
 */
const readAuthMessage = (decoder, y, permissionDeniedHandler) => {
  switch (lib0_decoding__WEBPACK_IMPORTED_MODULE_2__.readVarUint(decoder)) {
    case messagePermissionDenied: permissionDeniedHandler(y, lib0_decoding__WEBPACK_IMPORTED_MODULE_2__.readVarString(decoder))
  }
}


/***/ }),

/***/ "../node_modules/y-protocols/awareness.js":
/*!************************************************!*\
  !*** ../node_modules/y-protocols/awareness.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "outdatedTimeout": () => (/* binding */ outdatedTimeout),
/* harmony export */   "Awareness": () => (/* binding */ Awareness),
/* harmony export */   "removeAwarenessStates": () => (/* binding */ removeAwarenessStates),
/* harmony export */   "encodeAwarenessUpdate": () => (/* binding */ encodeAwarenessUpdate),
/* harmony export */   "modifyAwarenessUpdate": () => (/* binding */ modifyAwarenessUpdate),
/* harmony export */   "applyAwarenessUpdate": () => (/* binding */ applyAwarenessUpdate)
/* harmony export */ });
/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/encoding */ "../node_modules/lib0/encoding.js");
/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/decoding */ "../node_modules/lib0/decoding.js");
/* harmony import */ var lib0_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/time */ "../node_modules/lib0/time.js");
/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/math */ "../node_modules/lib0/math.js");
/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/observable */ "../node_modules/lib0/observable.js");
/* harmony import */ var lib0_function__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/function */ "../node_modules/lib0/function.js");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @module awareness-protocol
 */







 // eslint-disable-line

const outdatedTimeout = 30000

/**
 * @typedef {Object} MetaClientState
 * @property {number} MetaClientState.clock
 * @property {number} MetaClientState.lastUpdated unix timestamp
 */

/**
 * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information
 * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of
 * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.
 *
 * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override
 * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is
 * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that
 * a remote client is offline, it may propagate a message with
 * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a
 * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.
 *
 * Before a client disconnects, it should propagate a `null` state with an updated clock.
 *
 * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.
 *
 * @extends {Observable<string>}
 */
class Awareness extends lib0_observable__WEBPACK_IMPORTED_MODULE_1__.Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor (doc) {
    super()
    this.doc = doc
    /**
     * @type {number}
     */
    this.clientID = doc.clientID
    /**
     * Maps from client id to client state
     * @type {Map<number, Object<string, any>>}
     */
    this.states = new Map()
    /**
     * @type {Map<number, MetaClientState>}
     */
    this.meta = new Map()
    this._checkInterval = /** @type {any} */ (setInterval(() => {
      const now = lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {
        // renew local clock
        this.setLocalState(this.getLocalState())
      }
      /**
       * @type {Array<number>}
       */
      const remove = []
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid)
        }
      })
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, 'timeout')
      }
    }, lib0_math__WEBPACK_IMPORTED_MODULE_3__.floor(outdatedTimeout / 10)))
    doc.on('destroy', () => {
      this.destroy()
    })
    this.setLocalState({})
  }

  destroy () {
    this.emit('destroy', [this])
    this.setLocalState(null)
    super.destroy()
    clearInterval(this._checkInterval)
  }

  /**
   * @return {Object<string,any>|null}
   */
  getLocalState () {
    return this.states.get(this.clientID) || null
  }

  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState (state) {
    const clientID = this.clientID
    const currLocalMeta = this.meta.get(clientID)
    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1
    const prevState = this.states.get(clientID)
    if (state === null) {
      this.states.delete(clientID)
    } else {
      this.states.set(clientID, state)
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
    })
    const added = []
    const updated = []
    const filteredUpdated = []
    const removed = []
    if (state === null) {
      removed.push(clientID)
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID)
      }
    } else {
      updated.push(clientID)
      if (!lib0_function__WEBPACK_IMPORTED_MODULE_4__.equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID)
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])
    }
    this.emit('update', [{ added, updated, removed }, 'local'])
  }

  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField (field, value) {
    const state = this.getLocalState()
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      })
    }
  }

  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates () {
    return this.states
  }
}

/**
 * Mark (remote) clients as inactive and remove them from the list of active peers.
 * This change will be propagated to remote clients.
 *
 * @param {Awareness} awareness
 * @param {Array<number>} clients
 * @param {any} origin
 */
const removeAwarenessStates = (awareness, clients, origin) => {
  const removed = []
  for (let i = 0; i < clients.length; i++) {
    const clientID = clients[i]
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID)
      if (clientID === awareness.clientID) {
        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
        })
      }
      removed.push(clientID)
    }
  }
  if (removed.length > 0) {
    awareness.emit('change', [{ added: [], updated: [], removed }, origin])
    awareness.emit('update', [{ added: [], updated: [], removed }, origin])
  }
}

/**
 * @param {Awareness} awareness
 * @param {Array<number>} clients
 * @return {Uint8Array}
 */
const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length
  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.createEncoder()
  lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, len)
  for (let i = 0; i < len; i++) {
    const clientID = clients[i]
    const state = states.get(clientID) || null
    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clientID)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clock)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarString(encoder, JSON.stringify(state))
  }
  return lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.toUint8Array(encoder)
}

/**
 * Modify the content of an awareness update before re-encoding it to an awareness update.
 *
 * This might be useful when you have a central server that wants to ensure that clients
 * cant hijack somebody elses identity.
 *
 * @param {Uint8Array} update
 * @param {function(any):any} modify
 * @return {Uint8Array}
 */
const modifyAwarenessUpdate = (update, modify) => {
  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.createDecoder(update)
  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.createEncoder()
  const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, len)
  for (let i = 0; i < len; i++) {
    const clientID = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    const clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    const state = JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarString(decoder))
    const modifiedState = modify(state)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clientID)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clock)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarString(encoder, JSON.stringify(modifiedState))
  }
  return lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.toUint8Array(encoder)
}

/**
 * @param {Awareness} awareness
 * @param {Uint8Array} update
 * @param {any} origin This will be added to the emitted change event
 */
const applyAwarenessUpdate = (awareness, update, origin) => {
  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.createDecoder(update)
  const timestamp = lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
  const added = []
  const updated = []
  const filteredUpdated = []
  const removed = []
  const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
  for (let i = 0; i < len; i++) {
    const clientID = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    const state = JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarString(decoder))
    const clientMeta = awareness.meta.get(clientID)
    const prevState = awareness.states.get(clientID)
    const currClock = clientMeta === undefined ? 0 : clientMeta.clock
    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {
      if (state === null) {
        // never let a remote client remove this local state
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          // remote client removed the local state. Do not remote state. Broadcast a message indicating
          // that this client still exists by increasing the clock
          clock++
        } else {
          awareness.states.delete(clientID)
        }
      } else {
        awareness.states.set(clientID, state)
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      })
      if (clientMeta === undefined && state !== null) {
        added.push(clientID)
      } else if (clientMeta !== undefined && state === null) {
        removed.push(clientID)
      } else if (state !== null) {
        if (!lib0_function__WEBPACK_IMPORTED_MODULE_4__.equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID)
        }
        updated.push(clientID)
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit('change', [{
      added, updated: filteredUpdated, removed
    }, origin])
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit('update', [{
      added, updated, removed
    }, origin])
  }
}


/***/ }),

/***/ "../node_modules/y-protocols/sync.js":
/*!*******************************************!*\
  !*** ../node_modules/y-protocols/sync.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "messageYjsSyncStep1": () => (/* binding */ messageYjsSyncStep1),
/* harmony export */   "messageYjsSyncStep2": () => (/* binding */ messageYjsSyncStep2),
/* harmony export */   "messageYjsUpdate": () => (/* binding */ messageYjsUpdate),
/* harmony export */   "writeSyncStep1": () => (/* binding */ writeSyncStep1),
/* harmony export */   "writeSyncStep2": () => (/* binding */ writeSyncStep2),
/* harmony export */   "readSyncStep1": () => (/* binding */ readSyncStep1),
/* harmony export */   "readSyncStep2": () => (/* binding */ readSyncStep2),
/* harmony export */   "writeUpdate": () => (/* binding */ writeUpdate),
/* harmony export */   "readUpdate": () => (/* binding */ readUpdate),
/* harmony export */   "readSyncMessage": () => (/* binding */ readSyncMessage)
/* harmony export */ });
/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/encoding */ "../node_modules/lib0/encoding.js");
/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/decoding */ "../node_modules/lib0/decoding.js");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @module sync-protocol
 */





/**
 * @typedef {Map<number, number>} StateMap
 */

/**
 * Core Yjs defines two message types:
 * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.
 * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it
 *   received all information from the remote client.
 *
 * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection
 * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both
 * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.
 *
 * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.
 * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies
 * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the
 * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can
 * easily be implemented on top of http and websockets. 2. The server shoul only reply to requests, and not initiate them.
 * Therefore it is necesarry that the client initiates the sync.
 *
 * Construction of a message:
 * [messageType : varUint, message definition..]
 *
 * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!
 *
 * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)
 */

const messageYjsSyncStep1 = 0
const messageYjsSyncStep2 = 1
const messageYjsUpdate = 2

/**
 * Create a sync step 1 message based on the state of the current shared document.
 *
 * @param {encoding.Encoder} encoder
 * @param {Y.Doc} doc
 */
const writeSyncStep1 = (encoder, doc) => {
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint(encoder, messageYjsSyncStep1)
  const sv = yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateVector(doc)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint8Array(encoder, sv)
}

/**
 * @param {encoding.Encoder} encoder
 * @param {Y.Doc} doc
 * @param {Uint8Array} [encodedStateVector]
 */
const writeSyncStep2 = (encoder, doc, encodedStateVector) => {
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint(encoder, messageYjsSyncStep2)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint8Array(encoder, yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateAsUpdate(doc, encodedStateVector))
}

/**
 * Read SyncStep1 message and reply with SyncStep2.
 *
 * @param {decoding.Decoder} decoder The reply to the received message
 * @param {encoding.Encoder} encoder The received message
 * @param {Y.Doc} doc
 */
const readSyncStep1 = (decoder, encoder, doc) =>
  writeSyncStep2(encoder, doc, lib0_decoding__WEBPACK_IMPORTED_MODULE_2__.readVarUint8Array(decoder))

/**
 * Read and apply Structs and then DeleteStore to a y instance.
 *
 * @param {decoding.Decoder} decoder
 * @param {Y.Doc} doc
 * @param {any} transactionOrigin
 */
const readSyncStep2 = (decoder, doc, transactionOrigin) => {
  try {
    yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdate(doc, lib0_decoding__WEBPACK_IMPORTED_MODULE_2__.readVarUint8Array(decoder), transactionOrigin)
  } catch (error) {
    // This catches errors that are thrown by event handlers
    console.error('Caught error while handling a Yjs update', error)
  }
}

/**
 * @param {encoding.Encoder} encoder
 * @param {Uint8Array} update
 */
const writeUpdate = (encoder, update) => {
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint(encoder, messageYjsUpdate)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_1__.writeVarUint8Array(encoder, update)
}

/**
 * Read and apply Structs and then DeleteStore to a y instance.
 *
 * @param {decoding.Decoder} decoder
 * @param {Y.Doc} doc
 * @param {any} transactionOrigin
 */
const readUpdate = readSyncStep2

/**
 * @param {decoding.Decoder} decoder A message received from another client
 * @param {encoding.Encoder} encoder The reply message. Will not be sent if empty.
 * @param {Y.Doc} doc
 * @param {any} transactionOrigin
 */
const readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {
  const messageType = lib0_decoding__WEBPACK_IMPORTED_MODULE_2__.readVarUint(decoder)
  switch (messageType) {
    case messageYjsSyncStep1:
      readSyncStep1(decoder, encoder, doc)
      break
    case messageYjsSyncStep2:
      readSyncStep2(decoder, doc, transactionOrigin)
      break
    case messageYjsUpdate:
      readUpdate(decoder, doc, transactionOrigin)
      break
    default:
      throw new Error('Unknown message type')
  }
  return messageType
}


/***/ }),

/***/ "../node_modules/y-websocket/src/y-websocket.js":
/*!******************************************************!*\
  !*** ../node_modules/y-websocket/src/y-websocket.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebsocketProvider": () => (/* binding */ WebsocketProvider)
/* harmony export */ });
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/broadcastchannel */ "../node_modules/lib0/broadcastchannel.js");
/* harmony import */ var lib0_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/time */ "../node_modules/lib0/time.js");
/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding */ "../node_modules/lib0/encoding.js");
/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding */ "../node_modules/lib0/decoding.js");
/* harmony import */ var y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! y-protocols/sync */ "../node_modules/y-protocols/sync.js");
/* harmony import */ var y_protocols_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-protocols/auth */ "../node_modules/y-protocols/auth.js");
/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! y-protocols/awareness */ "../node_modules/y-protocols/awareness.js");
/* harmony import */ var lib0_mutex__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/mutex */ "../node_modules/lib0/mutex.js");
/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/observable */ "../node_modules/lib0/observable.js");
/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/math */ "../node_modules/lib0/math.js");
/* harmony import */ var lib0_url__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lib0/url */ "../node_modules/lib0/url.js");
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "../node_modules/process/browser.js");
/*
Unlike stated in the LICENSE file, it is not necessary to include the copyright notice and permission notice when you copy code from this file.
*/

/**
 * @module provider/websocket
 */

/* eslint-env browser */

 // eslint-disable-line












const messageSync = 0
const messageQueryAwareness = 3
const messageAwareness = 1
const messageAuth = 2

/**
 *                       encoder,          decoder,          provider,          emitSynced, messageType
 * @type {Array<function(encoding.Encoder, decoding.Decoder, WebsocketProvider, boolean,    number):void>}
 */
const messageHandlers = []

messageHandlers[messageSync] = (encoder, decoder, provider, emitSynced, messageType) => {
  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageSync)
  const syncMessageType = y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.readSyncMessage(decoder, encoder, provider.doc, provider)
  if (emitSynced && syncMessageType === y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.messageYjsSyncStep2 && !provider.synced) {
    provider.synced = true
  }
}

messageHandlers[messageQueryAwareness] = (encoder, decoder, provider, emitSynced, messageType) => {
  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageAwareness)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())))
}

messageHandlers[messageAwareness] = (encoder, decoder, provider, emitSynced, messageType) => {
  y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.applyAwarenessUpdate(provider.awareness, lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder), provider)
}

messageHandlers[messageAuth] = (encoder, decoder, provider, emitSynced, messageType) => {
  y_protocols_auth__WEBPACK_IMPORTED_MODULE_2__.readAuthMessage(decoder, provider.doc, permissionDeniedHandler)
}

const reconnectTimeoutBase = 1200
const maxReconnectTimeout = 2500
// @todo - this should depend on awareness.outdatedTime
const messageReconnectTimeout = 30000

/**
 * @param {WebsocketProvider} provider
 * @param {string} reason
 */
const permissionDeniedHandler = (provider, reason) => console.warn(`Permission denied to access ${provider.url}.\n${reason}`)

/**
 * @param {WebsocketProvider} provider
 * @param {Uint8Array} buf
 * @param {boolean} emitSynced
 * @return {encoding.Encoder}
 */
const readMessage = (provider, buf, emitSynced) => {
  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf)
  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
  const messageType = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)
  const messageHandler = provider.messageHandlers[messageType]
  if (/** @type {any} */ (messageHandler)) {
    messageHandler(encoder, decoder, provider, emitSynced, messageType)
  } else {
    console.error('Unable to compute message')
  }
  return encoder
}

/**
 * @param {WebsocketProvider} provider
 */
const setupWS = provider => {
  if (provider.shouldConnect && provider.ws === null) {
    const websocket = new provider._WS(provider.url)
    websocket.binaryType = 'arraybuffer'
    provider.ws = websocket
    provider.wsconnecting = true
    provider.wsconnected = false
    provider.synced = false

    websocket.onmessage = event => {
      provider.wsLastMessageReceived = lib0_time__WEBPACK_IMPORTED_MODULE_6__.getUnixTime()
      const encoder = readMessage(provider, new Uint8Array(event.data), true)
      if (lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.length(encoder) > 1) {
        websocket.send(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
      }
    }
    websocket.onclose = () => {
      provider.ws = null
      provider.wsconnecting = false
      if (provider.wsconnected) {
        provider.wsconnected = false
        provider.synced = false
        // update awareness (all users except local left)
        y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()).filter(client => client !== provider.doc.clientID), provider)
        provider.emit('status', [{
          status: 'disconnected'
        }])
      } else {
        provider.wsUnsuccessfulReconnects++
      }
      // Start with no reconnect timeout and increase timeout by
      // log10(wsUnsuccessfulReconnects).
      // The idea is to increase reconnect timeout slowly and have no reconnect
      // timeout at the beginning (log(1) = 0)
      setTimeout(setupWS, lib0_math__WEBPACK_IMPORTED_MODULE_7__.min(lib0_math__WEBPACK_IMPORTED_MODULE_7__.log10(provider.wsUnsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), provider)
    }
    websocket.onopen = () => {
      provider.wsLastMessageReceived = lib0_time__WEBPACK_IMPORTED_MODULE_6__.getUnixTime()
      provider.wsconnecting = false
      provider.wsconnected = true
      provider.wsUnsuccessfulReconnects = 0
      provider.emit('status', [{
        status: 'connected'
      }])
      // always send sync step 1 when connected
      const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageSync)
      y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.writeSyncStep1(encoder, provider.doc)
      websocket.send(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
      // broadcast local awareness state
      if (provider.awareness.getLocalState() !== null) {
        const encoderAwarenessState = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderAwarenessState, messageAwareness)
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoderAwarenessState, y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.encodeAwarenessUpdate(provider.awareness, [provider.doc.clientID]))
        websocket.send(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderAwarenessState))
      }
    }

    provider.emit('status', [{
      status: 'connecting'
    }])
  }
}

/**
 * @param {WebsocketProvider} provider
 * @param {ArrayBuffer} buf
 */
const broadcastMessage = (provider, buf) => {
  if (provider.wsconnected) {
    /** @type {WebSocket} */ (provider.ws).send(buf)
  }
  if (provider.bcconnected) {
    provider.mux(() => {
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.publish(provider.bcChannel, buf)
    })
  }
}

/**
 * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.
 * The document name is attached to the provided url. I.e. the following example
 * creates a websocket connection to http://localhost:1234/my-document-name
 *
 * @example
 *   import * as Y from 'yjs'
 *   import { WebsocketProvider } from 'y-websocket'
 *   const doc = new Y.Doc()
 *   const provider = new WebsocketProvider('http://localhost:1234', 'my-document-name', doc)
 *
 * @extends {Observable<string>}
 */
class WebsocketProvider extends lib0_observable__WEBPACK_IMPORTED_MODULE_9__.Observable {
  /**
   * @param {string} serverUrl
   * @param {string} roomname
   * @param {Y.Doc} doc
   * @param {object} [opts]
   * @param {boolean} [opts.connect]
   * @param {awarenessProtocol.Awareness} [opts.awareness]
   * @param {Object<string,string>} [opts.params]
   * @param {typeof WebSocket} [opts.WebSocketPolyfill] Optionall provide a WebSocket polyfill
   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds
   */
  constructor (serverUrl, roomname, doc, { connect = true, awareness = new y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.Awareness(doc), params = {}, WebSocketPolyfill = WebSocket, resyncInterval = -1 } = {}) {
    super()
    // ensure that url is always ends with /
    while (serverUrl[serverUrl.length - 1] === '/') {
      serverUrl = serverUrl.slice(0, serverUrl.length - 1)
    }
    const encodedParams = lib0_url__WEBPACK_IMPORTED_MODULE_10__.encodeQueryParams(params)
    this.bcChannel = serverUrl + '/' + roomname
    this.url = serverUrl + '/' + roomname + (encodedParams.length === 0 ? '' : '?' + encodedParams)
    this.roomname = roomname
    this.doc = doc
    this._WS = WebSocketPolyfill
    this.awareness = awareness
    this.wsconnected = false
    this.wsconnecting = false
    this.bcconnected = false
    this.wsUnsuccessfulReconnects = 0
    this.messageHandlers = messageHandlers.slice()
    this.mux = lib0_mutex__WEBPACK_IMPORTED_MODULE_11__.createMutex()
    /**
     * @type {boolean}
     */
    this._synced = false
    /**
     * @type {WebSocket?}
     */
    this.ws = null
    this.wsLastMessageReceived = 0
    /**
     * Whether to connect to other peers or not
     * @type {boolean}
     */
    this.shouldConnect = connect

    /**
     * @type {number}
     */
    this._resyncInterval = 0
    if (resyncInterval > 0) {
      this._resyncInterval = /** @type {any} */ (setInterval(() => {
        if (this.ws) {
          // resend sync step 1
          const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageSync)
          y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.writeSyncStep1(encoder, doc)
          this.ws.send(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
        }
      }, resyncInterval))
    }

    /**
     * @param {ArrayBuffer} data
     */
    this._bcSubscriber = data => {
      this.mux(() => {
        const encoder = readMessage(this, new Uint8Array(data), false)
        if (lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.length(encoder) > 1) {
          lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.publish(this.bcChannel, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
        }
      })
    }
    /**
     * Listens to Yjs updates and sends them to remote peers (ws and broadcastchannel)
     * @param {Uint8Array} update
     * @param {any} origin
     */
    this._updateHandler = (update, origin) => {
      if (origin !== this) {
        const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageSync)
        y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.writeUpdate(encoder, update)
        broadcastMessage(this, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
      }
    }
    this.doc.on('update', this._updateHandler)
    /**
     * @param {any} changed
     * @param {any} origin
     */
    this._awarenessUpdateHandler = ({ added, updated, removed }, origin) => {
      const changedClients = added.concat(updated).concat(removed)
      const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageAwareness)
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.encodeAwarenessUpdate(awareness, changedClients))
      broadcastMessage(this, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
    }
    this._beforeUnloadHandler = () => {
      y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload')
    }
    if (typeof window !== 'undefined') {
      window.addEventListener('beforeunload', this._beforeUnloadHandler)
    } else if (typeof process !== 'undefined') {
      process.on('exit', () => this._beforeUnloadHandler)
    }
    awareness.on('update', this._awarenessUpdateHandler)
    this._checkInterval = /** @type {any} */ (setInterval(() => {
      if (this.wsconnected && messageReconnectTimeout < lib0_time__WEBPACK_IMPORTED_MODULE_6__.getUnixTime() - this.wsLastMessageReceived) {
        // no message received in a long time - not even your own awareness
        // updates (which are updated every 15 seconds)
        /** @type {WebSocket} */ (this.ws).close()
      }
    }, messageReconnectTimeout / 10))
    if (connect) {
      this.connect()
    }
  }

  /**
   * @type {boolean}
   */
  get synced () {
    return this._synced
  }

  set synced (state) {
    if (this._synced !== state) {
      this._synced = state
      this.emit('synced', [state])
      this.emit('sync', [state])
    }
  }

  destroy () {
    if (this._resyncInterval !== 0) {
      clearInterval(this._resyncInterval)
    }
    clearInterval(this._checkInterval)
    this.disconnect()
    if (typeof window !== 'undefined') {
      window.removeEventListener('beforeunload', this._beforeUnloadHandler)
    } else if (typeof process !== 'undefined') {
      process.off('exit', () => this._beforeUnloadHandler)
    }
    this.awareness.off('update', this._awarenessUpdateHandler)
    this.doc.off('update', this._updateHandler)
    super.destroy()
  }

  connectBc () {
    if (!this.bcconnected) {
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.subscribe(this.bcChannel, this._bcSubscriber)
      this.bcconnected = true
    }
    // send sync step1 to bc
    this.mux(() => {
      // write sync step 1
      const encoderSync = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderSync, messageSync)
      y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.writeSyncStep1(encoderSync, this.doc)
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.publish(this.bcChannel, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderSync))
      // broadcast local state
      const encoderState = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderState, messageSync)
      y_protocols_sync__WEBPACK_IMPORTED_MODULE_1__.writeSyncStep2(encoderState, this.doc)
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.publish(this.bcChannel, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderState))
      // write queryAwareness
      const encoderAwarenessQuery = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderAwarenessQuery, messageQueryAwareness)
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.publish(this.bcChannel, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderAwarenessQuery))
      // broadcast local awareness state
      const encoderAwarenessState = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoderAwarenessState, messageAwareness)
      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoderAwarenessState, y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]))
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.publish(this.bcChannel, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoderAwarenessState))
    })
  }

  disconnectBc () {
    // broadcast message with local awareness state set to null (indicating disconnect)
    const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()
    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, messageAwareness)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, y_protocols_awareness__WEBPACK_IMPORTED_MODULE_3__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID], new Map()))
    broadcastMessage(this, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder))
    if (this.bcconnected) {
      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_8__.unsubscribe(this.bcChannel, this._bcSubscriber)
      this.bcconnected = false
    }
  }

  disconnect () {
    this.shouldConnect = false
    this.disconnectBc()
    if (this.ws !== null) {
      this.ws.close()
    }
  }

  connect () {
    this.shouldConnect = true
    if (!this.wsconnected && this.ws === null) {
      setupWS(this)
      this.connectBc()
    }
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL2xpYjAvYnJvYWRjYXN0Y2hhbm5lbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL2xpYjAvbXV0ZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9saWIwL3VybC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL2F1dGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy95LXByb3RvY29scy9hd2FyZW5lc3MuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy95LXByb3RvY29scy9zeW5jLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMveS13ZWJzb2NrZXQvc3JjL3ktd2Vic29ja2V0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRStCO0FBQ007QUFDRTs7QUFFdkM7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxjQUFjO0FBQzVCLGNBQWMsSUFBSTtBQUNsQjs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWUsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxJQUFJLGlEQUFnQixtRUFBbUUsT0FBTyxr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LHVEQUFxQjtBQUNoRDtBQUNBLE1BQU0sOERBQWM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfeS13ZWJzb2NrZXRfc3JjX3ktd2Vic29ja2V0X2pzLjFhMWYwYWY2NDBiNTk2MjY4NTdmLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogSGVscGVycyBmb3IgY3Jvc3MtdGFiIGNvbW11bmljYXRpb24gdXNpbmcgYnJvYWRjYXN0Y2hhbm5lbCB3aXRoIExvY2FsU3RvcmFnZSBmYWxsYmFjay5cbiAqXG4gKiBgYGBqc1xuICogLy8gSW4gYnJvd3NlciB3aW5kb3cgQTpcbiAqIGJyb2FkY2FzdGNoYW5uZWwuc3Vic2NyaWJlKCdteSBldmVudHMnLCBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpKVxuICogYnJvYWRjYXN0Y2hhbm5lbC5wdWJsaXNoKCdteSBldmVudHMnLCAnSGVsbG8gd29ybGQhJykgLy8gPT4gQTogJ0hlbGxvIHdvcmxkIScgZmlyZXMgc3luY2hyb25vdXNseSBpbiBzYW1lIHRhYlxuICpcbiAqIC8vIEluIGJyb3dzZXIgd2luZG93IEI6XG4gKiBicm9hZGNhc3RjaGFubmVsLnB1Ymxpc2goJ215IGV2ZW50cycsICdoZWxsbyBmcm9tIHRhYiBCJykgLy8gPT4gQTogJ2hlbGxvIGZyb20gdGFiIEInXG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIGJyb2FkY2FzdGNoYW5uZWxcbiAqL1xuXG4vLyBAdG9kbyBiZWZvcmUgbmV4dCBtYWpvcjogdXNlIFVpbnQ4QXJyYXkgaW5zdGVhZCBhcyBidWZmZXIgb2JqZWN0XG5cbmltcG9ydCAqIGFzIG1hcCBmcm9tICcuL21hcC5qcydcbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICcuL2J1ZmZlci5qcydcbmltcG9ydCAqIGFzIHN0b3JhZ2UgZnJvbSAnLi9zdG9yYWdlLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENoYW5uZWxcbiAqIEBwcm9wZXJ0eSB7U2V0PEZ1bmN0aW9uPn0gQ2hhbm5lbC5zdWJzXG4gKiBAcHJvcGVydHkge2FueX0gQ2hhbm5lbC5iY1xuICovXG5cbi8qKlxuICogQHR5cGUge01hcDxzdHJpbmcsIENoYW5uZWw+fVxuICovXG5jb25zdCBjaGFubmVscyA9IG5ldyBNYXAoKVxuXG5jbGFzcyBMb2NhbFN0b3JhZ2VQb2x5ZmlsbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJvb20pIHtcbiAgICB0aGlzLnJvb20gPSByb29tXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGx8ZnVuY3Rpb24oe2RhdGE6QXJyYXlCdWZmZXJ9KTp2b2lkfVxuICAgICAqL1xuICAgIHRoaXMub25tZXNzYWdlID0gbnVsbFxuICAgIHN0b3JhZ2Uub25DaGFuZ2UoZSA9PiBlLmtleSA9PT0gcm9vbSAmJiB0aGlzLm9ubWVzc2FnZSAhPT0gbnVsbCAmJiB0aGlzLm9ubWVzc2FnZSh7IGRhdGE6IGJ1ZmZlci5mcm9tQmFzZTY0KGUubmV3VmFsdWUgfHwgJycpIH0pKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZlxuICAgKi9cbiAgcG9zdE1lc3NhZ2UgKGJ1Zikge1xuICAgIHN0b3JhZ2UudmFyU3RvcmFnZS5zZXRJdGVtKHRoaXMucm9vbSwgYnVmZmVyLnRvQmFzZTY0KGJ1ZmZlci5jcmVhdGVVaW50OEFycmF5RnJvbUFycmF5QnVmZmVyKGJ1ZikpKVxuICB9XG59XG5cbi8vIFVzZSBCcm9hZGNhc3RDaGFubmVsIG9yIFBvbHlmaWxsXG5jb25zdCBCQyA9IHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsID09PSAndW5kZWZpbmVkJyA/IExvY2FsU3RvcmFnZVBvbHlmaWxsIDogQnJvYWRjYXN0Q2hhbm5lbFxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gKiBAcmV0dXJuIHtDaGFubmVsfVxuICovXG5jb25zdCBnZXRDaGFubmVsID0gcm9vbSA9PlxuICBtYXAuc2V0SWZVbmRlZmluZWQoY2hhbm5lbHMsIHJvb20sICgpID0+IHtcbiAgICBjb25zdCBzdWJzID0gbmV3IFNldCgpXG4gICAgY29uc3QgYmMgPSBuZXcgQkMocm9vbSlcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3tkYXRhOkFycmF5QnVmZmVyfX0gZVxuICAgICAqL1xuICAgIGJjLm9ubWVzc2FnZSA9IGUgPT4gc3Vicy5mb3JFYWNoKHN1YiA9PiBzdWIoZS5kYXRhKSlcbiAgICByZXR1cm4ge1xuICAgICAgYmMsIHN1YnNcbiAgICB9XG4gIH0pXG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIGdsb2JhbCBgcHVibGlzaGAgZXZlbnRzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTphbnl9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IHN1YnNjcmliZSA9IChyb29tLCBmKSA9PiBnZXRDaGFubmVsKHJvb20pLnN1YnMuYWRkKGYpXG5cbi8qKlxuICogVW5zdWJzY3JpYmUgZnJvbSBgcHVibGlzaGAgZ2xvYmFsIGV2ZW50cy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSk6YW55fSBmXG4gKi9cbmV4cG9ydCBjb25zdCB1bnN1YnNjcmliZSA9IChyb29tLCBmKSA9PiBnZXRDaGFubmVsKHJvb20pLnN1YnMuZGVsZXRlKGYpXG5cbi8qKlxuICogUHVibGlzaCBkYXRhIHRvIGFsbCBzdWJzY3JpYmVycyAoaW5jbHVkaW5nIHN1YnNjcmliZXJzIG9uIHRoaXMgdGFiKVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEBwYXJhbSB7YW55fSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBwdWJsaXNoID0gKHJvb20sIGRhdGEpID0+IHtcbiAgY29uc3QgYyA9IGdldENoYW5uZWwocm9vbSlcbiAgYy5iYy5wb3N0TWVzc2FnZShkYXRhKVxuICBjLnN1YnMuZm9yRWFjaChzdWIgPT4gc3ViKGRhdGEpKVxufVxuIiwiLyoqXG4gKiBNdXR1YWwgZXhjbHVkZSBmb3IgSmF2YVNjcmlwdC5cbiAqXG4gKiBAbW9kdWxlIG11dGV4XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgbXV0ZXhcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSBjYiBPbmx5IGV4ZWN1dGVkIHdoZW4gdGhpcyBtdXRleCBpcyBub3QgaW4gdGhlIGN1cnJlbnQgc3RhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSBbZWxzZUNiXSBFeGVjdXRlZCB3aGVuIHRoaXMgbXV0ZXggaXMgaW4gdGhlIGN1cnJlbnQgc3RhY2tcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtdXR1YWwgZXhjbHVkZSBmdW5jdGlvbiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydHk6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IG11dGV4ID0gY3JlYXRlTXV0ZXgoKVxuICogbXV0ZXgoKCkgPT4ge1xuICogICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGltbWVkaWF0ZWx5IGV4ZWN1dGVkXG4gKiAgIG11dGV4KCgpID0+IHtcbiAqICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBleGVjdXRlZCwgYXMgdGhlIG11dGV4IGlzIGFscmVhZHkgYWN0aXZlLlxuICogICB9KVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEByZXR1cm4ge211dGV4fSBBIG11dHVhbCBleGNsdWRlIGZ1bmN0aW9uXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVNdXRleCA9ICgpID0+IHtcbiAgbGV0IHRva2VuID0gdHJ1ZVxuICByZXR1cm4gKGYsIGcpID0+IHtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIHRva2VuID0gZmFsc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIGYoKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdG9rZW4gPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGcoKVxuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggdXJscy5cbiAqXG4gKiBAbW9kdWxlIHVybFxuICovXG5cbmltcG9ydCAqIGFzIG9iamVjdCBmcm9tICcuL29iamVjdC5qcydcblxuLyoqXG4gKiBQYXJzZSBxdWVyeSBwYXJhbWV0ZXJzIGZyb20gYW4gdXJsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsc3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVF1ZXJ5UGFyYW1zID0gdXJsID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLHN0cmluZz59XG4gICAqL1xuICBjb25zdCBxdWVyeSA9IHt9XG4gIGNvbnN0IHVybFF1ZXJ5U3BsaXQgPSB1cmwuc3BsaXQoJz8nKVxuICBjb25zdCBwYWlycyA9IHVybFF1ZXJ5U3BsaXRbdXJsUXVlcnlTcGxpdC5sZW5ndGggLSAxXS5zcGxpdCgnJicpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpdGVtID0gcGFpcnNbaV1cbiAgICBpZiAoaXRlbS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwYWlyID0gaXRlbS5zcGxpdCgnPScpXG4gICAgICBxdWVyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0gfHwgJycpXG4gICAgfVxuICB9XG4gIHJldHVybiBxdWVyeVxufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxzdHJpbmc+fSBwYXJhbXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVF1ZXJ5UGFyYW1zID0gcGFyYW1zID0+XG4gIG9iamVjdC5tYXAocGFyYW1zLCAodmFsLCBrZXkpID0+IGAke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWwpfWApLmpvaW4oJyYnKVxuIiwiXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5cbmV4cG9ydCBjb25zdCBtZXNzYWdlUGVybWlzc2lvbkRlbmllZCA9IDBcblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb25cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlUGVybWlzc2lvbkRlbmllZCA9IChlbmNvZGVyLCByZWFzb24pID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VQZXJtaXNzaW9uRGVuaWVkKVxuICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCByZWFzb24pXG59XG5cbi8qKlxuICogQGNhbGxiYWNrIFBlcm1pc3Npb25EZW5pZWRIYW5kbGVyXG4gKiBAcGFyYW0ge2FueX0geVxuICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICovXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtZLkRvY30geVxuICogQHBhcmFtIHtQZXJtaXNzaW9uRGVuaWVkSGFuZGxlcn0gcGVybWlzc2lvbkRlbmllZEhhbmRsZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRBdXRoTWVzc2FnZSA9IChkZWNvZGVyLCB5LCBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlcikgPT4ge1xuICBzd2l0Y2ggKGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpKSB7XG4gICAgY2FzZSBtZXNzYWdlUGVybWlzc2lvbkRlbmllZDogcGVybWlzc2lvbkRlbmllZEhhbmRsZXIoeSwgZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSlcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIGF3YXJlbmVzcy1wcm90b2NvbFxuICovXG5cbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuaW1wb3J0ICogYXMgdGltZSBmcm9tICdsaWIwL3RpbWUnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5pbXBvcnQgKiBhcyBmIGZyb20gJ2xpYjAvZnVuY3Rpb24nXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5leHBvcnQgY29uc3Qgb3V0ZGF0ZWRUaW1lb3V0ID0gMzAwMDBcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhQ2xpZW50U3RhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNZXRhQ2xpZW50U3RhdGUuY2xvY2tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBNZXRhQ2xpZW50U3RhdGUubGFzdFVwZGF0ZWQgdW5peCB0aW1lc3RhbXBcbiAqL1xuXG4vKipcbiAqIFRoZSBBd2FyZW5lc3MgY2xhc3MgaW1wbGVtZW50cyBhIHNpbXBsZSBzaGFyZWQgc3RhdGUgcHJvdG9jb2wgdGhhdCBjYW4gYmUgdXNlZCBmb3Igbm9uLXBlcnNpc3RlbnQgZGF0YSBsaWtlIGF3YXJlbmVzcyBpbmZvcm1hdGlvblxuICogKGN1cnNvciwgdXNlcm5hbWUsIHN0YXR1cywgLi4pLiBFYWNoIGNsaWVudCBjYW4gdXBkYXRlIGl0cyBvd24gbG9jYWwgc3RhdGUgYW5kIGxpc3RlbiB0byBzdGF0ZSBjaGFuZ2VzIG9mXG4gKiByZW1vdGUgY2xpZW50cy4gRXZlcnkgY2xpZW50IG1heSBzZXQgYSBzdGF0ZSBvZiBhIHJlbW90ZSBwZWVyIHRvIGBudWxsYCB0byBtYXJrIHRoZSBjbGllbnQgYXMgb2ZmbGluZS5cbiAqXG4gKiBFYWNoIGNsaWVudCBpcyBpZGVudGlmaWVkIGJ5IGEgdW5pcXVlIGNsaWVudCBpZCAoc29tZXRoaW5nIHdlIGJvcnJvdyBmcm9tIGBkb2MuY2xpZW50SURgKS4gQSBjbGllbnQgY2FuIG92ZXJyaWRlXG4gKiBpdHMgb3duIHN0YXRlIGJ5IHByb3BhZ2F0aW5nIGEgbWVzc2FnZSB3aXRoIGFuIGluY3JlYXNpbmcgdGltZXN0YW1wIChgY2xvY2tgKS4gSWYgc3VjaCBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIGl0IGlzXG4gKiBhcHBsaWVkIGlmIHRoZSBrbm93biBzdGF0ZSBvZiB0aGF0IGNsaWVudCBpcyBvbGRlciB0aGFuIHRoZSBuZXcgc3RhdGUgKGBjbG9jayA8IG5ld0Nsb2NrYCkuIElmIGEgY2xpZW50IHRoaW5rcyB0aGF0XG4gKiBhIHJlbW90ZSBjbGllbnQgaXMgb2ZmbGluZSwgaXQgbWF5IHByb3BhZ2F0ZSBhIG1lc3NhZ2Ugd2l0aFxuICogYHsgY2xvY2s6IGN1cnJlbnRDbGllbnRDbG9jaywgc3RhdGU6IG51bGwsIGNsaWVudDogcmVtb3RlQ2xpZW50IH1gLiBJZiBzdWNoIGFcbiAqIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIGFuZCB0aGUga25vd24gY2xvY2sgb2YgdGhhdCBjbGllbnQgZXF1YWxzIHRoZSByZWNlaXZlZCBjbG9jaywgaXQgd2lsbCBvdmVycmlkZSB0aGUgc3RhdGUgd2l0aCBgbnVsbGAuXG4gKlxuICogQmVmb3JlIGEgY2xpZW50IGRpc2Nvbm5lY3RzLCBpdCBzaG91bGQgcHJvcGFnYXRlIGEgYG51bGxgIHN0YXRlIHdpdGggYW4gdXBkYXRlZCBjbG9jay5cbiAqXG4gKiBBd2FyZW5lc3Mgc3RhdGVzIG11c3QgYmUgdXBkYXRlZCBldmVyeSAzMCBzZWNvbmRzLiBPdGhlcndpc2UgdGhlIEF3YXJlbmVzcyBpbnN0YW5jZSB3aWxsIGRlbGV0ZSB0aGUgY2xpZW50IHN0YXRlLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlPHN0cmluZz59XG4gKi9cbmV4cG9ydCBjbGFzcyBBd2FyZW5lc3MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRJRCA9IGRvYy5jbGllbnRJRFxuICAgIC8qKlxuICAgICAqIE1hcHMgZnJvbSBjbGllbnQgaWQgdG8gY2xpZW50IHN0YXRlXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsIE9iamVjdDxzdHJpbmcsIGFueT4+fVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsIE1ldGFDbGllbnRTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fY2hlY2tJbnRlcnZhbCA9IC8qKiBAdHlwZSB7YW55fSAqLyAoc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBpZiAodGhpcy5nZXRMb2NhbFN0YXRlKCkgIT09IG51bGwgJiYgKG91dGRhdGVkVGltZW91dCAvIDIgPD0gbm93IC0gLyoqIEB0eXBlIHt7bGFzdFVwZGF0ZWQ6bnVtYmVyfX0gKi8gKHRoaXMubWV0YS5nZXQodGhpcy5jbGllbnRJRCkpLmxhc3RVcGRhdGVkKSkge1xuICAgICAgICAvLyByZW5ldyBsb2NhbCBjbG9ja1xuICAgICAgICB0aGlzLnNldExvY2FsU3RhdGUodGhpcy5nZXRMb2NhbFN0YXRlKCkpXG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAgICovXG4gICAgICBjb25zdCByZW1vdmUgPSBbXVxuICAgICAgdGhpcy5tZXRhLmZvckVhY2goKG1ldGEsIGNsaWVudGlkKSA9PiB7XG4gICAgICAgIGlmIChjbGllbnRpZCAhPT0gdGhpcy5jbGllbnRJRCAmJiBvdXRkYXRlZFRpbWVvdXQgPD0gbm93IC0gbWV0YS5sYXN0VXBkYXRlZCAmJiB0aGlzLnN0YXRlcy5oYXMoY2xpZW50aWQpKSB7XG4gICAgICAgICAgcmVtb3ZlLnB1c2goY2xpZW50aWQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZiAocmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHRoaXMsIHJlbW92ZSwgJ3RpbWVvdXQnKVxuICAgICAgfVxuICAgIH0sIG1hdGguZmxvb3Iob3V0ZGF0ZWRUaW1lb3V0IC8gMTApKSlcbiAgICBkb2Mub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3koKVxuICAgIH0pXG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKHt9KVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JywgW3RoaXNdKVxuICAgIHRoaXMuc2V0TG9jYWxTdGF0ZShudWxsKVxuICAgIHN1cGVyLmRlc3Ryb3koKVxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tJbnRlcnZhbClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT58bnVsbH1cbiAgICovXG4gIGdldExvY2FsU3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlcy5nZXQodGhpcy5jbGllbnRJRCkgfHwgbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fG51bGx9IHN0YXRlXG4gICAqL1xuICBzZXRMb2NhbFN0YXRlIChzdGF0ZSkge1xuICAgIGNvbnN0IGNsaWVudElEID0gdGhpcy5jbGllbnRJRFxuICAgIGNvbnN0IGN1cnJMb2NhbE1ldGEgPSB0aGlzLm1ldGEuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IGNsb2NrID0gY3VyckxvY2FsTWV0YSA9PT0gdW5kZWZpbmVkID8gMCA6IGN1cnJMb2NhbE1ldGEuY2xvY2sgKyAxXG4gICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5zdGF0ZXMuZ2V0KGNsaWVudElEKVxuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlcy5zZXQoY2xpZW50SUQsIHN0YXRlKVxuICAgIH1cbiAgICB0aGlzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICBjbG9jayxcbiAgICAgIGxhc3RVcGRhdGVkOiB0aW1lLmdldFVuaXhUaW1lKClcbiAgICB9KVxuICAgIGNvbnN0IGFkZGVkID0gW11cbiAgICBjb25zdCB1cGRhdGVkID0gW11cbiAgICBjb25zdCBmaWx0ZXJlZFVwZGF0ZWQgPSBbXVxuICAgIGNvbnN0IHJlbW92ZWQgPSBbXVxuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKVxuICAgIH0gZWxzZSBpZiAocHJldlN0YXRlID09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgIGlmICghZi5lcXVhbGl0eURlZXAocHJldlN0YXRlLCBzdGF0ZSkpIHtcbiAgICAgICAgZmlsdGVyZWRVcGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IGZpbHRlcmVkVXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCBbeyBhZGRlZCwgdXBkYXRlZDogZmlsdGVyZWRVcGRhdGVkLCByZW1vdmVkIH0sICdsb2NhbCddKVxuICAgIH1cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIFt7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH0sICdsb2NhbCddKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZFxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICovXG4gIHNldExvY2FsU3RhdGVGaWVsZCAoZmllbGQsIHZhbHVlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldExvY2FsU3RhdGUoKVxuICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5zZXRMb2NhbFN0YXRlKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFtmaWVsZF06IHZhbHVlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtNYXA8bnVtYmVyLE9iamVjdDxzdHJpbmcsYW55Pj59XG4gICAqL1xuICBnZXRTdGF0ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1xuICB9XG59XG5cbi8qKlxuICogTWFyayAocmVtb3RlKSBjbGllbnRzIGFzIGluYWN0aXZlIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBwZWVycy5cbiAqIFRoaXMgY2hhbmdlIHdpbGwgYmUgcHJvcGFnYXRlZCB0byByZW1vdGUgY2xpZW50cy5cbiAqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsaWVudHNcbiAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUF3YXJlbmVzc1N0YXRlcyA9IChhd2FyZW5lc3MsIGNsaWVudHMsIG9yaWdpbikgPT4ge1xuICBjb25zdCByZW1vdmVkID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGllbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBjbGllbnRzW2ldXG4gICAgaWYgKGF3YXJlbmVzcy5zdGF0ZXMuaGFzKGNsaWVudElEKSkge1xuICAgICAgYXdhcmVuZXNzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpXG4gICAgICBpZiAoY2xpZW50SUQgPT09IGF3YXJlbmVzcy5jbGllbnRJRCkge1xuICAgICAgICBjb25zdCBjdXJNZXRhID0gLyoqIEB0eXBlIHtNZXRhQ2xpZW50U3RhdGV9ICovIChhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpKVxuICAgICAgICBhd2FyZW5lc3MubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgICAgICBjbG9jazogY3VyTWV0YS5jbG9jayArIDEsXG4gICAgICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ2NoYW5nZScsIFt7IGFkZGVkOiBbXSwgdXBkYXRlZDogW10sIHJlbW92ZWQgfSwgb3JpZ2luXSlcbiAgICBhd2FyZW5lc3MuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbGllbnRzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlQXdhcmVuZXNzVXBkYXRlID0gKGF3YXJlbmVzcywgY2xpZW50cywgc3RhdGVzID0gYXdhcmVuZXNzLnN0YXRlcykgPT4ge1xuICBjb25zdCBsZW4gPSBjbGllbnRzLmxlbmd0aFxuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGNsaWVudHNbaV1cbiAgICBjb25zdCBzdGF0ZSA9IHN0YXRlcy5nZXQoY2xpZW50SUQpIHx8IG51bGxcbiAgICBjb25zdCBjbG9jayA9IC8qKiBAdHlwZSB7TWV0YUNsaWVudFN0YXRlfSAqLyAoYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKSkuY2xvY2tcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xpZW50SUQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGNsb2NrKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIEpTT04uc3RyaW5naWZ5KHN0YXRlKSlcbiAgfVxuICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG59XG5cbi8qKlxuICogTW9kaWZ5IHRoZSBjb250ZW50IG9mIGFuIGF3YXJlbmVzcyB1cGRhdGUgYmVmb3JlIHJlLWVuY29kaW5nIGl0IHRvIGFuIGF3YXJlbmVzcyB1cGRhdGUuXG4gKlxuICogVGhpcyBtaWdodCBiZSB1c2VmdWwgd2hlbiB5b3UgaGF2ZSBhIGNlbnRyYWwgc2VydmVyIHRoYXQgd2FudHMgdG8gZW5zdXJlIHRoYXQgY2xpZW50c1xuICogY2FudCBoaWphY2sgc29tZWJvZHkgZWxzZXMgaWRlbnRpdHkuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTphbnl9IG1vZGlmeVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IG1vZGlmeUF3YXJlbmVzc1VwZGF0ZSA9ICh1cGRhdGUsIG1vZGlmeSkgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgY29uc3QgbGVuID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgY29uc3Qgc3RhdGUgPSBKU09OLnBhcnNlKGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikpXG4gICAgY29uc3QgbW9kaWZpZWRTdGF0ZSA9IG1vZGlmeShzdGF0ZSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xpZW50SUQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGNsb2NrKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIEpTT04uc3RyaW5naWZ5KG1vZGlmaWVkU3RhdGUpKVxuICB9XG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IG9yaWdpbiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVtaXR0ZWQgY2hhbmdlIGV2ZW50XG4gKi9cbmV4cG9ydCBjb25zdCBhcHBseUF3YXJlbmVzc1VwZGF0ZSA9IChhd2FyZW5lc3MsIHVwZGF0ZSwgb3JpZ2luKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSlcbiAgY29uc3QgdGltZXN0YW1wID0gdGltZS5nZXRVbml4VGltZSgpXG4gIGNvbnN0IGFkZGVkID0gW11cbiAgY29uc3QgdXBkYXRlZCA9IFtdXG4gIGNvbnN0IGZpbHRlcmVkVXBkYXRlZCA9IFtdXG4gIGNvbnN0IHJlbW92ZWQgPSBbXVxuICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGxldCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgY29uc3Qgc3RhdGUgPSBKU09OLnBhcnNlKGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikpXG4gICAgY29uc3QgY2xpZW50TWV0YSA9IGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRClcbiAgICBjb25zdCBwcmV2U3RhdGUgPSBhd2FyZW5lc3Muc3RhdGVzLmdldChjbGllbnRJRClcbiAgICBjb25zdCBjdXJyQ2xvY2sgPSBjbGllbnRNZXRhID09PSB1bmRlZmluZWQgPyAwIDogY2xpZW50TWV0YS5jbG9ja1xuICAgIGlmIChjdXJyQ2xvY2sgPCBjbG9jayB8fCAoY3VyckNsb2NrID09PSBjbG9jayAmJiBzdGF0ZSA9PT0gbnVsbCAmJiBhd2FyZW5lc3Muc3RhdGVzLmhhcyhjbGllbnRJRCkpKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gbmV2ZXIgbGV0IGEgcmVtb3RlIGNsaWVudCByZW1vdmUgdGhpcyBsb2NhbCBzdGF0ZVxuICAgICAgICBpZiAoY2xpZW50SUQgPT09IGF3YXJlbmVzcy5jbGllbnRJRCAmJiBhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpICE9IG51bGwpIHtcbiAgICAgICAgICAvLyByZW1vdGUgY2xpZW50IHJlbW92ZWQgdGhlIGxvY2FsIHN0YXRlLiBEbyBub3QgcmVtb3RlIHN0YXRlLiBCcm9hZGNhc3QgYSBtZXNzYWdlIGluZGljYXRpbmdcbiAgICAgICAgICAvLyB0aGF0IHRoaXMgY2xpZW50IHN0aWxsIGV4aXN0cyBieSBpbmNyZWFzaW5nIHRoZSBjbG9ja1xuICAgICAgICAgIGNsb2NrKytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FyZW5lc3Muc3RhdGVzLmRlbGV0ZShjbGllbnRJRClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhcmVuZXNzLnN0YXRlcy5zZXQoY2xpZW50SUQsIHN0YXRlKVxuICAgICAgfVxuICAgICAgYXdhcmVuZXNzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICAgIGNsb2NrLFxuICAgICAgICBsYXN0VXBkYXRlZDogdGltZXN0YW1wXG4gICAgICB9KVxuICAgICAgaWYgKGNsaWVudE1ldGEgPT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBhZGRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfSBlbHNlIGlmIChjbGllbnRNZXRhICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfSBlbHNlIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWYuZXF1YWxpdHlEZWVwKHN0YXRlLCBwcmV2U3RhdGUpKSB7XG4gICAgICAgICAgZmlsdGVyZWRVcGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCBmaWx0ZXJlZFVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgnY2hhbmdlJywgW3tcbiAgICAgIGFkZGVkLCB1cGRhdGVkOiBmaWx0ZXJlZFVwZGF0ZWQsIHJlbW92ZWRcbiAgICB9LCBvcmlnaW5dKVxuICB9XG4gIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IHVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgndXBkYXRlJywgW3tcbiAgICAgIGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkXG4gICAgfSwgb3JpZ2luXSlcbiAgfVxufVxuIiwiLyoqXG4gKiBAbW9kdWxlIHN5bmMtcHJvdG9jb2xcbiAqL1xuXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtNYXA8bnVtYmVyLCBudW1iZXI+fSBTdGF0ZU1hcFxuICovXG5cbi8qKlxuICogQ29yZSBZanMgZGVmaW5lcyB0d28gbWVzc2FnZSB0eXBlczpcbiAqIOKAoiBZanNTeW5jU3RlcDE6IEluY2x1ZGVzIHRoZSBTdGF0ZSBTZXQgb2YgdGhlIHNlbmRpbmcgY2xpZW50LiBXaGVuIHJlY2VpdmVkLCB0aGUgY2xpZW50IHNob3VsZCByZXBseSB3aXRoIFlqc1N5bmNTdGVwMi5cbiAqIOKAoiBZanNTeW5jU3RlcDI6IEluY2x1ZGVzIGFsbCBtaXNzaW5nIHN0cnVjdHMgYW5kIHRoZSBjb21wbGV0ZSBkZWxldGUgc2V0LiBXaGVuIHJlY2VpdmVkLCB0aGUgY2xpZW50IGlzIGFzc3VyZWQgdGhhdCBpdFxuICogICByZWNlaXZlZCBhbGwgaW5mb3JtYXRpb24gZnJvbSB0aGUgcmVtb3RlIGNsaWVudC5cbiAqXG4gKiBJbiBhIHBlZXItdG8tcGVlciBuZXR3b3JrLCB5b3UgbWF5IHdhbnQgdG8gaW50cm9kdWNlIGEgU3luY0RvbmUgbWVzc2FnZSB0eXBlLiBCb3RoIHBhcnRpZXMgc2hvdWxkIGluaXRpYXRlIHRoZSBjb25uZWN0aW9uXG4gKiB3aXRoIFN5bmNTdGVwMS4gV2hlbiBhIGNsaWVudCByZWNlaXZlZCBTeW5jU3RlcDIsIGl0IHNob3VsZCByZXBseSB3aXRoIFN5bmNEb25lLiBXaGVuIHRoZSBsb2NhbCBjbGllbnQgcmVjZWl2ZWQgYm90aFxuICogU3luY1N0ZXAyIGFuZCBTeW5jRG9uZSwgaXQgaXMgYXNzdXJlZCB0aGF0IGl0IGlzIHN5bmNlZCB0byB0aGUgcmVtb3RlIGNsaWVudC5cbiAqXG4gKiBJbiBhIGNsaWVudC1zZXJ2ZXIgbW9kZWwsIHlvdSB3YW50IHRvIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5OiBUaGUgY2xpZW50IHNob3VsZCBpbml0aWF0ZSB0aGUgY29ubmVjdGlvbiB3aXRoIFN5bmNTdGVwMS5cbiAqIFdoZW4gdGhlIHNlcnZlciByZWNlaXZlcyBTeW5jU3RlcDEsIGl0IHNob3VsZCByZXBseSB3aXRoIFN5bmNTdGVwMiBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBTeW5jU3RlcDEuIFRoZSBjbGllbnQgcmVwbGllc1xuICogd2l0aCBTeW5jU3RlcDIgd2hlbiBpdCByZWNlaXZlcyBTeW5jU3RlcDEuIE9wdGlvbmFsbHkgdGhlIHNlcnZlciBtYXkgc2VuZCBhIFN5bmNEb25lIGFmdGVyIGl0IHJlY2VpdmVkIFN5bmNTdGVwMiwgc28gdGhlXG4gKiBjbGllbnQga25vd3MgdGhhdCB0aGUgc3luYyBpcyBmaW5pc2hlZC4gIFRoZXJlIGFyZSB0d28gcmVhc29ucyBmb3IgdGhpcyBtb3JlIGVsYWJvcmF0ZWQgc3luYyBtb2RlbDogMS4gVGhpcyBwcm90b2NvbCBjYW5cbiAqIGVhc2lseSBiZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2YgaHR0cCBhbmQgd2Vic29ja2V0cy4gMi4gVGhlIHNlcnZlciBzaG91bCBvbmx5IHJlcGx5IHRvIHJlcXVlc3RzLCBhbmQgbm90IGluaXRpYXRlIHRoZW0uXG4gKiBUaGVyZWZvcmUgaXQgaXMgbmVjZXNhcnJ5IHRoYXQgdGhlIGNsaWVudCBpbml0aWF0ZXMgdGhlIHN5bmMuXG4gKlxuICogQ29uc3RydWN0aW9uIG9mIGEgbWVzc2FnZTpcbiAqIFttZXNzYWdlVHlwZSA6IHZhclVpbnQsIG1lc3NhZ2UgZGVmaW5pdGlvbi4uXVxuICpcbiAqIE5vdGU6IEEgbWVzc2FnZSBkb2VzIG5vdCBpbmNsdWRlIGluZm9ybWF0aW9uIGFib3V0IHRoZSByb29tIG5hbWUuIFRoaXMgbXVzdCB0byBiZSBoYW5kbGVkIGJ5IHRoZSB1cHBlciBsYXllciBwcm90b2NvbCFcbiAqXG4gKiBzdHJpbmdpZnlbbWVzc2FnZVR5cGVdIHN0cmluZ2lmaWVzIGEgbWVzc2FnZSBkZWZpbml0aW9uIChtZXNzYWdlVHlwZSBpcyBhbHJlYWR5IHJlYWQgZnJvbSB0aGUgYnVmZmZlcilcbiAqL1xuXG5leHBvcnQgY29uc3QgbWVzc2FnZVlqc1N5bmNTdGVwMSA9IDBcbmV4cG9ydCBjb25zdCBtZXNzYWdlWWpzU3luY1N0ZXAyID0gMVxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VZanNVcGRhdGUgPSAyXG5cbi8qKlxuICogQ3JlYXRlIGEgc3luYyBzdGVwIDEgbWVzc2FnZSBiYXNlZCBvbiB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgc2hhcmVkIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVN5bmNTdGVwMSA9IChlbmNvZGVyLCBkb2MpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VZanNTeW5jU3RlcDEpXG4gIGNvbnN0IHN2ID0gWS5lbmNvZGVTdGF0ZVZlY3Rvcihkb2MpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBzdilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSBbZW5jb2RlZFN0YXRlVmVjdG9yXVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVTeW5jU3RlcDIgPSAoZW5jb2RlciwgZG9jLCBlbmNvZGVkU3RhdGVWZWN0b3IpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VZanNTeW5jU3RlcDIpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBZLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jLCBlbmNvZGVkU3RhdGVWZWN0b3IpKVxufVxuXG4vKipcbiAqIFJlYWQgU3luY1N0ZXAxIG1lc3NhZ2UgYW5kIHJlcGx5IHdpdGggU3luY1N0ZXAyLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlciBUaGUgcmVwbHkgdG8gdGhlIHJlY2VpdmVkIG1lc3NhZ2VcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlciBUaGUgcmVjZWl2ZWQgbWVzc2FnZVxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkU3luY1N0ZXAxID0gKGRlY29kZXIsIGVuY29kZXIsIGRvYykgPT5cbiAgd3JpdGVTeW5jU3RlcDIoZW5jb2RlciwgZG9jLCBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSlcblxuLyoqXG4gKiBSZWFkIGFuZCBhcHBseSBTdHJ1Y3RzIGFuZCB0aGVuIERlbGV0ZVN0b3JlIHRvIGEgeSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICogQHBhcmFtIHthbnl9IHRyYW5zYWN0aW9uT3JpZ2luXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkU3luY1N0ZXAyID0gKGRlY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHtcbiAgdHJ5IHtcbiAgICBZLmFwcGx5VXBkYXRlKGRvYywgZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIHRyYW5zYWN0aW9uT3JpZ2luKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFRoaXMgY2F0Y2hlcyBlcnJvcnMgdGhhdCBhcmUgdGhyb3duIGJ5IGV2ZW50IGhhbmRsZXJzXG4gICAgY29uc29sZS5lcnJvcignQ2F1Z2h0IGVycm9yIHdoaWxlIGhhbmRsaW5nIGEgWWpzIHVwZGF0ZScsIGVycm9yKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVcGRhdGUgPSAoZW5jb2RlciwgdXBkYXRlKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzVXBkYXRlKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdXBkYXRlKVxufVxuXG4vKipcbiAqIFJlYWQgYW5kIGFwcGx5IFN0cnVjdHMgYW5kIHRoZW4gRGVsZXRlU3RvcmUgdG8gYSB5IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVcGRhdGUgPSByZWFkU3luY1N0ZXAyXG5cbi8qKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyIEEgbWVzc2FnZSByZWNlaXZlZCBmcm9tIGFub3RoZXIgY2xpZW50XG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXIgVGhlIHJlcGx5IG1lc3NhZ2UuIFdpbGwgbm90IGJlIHNlbnQgaWYgZW1wdHkuXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVhZFN5bmNNZXNzYWdlID0gKGRlY29kZXIsIGVuY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHtcbiAgY29uc3QgbWVzc2FnZVR5cGUgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBzd2l0Y2ggKG1lc3NhZ2VUeXBlKSB7XG4gICAgY2FzZSBtZXNzYWdlWWpzU3luY1N0ZXAxOlxuICAgICAgcmVhZFN5bmNTdGVwMShkZWNvZGVyLCBlbmNvZGVyLCBkb2MpXG4gICAgICBicmVha1xuICAgIGNhc2UgbWVzc2FnZVlqc1N5bmNTdGVwMjpcbiAgICAgIHJlYWRTeW5jU3RlcDIoZGVjb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlWWpzVXBkYXRlOlxuICAgICAgcmVhZFVwZGF0ZShkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1lc3NhZ2UgdHlwZScpXG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2VUeXBlXG59XG4iLCIvKlxuVW5saWtlIHN0YXRlZCBpbiB0aGUgTElDRU5TRSBmaWxlLCBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGluY2x1ZGUgdGhlIGNvcHlyaWdodCBub3RpY2UgYW5kIHBlcm1pc3Npb24gbm90aWNlIHdoZW4geW91IGNvcHkgY29kZSBmcm9tIHRoaXMgZmlsZS5cbiovXG5cbi8qKlxuICogQG1vZHVsZSBwcm92aWRlci93ZWJzb2NrZXRcbiAqL1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCAqIGFzIGJjIGZyb20gJ2xpYjAvYnJvYWRjYXN0Y2hhbm5lbCdcbmltcG9ydCAqIGFzIHRpbWUgZnJvbSAnbGliMC90aW1lJ1xuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyBzeW5jUHJvdG9jb2wgZnJvbSAneS1wcm90b2NvbHMvc3luYydcbmltcG9ydCAqIGFzIGF1dGhQcm90b2NvbCBmcm9tICd5LXByb3RvY29scy9hdXRoJ1xuaW1wb3J0ICogYXMgYXdhcmVuZXNzUHJvdG9jb2wgZnJvbSAneS1wcm90b2NvbHMvYXdhcmVuZXNzJ1xuaW1wb3J0ICogYXMgbXV0ZXggZnJvbSAnbGliMC9tdXRleCdcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCAqIGFzIHVybCBmcm9tICdsaWIwL3VybCdcblxuY29uc3QgbWVzc2FnZVN5bmMgPSAwXG5jb25zdCBtZXNzYWdlUXVlcnlBd2FyZW5lc3MgPSAzXG5jb25zdCBtZXNzYWdlQXdhcmVuZXNzID0gMVxuY29uc3QgbWVzc2FnZUF1dGggPSAyXG5cbi8qKlxuICogICAgICAgICAgICAgICAgICAgICAgIGVuY29kZXIsICAgICAgICAgIGRlY29kZXIsICAgICAgICAgIHByb3ZpZGVyLCAgICAgICAgICBlbWl0U3luY2VkLCBtZXNzYWdlVHlwZVxuICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKGVuY29kaW5nLkVuY29kZXIsIGRlY29kaW5nLkRlY29kZXIsIFdlYnNvY2tldFByb3ZpZGVyLCBib29sZWFuLCAgICBudW1iZXIpOnZvaWQ+fVxuICovXG5jb25zdCBtZXNzYWdlSGFuZGxlcnMgPSBbXVxuXG5tZXNzYWdlSGFuZGxlcnNbbWVzc2FnZVN5bmNdID0gKGVuY29kZXIsIGRlY29kZXIsIHByb3ZpZGVyLCBlbWl0U3luY2VkLCBtZXNzYWdlVHlwZSkgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVN5bmMpXG4gIGNvbnN0IHN5bmNNZXNzYWdlVHlwZSA9IHN5bmNQcm90b2NvbC5yZWFkU3luY01lc3NhZ2UoZGVjb2RlciwgZW5jb2RlciwgcHJvdmlkZXIuZG9jLCBwcm92aWRlcilcbiAgaWYgKGVtaXRTeW5jZWQgJiYgc3luY01lc3NhZ2VUeXBlID09PSBzeW5jUHJvdG9jb2wubWVzc2FnZVlqc1N5bmNTdGVwMiAmJiAhcHJvdmlkZXIuc3luY2VkKSB7XG4gICAgcHJvdmlkZXIuc3luY2VkID0gdHJ1ZVxuICB9XG59XG5cbm1lc3NhZ2VIYW5kbGVyc1ttZXNzYWdlUXVlcnlBd2FyZW5lc3NdID0gKGVuY29kZXIsIGRlY29kZXIsIHByb3ZpZGVyLCBlbWl0U3luY2VkLCBtZXNzYWdlVHlwZSkgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZUF3YXJlbmVzcylcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZShwcm92aWRlci5hd2FyZW5lc3MsIEFycmF5LmZyb20ocHJvdmlkZXIuYXdhcmVuZXNzLmdldFN0YXRlcygpLmtleXMoKSkpKVxufVxuXG5tZXNzYWdlSGFuZGxlcnNbbWVzc2FnZUF3YXJlbmVzc10gPSAoZW5jb2RlciwgZGVjb2RlciwgcHJvdmlkZXIsIGVtaXRTeW5jZWQsIG1lc3NhZ2VUeXBlKSA9PiB7XG4gIGF3YXJlbmVzc1Byb3RvY29sLmFwcGx5QXdhcmVuZXNzVXBkYXRlKHByb3ZpZGVyLmF3YXJlbmVzcywgZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIHByb3ZpZGVyKVxufVxuXG5tZXNzYWdlSGFuZGxlcnNbbWVzc2FnZUF1dGhdID0gKGVuY29kZXIsIGRlY29kZXIsIHByb3ZpZGVyLCBlbWl0U3luY2VkLCBtZXNzYWdlVHlwZSkgPT4ge1xuICBhdXRoUHJvdG9jb2wucmVhZEF1dGhNZXNzYWdlKGRlY29kZXIsIHByb3ZpZGVyLmRvYywgcGVybWlzc2lvbkRlbmllZEhhbmRsZXIpXG59XG5cbmNvbnN0IHJlY29ubmVjdFRpbWVvdXRCYXNlID0gMTIwMFxuY29uc3QgbWF4UmVjb25uZWN0VGltZW91dCA9IDI1MDBcbi8vIEB0b2RvIC0gdGhpcyBzaG91bGQgZGVwZW5kIG9uIGF3YXJlbmVzcy5vdXRkYXRlZFRpbWVcbmNvbnN0IG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0ID0gMzAwMDBcblxuLyoqXG4gKiBAcGFyYW0ge1dlYnNvY2tldFByb3ZpZGVyfSBwcm92aWRlclxuICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICovXG5jb25zdCBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlciA9IChwcm92aWRlciwgcmVhc29uKSA9PiBjb25zb2xlLndhcm4oYFBlcm1pc3Npb24gZGVuaWVkIHRvIGFjY2VzcyAke3Byb3ZpZGVyLnVybH0uXFxuJHtyZWFzb259YClcblxuLyoqXG4gKiBAcGFyYW0ge1dlYnNvY2tldFByb3ZpZGVyfSBwcm92aWRlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW1pdFN5bmNlZFxuICogQHJldHVybiB7ZW5jb2RpbmcuRW5jb2Rlcn1cbiAqL1xuY29uc3QgcmVhZE1lc3NhZ2UgPSAocHJvdmlkZXIsIGJ1ZiwgZW1pdFN5bmNlZCkgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgY29uc3QgbWVzc2FnZVR5cGUgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IHByb3ZpZGVyLm1lc3NhZ2VIYW5kbGVyc1ttZXNzYWdlVHlwZV1cbiAgaWYgKC8qKiBAdHlwZSB7YW55fSAqLyAobWVzc2FnZUhhbmRsZXIpKSB7XG4gICAgbWVzc2FnZUhhbmRsZXIoZW5jb2RlciwgZGVjb2RlciwgcHJvdmlkZXIsIGVtaXRTeW5jZWQsIG1lc3NhZ2VUeXBlKVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1VuYWJsZSB0byBjb21wdXRlIG1lc3NhZ2UnKVxuICB9XG4gIHJldHVybiBlbmNvZGVyXG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWJzb2NrZXRQcm92aWRlcn0gcHJvdmlkZXJcbiAqL1xuY29uc3Qgc2V0dXBXUyA9IHByb3ZpZGVyID0+IHtcbiAgaWYgKHByb3ZpZGVyLnNob3VsZENvbm5lY3QgJiYgcHJvdmlkZXIud3MgPT09IG51bGwpIHtcbiAgICBjb25zdCB3ZWJzb2NrZXQgPSBuZXcgcHJvdmlkZXIuX1dTKHByb3ZpZGVyLnVybClcbiAgICB3ZWJzb2NrZXQuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgICBwcm92aWRlci53cyA9IHdlYnNvY2tldFxuICAgIHByb3ZpZGVyLndzY29ubmVjdGluZyA9IHRydWVcbiAgICBwcm92aWRlci53c2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgcHJvdmlkZXIuc3luY2VkID0gZmFsc2VcblxuICAgIHdlYnNvY2tldC5vbm1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICBwcm92aWRlci53c0xhc3RNZXNzYWdlUmVjZWl2ZWQgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIGNvbnN0IGVuY29kZXIgPSByZWFkTWVzc2FnZShwcm92aWRlciwgbmV3IFVpbnQ4QXJyYXkoZXZlbnQuZGF0YSksIHRydWUpXG4gICAgICBpZiAoZW5jb2RpbmcubGVuZ3RoKGVuY29kZXIpID4gMSkge1xuICAgICAgICB3ZWJzb2NrZXQuc2VuZChlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gICAgICB9XG4gICAgfVxuICAgIHdlYnNvY2tldC5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgcHJvdmlkZXIud3MgPSBudWxsXG4gICAgICBwcm92aWRlci53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgaWYgKHByb3ZpZGVyLndzY29ubmVjdGVkKSB7XG4gICAgICAgIHByb3ZpZGVyLndzY29ubmVjdGVkID0gZmFsc2VcbiAgICAgICAgcHJvdmlkZXIuc3luY2VkID0gZmFsc2VcbiAgICAgICAgLy8gdXBkYXRlIGF3YXJlbmVzcyAoYWxsIHVzZXJzIGV4Y2VwdCBsb2NhbCBsZWZ0KVxuICAgICAgICBhd2FyZW5lc3NQcm90b2NvbC5yZW1vdmVBd2FyZW5lc3NTdGF0ZXMocHJvdmlkZXIuYXdhcmVuZXNzLCBBcnJheS5mcm9tKHByb3ZpZGVyLmF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5rZXlzKCkpLmZpbHRlcihjbGllbnQgPT4gY2xpZW50ICE9PSBwcm92aWRlci5kb2MuY2xpZW50SUQpLCBwcm92aWRlcilcbiAgICAgICAgcHJvdmlkZXIuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgICAgICBzdGF0dXM6ICdkaXNjb25uZWN0ZWQnXG4gICAgICAgIH1dKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdmlkZXIud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzKytcbiAgICAgIH1cbiAgICAgIC8vIFN0YXJ0IHdpdGggbm8gcmVjb25uZWN0IHRpbWVvdXQgYW5kIGluY3JlYXNlIHRpbWVvdXQgYnlcbiAgICAgIC8vIGxvZzEwKHdzVW5zdWNjZXNzZnVsUmVjb25uZWN0cykuXG4gICAgICAvLyBUaGUgaWRlYSBpcyB0byBpbmNyZWFzZSByZWNvbm5lY3QgdGltZW91dCBzbG93bHkgYW5kIGhhdmUgbm8gcmVjb25uZWN0XG4gICAgICAvLyB0aW1lb3V0IGF0IHRoZSBiZWdpbm5pbmcgKGxvZygxKSA9IDApXG4gICAgICBzZXRUaW1lb3V0KHNldHVwV1MsIG1hdGgubWluKG1hdGgubG9nMTAocHJvdmlkZXIud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzICsgMSkgKiByZWNvbm5lY3RUaW1lb3V0QmFzZSwgbWF4UmVjb25uZWN0VGltZW91dCksIHByb3ZpZGVyKVxuICAgIH1cbiAgICB3ZWJzb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgcHJvdmlkZXIud3NMYXN0TWVzc2FnZVJlY2VpdmVkID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBwcm92aWRlci53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgcHJvdmlkZXIud3Njb25uZWN0ZWQgPSB0cnVlXG4gICAgICBwcm92aWRlci53c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMgPSAwXG4gICAgICBwcm92aWRlci5lbWl0KCdzdGF0dXMnLCBbe1xuICAgICAgICBzdGF0dXM6ICdjb25uZWN0ZWQnXG4gICAgICB9XSlcbiAgICAgIC8vIGFsd2F5cyBzZW5kIHN5bmMgc3RlcCAxIHdoZW4gY29ubmVjdGVkXG4gICAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVN5bmMpXG4gICAgICBzeW5jUHJvdG9jb2wud3JpdGVTeW5jU3RlcDEoZW5jb2RlciwgcHJvdmlkZXIuZG9jKVxuICAgICAgd2Vic29ja2V0LnNlbmQoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgICAgLy8gYnJvYWRjYXN0IGxvY2FsIGF3YXJlbmVzcyBzdGF0ZVxuICAgICAgaWYgKHByb3ZpZGVyLmF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlckF3YXJlbmVzc1N0YXRlID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyQXdhcmVuZXNzU3RhdGUsIG1lc3NhZ2VBd2FyZW5lc3MpXG4gICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzU3RhdGUsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZShwcm92aWRlci5hd2FyZW5lc3MsIFtwcm92aWRlci5kb2MuY2xpZW50SURdKSlcbiAgICAgICAgd2Vic29ja2V0LnNlbmQoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJBd2FyZW5lc3NTdGF0ZSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvdmlkZXIuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgIHN0YXR1czogJ2Nvbm5lY3RpbmcnXG4gICAgfV0pXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYnNvY2tldFByb3ZpZGVyfSBwcm92aWRlclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmXG4gKi9cbmNvbnN0IGJyb2FkY2FzdE1lc3NhZ2UgPSAocHJvdmlkZXIsIGJ1ZikgPT4ge1xuICBpZiAocHJvdmlkZXIud3Njb25uZWN0ZWQpIHtcbiAgICAvKiogQHR5cGUge1dlYlNvY2tldH0gKi8gKHByb3ZpZGVyLndzKS5zZW5kKGJ1ZilcbiAgfVxuICBpZiAocHJvdmlkZXIuYmNjb25uZWN0ZWQpIHtcbiAgICBwcm92aWRlci5tdXgoKCkgPT4ge1xuICAgICAgYmMucHVibGlzaChwcm92aWRlci5iY0NoYW5uZWwsIGJ1ZilcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogV2Vic29ja2V0IFByb3ZpZGVyIGZvciBZanMuIENyZWF0ZXMgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiB0byBzeW5jIHRoZSBzaGFyZWQgZG9jdW1lbnQuXG4gKiBUaGUgZG9jdW1lbnQgbmFtZSBpcyBhdHRhY2hlZCB0byB0aGUgcHJvdmlkZWQgdXJsLiBJLmUuIHRoZSBmb2xsb3dpbmcgZXhhbXBsZVxuICogY3JlYXRlcyBhIHdlYnNvY2tldCBjb25uZWN0aW9uIHRvIGh0dHA6Ly9sb2NhbGhvc3Q6MTIzNC9teS1kb2N1bWVudC1uYW1lXG4gKlxuICogQGV4YW1wbGVcbiAqICAgaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG4gKiAgIGltcG9ydCB7IFdlYnNvY2tldFByb3ZpZGVyIH0gZnJvbSAneS13ZWJzb2NrZXQnXG4gKiAgIGNvbnN0IGRvYyA9IG5ldyBZLkRvYygpXG4gKiAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IFdlYnNvY2tldFByb3ZpZGVyKCdodHRwOi8vbG9jYWxob3N0OjEyMzQnLCAnbXktZG9jdW1lbnQtbmFtZScsIGRvYylcbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2YWJsZTxzdHJpbmc+fVxuICovXG5leHBvcnQgY2xhc3MgV2Vic29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJVcmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb21uYW1lXG4gICAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdHNdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuY29ubmVjdF1cbiAgICogQHBhcmFtIHthd2FyZW5lc3NQcm90b2NvbC5Bd2FyZW5lc3N9IFtvcHRzLmF3YXJlbmVzc11cbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLHN0cmluZz59IFtvcHRzLnBhcmFtc11cbiAgICogQHBhcmFtIHt0eXBlb2YgV2ViU29ja2V0fSBbb3B0cy5XZWJTb2NrZXRQb2x5ZmlsbF0gT3B0aW9uYWxsIHByb3ZpZGUgYSBXZWJTb2NrZXQgcG9seWZpbGxcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJlc3luY0ludGVydmFsXSBSZXF1ZXN0IHNlcnZlciBzdGF0ZSBldmVyeSBgcmVzeW5jSW50ZXJ2YWxgIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHNlcnZlclVybCwgcm9vbW5hbWUsIGRvYywgeyBjb25uZWN0ID0gdHJ1ZSwgYXdhcmVuZXNzID0gbmV3IGF3YXJlbmVzc1Byb3RvY29sLkF3YXJlbmVzcyhkb2MpLCBwYXJhbXMgPSB7fSwgV2ViU29ja2V0UG9seWZpbGwgPSBXZWJTb2NrZXQsIHJlc3luY0ludGVydmFsID0gLTEgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIC8vIGVuc3VyZSB0aGF0IHVybCBpcyBhbHdheXMgZW5kcyB3aXRoIC9cbiAgICB3aGlsZSAoc2VydmVyVXJsW3NlcnZlclVybC5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICBzZXJ2ZXJVcmwgPSBzZXJ2ZXJVcmwuc2xpY2UoMCwgc2VydmVyVXJsLmxlbmd0aCAtIDEpXG4gICAgfVxuICAgIGNvbnN0IGVuY29kZWRQYXJhbXMgPSB1cmwuZW5jb2RlUXVlcnlQYXJhbXMocGFyYW1zKVxuICAgIHRoaXMuYmNDaGFubmVsID0gc2VydmVyVXJsICsgJy8nICsgcm9vbW5hbWVcbiAgICB0aGlzLnVybCA9IHNlcnZlclVybCArICcvJyArIHJvb21uYW1lICsgKGVuY29kZWRQYXJhbXMubGVuZ3RoID09PSAwID8gJycgOiAnPycgKyBlbmNvZGVkUGFyYW1zKVxuICAgIHRoaXMucm9vbW5hbWUgPSByb29tbmFtZVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgdGhpcy5fV1MgPSBXZWJTb2NrZXRQb2x5ZmlsbFxuICAgIHRoaXMuYXdhcmVuZXNzID0gYXdhcmVuZXNzXG4gICAgdGhpcy53c2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHRoaXMuYmNjb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzID0gMFxuICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzID0gbWVzc2FnZUhhbmRsZXJzLnNsaWNlKClcbiAgICB0aGlzLm11eCA9IG11dGV4LmNyZWF0ZU11dGV4KClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9zeW5jZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtXZWJTb2NrZXQ/fVxuICAgICAqL1xuICAgIHRoaXMud3MgPSBudWxsXG4gICAgdGhpcy53c0xhc3RNZXNzYWdlUmVjZWl2ZWQgPSAwXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBjb25uZWN0IHRvIG90aGVyIHBlZXJzIG9yIG5vdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IGNvbm5lY3RcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fcmVzeW5jSW50ZXJ2YWwgPSAwXG4gICAgaWYgKHJlc3luY0ludGVydmFsID4gMCkge1xuICAgICAgdGhpcy5fcmVzeW5jSW50ZXJ2YWwgPSAvKiogQHR5cGUge2FueX0gKi8gKHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAvLyByZXNlbmQgc3luYyBzdGVwIDFcbiAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VTeW5jKVxuICAgICAgICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMShlbmNvZGVyLCBkb2MpXG4gICAgICAgICAgdGhpcy53cy5zZW5kKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICAgICAgfVxuICAgICAgfSwgcmVzeW5jSW50ZXJ2YWwpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAgICAgKi9cbiAgICB0aGlzLl9iY1N1YnNjcmliZXIgPSBkYXRhID0+IHtcbiAgICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IHJlYWRNZXNzYWdlKHRoaXMsIG5ldyBVaW50OEFycmF5KGRhdGEpLCBmYWxzZSlcbiAgICAgICAgaWYgKGVuY29kaW5nLmxlbmd0aChlbmNvZGVyKSA+IDEpIHtcbiAgICAgICAgICBiYy5wdWJsaXNoKHRoaXMuYmNDaGFubmVsLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RlbnMgdG8gWWpzIHVwZGF0ZXMgYW5kIHNlbmRzIHRoZW0gdG8gcmVtb3RlIHBlZXJzICh3cyBhbmQgYnJvYWRjYXN0Y2hhbm5lbClcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICAgKi9cbiAgICB0aGlzLl91cGRhdGVIYW5kbGVyID0gKHVwZGF0ZSwgb3JpZ2luKSA9PiB7XG4gICAgICBpZiAob3JpZ2luICE9PSB0aGlzKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VTeW5jKVxuICAgICAgICBzeW5jUHJvdG9jb2wud3JpdGVVcGRhdGUoZW5jb2RlciwgdXBkYXRlKVxuICAgICAgICBicm9hZGNhc3RNZXNzYWdlKHRoaXMsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kb2Mub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZUhhbmRsZXIpXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAgICovXG4gICAgdGhpcy5fYXdhcmVuZXNzVXBkYXRlSGFuZGxlciA9ICh7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH0sIG9yaWdpbikgPT4ge1xuICAgICAgY29uc3QgY2hhbmdlZENsaWVudHMgPSBhZGRlZC5jb25jYXQodXBkYXRlZCkuY29uY2F0KHJlbW92ZWQpXG4gICAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBhd2FyZW5lc3NQcm90b2NvbC5lbmNvZGVBd2FyZW5lc3NVcGRhdGUoYXdhcmVuZXNzLCBjaGFuZ2VkQ2xpZW50cykpXG4gICAgICBicm9hZGNhc3RNZXNzYWdlKHRoaXMsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICB9XG4gICAgdGhpcy5fYmVmb3JlVW5sb2FkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGF3YXJlbmVzc1Byb3RvY29sLnJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLmF3YXJlbmVzcywgW2RvYy5jbGllbnRJRF0sICd3aW5kb3cgdW5sb2FkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5fYmVmb3JlVW5sb2FkSGFuZGxlcilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcHJvY2Vzcy5vbignZXhpdCcsICgpID0+IHRoaXMuX2JlZm9yZVVubG9hZEhhbmRsZXIpXG4gICAgfVxuICAgIGF3YXJlbmVzcy5vbigndXBkYXRlJywgdGhpcy5fYXdhcmVuZXNzVXBkYXRlSGFuZGxlcilcbiAgICB0aGlzLl9jaGVja0ludGVydmFsID0gLyoqIEB0eXBlIHthbnl9ICovIChzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy53c2Nvbm5lY3RlZCAmJiBtZXNzYWdlUmVjb25uZWN0VGltZW91dCA8IHRpbWUuZ2V0VW5peFRpbWUoKSAtIHRoaXMud3NMYXN0TWVzc2FnZVJlY2VpdmVkKSB7XG4gICAgICAgIC8vIG5vIG1lc3NhZ2UgcmVjZWl2ZWQgaW4gYSBsb25nIHRpbWUgLSBub3QgZXZlbiB5b3VyIG93biBhd2FyZW5lc3NcbiAgICAgICAgLy8gdXBkYXRlcyAod2hpY2ggYXJlIHVwZGF0ZWQgZXZlcnkgMTUgc2Vjb25kcylcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJTb2NrZXR9ICovICh0aGlzLndzKS5jbG9zZSgpXG4gICAgICB9XG4gICAgfSwgbWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgLyAxMCkpXG4gICAgaWYgKGNvbm5lY3QpIHtcbiAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHN5bmNlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bmNlZFxuICB9XG5cbiAgc2V0IHN5bmNlZCAoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fc3luY2VkICE9PSBzdGF0ZSkge1xuICAgICAgdGhpcy5fc3luY2VkID0gc3RhdGVcbiAgICAgIHRoaXMuZW1pdCgnc3luY2VkJywgW3N0YXRlXSlcbiAgICAgIHRoaXMuZW1pdCgnc3luYycsIFtzdGF0ZV0pXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgaWYgKHRoaXMuX3Jlc3luY0ludGVydmFsICE9PSAwKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3Jlc3luY0ludGVydmFsKVxuICAgIH1cbiAgICBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrSW50ZXJ2YWwpXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLl9iZWZvcmVVbmxvYWRIYW5kbGVyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwcm9jZXNzLm9mZignZXhpdCcsICgpID0+IHRoaXMuX2JlZm9yZVVubG9hZEhhbmRsZXIpXG4gICAgfVxuICAgIHRoaXMuYXdhcmVuZXNzLm9mZigndXBkYXRlJywgdGhpcy5fYXdhcmVuZXNzVXBkYXRlSGFuZGxlcilcbiAgICB0aGlzLmRvYy5vZmYoJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZUhhbmRsZXIpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gIH1cblxuICBjb25uZWN0QmMgKCkge1xuICAgIGlmICghdGhpcy5iY2Nvbm5lY3RlZCkge1xuICAgICAgYmMuc3Vic2NyaWJlKHRoaXMuYmNDaGFubmVsLCB0aGlzLl9iY1N1YnNjcmliZXIpXG4gICAgICB0aGlzLmJjY29ubmVjdGVkID0gdHJ1ZVxuICAgIH1cbiAgICAvLyBzZW5kIHN5bmMgc3RlcDEgdG8gYmNcbiAgICB0aGlzLm11eCgoKSA9PiB7XG4gICAgICAvLyB3cml0ZSBzeW5jIHN0ZXAgMVxuICAgICAgY29uc3QgZW5jb2RlclN5bmMgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyU3luYywgbWVzc2FnZVN5bmMpXG4gICAgICBzeW5jUHJvdG9jb2wud3JpdGVTeW5jU3RlcDEoZW5jb2RlclN5bmMsIHRoaXMuZG9jKVxuICAgICAgYmMucHVibGlzaCh0aGlzLmJjQ2hhbm5lbCwgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJTeW5jKSlcbiAgICAgIC8vIGJyb2FkY2FzdCBsb2NhbCBzdGF0ZVxuICAgICAgY29uc3QgZW5jb2RlclN0YXRlID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlclN0YXRlLCBtZXNzYWdlU3luYylcbiAgICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMihlbmNvZGVyU3RhdGUsIHRoaXMuZG9jKVxuICAgICAgYmMucHVibGlzaCh0aGlzLmJjQ2hhbm5lbCwgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJTdGF0ZSkpXG4gICAgICAvLyB3cml0ZSBxdWVyeUF3YXJlbmVzc1xuICAgICAgY29uc3QgZW5jb2RlckF3YXJlbmVzc1F1ZXJ5ID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlckF3YXJlbmVzc1F1ZXJ5LCBtZXNzYWdlUXVlcnlBd2FyZW5lc3MpXG4gICAgICBiYy5wdWJsaXNoKHRoaXMuYmNDaGFubmVsLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzc1F1ZXJ5KSlcbiAgICAgIC8vIGJyb2FkY2FzdCBsb2NhbCBhd2FyZW5lc3Mgc3RhdGVcbiAgICAgIGNvbnN0IGVuY29kZXJBd2FyZW5lc3NTdGF0ZSA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXJBd2FyZW5lc3NTdGF0ZSwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzU3RhdGUsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZSh0aGlzLmF3YXJlbmVzcywgW3RoaXMuZG9jLmNsaWVudElEXSkpXG4gICAgICBiYy5wdWJsaXNoKHRoaXMuYmNDaGFubmVsLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzc1N0YXRlKSlcbiAgICB9KVxuICB9XG5cbiAgZGlzY29ubmVjdEJjICgpIHtcbiAgICAvLyBicm9hZGNhc3QgbWVzc2FnZSB3aXRoIGxvY2FsIGF3YXJlbmVzcyBzdGF0ZSBzZXQgdG8gbnVsbCAoaW5kaWNhdGluZyBkaXNjb25uZWN0KVxuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgYXdhcmVuZXNzUHJvdG9jb2wuZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHRoaXMuYXdhcmVuZXNzLCBbdGhpcy5kb2MuY2xpZW50SURdLCBuZXcgTWFwKCkpKVxuICAgIGJyb2FkY2FzdE1lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgIGlmICh0aGlzLmJjY29ubmVjdGVkKSB7XG4gICAgICBiYy51bnN1YnNjcmliZSh0aGlzLmJjQ2hhbm5lbCwgdGhpcy5fYmNTdWJzY3JpYmVyKVxuICAgICAgdGhpcy5iY2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gZmFsc2VcbiAgICB0aGlzLmRpc2Nvbm5lY3RCYygpXG4gICAgaWYgKHRoaXMud3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3QgKCkge1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IHRydWVcbiAgICBpZiAoIXRoaXMud3Njb25uZWN0ZWQgJiYgdGhpcy53cyA9PT0gbnVsbCkge1xuICAgICAgc2V0dXBXUyh0aGlzKVxuICAgICAgdGhpcy5jb25uZWN0QmMoKVxuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==