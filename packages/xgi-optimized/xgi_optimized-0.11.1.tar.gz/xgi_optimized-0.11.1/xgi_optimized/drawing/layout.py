"""Algorithms to compute node positions for drawing."""

import random

import igraph as ig
import numpy as np
from numpy.linalg import inv, svd
from .. import convert
from ..convert.bipartite_graph import to_bipartite_graph
from xgi.core import DiHypergraph, SimplicialComplex

__all__ = [
    "random_layout",
    "pairwise_spring_layout",
    "barycenter_spring_layout",
    "weighted_barycenter_spring_layout",
    "pca_transform",
    "circular_layout",
    "spiral_layout",
    "barycenter_kamada_kawai_layout",
    "bipartite_spring_layout",
    "edge_positions_from_barycenters",
]


def vertexes_to_graph(H):
    empty_graph = ig.Graph()
    phantom_node_id = 0
    for n in H.nodes:
        empty_graph.add_vertex(n)
        for k, v in H.nodes[n].items():
            empty_graph.vs[phantom_node_id][k] = v
        phantom_node_id += 1
    return empty_graph


def random_layout(H, center=None, seed=None):
    """Position nodes uniformly at random in the unit square.

    For every node, a position is generated by choosing each of dim coordinates
    uniformly at random on the interval [0.0, 1.0).  NumPy (http://scipy.org) is
    required for this function.

    Parameters
    ----------
    H : Hypergraph or SimplicialComplex
        A position will be assigned to every node in HG.
    center : array-like, optional
        Coordinate pair around which to center the layout.
        If None (default), does not center the positions.
    seed : int, optional
        Set the random state for deterministic node layouts.
        If int, `seed` is the seed used by the random number generator,
        If None (default), random numbers are sampled from the
        numpy random number generator without initialization.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    See Also
    --------
    pairwise_spring_layout
    barycenter_spring_layout
    weighted_barycenter_spring_layout

    Notes
    -----
    This function proceeds exactly as NetworkX does.

    Examples
    --------
    >>> import xgi_optimized
    >>> N = 50
    >>> ps = [0.1, 0.01]
    >>> H = xgi_optimized.random_hypergraph(N, ps)
    >>> pos = xgi_optimized.random_layout(H)

    """
    import numpy as np

    if isinstance(H, SimplicialComplex):
        H = convert.from_max_simplices(H)

    if seed is not None:
        np.random.seed(seed)

    if not isinstance(H, ig.Graph):
        H = vertexes_to_graph(H)

    if center is None:
        center = np.zeros(2)
    else:
        center = np.asarray(center)

    if len(center) != 2:
        msg = "length of center coordinates must match dimension of layout"
        raise ValueError(msg)

    pos = np.random.rand(len(H.vs), 2) + center
    pos = pos.astype(np.float32)
    pos = dict(zip(H.vs.indices, pos))
    return pos


def pairwise_spring_layout(H, seed=None, k=None, **kwargs):
    """
    Position the nodes using Fruchterman-Reingold force-directed
    algorithm using the graph projection of the hypergraph
    or the hypergraph constructed from the simplicial complex.

    Parameters
    ----------
    H : Hypergraph or SimplicialComplex
        A position will be assigned to every node in H.
    seed : int, optional
        Set the random state for deterministic node layouts.
        If int, `seed` is the seed used by the random number generator,
        If None (default), random numbers are sampled from the
        numpy random number generator without initialization.
    k : float
        The spring constant of the links. When k=None (default),
        k = 1/sqrt(N). For more information, see the documentation
        for the NetworkX spring_layout() function.
    kwargs :
        Optional arguments for the NetworkX spring_layout() function.
        See https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    See Also
    --------
    random_layout
    barycenter_spring_layout
    weighted_barycenter_spring_layout

    Notes
    -----
    If a simplicial complex is provided the results will be based on the
    hypergraph constructed from its maximal simplices.

    Examples
    --------
    >>> import xgi_optimized
    >>> N = 50
    >>> ps = [0.1, 0.01]
    >>> H = xgi_optimized.random_hypergraph(N, ps)
    >>> pos = xgi_optimized.pairwise_spring_layout(H)
    """

    if seed is not None:
        random.seed(seed)

    if isinstance(H, SimplicialComplex):
        H = convert.from_max_simplices(H)
    G = convert.to_ig_graph(H)
    pos = G.layout_fruchterman_reingold(dim=2, seed=seed)
    return pos


def _augmented_projection(H, weighted=False):
    """Augmented version of the the graph projection of the hypergraph
    (or simplicial complex), where phantom nodes (barycenters) are created
    for each edge composed by more than two nodes.

    Parameters
    ----------
    H : Hypergraph or SimplicialComplex
    weighted : bool (default=False)
               If True weights are assigned to all hyperedges of order d=1 (links)
               and to all connections to phantom nodes within each hyperedge of
               order d>1 to keep them together. Weights scale as the order d.


    Returns
    -------
    G : networkx.Graph
        The augmented version of the graph projection
    """

    # Создание пустого графа igraph
    G = ig.Graph()
    phantom_node_id = 0
    for n in H.nodes:
        G.add_vertex(n)
        G.vs[phantom_node_id]["type"] = False
        for k, v in H.nodes[n].items():
            G.vs[phantom_node_id][k] = v
        phantom_node_id += 1

    edges = H.edges.filterby("order", 1, "geq")

    # Looping over the hyperedges of different order
    for he_id, members in edges.members(dtype=dict).items():
        d = len(members) - 1
        # Adding one phantom node for each hyperedge

        G.add_vertex(phantom_node_id)
        G.vs[phantom_node_id]["type"] = True
        # and linking it to the nodes of the hyperedge
        for n in members:

            if weighted:
                G.add_edge(G.vs.find(name=phantom_node_id).index, G.vs.find(name=n).index, weight=d)
            else:
                G.add_edge(G.vs.find(name=phantom_node_id).index, G.vs.find(name=n).index)
        phantom_node_id += 1

    return G


def bipartite_spring_layout(H, seed=None, k=None, **kwargs):
    """
    Position the nodes and edges using Fruchterman-Reingold force-directed
    algorithm using the hypergraph converted to a bipartite network.

    Parameters
    ----------
    H : Hypergraph
        A position will be assigned to every node and edge in H.
    seed : int, RandomState instance or None  optional (default=None)
        Set the random state for deterministic node layouts.
        If int, `seed` is the seed used by the random number generator,
        If None (default), random numbers are sampled from the
        numpy random number generator without initialization.
    k : float
        The spring constant of the links. When k=None (default),
        k = 1/sqrt(N). For more information, see the documentation
        for the NetworkX spring_layout() function.
    kwargs :
        Optional arguments for the NetworkX spring_layout() function.
        See https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html


    Returns
    -------
    pos : tuple of dicts
        A tuple of two dictionaries:
        the first is a dictionary of positions keyed by node
        the second is a dictionary of positions keyed by edge

    See Also
    --------
    random_layout
    pairwise_spring_layout
    weighted_barycenter_spring_layout

    Examples
    --------
    >>> import xgi_optimized
    >>> N = 50
    >>> ps = [0.1, 0.01]
    >>> H = xgi_optimized.random_hypergraph(N, ps)
    >>> pos = xgi_optimized.bipartite_spring_layout(H)
    """
    if seed is not None:
        random.seed(seed)

    G, nodedict, edgedict = to_bipartite_graph(H, index=True)

    # Creating a dictionary for the position of the nodes with the standard spring
    # layout
    pos = G.layout_fruchterman_reingold(seed=seed, k=k, weights="weight")

    node_pos = {nodedict[i]: pos[i] for i in nodedict}
    edge_pos = {edgedict[i]: pos[i] for i in edgedict}

    return node_pos, edge_pos


def edge_positions_from_barycenters(H, node_pos):
    """
    Given a higher-order network and node positions, assigns
    edge marker positions to be the barycenters of its
    member nodes.

    Parameters
    ----------
    H : Hypergraph, SimplicialComplex, or DiHypergraph
        A position will be assigned to every node and edge in H.
    node_pos : dict
        Nodal positions where keys are node ids and values are
        Numpy arrays of the positions.

    Returns
    -------
    edge_pos : dict
        a dictionary of positions keyed by edge

    See Also
    --------
    bipartite_spring_layout

    Examples
    --------
    >>> import xgi_optimized
    >>> N = 50
    >>> ps = [0.1, 0.01]
    >>> H = xgi_optimized.random_hypergraph(N, ps)
    >>> node_pos = xgi_optimized.pairwise_spring_layout(H)
    >>> edge_pos = xgi_optimized.edge_positions_from_barycenters(H, node_pos)
    """
    if isinstance(H, DiHypergraph):
        from ..convert import to_hypergraph

        H = to_hypergraph(H)
    edge_pos = {}
    for idx, e in H.edges.members(dtype=dict).items():
        edge_pos[idx] = np.mean([node_pos[n] for n in e], axis=0)

    return edge_pos


def barycenter_spring_layout(
        H, return_phantom_graph=False, seed=None, k=None, **kwargs
):
    """
    Position the nodes using Fruchterman-Reingold force-directed
    algorithm using an augmented version of the the graph projection
    of the hypergraph (or simplicial complex), where phantom nodes
    (barycenters) are created for each edge composed by more than two nodes.
    If a simplicial complex is provided the results will be based on the
    hypergraph constructed from its maximal simplices.

    Parameters
    ----------
    H : xgi Hypergraph or SimplicialComplex
        A position will be assigned to every node in H.
    return_phantom_graph: bool (default=False)
        If True the function returns also the augmented version of the
        the graph projection of the hypergraph (or simplicial complex).
    seed : int, RandomState instance or None  optional (default=None)
        Set the random state for deterministic node layouts.
        If int, `seed` is the seed used by the random number generator,
        If None (default), random numbers are sampled from the
        numpy random number generator without initialization.
    k : float
        The spring constant of the links. When k=None (default),
        k = 1/sqrt(N). For more information, see the documentation
        for the NetworkX spring_layout() function.
    kwargs :
        Optional arguments for the NetworkX spring_layout() function.
        See https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html


    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    See Also
    --------
    random_layout
    pairwise_spring_layout
    weighted_barycenter_spring_layout

    Examples
    --------
    >>> import xgi_optimized
    >>> N = 50
    >>> ps = [0.1, 0.01]
    >>> H = xgi_optimized.random_hypergraph(N, ps)
    >>> pos = xgi_optimized.barycenter_spring_layout(H)
    """
    if seed is not None:
        random.seed(seed)

    if isinstance(H, SimplicialComplex):
        H = convert.from_max_simplices(H)

    G = _augmented_projection(H)

    # Creating a dictionary for the position of the nodes with the standard spring
    # layout
    pos_with_phantom_nodes = G.layout_fruchterman_reingold(seed=seed)

    # Retaining only the positions of the real nodes
    pos = {k: pos_with_phantom_nodes[k] for k in list(H.nodes)}

    if return_phantom_graph:
        return pos, G
    else:
        return pos


def weighted_barycenter_spring_layout(
        H, return_phantom_graph=False, seed=None, k=None, **kwargs
):
    """Position the nodes using Fruchterman-Reingold force-directed algorithm.

    This uses an augmented version of the the graph projection of the hypergraph (or
    simplicial complex), where phantom nodes (barycenters) are created for each edge of
    order d>1 (composed by more than two nodes).  Weights are assigned to all hyperedges
    of order 1 (links) and to all connections to phantom nodes within each hyperedge to
    keep them together. Weights scale as the order d.  If a simplicial complex is
    provided the results will be based on the hypergraph constructed from its maximal
    simplices.

    Parameters
    ----------
    H : Hypergraph or SimplicialComplex
        A position will be assigned to every node in H.
    return_phantom_graph: bool (default=False)
        If True the function returns also the augmented version of the
        the graph projection of the hypergraph (or simplicial complex).
    seed : int, RandomState instance or None  optional (default=None)
        Set the random state for deterministic node layouts.
        If int, `seed` is the seed used by the random number generator,
        If None (default), random numbers are sampled from the
        numpy random number generator without initialization.
    k : float
        The spring constant of the links. When k=None (default),
        k = 1/sqrt(N). For more information, see the documentation
        for the NetworkX spring_layout() function.
    kwargs :
        Optional arguments for the NetworkX spring_layout() function.
        See https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html


    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node

    See Also
    --------
    random_layout
    pairwise_spring_layout
    barycenter_spring_layout

    Examples
    --------
    >>> import xgi_optimized
    >>> N = 50
    >>> ps = [0.1, 0.01]
    >>> H = xgi_optimized.random_hypergraph(N, ps)
    >>> pos = xgi_optimized.weighted_barycenter_spring_layout(H)

    """
    if seed is not None:
        random.seed(seed)

    if isinstance(H, SimplicialComplex):
        H = convert.from_max_simplices(H)

    G = _augmented_projection(H, weighted=True)

    # Creating a dictionary for node position with the standard spring layout
    pos_with_phantom_nodes = G.layout_fruchterman_reingold(seed=seed)

    # Retaining only the positions of the real nodes
    pos = {k: pos_with_phantom_nodes[k] for k in list(H.nodes)}

    if return_phantom_graph:
        return pos, G
    else:
        return pos


def pca_transform(pos, theta=0, degrees=True):
    """Transforms the positions of the nodes based on the
    principal components.

    Parameters
    ----------
    pos : dict of numpy arrays
        The output from any layout function
    theta : float, optional
        The angle between the horizontal axis and the principal axis
        measured counterclockwise, by default 0.
    degrees : bool, optional
        Whether the angle specified is in degrees (True)
        or in radians (False), by default True.

    Returns
    -------
    dict of numpy arrays
        The transformed positions.

    See Also
    --------
    random_layout
    pairwise_spring_layout
    barycenter_spring_layout
    weighted_barycenter_spring_layout
    """
    p = np.array(list(pos.values()))
    _, _, w = svd(p)

    pa = inv(w)

    if degrees:
        theta *= np.pi / 180

    r = np.array([[np.cos(theta), np.sin(theta)], [-np.sin(theta), np.cos(theta)]])
    t_p = p.dot(pa).dot(r).T
    x = t_p[0]
    y = t_p[1]

    return {n: np.array([x[i], y[i]]) for i, n in enumerate(pos.keys())}


def circular_layout(H, center=None, radius=None):
    """Position nodes on a circle.

    Parameters
    ----------
    H : Hypergraph or SimplicialComplex
        A position will be assigned to every node in H.
    center : array-like or None
        Coordinate pair around which to center the layout.
        If None set to [0,0]
    radius : float or None (default=None)
        Radius of the circle on which to draw the nodes,
        if None set to 1.0.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node
    """
    if center is None:
        center = [0, 0]

    if radius is None:
        radius = 1.0

    if H.num_nodes == 0:
        pos = {}
    elif H.num_nodes == 1:
        pos = {list(H.nodes)[0]: center}
    else:
        theta = np.linspace(0, 1, len(H) + 1)[:-1] * 2 * np.pi
        pos = np.column_stack(
            [radius * np.cos(theta) + center[0], radius * np.sin(theta) + center[1]]
        )
        pos = dict(zip(list(H.nodes), pos))

    return pos


def spiral_layout(H, center=None, resolution=0.35, equidistant=False):
    """Position nodes in a spiral layout.

    Parameters
    ----------
    H : Hypergraph or SimplicialComplex
        A position will be assigned to every node in H.
    center : array-like or None
        Coordinate pair around which to center the layout.
        If None set to [0,0]
    resolution : float, default=0.35
        The compactness of the spiral layout returned.
        Lower values result in more compressed spiral layouts.
    equidistant : bool, default=False
        If True, nodes will be positioned equidistant from each other
        by decreasing angle further from center.
        If False, nodes will be positioned at equal angles
        from each other by increasing separation further from center.

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node
    """
    if center is None:
        center = [0, 0]

    if H.num_nodes == 0:
        pos = {}
        return pos
    elif H.num_nodes == 1:
        pos = {list(H.nodes)[0]: center}
        return pos

    pos = []
    if equidistant:
        chord = 1
        step = 0.5
        theta = resolution
        theta += chord / (step * theta)
        for _ in range(len(H)):
            r = step * theta
            theta += chord / r
            pos.append([np.cos(theta) * r + center[0], np.sin(theta) * r + center[1]])
    else:
        dist = np.arange(len(H), dtype=float)
        angle = resolution * dist
        pos = np.transpose(dist * np.array([np.cos(angle), np.sin(angle)]))

    pos = dict(zip(list(H.nodes), pos))

    return pos


def barycenter_kamada_kawai_layout(H, return_phantom_graph=False, **kwargs):
    """Position nodes using Kamada-Kawai path-length cost-function
    using an augmented version of the the graph projection
    of the hypergraph (or simplicial complex), where phantom nodes
    (barycenters) are created for each edge composed by more than two nodes.
    If a simplicial complex is provided the results will be based on the
    hypergraph constructed from its maximal simplices.

    Parameters
    ----------
    H : xgi_optimized Hypergraph or SimplicialComplex
        A position will be assigned to every node in H.
    return_phantom_graph: bool (default=False)
        If True the function returns also the augmented version of the
        the graph projection of the hypergraph (or simplicial complex).
    kwargs :
        Optional arguments for the NetworkX spring_layout() function.
        See https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.kamada_kawai_layout.html

    Returns
    -------
    pos : dict
        A dictionary of positions keyed by node
    """
    if isinstance(H, SimplicialComplex):
        H = convert.from_max_simplices(H)

    G = _augmented_projection(H)

    # Creating a dictionary for the position of the nodes with the standard spring layout
    pos_with_phantom_nodes = G.layout_kamada_kawai(**kwargs)

    # Retaining only the positions of the real nodes
    pos = {k: pos_with_phantom_nodes[k] for k in list(H.nodes)}

    if return_phantom_graph:
        return pos, G
    else:
        return pos
