from __future__ import annotations

from collections.abc import Callable
from typing import Any, Dict, List, Optional, Type, TypeVar, Union

from flask import Response

from flask_inputfilter.conditions import BaseCondition
from flask_inputfilter.filters import BaseFilter
from flask_inputfilter.models import ExternalApiConfig, FieldModel
from flask_inputfilter.validators import BaseValidator

T = TypeVar("T")

class InputFilter:
    methods: List[str]
    fields: Dict[str, FieldModel]
    conditions: List[BaseCondition]
    global_filters: List[BaseFilter]
    global_validators: List[BaseValidator]
    data: Dict[str, Any]
    validated_data: Dict[str, Any]
    errors: Dict[str, str]
    model_class: Optional[Type[T]]

    def __init__(self, methods: Optional[List[str]] = ...) -> None: ...
    def isValid(self) -> bool: ...
    @classmethod
    def validate(
        cls,
    ) -> Callable[
        [Any],
        Callable[
            [tuple[Any, ...], Dict[str, Any]],
            Union[Response, tuple[Any, Dict[str, Any]]],
        ],
    ]: ...
    def validateData(
        self, data: Optional[Dict[str, Any]] = ...
    ) -> Union[Dict[str, Any], Type[T]]: ...
    def addCondition(self, condition: BaseCondition) -> None: ...
    def getConditions(self) -> List[BaseCondition]: ...
    def setData(self, data: Dict[str, Any]) -> None: ...
    def getValue(self, name: str) -> Any: ...
    def getValues(self) -> Dict[str, Any]: ...
    def getRawValue(self, name: str) -> Any: ...
    def getRawValues(self) -> Dict[str, Any]: ...
    def getUnfilteredData(self) -> Dict[str, Any]: ...
    def setUnfilteredData(self, data: Dict[str, Any]) -> None: ...
    def hasUnknown(self) -> bool: ...
    def getErrorMessage(self, field_name: str) -> Optional[str]: ...
    def getErrorMessages(self) -> Dict[str, str]: ...
    def add(
        self,
        name: str,
        required: bool = ...,
        default: Any = ...,
        fallback: Any = ...,
        filters: Optional[List[BaseFilter]] = ...,
        validators: Optional[List[BaseValidator]] = ...,
        steps: Optional[List[Union[BaseFilter, BaseValidator]]] = ...,
        external_api: Optional[ExternalApiConfig] = ...,
        copy: Optional[str] = ...,
    ) -> None: ...
    def has(self, field_name: str) -> bool: ...
    def getInput(self, field_name: str) -> Optional[FieldModel]: ...
    def getInputs(self) -> Dict[str, FieldModel]: ...
    def remove(self, field_name: str) -> Optional[FieldModel]: ...
    def count(self) -> int: ...
    def replace(
        self,
        name: str,
        required: bool = ...,
        default: Any = ...,
        fallback: Any = ...,
        filters: Optional[List[BaseFilter]] = ...,
        validators: Optional[List[BaseValidator]] = ...,
        steps: Optional[List[Union[BaseFilter, BaseValidator]]] = ...,
        external_api: Optional[ExternalApiConfig] = ...,
        copy: Optional[str] = ...,
    ) -> None: ...
    def addGlobalFilter(self, filter: BaseFilter) -> None: ...
    def getGlobalFilters(self) -> List[BaseFilter]: ...
    def clear(self) -> None: ...
    def merge(self, other: InputFilter) -> None: ...
    def setModel(self, model_class: Type[T]) -> None: ...
    def serialize(self) -> Union[Dict[str, Any], T]: ...
    def addGlobalValidator(self, validator: BaseValidator) -> None: ...
    def getGlobalValidators(self) -> List[BaseValidator]: ...
